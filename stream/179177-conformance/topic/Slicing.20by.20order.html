---
layout: page
title: "FHIR Chat  · Slicing by order · conformance"
---

{% raw %}<h2>Stream: <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/index.html">conformance</a></h2>
<h3>Topic: <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html">Slicing by order</a></h3>

<hr>

<base href="https://chat.fhir.org">

<head><link href="https://fhir.github.io/chat-archive/style.css" rel="stylesheet"></head>

<a name="153916556"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153916556" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simone Heckmann <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153916556">(Oct 27 2017 at 21:34)</a>:</h4>
<p>Is it possible/allowed to assign meaning to slices according to their order?<br>
e.g. I have an ordered, closed set of two slices, that are indistinguishable by their attributes.<br>
The first slice is mandatory, the second is optional.</p>
<p>The reason for slicing is mostly to be able to add distinct documentation to each slice, the validation rules for both are the same.</p>



<a name="153916561"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153916561" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Grahame Grieve <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153916561">(Oct 27 2017 at 22:59)</a>:</h4>
<p>I don't think that's possible</p>



<a name="153916565"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153916565" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lloyd McKenzie <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153916565">(Oct 27 2017 at 23:40)</a>:</h4>
<p>We've talked about being able to slice by order, but haven't implemented it.  (It would only be meaningful if the element being sliced is defined as having a semantic order.)</p>



<a name="153916588"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153916588" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simone Heckmann <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153916588">(Oct 28 2017 at 10:18)</a>:</h4>
<p>In our case, it's about the payor element in Coverage.<br>
We always have a primary payor, in some cases, there's also a secondary. They're both references to Organizations conforming to the same profile.<br>
I don't know how to convey that in my Coverage profile...</p>



<a name="153916589"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153916589" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simone Heckmann <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153916589">(Oct 28 2017 at 10:24)</a>:</h4>
<p>I mean. There <em>are</em> ways to solve that. But all I could come up with so far (adding a "secondaryPayor"-Extension to Coverage or extending the Reference type to include a priority) seem kind of bulky compared to just simply saying: "The first payor is primary and the second payor is secondary."</p>



<a name="153916602"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153916602" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lloyd McKenzie <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153916602">(Oct 28 2017 at 15:02)</a>:</h4>
<p>Primary vs. secondary can be claim specific.  So I'd expect each to be a separate Coverage instance.  The Claim would then list them in order of precedence.</p>



<a name="153916610"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153916610" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simone Heckmann <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153916610">(Oct 28 2017 at 15:51)</a>:</h4>
<p>No, actually that's what's on the data on our statutory health insurance card. It's the same coverage, except that some insurances don't handle the claim stuff themselves but refer it to another insurance. That's why we sometimes have two payor references that have slightly different semantics:<br>
the first is always the primary contact for everything whereas the secondary (if present) only handles the claims.</p>



<a name="153916611"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153916611" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simone Heckmann <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153916611">(Oct 28 2017 at 15:52)</a>:</h4>
<p>The intention is to keep the mapping of the card data to the Coverage resource as straightforward as possible.</p>



<a name="153916613"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153916613" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lloyd McKenzie <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153916613">(Oct 28 2017 at 21:19)</a>:</h4>
<p>Ah, so one is providing the coverage and one is doing the processing?</p>



<a name="153916621"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153916621" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simone Heckmann <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153916621">(Oct 29 2017 at 10:09)</a>:</h4>
<p>Sort of, yes. I don't even know the details about it. The explanation I got from reading the card data spec wasn't very verbose.<br>
On second thought, I think the best way to go forward is to simply set the payor cardinality to 1..2 and add some prose to the definition of what it means if there's a second payor in an instance. In terms of validation it doesn't make a difference since both slices adhere to the same rules.</p>



<a name="153917044"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153917044" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Vadim Peretokin <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153917044">(Nov 01 2017 at 08:58)</a>:</h4>
<p>Is tagging with an extension not an option?</p>



<a name="153917327"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153917327" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Grenz <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153917327">(Nov 02 2017 at 15:39)</a>:</h4>
<p>When we discussed this in the past, here's how it was suggested (by Grahame).  A simple use case was first name vs. middle name(s). I have no idea if any current infrastructure support this.  A profile would:<br>
1. Declare an ordered slicing for an element (slicing.ordered:true) and no discriminator.<br>
2. Create the first slice with a max:1<br>
3. Create a second (and, if you desire, many more) with an appropriate max.<br>
The validator/parser would then "consume" the slices in order.<br>
It's tricky and error prone since the intent is relatively hidden.<br>
<span class="user-mention" data-user-id="191328">@Ewout Kramer</span> <span class="user-mention" data-user-id="191316">@Grahame Grieve</span> - would your validators handle this?</p>



<a name="153917333"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153917333" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lloyd McKenzie <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153917333">(Nov 02 2017 at 16:38)</a>:</h4>
<p>If there's no discriminator, then there must be a slicing description - and the validators would presume that the slicing mechanism is non-computable.  They certainly wouldn't presume that the slicing was based solely on order.</p>



<a name="153917338"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153917338" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simone Heckmann <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153917338">(Nov 02 2017 at 16:49)</a>:</h4>
<p>Forge at least doesn't currently permit to create slicing as you describe. If the descriminator is empty, that's a hard error.</p>



<a name="153917371"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153917371" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Grenz <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153917371">(Nov 02 2017 at 18:40)</a>:</h4>
<p>Yep.  <a href="http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=9729" target="_blank" title="http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=9729">GF#9729</a> was to address this issue with the description I gave above given as the solution. And thus, the request was withdrawn.  If we don't think that works and nobody supports it, then we need to re-open the issue.</p>



<a name="153917514"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153917514" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lloyd McKenzie <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153917514">(Nov 03 2017 at 03:08)</a>:</h4>
<p>Probably best to raise a new issue and point to the old one and explain why it needs to be readdressed</p>



<a name="153917538"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153917538" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michel Rutten <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153917538">(Nov 03 2017 at 13:52)</a>:</h4>
<p><span class="user-mention" data-user-id="191450">@Simone Heckmann</span> Forge simply tries enforce the standard invariants, including eld-1: "On ElementDefinition.slicing: If there are no discriminators, there must be a definition".<br>
So if you define an ordered slicing according to Chris' approach and fill in the slicing.description field, then the eld-1 invariant will hold.</p>



<a name="153917539"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153917539" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Simone Heckmann <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153917539">(Nov 03 2017 at 14:01)</a>:</h4>
<p>Ah! <em>That's</em> where I went wrong... Thanks!</p>



<a name="153921821"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179177-conformance/topic/Slicing%20by%20order/near/153921821" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ewout Kramer <a href="https://fhir.github.io/chat-archive/stream/179177-conformance/topic/Slicing.20by.20order.html#153921821">(Nov 28 2017 at 11:44)</a>:</h4>
<blockquote>
<p>When we discussed this in the past, here's how it was suggested (by Grahame).  A simple use case was first name vs. middle name(s). I have no idea if any current infrastructure support this.  A profile would:<br>
1. Declare an ordered slicing for an element (slicing.ordered:true) and no discriminator.<br>
2. Create the first slice with a max:1<br>
3. Create a second (and, if you desire, many more) with an appropriate max.<br>
The validator/parser would then "consume" the slices in order.<br>
It's tricky and error prone since the intent is relatively hidden.<br>
<span class="user-mention" data-user-id="191328">@Ewout Kramer</span> <span class="user-mention" data-user-id="191316">@Grahame Grieve</span> - would your validators handle this?</p>
</blockquote>
<p>Sorry for the late reply, but no: as long as the repeats "validate" in the slice (since there's no discriminator, a repeat just needs to validate to the constraints of the slice), it will keep on "filling" that slice - disregarding the cardinality. You'll get an error saying that 1..1 was expected, but many were found...</p>


{% endraw %}
<hr><p>Last updated: Apr 12 2022 at 19:14 UTC</p>
