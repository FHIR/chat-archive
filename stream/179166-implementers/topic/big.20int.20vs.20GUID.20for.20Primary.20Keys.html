---
layout: page
title: "FHIR Chat  · big int vs GUID for Primary Keys · implementers"
---

{% raw %}<h2>Stream: <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/index.html">implementers</a></h2>
<h3>Topic: <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/topic/big.20int.20vs.20GUID.20for.20Primary.20Keys.html">big int vs GUID for Primary Keys</a></h3>

<hr>

<base href="https://chat.fhir.org">

<head><link href="https://fhir.github.io/chat-archive/style.css" rel="stylesheet"></head>

<a name="174922376"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179166-implementers/topic/big%20int%20vs%20GUID%20for%20Primary%20Keys/near/174922376" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Shane O&#x27;Neill <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/topic/big.20int.20vs.20GUID.20for.20Primary.20Keys.html#174922376">(Sep 04 2019 at 20:59)</a>:</h4>
<p>Howdy</p>
<p>in a relational DBMS, are there any advantages to using GUIDs vs the native primary key (big int) implementation to identify FHIR resources?</p>



<a name="174938014"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179166-implementers/topic/big%20int%20vs%20GUID%20for%20Primary%20Keys/near/174938014" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lloyd McKenzie <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/topic/big.20int.20vs.20GUID.20for.20Primary.20Keys.html#174938014">(Sep 05 2019 at 01:49)</a>:</h4>
<p>Only benefit is if you want to use PUT creates on a server where lots of other servers are also performing creates.  With GUIDs you know there won't be collisions.  With big int ids, there can be.  If you're not in that situation, no benefit.</p>



<a name="174958314"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179166-implementers/topic/big%20int%20vs%20GUID%20for%20Primary%20Keys/near/174958314" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Agnew <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/topic/big.20int.20vs.20GUID.20for.20Primary.20Keys.html#174958314">(Sep 05 2019 at 09:39)</a>:</h4>
<p>GUIDs could also have a minor privacy benefit, in that you can't infer anything about the order that resources were created by looking  at their IDs. I can't think of a scenario where that would be an exploitable fact, but that doesn't mean there aren't any..</p>



<a name="174959668"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179166-implementers/topic/big%20int%20vs%20GUID%20for%20Primary%20Keys/near/174959668" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Adam Flinton <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/topic/big.20int.20vs.20GUID.20for.20Primary.20Keys.html#174959668">(Sep 05 2019 at 10:02)</a>:</h4>
<p>I would use guids for a number of reasons:<br>
Clearly don't know your usecases nor db choice etc but 3 quick reasons (out of a greater number)<br>
1) Often for reasons of scalability (or lack thereof) you might have identical db'es in a n customer orgs (e.g. gp surgeries or hospitals) per db arrangement. If the scalability then improves and you want to move to one db period or even simply more customer orgs per db then you will have a problem of identical keys with ints.<br>
2) If using a variety of sharded db options guids are more random and thus ease the hot partition problem<br>
3) Because of the growing prevalence of the use of guids as keys the indexing around them has improved such that there is little if any benefit any more to using ints (admittedly there did use to be &amp; possibly in your choice of db there still might be)</p>



<a name="174972086"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179166-implementers/topic/big%20int%20vs%20GUID%20for%20Primary%20Keys/near/174972086" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Silva <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/topic/big.20int.20vs.20GUID.20for.20Primary.20Keys.html#174972086">(Sep 05 2019 at 13:16)</a>:</h4>
<p><span class="user-mention" data-user-id="232411">@Shane O'Neill</span>  -- one disadvantage of using GUIDs is that they do not necessarily work well as primary DB keys.  I'm not a 'DB guy' but I remember a DB architect talking about this problem from a performance and space perspective.</p>



<a name="174985256"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179166-implementers/topic/big%20int%20vs%20GUID%20for%20Primary%20Keys/near/174985256" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jenni Syed <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/topic/big.20int.20vs.20GUID.20for.20Primary.20Keys.html#174985256">(Sep 05 2019 at 15:31)</a>:</h4>
<p>The issue typically comes in if the DB in question doesn't have a first class GUID/UUID type and thus dumps these into strings. And indexing off those strings for what would have been a "unique id" lookup tends to be slower, from what I understand</p>



<a name="174987208"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179166-implementers/topic/big%20int%20vs%20GUID%20for%20Primary%20Keys/near/174987208" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gino Canessa <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/topic/big.20int.20vs.20GUID.20for.20Primary.20Keys.html#174987208">(Sep 05 2019 at 15:50)</a>:</h4>
<p>In MSSQL Server (relational I'm most comfortable with), uniqueidentifier is a 128 bit binary value.  Performance is no different from other binary types, but it's larger than an integer type (e.g., 64 bit bigint).  That said, I'm now of the 'storage is cheap' camp for things like this - I'd rather inflate by the extra 64 bits and not worry about collisions when I consolidate databases.</p>



<a name="175018631"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179166-implementers/topic/big%20int%20vs%20GUID%20for%20Primary%20Keys/near/175018631" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Agnew <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/topic/big.20int.20vs.20GUID.20for.20Primary.20Keys.html#175018631">(Sep 05 2019 at 21:57)</a>:</h4>
<p>One other point in favour of GUIDs: Anytime you use a sequence to generate IDs, sooner or later an application restart or rolled back transaction causes a gap in your IDs, and even though this gap makes absolutely no meaningful difference to anyone or anything, it's a guarantee that some bright-eyed analyst will notice and freak out on the developers that there are gaps. Use GUIDs and the issue goes away..... ;)</p>



<a name="175020576"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179166-implementers/topic/big%20int%20vs%20GUID%20for%20Primary%20Keys/near/175020576" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Peter Jordan <a href="https://fhir.github.io/chat-archive/stream/179166-implementers/topic/big.20int.20vs.20GUID.20for.20Primary.20Keys.html#175020576">(Sep 05 2019 at 22:27)</a>:</h4>
<p>GUIDs are good candidates for primary keys in modern RDBMS, providing they are not used as clustered indexes. From an RDBMS perspective (certainly in MSSQLS) they are required to perform replication. They are also used as identifiers in SNOMED CT Reference Sets.</p>


{% endraw %}
<hr><p>Last updated: Apr 12 2022 at 19:14 UTC</p>
