---
layout: page
title: "FHIR Chat  · Idea for $import referential integrity · bulk data"
---

{% raw %}<h2>Stream: <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/index.html">bulk data</a></h2>
<h3>Topic: <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/topic/Idea.20for.20.24import.20referential.20integrity.html">Idea for $import referential integrity</a></h3>

<hr>

<base href="https://chat.fhir.org">

<head><link href="https://fhir.github.io/chat-archive/style.css" rel="stylesheet"></head>

<a name="182503223"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179250-bulk%20data/topic/Idea%20for%20%24import%20referential%20integrity/near/182503223" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Paul Church <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/topic/Idea.20for.20.24import.20referential.20integrity.html#182503223">(Dec 03 2019 at 22:22)</a>:</h4>
<p>One of the hardest parts of bringing in a large data set is how to fix up the source system's references in a robust way that doesn't require preprocessing the entire input and doesn't leave dangling references.</p>
<p>Perhaps we can leverage the proposed meta import-source extension, which is an Identifier. What if all literal references in the imported data that refer to resources on the source system are rewritten during $import to be logical references (reference.identifier) with the system and value corresponding to the import-source that the referenced resource will have once imported?</p>
<p>After the first pass of importing and rewriting all of the resources, a second pass can go through and rewrite these logical references back into literal references if possible, and report errors where it wasn't possible. Other clients can rely on literal references having integrity, and logical references maybe referring to a resource or maybe not (which is par for the course on any logical reference).</p>



<a name="182515090"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179250-bulk%20data/topic/Idea%20for%20%24import%20referential%20integrity/near/182515090" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Mandel <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/topic/Idea.20for.20.24import.20referential.20integrity.html#182515090">(Dec 04 2019 at 01:01)</a>:</h4>
<p>This is interesting, <span class="user-mention" data-user-id="197072">@Paul Church</span>. If I'm reading it right, the end-result would be ... references in the new server that were sometimes logical and sometimes literal? For the ones (stuck as) logical, identifier-based, won't that break queries on the new server  (like, chaining and <code>_include</code> and compartment syntax and so on)?</p>



<a name="182518313"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179250-bulk%20data/topic/Idea%20for%20%24import%20referential%20integrity/near/182518313" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Paul Church <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/topic/Idea.20for.20.24import.20referential.20integrity.html#182518313">(Dec 04 2019 at 02:15)</a>:</h4>
<p>Well, if 1) all references in the source system were literal, 2) every reference was valid on the source system, 3) every referenced resource was in the exported data, 4) every referenced resource was successfully imported, and 5) enough time passes for the second pass to finish, then there will be guaranteed no logical references remaining. These are reasonable assumptions in many use cases. The hardest one is fixing up #4 when a small percentage of resources in a large import job are rejected.</p>
<p>It's true that stuck logical references will cause all of those gaps in functionality. But the primary alternatives are to ignore ref integrity entirely (as GCP currently does during imports), or discard the transitive closure of every imported resource that would violate ref integrity, or...?</p>
<p>Conformant clients might be presented with logical references at any time unless a profile disallows it, so hopefully they will be robust.</p>



<a name="182519194"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179250-bulk%20data/topic/Idea%20for%20%24import%20referential%20integrity/near/182519194" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Josh Mandel <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/topic/Idea.20for.20.24import.20referential.20integrity.html#182519194">(Dec 04 2019 at 02:32)</a>:</h4>
<p>Okay -- that makes sense and I'm not disagreeing :)  Just trying to figure out what the implications look like.</p>



<a name="182534840"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179250-bulk%20data/topic/Idea%20for%20%24import%20referential%20integrity/near/182534840" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michele Mottini <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/topic/Idea.20for.20.24import.20referential.20integrity.html#182534840">(Dec 04 2019 at 08:25)</a>:</h4>
<blockquote>
<p>Conformant clients might be presented with logical references </p>
</blockquote>
<p>This is very optimistic. Servers do not necessarily support searches by identifier - making logical references unresolvable</p>



<a name="182561670"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179250-bulk%20data/topic/Idea%20for%20%24import%20referential%20integrity/near/182561670" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Paul Church <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/topic/Idea.20for.20.24import.20referential.20integrity.html#182561670">(Dec 04 2019 at 14:48)</a>:</h4>
<p>I wouldn't expect the client/server to react to logical references by trying to resolve them - it's often impossible. The client just needs to accept that there are references it can't follow.</p>



<a name="182561927"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179250-bulk%20data/topic/Idea%20for%20%24import%20referential%20integrity/near/182561927" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Paul Church <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/topic/Idea.20for.20.24import.20referential.20integrity.html#182561927">(Dec 04 2019 at 14:50)</a>:</h4>
<p>As a further enhancement, when doing a subsequent $import from the same source that may update some existing resources and create others, references to resources that already existed from the previous $import can be resolved immediately by the same mechanism the server uses to find which resources should be updated.</p>



<a name="182563547"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179250-bulk%20data/topic/Idea%20for%20%24import%20referential%20integrity/near/182563547" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Michele Mottini <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/topic/Idea.20for.20.24import.20referential.20integrity.html#182563547">(Dec 04 2019 at 15:05)</a>:</h4>
<blockquote>
<p>The client just needs to accept that there are references it can't follow.</p>
</blockquote>
<p>That's not a thing for all clients that use SQL db with foreign keys linking the different concepts - either you can resolve the reference or you have to ignore the data</p>



<a name="182565317"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179250-bulk%20data/topic/Idea%20for%20%24import%20referential%20integrity/near/182565317" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Paul Church <a href="https://fhir.github.io/chat-archive/stream/179250-bulk-data/topic/Idea.20for.20.24import.20referential.20integrity.html#182565317">(Dec 04 2019 at 15:20)</a>:</h4>
<p>Those clients have to fall back to ignoring the transitive closure of things that didn't make it through the $import. That's the baseline option in any scenario though - if you replicated data from another server and some references are dangling, the data surely won't satisfy everyone.</p>


{% endraw %}
<hr><p>Last updated: Apr 12 2022 at 19:14 UTC</p>
