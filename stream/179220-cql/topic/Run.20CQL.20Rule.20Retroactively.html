---
layout: page
title: "FHIR Chat  · Run CQL Rule Retroactively · cql"
---

{% raw %}<h2>Stream: <a href="https://fhir.github.io/chat-archive/stream/179220-cql/index.html">cql</a></h2>
<h3>Topic: <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Run.20CQL.20Rule.20Retroactively.html">Run CQL Rule Retroactively</a></h3>

<hr>

<base href="https://chat.fhir.org">

<head><link href="https://fhir.github.io/chat-archive/style.css" rel="stylesheet"></head>

<a name="227295951"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Run%20CQL%20Rule%20Retroactively/near/227295951" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Rich Boyce <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Run.20CQL.20Rule.20Retroactively.html#227295951">(Feb 22 2021 at 16:35)</a>:</h4>
<p>We are currently developing a process to rule a CQL rule over a date range in the past to determine which cards (if any) are returned on each individual day. We have figured out how to create prefetch data for a specific patient on a date in the past utilizing the "effective" and "authoredon" query parameters in the FHIR endpoint but we are wondering how we can essentially ignore a patient's medication history stored on a FHIR server when running the CQL rule. Do you know of any way of doing this in the CQF Ruler or in a CDS hook?</p>



<a name="227311366"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Run%20CQL%20Rule%20Retroactively/near/227311366" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Run.20CQL.20Rule.20Retroactively.html#227311366">(Feb 22 2021 at 18:09)</a>:</h4>
<p>There is an "asOf" parameter to the engine that determines what the engine will return from the Now() and Today() functions. It hasn't been exposed though, so that would need to be something that's exposed through the layers in order to get that to run correctly.</p>



<a name="227311454"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Run%20CQL%20Rule%20Retroactively/near/227311454" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Run.20CQL.20Rule.20Retroactively.html#227311454">(Feb 22 2021 at 18:09)</a>:</h4>
<p>The second part, of getting the data access layer to respect that, if you run the engine such that it only access the data provided as part of the prefetch, and you manage the data passed to the prefetch with parameters, that should work as expected.</p>



<a name="227322380"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Run%20CQL%20Rule%20Retroactively/near/227322380" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Rich Boyce <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Run.20CQL.20Rule.20Retroactively.html#227322380">(Feb 22 2021 at 19:22)</a>:</h4>
<p>Thank you for the quick response. I see how asOf() and Now() are implemented in the engine but where would I feasibly be able to modify the engine so that only the prefetch provided is the only data that is accessed?</p>



<a name="227324741"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Run%20CQL%20Rule%20Retroactively/near/227324741" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> JP <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Run.20CQL.20Rule.20Retroactively.html#227324741">(Feb 22 2021 at 19:38)</a>:</h4>
<p>Hi Rich,</p>
<p>Considering only prefetch is not yet implemented in the ruler but conceptually you supply the cql-engine with a data provider that has only the prefetch data available. For example, you might create a Bundle with only the prefetch data and create a data provider that accesses only that. Under the covers that's how the Atom plugin works. It Bundles the appropriate  resources  in the <code>tests</code>directory and then uses this class:</p>
<p><a href="https://github.com/DBCG/cql-evaluator/blob/master/evaluator.engine/src/main/java/org/opencds/cqf/cql/evaluator/engine/retrieve/BundleRetrieveProvider.java#L37">https://github.com/DBCG/cql-evaluator/blob/master/evaluator.engine/src/main/java/org/opencds/cqf/cql/evaluator/engine/retrieve/BundleRetrieveProvider.java#L37</a></p>


{% endraw %}
<hr><p>Last updated: Apr 12 2022 at 19:14 UTC</p>
