---
layout: page
title: "FHIR Chat  · algorithms · cql"
---

{% raw %}<h2>Stream: <a href="https://fhir.github.io/chat-archive/stream/179220-cql/index.html">cql</a></h2>
<h3>Topic: <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html">algorithms</a></h3>

<hr>

<base href="https://chat.fhir.org">

<head><link href="https://fhir.github.io/chat-archive/style.css" rel="stylesheet"></head>

<a name="177201328"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177201328" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Adrian <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177201328">(Oct 02 2019 at 23:11)</a>:</h4>
<p>The problem I am working on at the moment seems to condense to a couple of very simple algorithms whose solutions in CQL, nevertheless, have remained elusive. The first and simplest of the two concerns combining two lists:</p>
<p>Define the function fold({a0, a1, ..., ak}, {b0, b1, ..., bk}) -&gt; {{a1, b1}, {a2, b2}, ..., {ak, bk}}</p>
<p>The second concerns finding clusters of dates. Define an n-cluster of dates as being groups of dates that are separated by no more than n days. For example the dates 2019-01-05, 2019-01-15, and 2019-01-24 are in a 10-cluster, but not in a 9-cluster. From the definition, it's clear that n-clusters are separated by gaps of more than n days. There can also be singleton clusters, that contain only one date which is separated from both it's predecessor and antecedent by gaps of more than n-days. My problem condenses to this:</p>
<p>Given D, a List&lt;DateTime&gt; {d0, d1, d2, ..., dk}, d0 &lt;= d1 &lt;= d2 &lt;= dk and an integer n, return a list of all n-clusters in D. For example for the ordered list, {d0, d1, d2, [31-day gap] d3, [70-day gap], d4, d5, [50-day gap] d6, d7, d8, d9} and n = 30, return the list {{d0, d1, d2}, {d3}, {d4, d5}, {d6, d7, d8, d9}}. Alternatively, returning the endpoints of each cluster is also acceptable: {{d0, d2}, {d3, d3}, {d4, d5}, {d6, d9}}.</p>
<p>Any ideas as to how these two functions would be defined in CQL?</p>



<a name="177205241"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177205241" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177205241">(Oct 03 2019 at 00:29)</a>:</h4>
<p>Oooh.  This feels like a coding interview question!  I only have time for one, but here's a solution for folding in CQL.  I'll admit, it's a little weird, but I tested it and it works.</p>
<div class="codehilite"><pre><span></span>library CQLFold version &#39;1.0&#39;

define function Fold(L1 List&lt;String&gt;, L2 List&lt;String&gt;):
 (expand { Interval[0, Length(L1)-1] } per 1 &#39;1&#39;) I
   return { L1[start of I], L2[start of I] }

// Test it
define L1: {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
define L2: {&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;}
define Answer: Fold(L1, L2)
</pre></div>


<p>So we basically want to iterate over a list of indexes 0 to N and then create pairs of { L1[i], L2[i] }.  Here's a breakdown of the CQL since it is a little funky. For this example, consider L1: <code>{'A', 'B', 'C'}</code> and L2: <code>{'X', 'Y', 'Z'}</code>.</p>
<ul>
<li>First create an interval from 0 to Length(L1) - 1<ul>
<li>CQL: <code>{ Interval[0, Length(L1)-1] }</code></li>
<li>Result: =&gt; <code>Interval[0,2]</code></li>
</ul>
</li>
<li>Then expand it into intervals of size 1, giving us Length(L1)-1 unit intervals<ul>
<li>CQL: <code>(expand { Interval[0, Length(L1)-1] } per 1 '1')</code></li>
<li>Result: <code>{ Interval[0,0], Interval[1,1], Interval[2,2] }</code></li>
</ul>
</li>
<li>Now query over that returning <code>{ L1[start of I], L2[start of I] }</code> pairs<ul>
<li>CQL: <code>I return { L1[start of I], L2[start of I] }</code></li>
<li>Result: <code>{ {'A','X'}, {'B','Y'}, {'C','Z'} }</code></li>
</ul>
</li>
</ul>



<a name="177207280"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177207280" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Adrian <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177207280">(Oct 03 2019 at 01:18)</a>:</h4>
<p>Thanks, Chris. Because of this, I was able to solve my n-cluster problem. Here's  the solution:</p>
<p>define function leftEndPoints(l List&lt;DateTime&gt;, n Integer): l L without l L2 such that L2 &lt; L and difference in days between L2 and L &lt; 30<br>
define function rightEndPoints(l List&lt;DateTime&gt;, n Integer): l L without l L2 such that L2 &gt; L and difference in days between L and L2 &lt; 30</p>
<p>define LHTest: leftEndPoints({DateTime(2019, 1, 1), DateTime(2019, 1, 2), DateTime(2019, 1, 3), DateTime(2019, 3, 1), DateTime(2019, 5, 1), DateTime(2019, 5, 2), DateTime(2019, 7, 1), DateTime(2019, 9, 1), DateTime(2019, 9, 2), DateTime(2019, 9, 3), DateTime(2019, 9, 4)},<br>
                            30)<br>
define RHTest: rightEndPoints({DateTime(2019, 1, 1), DateTime(2019, 1, 2), DateTime(2019, 1, 3), DateTime(2019, 3, 1), DateTime(2019, 5, 1), DateTime(2019, 5, 2), DateTime(2019, 7, 1), DateTime(2019, 9, 1), DateTime(2019, 9, 2), DateTime(2019, 9, 3), DateTime(2019, 9, 4)},<br>
                            30)</p>
<p>define function nClusters(l List&lt;DateTime&gt;, n Integer): fold(leftEndPoints(l, n), rightEndPoints(l, n))</p>
<p>define nClusterTest: nClusters({DateTime(2019, 1, 1), DateTime(2019, 1, 2), DateTime(2019, 1, 3), DateTime(2019, 3, 1), DateTime(2019, 5, 1), DateTime(2019, 5, 2), DateTime(2019, 7, 1), DateTime(2019, 9, 1), DateTime(2019, 9, 2), DateTime(2019, 9, 3), DateTime(2019, 9, 4)},<br>
                            30)</p>



<a name="177207468"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177207468" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Adrian <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177207468">(Oct 03 2019 at 01:23)</a>:</h4>
<p>OK, replace the 30's in the leftEndPoints and rightEndPoints functions with n and it will be correct for n other than 30 <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span> .</p>



<a name="177207565"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177207565" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177207565">(Oct 03 2019 at 01:25)</a>:</h4>
<p>That's awesome.  I couldn't help myself so I was also working on this -- but from a different angle. I felt like it should be a fairly simple application of the <a href="https://cql.hl7.org/09-b-cqlreference.html#collapse" target="_blank" title="https://cql.hl7.org/09-b-cqlreference.html#collapse">collapse</a> operator. I came up with this (returning the endpoints only):</p>
<div class="codehilite"><pre><span></span>library CQLClusters

define function Clusters(Dates List&lt;Date&gt;, N Quantity):
  collapse (Dates D return Interval[D,D]) per N

define Dates: {
  @2000-02-10,
  @2000-02-28,
  @2000-03-01,
  // 31-day gap
  @2000-04-01,
  // 70-day gap
  @2000-06-10,
  @2000-06-15,
  // 50-day gap
  @2000-08-04,
  @2000-09-01,
  @2000-10-01,
  @2000-10-31
 }

define Answer: Clusters(Dates, 30 days)
</pre></div>


<p><strong>But</strong>...  it doesn't work in the Java-based CQL execution engine or the JavaScript-based CQL execution engine, so either they're wrong or I'm wrong. I code-reviewed the JavaScript engine's <code>collapse</code> implementation before it was merged, so I like to think that it's right, but then that means my CQL is wrong. ;-)  As for the Java-based implementation, it seems definitely way wrong because it returns <code>[Interval[2000-02-10, 2000-11-07]]</code> which goes entirely <em>past</em> the input intervals  (<span class="user-mention" data-user-id="191359">@Bryn Rhodes</span> ).</p>
<p>Anyway, I'm glad you found a way, and I'm glad my first solution could help lead you there!</p>



<a name="177207839"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177207839" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177207839">(Oct 03 2019 at 01:32)</a>:</h4>
<p>Although, I have to admit, I popped your solution into <a href="http://cql-runner.dataphoria.org/" target="_blank" title="http://cql-runner.dataphoria.org/">CQL Runner</a> and I got the wrong answers:</p>
<div class="codehilite"><pre><span></span>&gt;&gt; Fold [2:1] Definition successfully validated
&gt;&gt; leftEndPoints [6:1] Definition successfully validated
&gt;&gt; rightEndPoints [7:1] Definition successfully validated
&gt;&gt; LHTest [9:1] [2019-01-01, 2019-01-02, 2019-01-03, 2019-03-01, 2019-05-01, 2019-05-02, 2019-07-01, 2019-09-01, 2019-09-02, 2019-09-03, 2019-09-04]
&gt;&gt; RHTest [11:1] [2019-01-01, 2019-01-02, 2019-01-03, 2019-03-01, 2019-05-01, 2019-05-02, 2019-07-01, 2019-09-01, 2019-09-02, 2019-09-03, 2019-09-04]
&gt;&gt; nClusters [14:1] Definition successfully validated
&gt;&gt; nClusterTest [16:1] [[2019-01-01, 2019-01-01], [2019-01-02, 2019-01-02], [2019-01-03, 2019-01-03], [2019-03-01, 2019-03-01], [2019-05-01, 2019-05-01], [2019-05-02, 2019-05-02], [2019-07-01, 2019-07-01], [2019-09-01, 2019-09-01], [2019-09-02, 2019-09-02], [2019-09-03, 2019-09-03], [2019-09-04, 2019-09-04]]
</pre></div>


<p>If it worked for you, however, perhaps it is an issue with CQL Runner.</p>



<a name="177211332"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177211332" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Adrian <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177211332">(Oct 03 2019 at 03:10)</a>:</h4>
<p>I can't comment on CQL Runner, but my implementation gives <br>
LHTest: [2019-01-01, 2019-03-01, 2019-05-01, 2019-07-01, 2019-09-01]<br>
RHTest: [2019-01-03, 2019-03-01, 2019-05-02, 2019-07-01, 2019-09-04]</p>
<p>nClusterTest:[[2019-01-01, 2019-01-03],[2019-03-01, 2019-03-01], [2019-05-01, 2019-05-02], [2019-07-01, 2019-07-01], [2019-09-01, 2019-09-04]]</p>



<a name="177213645"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177213645" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177213645">(Oct 03 2019 at 04:15)</a>:</h4>
<p>Clever use of expand to create a sequence <span class="user-mention" data-user-id="191469">@Chris Moesel</span>, very nice :)</p>



<a name="177213653"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177213653" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177213653">(Oct 03 2019 at 04:15)</a>:</h4>
<p>I agree these should be working, I will test these on the runner and get to the bottom of why they're not giving the results expected here.</p>



<a name="177240337"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177240337" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177240337">(Oct 03 2019 at 12:50)</a>:</h4>
<p><span class="user-mention" data-user-id="191359">@Bryn Rhodes</span>, it did get me to thinking though... should we consider some new features for CQL?</p>
<ol>
<li>
<p><strong>Convert an Interval&lt;Integer&gt; to a list.</strong> Ruby supports something like this.  It might look like <code>convert Interval[0,15] to List&lt;Integer&gt;</code>.  That said, this is a pretty narrow use case and I wouldn't want to have to support it for other types, so maybe not.  The expression for doing this (<code>(expand { Interval[0, N] } per 1 '1') IVL return start of IVL</code>) isn't too bad.</p>
</li>
<li>
<p><strong>Support an indexer argument on queries.</strong> Since the primary use case for getting a sequence of integers might be something similar to the fold operation, we could borrow a page from ES6 (sort of) and have an optional indexer argument on a query.  Then that fold function would be simplified to:</p>
</li>
</ol>
<div class="codehilite"><pre><span></span>define function Fold(L1 List&lt;String&gt;, L2 List&lt;String&gt;):
 L1 Item, Index return { Item, L2[Index] }
</pre></div>


<p>That said, we already use <code>,</code> to separate sources in a multi-source query, so we'd want to be careful not to confuse matters too much (although, technically, I think the parser could disambiguate).  Still if we wanted to make it clearer, we could introduce new keywords (e.g., <code>L1 Item at Index</code>, <code>L1 Item at index Index</code>, <code>L1 Item using index Index</code>, etc).</p>
<p>Anyway, just a thought.  Do you think it's worth me filing an official STU comment?</p>



<a name="177241671"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177241671" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Adrian <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177241671">(Oct 03 2019 at 13:05)</a>:</h4>
<p>It might be. Another choice in addition to an indexer, could be lag(n) and/or lead(n) functions like are found in some SQL implementations, which return records n elements before or after the current one. Sometimes relative indexing works better than absolute.</p>



<a name="177252611"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177252611" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177252611">(Oct 03 2019 at 14:58)</a>:</h4>
<p>re: lag/lead, couldn't you accomplish the same w/ an index?  E.g. <code>Items.lag(4)</code> == <code>Items[Index-4]</code>?</p>



<a name="177252719"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177252719" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177252719">(Oct 03 2019 at 14:58)</a>:</h4>
<p>Although I guess in a complex query, you don't have a simple variable that equates to all the results... so maybe not.</p>



<a name="177547288"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177547288" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177547288">(Oct 07 2019 at 18:39)</a>:</h4>
<p><span class="user-mention" data-user-id="191469">@Chris Moesel</span> , apologies for the delay here. Yes, I think it would be worth submitting those as STU comments. Another specific item I've wished for is some answer for recursive queries.</p>



<a name="177547364"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177547364" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177547364">(Oct 07 2019 at 18:40)</a>:</h4>
<p>For the indexer argument on queries, am I misunderstanding the request, or would the $this iteration accessor work?</p>



<a name="177547437"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177547437" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177547437">(Oct 07 2019 at 18:40)</a>:</h4>
<p>Sorry, $index, not $this</p>



<a name="177551787"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177551787" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177551787">(Oct 07 2019 at 19:33)</a>:</h4>
<p>Hey <span class="user-mention" data-user-id="191359">@Bryn Rhodes</span> -- is <code>$index</code> defined as part of the core CQL spec? I'm having trouble finding any documentation about it in the CQL spec.  Even in the FHIRPath 1.0 spec, only <code>$this</code> is called out as a keyword.</p>



<a name="177551909"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177551909" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177551909">(Oct 07 2019 at 19:34)</a>:</h4>
<p>OK, I did just find it in the proposed FHIRPath 2.0 spec, but still having trouble finding it in the CQL spec.</p>



<a name="177552640"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177552640" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177552640">(Oct 07 2019 at 19:42)</a>:</h4>
<p>True enough, I had thought we documented those here: <a href="https://cql.hl7.org/03-developersguide.html#using-fhirpath" target="_blank" title="https://cql.hl7.org/03-developersguide.html#using-fhirpath">https://cql.hl7.org/03-developersguide.html#using-fhirpath</a></p>



<a name="177552648"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177552648" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177552648">(Oct 07 2019 at 19:42)</a>:</h4>
<p>Sounds like another STU comment.</p>



<a name="177552815"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177552815" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177552815">(Oct 07 2019 at 19:44)</a>:</h4>
<p>Since the cql.g4 includes the fhirpath.g4, it is part of the grammar, but yes, the specification should be clear about the behavior in CQL.</p>



<a name="177557604"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177557604" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177557604">(Oct 07 2019 at 20:31)</a>:</h4>
<p>I don't think we need <code>$index</code> <em>and</em> the second index arg on queries -- so if have <code>$index</code> that ought to be good enough.</p>



<a name="177557744"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177557744" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177557744">(Oct 07 2019 at 20:33)</a>:</h4>
<p>But is <code>$this</code> and <code>$index</code> considered part of the core spec?  E.g., can we expect standard CQL engines (for CDS/eCQM use cases) to support this?  If it's in the "Using FHIRPath" section, it sounds ancillary.</p>



<a name="177559721"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177559721" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177559721">(Oct 07 2019 at 20:54)</a>:</h4>
<p>Well CQL is defined as a superset of FHIRPath, so any valid FHIRPath expression should be valid in CQL.</p>



<a name="177559768"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177559768" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177559768">(Oct 07 2019 at 20:55)</a>:</h4>
<p>There are some specific options in the translator for disabling some of the FHIRPath functionality, but in general, yes, any CQL engine should be able to run any FHIRPath expression.</p>



<a name="177570894"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/177570894" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#177570894">(Oct 07 2019 at 23:29)</a>:</h4>
<p>I understand that -- but I thought there were general recommendations regarding what features should generally be used or not used in CQL for quality purposes (e.g., for CDS/eCQM).  For example, as you know (since you probably wrote it), the CPG IG defines recommended compiler settings here: <a href="http://hl7.org/fhir/uv/cpg/2019SEP/documentation-libraries.html" target="_blank" title="http://hl7.org/fhir/uv/cpg/2019SEP/documentation-libraries.html">http://hl7.org/fhir/uv/cpg/2019SEP/documentation-libraries.html</a>.</p>
<p>I guess I just have a feeling (right or not) that quality engines may ignore most of what is in the FHIRPath part of CQL (especially since it is mainly relegated to the Appendix -- and Appendix Letter I no less!).  If we want to encourage use of <code>$index</code> in CDS/eCQM and quality engines, we probably ought to document it in the actual <em>chapters</em> of the spec rather than just the appendix.  As someone who built a reference implementation myself, I have to admit that I did not add support for <code>$this</code> or <code>$index</code> (yet)!</p>



<a name="178942381"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/178942381" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Saoji Adhe <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#178942381">(Oct 24 2019 at 11:29)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="191469">@Chris Moesel</span> ,<br>
i want to test cqf-ruler-0.1.13-SNAPSHOT.jar with hapi-fhir-3.8 , to test $evaluate-measure<br>
but it's not working with example given by hspc in there documentation<br>
anybody know about where i will get example related to $evaluate-measure, $apply, cds-hooks etc...<br>
Thank you in advance.</p>



<a name="178957657"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/178957657" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#178957657">(Oct 24 2019 at 14:29)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="196449">@Saoji Adhe</span> -- I don't work on (or use) CQF Ruler, so I'm afraid I can't help you much.  You might want to take up <span class="user-mention" data-user-id="197470">@Alexander Kiel</span> on his offer to try Blaze, or wait for a response from <span class="user-mention" data-user-id="191359">@Bryn Rhodes</span> who is more familiar with CQF Ruler.</p>



<a name="178984678"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/178984678" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#178984678">(Oct 24 2019 at 18:52)</a>:</h4>
<p><span class="user-mention" data-user-id="196449">@Saoji Adhe</span> , there is a CQF-Ruler running <a href="http://cqm-sandbox.alphora.com/cqf-ruler-dstu3" target="_blank" title="http://cqm-sandbox.alphora.com/cqf-ruler-dstu3">here</a> that we use as a sandbox for the connectathons. That has the content from the latest <a href="https://github.com/dbcg/connectathon" target="_blank" title="https://github.com/dbcg/connectathon">connectathon</a> loaded. We are still addressing issues uncovered by that connectathon, so no guarantees that everything there is 100% functional, but it should be enough to play around with.</p>



<a name="184557123"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/184557123" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Adrian <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#184557123">(Dec 31 2019 at 18:02)</a>:</h4>
<p>Another CQL query question.</p>
<p>I have a list of MedicationDispenses (MD[i]), each with a whenHandedOver date and daysSupply quantity. For each MedicationDispense, I need to compute  the consumptionInterval(CI) for the dispense, defined as the earliest interval when this drug could be consumed (i.e., starting at the later of when all prior dispenses have been consumed or when this dispense was handed over and ending when this dispense runs out):<br>
start of CI[i] = maximum(CI[i-1] + 1 day, MD[i].whenHandedOver),<br>
end of CI[i] = start of CI[i] + daysSupply</p>
<p>The problem is that CI[i] depends on the value of CI[i-1], which you can't access from the computation of CI[i]. How does one go about doing something like this in CQL? The best solution I've found so far involves unrolling the evaluation loop, making each calculation of a given CI[i] its own definition, but not only is thisdefinitely not the CQL way to solve this, it also doesn't work for more dispenses than the loop has been unrolled with.</p>
<p>If you want to get CS'y about this, it boils down to computing the earliest start and end times for tasks using batch queueing  on a uniprocessor (the when handed over date is the arrival time, the days supply is the task length, and the consumption interval is the run interval of the task, and the patient is the uniprocessor). Calculating this is essentially a (very simple)  dynamic programming problem. The trouble is that CQL doesn't seem very amenable to dynamic programming problems. If I had a reduce function, this would be fairly simple, but CQL doesn't have that, either. Any ideas?</p>



<a name="184559435"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/184559435" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Adrian <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#184559435">(Dec 31 2019 at 18:44)</a>:</h4>
<p>I also forgot to say that by collapsing the CI[i], you compute the overall set of intervals during which the patient was supplied with drugs.</p>



<a name="184739529"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/184739529" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lloyd McKenzie <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#184739529">(Jan 03 2020 at 14:59)</a>:</h4>
<p><span class="user-mention" data-user-id="191359">@Bryn Rhodes</span></p>



<a name="184755208"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/184755208" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#184755208">(Jan 03 2020 at 18:20)</a>:</h4>
<p>I haven't had time to give this the attention it deserves, but I wonder if the <a href="http://build.fhir.org/ig/HL7/FHIRPath/#aggregateaggregator-expression-init-value-value" target="_blank" title="http://build.fhir.org/ig/HL7/FHIRPath/#aggregateaggregator-expression-init-value-value">.aggregate()</a> operator would provide a solution here?</p>



<a name="184934463"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/184934463" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Adrian <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#184934463">(Jan 06 2020 at 18:51)</a>:</h4>
<p>Thanks for the suggestion, Bryn. I'll see if this function is implemented and if I can come up with something that works using the function.</p>



<a name="184963970"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/184963970" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Keith Deutsch <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#184963970">(Jan 06 2020 at 22:30)</a>:</h4>
<p><span class="user-mention" data-user-id="191359">@Bryn Rhodes</span> , thanks for the aggregate suggestion, but I'm not sure it applies. What I'd like to try to do is reduce <span class="user-mention" data-user-id="242670">@Frank Adrian</span> 's description of the overall problem to a simple, explicit example of what I think is the core problem here. Basically, we can reduce the various MedicationDispense events to a list of intervals like this:</p>
<p>{[1,6], [2,3], [7,10], [15,17]}</p>
<p>And what I think we need to do is to determine a kind of extending overlap such that if the first two overlap, they are added together recursively until we hit a non- overlapping member. The desired sequence of reductions is then:</p>
<p>{[1,8], [7,10], [15,17]}</p>
<p>and finally: {[1,12], [15,17]}</p>
<p>I can achieve this relatively easily in a general purpose language by iteratively replacing the first and second intervals in the list with a single interval that starts when the first interval starts, and has a length that is the sum of the lengths of the first and second intervals, iterating as long as the first two intervals overlap, and then starting the process again with the now second element, until I reach the end of the list. I haven't been able to figure out a way to do this in CQL.</p>



<a name="185228856"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/185228856" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Frank Adrian <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#185228856">(Jan 09 2020 at 16:30)</a>:</h4>
<p>I found an algorithm that (sort of) works, but I basically had to manually unroll the iteration as follows:</p>
<div class="codehilite"><pre><span></span>//Dispense objects represent what happens to a given dispense - it is received on the who (whenHandedOver) date, has ds days supply, with the start of consumption being st, and the end of consumption being nd.
define function Dispense(who DateTime, ds Integer): Tuple{who:date from who, ds: ds, st: date from who, nd: date from who + ds}
define function Dispense(who DateTime, ds Integer, st DateTime, nd DateTime): Tuple{who:date from who, len: ds, st: date from st, nd: date from nd}

//For testing...
define &quot;All Dispenses&quot;: ({Dispense(DateTime(2018, 1, 1), 30), Dispense(DateTime(2018, 1, 1), 30), Dispense(DateTime(2018, 2, 1), 30), Dispense(DateTime(2018, 3, 1), 30)}) T sort by date from who

define function Index(l List&lt;Any&gt;): (expand {Interval[0, Count(l) - 1]} per 1 &#39;1&#39;) I return Tuple{idx: start of I, obj: l[start of I]}

define &quot;All Dispenses Indexed&quot;: Index(&quot;All Dispenses&quot;)
define function GetItem(dispenseListSoFar List&lt;Tuple{idx Integer, obj Any}&gt;, i Integer): First(dispenseListSoFar T where T.idx = i return all T.obj)

//Work around random issue in the execution engine
define function MyMaximum(dtl DateTime, dtr DateTime): if dtl &lt;= dtr then dtr else dtl

//Calculate the start and end consumption dates for the i&#39;th dispense of a given drug. The start of consumption is the maximum of the whenHandedOver date of the i&#39;th dispense
//and the end of consumption of the i-1&#39;th dispense plus one day. The end of consumption for the i&#39;th dispense is the start of consumption of the i&#39;th dispense plus daysSupply.
//Note that the start and end consumption dates for the i&#39;th dispense depends on the end consumption date for the i-1&#39;th dispense (and thus depends on all previous consumption
//dates, which must be computed before the i&#39;th is computed).
define function ComputeStartAndEndDate(i Integer, dispListSoFar List&lt;Tuple{idx Integer, obj Tuple{who DateTime, ds Integer, st DateTime, nd DateTime}}&gt;):
    First(({0}) X //This bit of cruft needed because CQL does not let you define a let outside the confines of a query.
        let dsp: GetItem(dispListSoFar, i) as Tuple{who DateTime, ds Integer, st DateTime, nd DateTime},
            prv: GetItem(dispListSoFar, i-1) as Tuple{who DateTime, ds Integer, st DateTime, nd DateTime},
            //ccStart: Maximum(prv.nd + 1 day, dsp.who),
            ccStart: MyMaximum(date from prv.nd + 1 day, date from dsp.who),  //work around compiler issue above
            ccEnd: ccStart + dsp.ds - 1 day,
            lim: Count(&quot;All Dispenses Indexed&quot;) - 1
        return if i &lt;= 0 or i &gt;= lim
               then dispListSoFar
               else
                  (dispListSoFar except {dsp}) union {Tuple{idx: i, obj: Dispense(dsp.who, dsp.ds, ccStart, ccEnd)}})


define Test0: &quot;All Dispenses Indexed&quot; as List&lt;Tuple{idx Integer, obj Tuple{who DateTime, ds Integer, st DateTime, nd DateTime}}&gt;
define Test1: ComputeStartAndEndDate(1, Test0 as List&lt;Tuple{idx Integer, obj Tuple{who DateTime, ds Integer, st DateTime, nd DateTime}}&gt;)
define Test2: ComputeStartAndEndDate(2, Test1 as List&lt;Tuple{idx Integer, obj Tuple{who DateTime, ds Integer, st DateTime, nd DateTime}}&gt;)
define Test3: ComputeStartAndEndDate(3, Test2 as List&lt;Tuple{idx Integer, obj Tuple{who DateTime, ds Integer, st DateTime, nd DateTime}}&gt;)
//...up to TestN where N is Count(&quot;All Dispenses Indexed&quot;) - 1.
//Ideally, there would be a construct in the language that would allow us to iterate (or at least to do the unrolling in a single line of code).
//Here, we&#39;re unrolling the loop manually. We&#39;ll set a limit here of 50 dispenses or so, with an error escape in case the number of dispenses exceed that amount.
</pre></div>


<p>As far as I can tell, CQL's inability to modify data that has been defined previously requires a new definition to be created for each new piece of state that needs to be iterated over. I'd still like a better solution, if anyone can come up with one.</p>



<a name="187354664"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/187354664" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#187354664">(Feb 04 2020 at 12:39)</a>:</h4>
<p>So, I'm not 100% sure this will work, but here's what I think is a solution using the <code>aggregate()</code> method:</p>
<div class="codehilite"><pre><span></span>define MedicationRequestIntervals:
  [MedicationRequest] MD
    return Interval[MD.whenHandedOver, MD.whenHandedOver + (MD.daysSupply * 1 day)]

define RolledOutIntervals:
  MedicationRequestIntervals.aggregate($total union
    ($this) X
      let S: Max({ end of Last($total) + 1 day, start of X }),
      E: S + duration in days of X
      return Interval[S, E]
  )
</pre></div>



<a name="187354768"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/187354768" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#187354768">(Feb 04 2020 at 12:41)</a>:</h4>
<p>Basically, <code>aggregate</code> sets the value of <code>$total</code> to the result of evaluating the function after each iteration, and returns the overall $total. So each iteration will union the current $total with the calculation of an Interval based on the Last interval in $total.</p>



<a name="187354780"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/187354780" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#187354780">(Feb 04 2020 at 12:41)</a>:</h4>
<p>I think there's probably a bug in that Last will return null if $total is empty (on the first iteration) so there's probably a Coalesce needed there, but that's the gist.</p>



<a name="187354849"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/187354849" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#187354849">(Feb 04 2020 at 12:42)</a>:</h4>
<p>Again, I'm not sure it would work, and even if it did, I'd like to see something more first-class that could handle this.</p>



<a name="187919371"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/algorithms/near/187919371" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/algorithms.html#187919371">(Feb 11 2020 at 15:01)</a>:</h4>
<p>At the Sydney WGM we worked on this problem and are proposing an <code>aggregate</code> clause that would support expression of this type of query. In particular: <a href="/user_uploads/10155/7fMGEIdl_5dOoS4dWRQ_Dkjr/pasted_image.png" target="_blank" title="pasted_image.png">pasted image</a></p>
<div class="message_inline_image"><a href="/user_uploads/10155/7fMGEIdl_5dOoS4dWRQ_Dkjr/pasted_image.png" target="_blank" title="pasted image"><img src="/user_uploads/10155/7fMGEIdl_5dOoS4dWRQ_Dkjr/pasted_image.png"></a></div>


{% endraw %}
<hr><p>Last updated: Apr 12 2022 at 19:14 UTC</p>
