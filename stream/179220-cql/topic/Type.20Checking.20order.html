---
layout: page
title: "FHIR Chat  · Type Checking order · cql"
---

{% raw %}<h2>Stream: <a href="https://fhir.github.io/chat-archive/stream/179220-cql/index.html">cql</a></h2>
<h3>Topic: <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Type.20Checking.20order.html">Type Checking order</a></h3>

<hr>

<base href="https://chat.fhir.org">

<head><link href="https://fhir.github.io/chat-archive/style.css" rel="stylesheet"></head>

<a name="179942211"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Type%20Checking%20order/near/179942211" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Pombrio <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Type.20Checking.20order.html#179942211">(Nov 05 2019 at 15:25)</a>:</h4>
<p>I have a question about how type checking should be implemented in CQL.</p>
<p>Defines and functions can appear in any order. But since they can depend on each other, I'm not sure what order they should be type checked in. For example:</p>
<div class="codehilite"><pre><span></span>define function isSmall(n Integer): lessThanOne(n)
define function lessThanOne(n Integer): n &lt; 1
</pre></div>


<p>It seems to me that it's important to type check <code>lessThanOne</code> _first_, to figure out that it returns a boolean. (Since the return type isn't written in the program.) And then when type checking <code>isSmall</code>, you can see that <code>lessThanOne(n)</code> will return a boolean.</p>
<p>How can you determine what order to type check functions in?</p>
<p>And if they're recursive, like if <code>f</code> calls <code>g</code>, and <code>g</code> calls <code>f</code>, how do you deal with that? Because when functions are recursive, it seems to me that there's no good order that works.</p>



<a name="179948749"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Type%20Checking%20order/near/179948749" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Moesel <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Type.20Checking.20order.html#179948749">(Nov 05 2019 at 16:26)</a>:</h4>
<p>Is this question in the context of processing/compiling the CQL syntax directly?  If you're using the open source CQL-to-ELM translator, there is a flag you can set to have the outputted ELM include the return type for each expression.  Of course, you could also look at the CQL-to-ELM translator to see how it approaches type checking.  I think <span class="user-mention" data-user-id="191359">@Bryn Rhodes</span> implemented most of the type checking there, so he may be able to provide a high-level overview of the approach.</p>



<a name="179949036"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Type%20Checking%20order/near/179949036" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Pombrio <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Type.20Checking.20order.html#179949036">(Nov 05 2019 at 16:29)</a>:</h4>
<p>It's in the context of implementing a new CQL-to-ELM translator.</p>



<a name="179979427"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Type%20Checking%20order/near/179979427" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Pombrio <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Type.20Checking.20order.html#179979427">(Nov 05 2019 at 21:25)</a>:</h4>
<p>Oh, I missed this part of the spec! "Functions can be defined that reference other functions anywhere within any library and to any degree of nesting, so long as the reference does not result in a circular reference." So recursion simply isn't allowed. That answers my question.</p>



<a name="179979524"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Type%20Checking%20order/near/179979524" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Grahame Grieve <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Type.20Checking.20order.html#179979524">(Nov 05 2019 at 21:26)</a>:</h4>
<p>I would think that there's valid uses for recursion in the CQL space. Certainly FHIR resources have a few structures where recursion is a natural fit...</p>



<a name="179980890"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Type%20Checking%20order/near/179980890" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Pombrio <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Type.20Checking.20order.html#179980890">(Nov 05 2019 at 21:43)</a>:</h4>
<p>It would make type checking difficult. In most statically typed languages, function return types are required for exactly this reason.</p>
<p>In Haskell they're not required. But to support this, it uses type inference and unification, and you can end up with a function's return type being an ununified type variable. Adding type variables would be a pretty big addition to CQL's type system.</p>
<p>I don't know of any easy (and sound) way to support type-checking recursive functions when their return types can be omitted.</p>



<a name="179982240"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Type%20Checking%20order/near/179982240" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Grahame Grieve <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Type.20Checking.20order.html#179982240">(Nov 05 2019 at 21:57)</a>:</h4>
<p>run time resolution....? (javascript?)</p>



<a name="180064144"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Type%20Checking%20order/near/180064144" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bryn Rhodes <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Type.20Checking.20order.html#180064144">(Nov 06 2019 at 18:47)</a>:</h4>
<p>There are valid uses for recursion, but it is currently explicitly disallowed. One approach would be to allow it generally (and require the explicit declaration of return types where recursion was used in a function declaration that prevented inference of the type). Another approach would be to introduce a recursive construct (like CTEs in T-SQL).</p>



<a name="180083675"></a>
<h4><a href="https://chat.fhir.org#narrow/stream/179220-cql/topic/Type%20Checking%20order/near/180083675" class="zl"><img src="https://fhir.github.io/chat-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Justin Pombrio <a href="https://fhir.github.io/chat-archive/stream/179220-cql/topic/Type.20Checking.20order.html#180083675">(Nov 06 2019 at 22:36)</a>:</h4>
<p><span class="user-mention" data-user-id="191359">@Bryn Rhodes</span> That makes sense.</p>


{% endraw %}
<hr><p>Last updated: Apr 12 2022 at 19:14 UTC</p>
