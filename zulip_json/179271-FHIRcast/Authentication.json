[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192821\">@Martin Bellehumeur</span>  Have you started with OAuth yet? I'm just looking into it on my side. Microsoft supplies OWIN.OAuth, so I won't have to implement any low level stuff. I'm still not clear on how I want to implement certain things though.</p>\n<p>We need to create a topic that is based on an identity (radiologist). The only way I see this happening is to create a configuration file/database in the hub (which will also be my authentication server). It will enable the authentication process to identify the application user based on their credentials, and return them a topic (essentially the session id).</p>\n<p>From a customer implementation perspective, this could get kind of ugly if individual passwords are required for authentication. <span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span>  suggested that we could use an application-wide secret, which would make it easier. However, we still need to configure users and their grouping. For example, if I am \"gkustas61\" on a PACS but \"georgek\" on Powerscribe, someone needs to configure that. When authentication occurs, the association is made so that they both receive the same topic.</p>\n<p>Any thoughts?</p>",
        "id": 156404069,
        "sender_full_name": "George Kustas",
        "timestamp": 1547849456
    },
    {
        "content": "<p>Hi, I had a busy week with major work-life change.  Sorry, not much progress but this coming week will be much better.  <br>\nI hope we can diverge from the topic definition as defined by websub.  I see it the same way, the topic for us is a user session (for websub, it's a service such as a blog and they contact that service to find out if where  is the hub).  So we should propose a mechanism to resolve \"users of apps\" to a 'user fhircast session- or cast-session' and this would the topic instead of a URL.  At a minimum, we need to receive the name of the app (which would identify the common secret which we would not send out)  and the user identifier in that app.  The hub would need to keep a table of user ids for each app.</p>",
        "id": 156437283,
        "sender_full_name": "Martin Bellehumeur (Visage Imaging)",
        "timestamp": 1547904877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192821\">@Martin Bellehumeur</span>  Thanks for the reply. I hope everything is OK. <br>\nYes - we agreed to use the topic to identify the session, in fact, removed cast-session from use.<br>\nI'm going to take some time to think about this mechanism in a way that addresses:<br>\n1) security - authentication should produce the topic<br>\n2) reasonable usability from a configuration standpoint  - how often will a client app customer need to re-configure based on new/removed users? Can it be automated (triggered) by an application server? Would client app vendors implement that and support it?<br>\n3)Guaranteed synchronization between client and hub (integrity).<br>\nI'll share some ideas as I go along. We only have until May to come up with a specification and a working prototype that follows that spec. This mechanism we're talking about could perhaps be loosely defined in the spec so that the it can be implemented in different ways. But we should also expect that new client app vendors entering into FHIRCast are going to look at real work examples first. I know I would.</p>",
        "id": 156486936,
        "sender_full_name": "George Kustas",
        "timestamp": 1548000597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192821\">@Martin Bellehumeur</span> , <span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span> <span class=\"user-mention\" data-user-id=\"194364\">@Leo Bergnéhr</span> <span class=\"user-mention\" data-user-id=\"194356\">@Will Maethner</span> </p>\n<p>Suggested mechanism for simple client authentication and topic creation. Please take a look and see if you have any comments or suggestions.</p>\n<p>Data model:<br>\n<a href=\"/user_uploads/10155/uoxwWhGkZsQIFmffVxtRGoZp/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/uoxwWhGkZsQIFmffVxtRGoZp/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/uoxwWhGkZsQIFmffVxtRGoZp/pasted_image.png\"></a></div><p>Existing values (as an example):<br>\n<a href=\"/user_uploads/10155/_LJ9au45GUdyk0Yeak3Bvsep/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/_LJ9au45GUdyk0Yeak3Bvsep/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/_LJ9au45GUdyk0Yeak3Bvsep/pasted_image.png\"></a></div><p>1. The \"authentication server\" (which in my prototype will be my FHIR hub) will provide a REST method for authentication. Example: https:/hub-fhircast.nuance.com/authenticate?username=joe&amp;secret=61B584A8-C5AD-4A87-A40F-19E448EEBBAD<br>\n2. The method will return a topic (client id/session id) of 1A3DF21C-1451-4DC5-8B59-3F824D3A7ED7 based on the existing values shown above<br>\n3. If I launch the test app, I can authenticate using:  https:/hub-fhircast.nuance.com/authenticate?username=joe2&amp;secret=EF25A906-1C48-4E87-AC1F-0E48366AAEEB.<br>\n4. I would then receive the same topic as I did in step 2. </p>\n<p>Both apps would then subscribe using this topic and share context from there on.</p>",
        "id": 156502992,
        "sender_full_name": "George Kustas",
        "timestamp": 1548026992
    },
    {
        "content": "<p>Please put in a Security Consideration to remind the implementer to choose the best-available-randomness-on-their-platform for creation of these nonce. Essentially to assure they don't just use a timestamp or counter when a random function is available. Poor nonce will significantly weaken this session authentication mechanism. (this is noted in websub <a href=\"https://www.w3.org/TR/websub/#security-considerations\" target=\"_blank\" title=\"https://www.w3.org/TR/websub/#security-considerations\">https://www.w3.org/TR/websub/#security-considerations</a>, just need emphasis)</p>",
        "id": 156544191,
        "sender_full_name": "John Moehrke",
        "timestamp": 1548085307
    },
    {
        "content": "<p>Yes but maybe it would be easier to get buy-in if we align attribute naming to OpenID.</p>",
        "id": 156601648,
        "sender_full_name": "Martin Bellehumeur (Visage Imaging)",
        "timestamp": 1548161791
    },
    {
        "content": "<p>I'm hoping to revive this thread... We've been using my proposed simple authentication/authorization scheme above for prototyping. We want to start designing a more permanent solution. Everyone seems to agree on OAuth in one way or another. SMART Launch - I hope - will be an option for us. I've read <a href=\"http://www.hl7.org/fhir/smart-app-launch\" target=\"_blank\" title=\"http://www.hl7.org/fhir/smart-app-launch\">http://www.hl7.org/fhir/smart-app-launch</a>, and I think we could fit into the \"standalone launch\" scenario, if...<br>\n1. it will work even even though our app is not browser based (which I think is OK), and<br>\n2. it doesn't require an endpoint/redirect uri on our app (client). This is the same restriction that brought us to websockets to begin with.<br>\nAgain - we're thinking about context sharing as possible data sharing for \"things\" related to imaging studies. I feel that once we (PACS, RIS, EHR and reporting) have a valid topic (user session) established, we're ready to go.</p>\n<p>My question is, can our app, which is an executable launched by the end user, authenticate and receive a topic using the SMART launch specification. If so,  has anyone looked into doing this? <span class=\"user-mention\" data-user-id=\"194364\">@Leo Bergnéhr</span>  perhaps? <span class=\"user-mention\" data-user-id=\"192821\">@Martin Bellehumeur</span> ?</p>",
        "id": 164168993,
        "sender_full_name": "George Kustas",
        "timestamp": 1556198428
    },
    {
        "content": "<p>Hey George, the SMART standalone launch sequence requires a redirect url. There's a couple approaches for this url for mobile/desktop apps.</p>",
        "id": 164177321,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1556204018
    },
    {
        "content": "<p>1) Register a custom protocol handler on the end-user device/Windows machine, e.g. myapp://; then have the OAuth server redirect to this url.</p>",
        "id": 164177347,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1556204028
    },
    {
        "content": "<p>2) The various OS's have somewhat recognized this problem and created: <a href=\"https://docs.microsoft.com/en-us/windows/uwp/launch-resume/web-to-app-linking\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/uwp/launch-resume/web-to-app-linking\">Windows \"app URI handlers\"</a>, <a href=\"https://developer.android.com/training/app-links/\" target=\"_blank\" title=\"https://developer.android.com/training/app-links/\">Android app links</a> and <a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html\" target=\"_blank\" title=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html\">iOS Universal Links</a>. These variously named technologies all work in the same way and allow a desktop/mobile app to be associated with a regular https url, such that when the registered url is navigated to, the app opens instead of a browser.</p>",
        "id": 164177349,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1556204031
    },
    {
        "content": "<p>Interesting... But we would still need an SSL cert, right? Or maybe not, since we can require that the auth server be inside the customer's intranet. This is where our current HL7 Bridge server is, and we can actually put it on the same box. </p>\n<p>Thanks Isaac. I'll look into this.</p>",
        "id": 164269294,
        "sender_full_name": "George Kustas",
        "timestamp": 1556290741
    },
    {
        "content": "<p>Hey George, if you used the Windows \"app URI handlers\" functionality (which looks like it's limited to IE Edge), then I don't think that you'd need a local SSL cert. The intent of these app URI handlers functionality is that an app's public/internet website uri is used as the url for the locally installed app.</p>",
        "id": 164278560,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1556297856
    },
    {
        "content": "<p>Thanks again. I think we will be able to create a simple endpoint in our Powerscribe executable that can handle the redirect.  Of course that's assuming that the Auth server will reside in a safe internal network, not in the cloud. If we need to use an auth server in the cloud, we could create a \"proxy\" endpoint in our HL7 server to handle the redirect, which we would secure with a SSL cert.  It would require one more level of communication from the client to the auth server, but it's workable.</p>",
        "id": 164282361,
        "sender_full_name": "George Kustas",
        "timestamp": 1556300729
    },
    {
        "content": "<p>Hey George, even with the auth server in the cloud, the auth server is telling a browser to redirect to a url. The browser is resolving the url; so redirect urls need to be accessible to the browser, not the oauth server.  Does that make sense?</p>",
        "id": 164289989,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1556306212
    },
    {
        "content": "<p>Further, I've seen some SMART apps implement the EHR launch flow, without redirecting a browser as part of the interaction with the OAuth server's /authorize endpoint, but rather, assuming there's a launch token, call the /authorize endpoint as a RESTful web service themselves. This has the potential to both improve performance and to simplify non-browser based SMART apps. I don't understand the security or authorization implications of this approach.</p>",
        "id": 164290194,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1556306368
    },
    {
        "content": "<p>I hadn't come across the windows app URI handlers, but they smell to me. User doesn't control whether to get the local app or not, and app doesn't control it either? feels like the worst of both worlds...</p>",
        "id": 164294277,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1556309592
    },
    {
        "content": "<p>Grahame, these app URI handlers are really just a more secure version of registering custom protocol schemes as redirect urls in an OAuth2 server. For example, if a developer specifies a redirect url of myapp://, this \"protocol\" must be registered in the OS as part of the app installation. This also presents an attack vector by a 3rd app registering this protocol. These app uri schemes provide an OS-assured method for a redirect url to be known to be owned by the app. When the OS hasn't verified that the https url should open the app, it naturally opens the web page.</p>",
        "id": 164297381,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1556312384
    },
    {
        "content": "<p>(Sorry, not explaining this well).</p>",
        "id": 164297387,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1556312390
    },
    {
        "content": "<p>I'm sceptical that it solves the problem. I'll investigate</p>",
        "id": 164298680,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1556313445
    },
    {
        "content": "<p>This approach is certainly the cleanest way to reuse existing SMART specs. Will be good to see what folks learn by trying. If it doesn't hold up in practice, I'd love to help with formalizing the constraints here, so we can explore other OAuth flows.</p>",
        "id": 164335910,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1556372060
    },
    {
        "content": "<p>Sorry I'm late with a response... I don't know if this matters or not, but our app isn't looking to be \"launched\". We are a desktop (Windows WPF executable) that is launched automatically at user login. When a user logs in (with valid credentials store locally, active directory, etc...), we want to authenticate with the FHIRCast OAuth server simply for the purposes of obtaining a topic (user session) that matches with the same user's \"other applications\" like PACS, RIS, EHR. Whatever it takes, SMART FHIR or something else, we want to confirm to whatever the standard becomes.  We want other vendors to be willing and able to work with our hub (should they desire).</p>",
        "id": 164634915,
        "sender_full_name": "George Kustas",
        "timestamp": 1556727066
    },
    {
        "content": "<p><em>conform</em>, not \"confirm\". So Isaac, are you saying that we can obtain the token needed without being redirected to, obtain a token (as part of the HTTP response), and then use that token to query the auth server for a topic? I didn't get that from the article, but I'll investigate further. That is certainly an option. Again - our only problem is having to expose our app clients to the cloud, because that would require an SSL cert for all of them (major implementation issue).</p>",
        "id": 164635690,
        "sender_full_name": "George Kustas",
        "timestamp": 1556727726
    },
    {
        "content": "<p>I guess there's also the not-very-elegant way of hosting a webserver on the client app.</p>",
        "id": 165166846,
        "sender_full_name": "Leo Bergnéhr",
        "timestamp": 1557325165
    }
]