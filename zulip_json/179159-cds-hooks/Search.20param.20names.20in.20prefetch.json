[
    {
        "content": "<p>Prefetch templates define queries that a particular service would <em>like</em> to be performed with the results passed as part of the service specification.  However, there are a few things that aren't currently addressed in the CDS Hooks specification:</p>\n<ul>\n<li>The search parameter names aren't nailed down by FHIR.  Preferred ones are defined, but servers are allowed to define alternate names - and in the case of collisions, will have to define alternate names.  The true meaning of a given search parameter is determined by looking up the search name in the CapabilityStatement for that server and finding what SearchParameter canonical URL it's tied to.  This is a particular issue when the searches may need to use SearchParameters that aren't defined in the core specification.   What is the intention for how this will work?</li>\n<li>The standard behavior in FHIR when performing queries is to query with what parameters they support and echo what parameters they actually paid attention to in the 'self' link - and the client system then deals with the discrepancy by filtering or issuing narrower queries.  However, in the hook invocation, there's no mechanism to include the 'self' link.  Is the presumption therefore that if a system doesn't support the fully query exactly as specified, it won't execute that prefetch query?  If not, how is the server to know that what it has isn't exectly what it asked for (and that it might have more data or less data than hoped for)?</li>\n<li>Some queries might result in more data than is reasonable to include in the hook call.  Is the expectation that if the result set is too large, that that particular prefetch result will be excluded?</li>\n</ul>",
        "id": 153985606,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534125120
    },
    {
        "content": "<blockquote>\n<p>Some queries might result in more data than is reasonable to include in the hook call. Is the expectation that if the result set is too large, that that particular prefetch result will be excluded?</p>\n</blockquote>\n<p>Yes. I'm pretty sure that we even talked about this (somewhere on github) as one of the scenario's for why it's reasonable for an EHR to not satisfy a pre-fetch request.</p>",
        "id": 153985824,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1534176029
    },
    {
        "content": "<p>Should the specification make that explicit that systems SHALL NOT return pre-fetch if they don't support the fully query as requested?</p>",
        "id": 153985830,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534176807
    },
    {
        "content": "<blockquote>\n<p>Should the specification make that explicit that systems SHALL NOT return pre-fetch if they don't support the fully query as requested?</p>\n</blockquote>\n<p>Lloyd, are you still talking about a search response's size? If so, we do have this in the spec now:</p>\n<blockquote>\n<blockquote>\n<p>The resulting response, which MUST BE rendered in a single page — no \"next page\" links allowed — is passed along to the CDS Service using the prefetch parameter (see below for a complete example).<br>\nand<br>\nthe prefetched data given to the CDS Service MUST BE equivalent to the data the CDS Service would receive if it were making its own call to the EHR FHIR server </p>\n</blockquote>\n</blockquote>\n<p>There's also language around how to handle error'd searches.</p>",
        "id": 153985846,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1534180259
    },
    {
        "content": "<p>The <a href=\"https://cds-hooks.org/specification/1.0/#prefetch-query-restrictions\" target=\"_blank\" title=\"https://cds-hooks.org/specification/1.0/#prefetch-query-restrictions\">Prefetch query restrictions</a> is the section of the spec that is related. (It's been a while since I read this section of the spec). </p>\n<p>The primary goal here is for the CDS service to use search paramters that are supported by the EHR's FHIR server. In practice and for the short-term, this means using US Core's CCDS profiled search terms. Optimally, the search parameters used/useable in CDS Hooks wouldn't be defined in the CDS Hooks specification, but rather would fall back to FHIR while also remaining true to production FHIR servers.</p>",
        "id": 153985847,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1534180439
    },
    {
        "content": "<p>It's not normally an error if someone says \"please filter on x\" and you don't support that filter - typically you just return the search results without the filter applied and declare that's what you've done.  If we need that to be treated as an error from a prefetch perspective, we should make that explicit.</p>",
        "id": 153985881,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534188611
    },
    {
        "content": "<p>Where's the language on limiting max number of rows?  (Beyond supporting the _count parameter)</p>",
        "id": 153985882,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534188722
    },
    {
        "content": "<p>I would think that the case when the server returned results without an expected filter applied should definitely be considered an error condition; if that's the expectation from the FHIR server side we should make a note about in the CDS Hooks prefetch discussion.</p>",
        "id": 153985894,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1534191152
    },
    {
        "content": "<p>As far as limiting the max number of rows, we don't have language beyond just supporting the _count parameter. Should we?</p>",
        "id": 153985895,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1534191176
    },
    {
        "content": "<p>Also, any thoughts on dealing with non-standard search parameter names?</p>",
        "id": 153986100,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534213422
    },
    {
        "content": "<p>this is  a copout, but do we really need to?</p>",
        "id": 153986129,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1534214945
    },
    {
        "content": "<p>I've had to introduce 3 in DaVinci already.</p>",
        "id": 153986130,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534215085
    },
    {
        "content": "<p>Now hopefully those will become part of the core spec for R4, but they won't for R3.</p>",
        "id": 153986131,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534215106
    },
    {
        "content": "<p>(And one of them was the ability to search on Patient for SupplyRequest...)</p>",
        "id": 153986132,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534215153
    },
    {
        "content": "<p>so not exactly esoteric.</p>",
        "id": 153986133,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534215162
    },
    {
        "content": "<p>For R3, can we say that the service consults the FHIR server / implementing health system as part of implementation to determine supported search params?</p>",
        "id": 153986134,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1534215323
    },
    {
        "content": "<p>We can do that for regular queries, but not for prefetch.</p>",
        "id": 153986138,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534215434
    },
    {
        "content": "<p>In that case, the client would need to consult the server - and the server might not have a FHIR endpoint</p>",
        "id": 153986140,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534215457
    },
    {
        "content": "<blockquote>\n<p>Lloyd McKenzie: We can do that for regular queries, but not for prefetch.</p>\n</blockquote>\n<p>hence, the words \"implementing\" and \"implementation\" <span class=\"emoji emoji-1f419\" title=\"octopus\">:octopus:</span></p>",
        "id": 153986147,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1534215606
    },
    {
        "content": "<p>My expectation was that a service gets defined and then exposes itself to a wide variety of clients running a variety of software.  And I wasn't necessarily expecting what those servers supported to be homogeneous or static.</p>",
        "id": 153986150,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534215709
    },
    {
        "content": "<p>Are services expected to be tuned to a single client or small set of clients?</p>",
        "id": 153986151,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534215729
    },
    {
        "content": "<p>No. Services should be tuned to widely and commonly implemented API features ... </p>\n<p>In the absence of widely implemented APIs, stuff gets harder and either services or clients do need to be tuned. A single client should be configured to meet the query needs of the service.</p>",
        "id": 153986158,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1534216006
    },
    {
        "content": "<p>Right.  But is that tuning expected to be handled out-of-band?  My preference is that the discovery mechanism would expose enough information that a client could determine what it needs to do without human-to-human interaction.  Is that unrealistic/not part of intended scope?</p>",
        "id": 153986160,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534216179
    },
    {
        "content": "<p>I understand and empathize. There isn't a configuration mechanism available.</p>",
        "id": 153986162,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1534216245
    },
    {
        "content": "<p>We could make the prefetch declaration unambiguous by providing a list of search-term  - SearchParameter canonical URL pairs.</p>",
        "id": 153986163,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534216539
    },
    {
        "content": "<p>Hey Lloyd, what you're suggesting is, I think, well outside of the 80+% case. The more reasonable alternative would be for the client to specify it's FHIR server when calling the discovery endpoint -- thereby enabling the CDS service to adjust it's prefetch queries to the FHIR server's capabilities. An HTTP GET _iss_ parameter would be reasonable. If the client authenticated (using the same jwt mechanism currently specified for the request), the CDS service would be able to keep track of which client had which capabilities. </p>\n<p>This is pretty advanced stuff, but the above would solve a generic problem.</p>",
        "id": 153986194,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1534222181
    },
    {
        "content": "<blockquote>\n<p>We could make the prefetch declaration unambiguous by providing a list of search-term - SearchParameter canonical URL pairs.</p>\n</blockquote>\n<p>Another option would be DataRequirements in a CapabilityStatement. (would need to be an extension at this point, but we already defined an extension to support a CDS Hooks service endpoint declaration).</p>",
        "id": 153986196,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1534222373
    },
    {
        "content": "<p>Hey Bryn, DataRequirements would interoperably define what the service expects, but not what the client's FHIR server supports -- which is the specific problem Lloyd is trying to solve (I think).</p>",
        "id": 153986201,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1534222653
    },
    {
        "content": "<p>Oh I see, yes.</p>",
        "id": 153986203,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1534222761
    },
    {
        "content": "<p>Listing what each search parameter means is in the 80% for CapabilityStatement and allows the statements to be passive.  The expectation is that whenever clients do a query, they always check the CapabilityStatement before evaluating a query because that's the only way to know what the search parameters mean.  Exposing the linkage in CDSService.prefetch would be consistent with that.</p>\n<p>Active, client-centric declarations of capability would be pretty cool, but seem super-advanced and push a lot of complexity into the server.   Some FHIR servers support that to show user permissions, but it's not common.</p>",
        "id": 153986321,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1534255630
    }
]