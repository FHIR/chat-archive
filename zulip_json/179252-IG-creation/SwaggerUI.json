[
    {
        "content": "<p>Has anyone used the generated OpenAPI files in SwaggerUI?</p>",
        "id": 223858078,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1611554077
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span>  ?</p>",
        "id": 224789670,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612213106
    },
    {
        "content": "<p>I have generated core spec files and used them in SwaggerUI (e.g., <a href=\"https://app.swaggerhub.com/apis/GinoCanessa/fhir-r_4_4_0_1/1.0.0\">4.0.1</a>).  I have not gotten to loading profiles into the code generator yet though.</p>",
        "id": 224789952,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1612213213
    },
    {
        "content": "<p>I want to see the feasibility of adding a SwaggerUI page in an IG. Anything I should look at?</p>",
        "id": 224790707,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1612213524
    },
    {
        "content": "<p><em>opens can of worms</em>  =).  The biggest issue is that there is a lot of variation based on what tooling people are using.  Issues such as:</p>\n<ul>\n<li>variable casing (some tools I've tested against want the first character lower-case, others want upper-case)</li>\n<li>support for circular definitions</li>\n<li>support for referential definitions</li>\n<li>requiring comments vs. prohibiting them</li>\n<li>etc.</li>\n</ul>\n<p>It was painful enough trying to come up with a single definition that works for a people that I gave up on the output files.  Instead, I've tried to make progress on tooling so that people can generate what they need.</p>\n<p>Is that the kind of info you are looking for?</p>",
        "id": 224792547,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1612214348
    },
    {
        "content": "<p>I'm one step behind, I guess.<br>\nDoesn't the publisher already handle the generation of the json  schema? How far are we from the idea of throwing that json at swaggerUI or something like this<br>\n<a href=\"https://github.com/Redocly/redoc\">https://github.com/Redocly/redoc</a><br>\n?</p>",
        "id": 224794112,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1612215101
    },
    {
        "content": "<p>Yes it does.  Generating a definition that matches those properties is certainly possible.</p>\n<p>Unfortunately, if you try to run those definitions through various toolchains many will reject them.  In the two first use cases I was asked to look at, the toolchain requirements meant that a single set <em>could not</em> pass both sets of checks.  One toolchain required all models start with a lower-case letter, while the other required they start with an upper-case letter (as one issue).  There is no rule about it in OpenAPI, and we can certainly set a convention in FHIR (e.g., what the publisher exports), but the file isn't usable if it won't pass validation in someone's workflow.  It would be great if we had the leverage to say \"this is the way we do it, so adapt the toolchain\", but I don't think we're quite there yet.</p>\n<p>My question becomes: why are you generating them?  If the goal is to give people another way to visualize the models, no problem.  If the goal is to allow people to use the definitions with existing systems, <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> </p>\n<p>There are similar challenges with just exporting code from OpenAPI.  Since most people don't use raw models, you need to try and align the exported code with various SDKs (e.g., test exporting Java code and then integrate with the hapi libs, same for C# and Firely, etc.).  I'm not as familiar with the Java libraries, but I can say in the C# side that even if we matched conventions, the generated code would not work.  The libraries do a lot of work to make things 'nicer' for developers, so the raw models aren't <del>typically</del> exactly exposed.</p>\n<p>It may be interesting to build export modules that are compatible with the various libraries... in fact, it sounds like so much fun that I've added it to my list.  But my list is pretty long right now, so it will be a while before I can get there.</p>",
        "id": 224796271,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1612216158
    },
    {
        "content": "<p>Rereading my above comments, it sounds pretty negative.  It shouldn't be, but I'm not sure how to fix it.  I don't want to discourage work and exploration in the area, but I also want to communicate the challenges.</p>\n<p>I would argue that exporting some definition is better than none.  I just want you to know that you are going to get a lot of feedback when people start trying to use them about changes they want.</p>",
        "id": 224797518,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1612216737
    },
    {
        "content": "<p>Nice topic! I would love to provide an OpenAPI/Swagger view on any <a href=\"http://Simplifier.net\">Simplifier.net</a> project or package. (Created <a href=\"https://app.swaggerhub.com/apis-docs/firely/Simplifier.net_FHIR_Package_API\">OpenAPI docs for the Package API</a> while exploring)</p>\n<p>I've tested <a href=\"https://www.npmjs.com/package/fhir-swagger\">https://www.npmjs.com/package/fhir-swagger</a> as a command line tool to create a swagger.json file from a server conformance statement (/metadata), which worked well, but it seems limited to showing the supported profiles.</p>\n<p>A full conformance statement, which not many projects/packages have, is likely necessary to even know what the user intended the spec for; whether it's a server or an app, whether it wants to receive/send data conform certain profiles.</p>\n<p>I think we'll start with an OpenAPI-ish view of per package/project:</p>\n<ul>\n<li>the different used base resources as endpoints with the possible GET/POST/PUT/DELETE formats</li>\n<li>under that the different profiles, search parameters, operation definitions</li>\n<li>and under that linked examples as example data</li>\n</ul>\n<p>Would that cover what you want to see in your OpenAPI view?</p>",
        "id": 225146131,
        "sender_full_name": "Ward Weistra",
        "timestamp": 1612437383
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> <span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> if you missed it <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 225833999,
        "sender_full_name": "Ward Weistra",
        "timestamp": 1612963153
    },
    {
        "content": "<p>Hi Ward, that sounds like a great starting point.</p>\n<p>Where I am stuck is in how the files are going to be used.  If the idea is to generate documentation / views, this is fantastic.  However, if these are going to be used for code generation* or deployment pipelines, there are a <em>lot</em> of things that need to be configurable at runtime.  To pick a different example from earlier: what MIME types are going to be included on the endpoints?  If you are using these files to configure routing / security rules, the MIME types have to be defined and match what the server supports.  An even simpler use case is for a read-only set of definitions.</p>\n<p>So far, I've been going down the road of putting this in the generation.  Maybe it's better for us to pick a standard model and then transform the specs as necessary after?  Or some other process?</p>\n<p>*as mentioned here (and on another thread recently, but I don't have a link handy), code generation is its own problem - it's unlikely that anyone actually wants raw objects, as they would probably prefer code that interoperates with their FHIR library.  Since the conventions aren't the same across languages, this will have to be built out per language as well.</p>",
        "id": 225859048,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1612973124
    },
    {
        "content": "<p>I think my goal was relatively modest, compared to what is described:<br>\nI want to add a SwaggerUI or ReDoc frontend in an ImplementationGuide. <br>\nIn there, we could add a url pointing to a server that is known to support this and say \"here's a test server where you can test these GETs and POSTs)</p>",
        "id": 225860243,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1612973397
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> Good one to add, configure a test server and try it out live.</p>\n<p><span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> This thread? <a href=\"#narrow/stream/179166-implementers/topic/XSD.20Schemas.20from.20FHIR.20Profiles.20for.20Code.20Generation\">https://chat.fhir.org/#narrow/stream/179166-implementers/topic/XSD.20Schemas.20from.20FHIR.20Profiles.20for.20Code.20Generation</a><br>\nIndeed, I was only thinking about documentation here. And indeed, already there there's a lot to be configured to come from a set of resources or even a capability statement to a full API description.<br>\nAnd we also had some requests for downloading classes from resources on <a href=\"http://Simplifier.net\">Simplifier.net</a>. With your code we might be able to offer that at least for .NET, but we're still gathering user requirements on what they'd expect to be in there.</p>",
        "id": 225994322,
        "sender_full_name": "Ward Weistra",
        "timestamp": 1613052243
    },
    {
        "content": "<p>I love ReDoc!  =)</p>\n<p>I am curious to see how more advanced cases work with the generic (non-FHIR) serializers and parsers.  <em>Generally</em> they seemed to behave  in my testing, but I haven't checked to see if everything is valid, just if it \"worked\".</p>\n<p>I'm not as familiar with IG packages from Simplifier (unless they are the same as the ones generated by the IG build).  Does it have enough information that you don't need a a server/capability statement (or the core spec definitions) to generate the definitions?  For example, if someone is profiling the <code>Patient</code> resource, in addition to what is locally defined I think you need:</p>\n<ul>\n<li>search parameter definitions for the resource (so you can successfully do a <code>GET</code>)</li>\n<li>structure for <code>Bundle</code> (so you can search - may not be needed on every profile)</li>\n<li>structure for <code>OperationOutcome</code> (which the IG schema seem do via external reference - not sure if this works)<br>\n...</li>\n</ul>\n<p>For the C# code, yes - I'd like to explore that.  It is a bit down my list right now though, so if anyone else wants to explore I'd love to see the outcome  =)</p>",
        "id": 226015361,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1613059826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> A package is not much more than a snapshot of a FHIR project in time, there's no requirements from <a href=\"http://Simplifier.net\">Simplifier.net</a> on what resources are minimally contained. So, it may well only contain a Patient profile. That's indeed why I'm really looking very generic solutions <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 226112414,
        "sender_full_name": "Ward Weistra",
        "timestamp": 1613120959
    }
]