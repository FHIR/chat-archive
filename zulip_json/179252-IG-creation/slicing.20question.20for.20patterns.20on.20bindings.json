[
    {
        "content": "<p>based on this:</p>\n<blockquote>\n<p>Each slice must use the element definition for the element(s) in the discriminator(s) to ensure that the slices are clearly differentiated by assigning an appropriate value domain, depending on the discriminator type. If the type is value, or pattern, then the element definition must use either:</p>\n</blockquote>\n<blockquote>\n<p>ElementDefinition.fixed[x], or<br>\nElementDefinition.pattern[x], or<br>\n<strong>if the element has a terminology binding, a required binding with a Value Set that enumerates the list of possible codes in the value set (\"extensional definition\")</strong>  (my highlighting )</p>\n</blockquote>\n<p>I did this ...</p>\n<div class=\"codehilite\" data-code-language=\"YAML\"><pre><span></span><code><span class=\"c1\">#....</span>\n    <span class=\"p p-Indicator\">-</span> <span class=\"nt\">id</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">DiagnosticReport.category</span>\n      <span class=\"nt\">path</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">DiagnosticReport.category</span>\n      <span class=\"nt\">slicing</span><span class=\"p\">:</span>\n        <span class=\"nt\">discriminator</span><span class=\"p\">:</span>\n          <span class=\"p p-Indicator\">-</span> <span class=\"nt\">type</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">pattern</span>    <span class=\"c1\">#&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>\n            <span class=\"nt\">path</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">$this</span>          <span class=\"c1\">#&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>\n        <span class=\"nt\">rules</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">open</span>\n      <span class=\"nt\">min</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">1</span>\n      <span class=\"nt\">mustSupport</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">true</span>\n    <span class=\"p p-Indicator\">-</span> <span class=\"nt\">id</span><span class=\"p\">:</span> <span class=\"s\">'DiagnosticReport.category:us-core'</span>\n      <span class=\"nt\">path</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">DiagnosticReport.category</span>\n      <span class=\"nt\">sliceName</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">us-core</span>\n      <span class=\"nt\">min</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">1</span>\n      <span class=\"nt\">mustSupport</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">true</span>\n      <span class=\"nt\">binding</span><span class=\"p\">:</span>  <span class=\"c1\">#&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>\n        <span class=\"nt\">strength</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">extensible</span>  <span class=\"c1\">#&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>\n        <span class=\"nt\">valueSet</span><span class=\"p\">:</span> <span class=\"s\">'http://hl7.org/fhir/us/core/ValueSet/us-core-diagnosticreport-category'</span>  <span class=\"c1\">#&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>\n</code></pre></div>\n<p>which is causing this validation error:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>1. ERROR: DiagnosticReport/bone-density-report: DiagnosticReport.category[0]: Slicing cannot be evaluated: Could not match discriminator ([$this]) for slice DiagnosticReport.category:us-core in profile http://hl7.org/fhir/us/core/StructureDefinition/us-core-diagnosticreport-note - the discriminator [$this] does not have fixed value, binding or existence assertions\n</code></pre></div>\n\n</blockquote>",
        "id": 262739726,
        "sender_full_name": "Eric Haas",
        "timestamp": 1637872984
    },
    {
        "content": "<p>I want this slice to be an extensible binding and to replicate the same binding rules as an extensible binding on CodeableConcept behaves - i.e., at least one of the Categories contains a value from the extensible binding.</p>\n<p>how do I fix it ?</p>\n<ul>\n<li>Does the binding need to be required?  ()</li>\n</ul>\n<p>What does \"extensional definition\" in the documentation above mean exactly (\"a required binding with a Value Set that enumerates the list of possible codes in the value set (\"extensional definition\")?</p>",
        "id": 262739823,
        "sender_full_name": "Eric Haas",
        "timestamp": 1637873108
    },
    {
        "content": "<p>I think the definition is pretty clear: a required binding</p>",
        "id": 262741408,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637874965
    },
    {
        "content": "<p>extensional: see <a href=\"https://www.hl7.org/fhir/valueset.html#int-ext\">https://www.hl7.org/fhir/valueset.html#int-ext</a></p>",
        "id": 262741429,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637875003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> <a href=\"#narrow/stream/179252-IG-creation/topic/slicing.20question.20for.20patterns.20on.20bindings/near/262741408\">said</a>:</p>\n<blockquote>\n<p>I think the definition is pretty clear: a required binding</p>\n</blockquote>\n<p>My question <em>really</em>  is the parenthetic \"extensional definition\" makes no sense in in the context of this  documentation : \"a required binding with a Value Set that enumerates the list of possible codes in the value set (\"extensional definition\")\"   Why is it there ? </p>\n<p>Second, I want this slice to be an extensible binding and to replicate the same binding rules as an extensible binding on CodeableConcept behaves - i.e., at least one of the Categories contains a value from the extensible binding.  how do I do that?   In other words how does validation behave for extensible bindings on CodeableConcepts?  it would be the same as that for slicing.</p>",
        "id": 262743526,
        "sender_full_name": "Eric Haas",
        "timestamp": 1637877651
    },
    {
        "content": "<p>for example,  I have a value set A  = 'foo', 'bar'.  I would like a slice for element bound to value set A but also allow for 'baz' if that is a local extension of the valueset.</p>",
        "id": 262743664,
        "sender_full_name": "Eric Haas",
        "timestamp": 1637877824
    },
    {
        "content": "<p>I don't know how the documentation could be more clear: you can only slice by a required binding</p>",
        "id": 262743865,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637878067
    },
    {
        "content": "<p>and the vocabulary committee don't think \"extensional definition\" makes no sense. it's just what we call 'a value set that enumerates the list of possible codes in the value set' is</p>",
        "id": 262743926,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637878127
    },
    {
        "content": "<p>If the binding is extensible, there's no way for the engine to know when the slice doesn't apply - because any code you send could potentially fall into the 'extensible' space.  (And it would take a human being to figure out whether it did or not.)</p>",
        "id": 262762040,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1637905576
    },
    {
        "content": "<p>IMO This is an academic argument that doesn't reflect the real world and is bad for actual implementation.</p>",
        "id": 262835071,
        "sender_full_name": "Eric Haas",
        "timestamp": 1637961042
    },
    {
        "content": "<p>no. using an extensible binding for a slice discriminator would be bad for actual implementation</p>",
        "id": 262835106,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637961099
    },
    {
        "content": "<p>and what about CodeableConcept with extensiblible bindings - how does that work today?</p>",
        "id": 262835113,
        "sender_full_name": "Eric Haas",
        "timestamp": 1637961108
    },
    {
        "content": "<p>works moderately badly, but what's the relationship?</p>",
        "id": 262835256,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637961244
    },
    {
        "content": "<p>We  assumed incorrectly that an extensibly bound element would behave that way too.  but alas it does not.  So it turns out slicing does not get you that  either.  This is a gap</p>",
        "id": 262835279,
        "sender_full_name": "Eric Haas",
        "timestamp": 1637961289
    },
    {
        "content": "<p>moderately good or badly?</p>",
        "id": 262835291,
        "sender_full_name": "Eric Haas",
        "timestamp": 1637961311
    },
    {
        "content": "<p>I'm not sure what you're saying here. if your question is, 'can a slice have an extensible binding?' then the answer is yes, of course it can. Just like if it wasn't sliced. But if you question is 'can you discriminate a slice based on an extensible binding?' then the answer is no, you can't discriminate like that</p>",
        "id": 262835346,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637961366
    },
    {
        "content": "<p>(and slices that can't be discriminated are bad for implementers)</p>",
        "id": 262835433,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637961500
    },
    {
        "content": "<p>So one solution could be to describe the discriminator and let Inferno figure it out for certification ... <span class=\"user-mention\" data-user-id=\"191506\">@Yunwei Wang</span>  heads up</p>",
        "id": 262835647,
        "sender_full_name": "Eric Haas",
        "timestamp": 1637961759
    },
    {
        "content": "<p>How exactly would you expect the engine to discriminate on an extensible binding <span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span>?  In what circumstances would an instance not <em>always</em> match the slice with that binding?</p>",
        "id": 262836304,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1637962543
    },
    {
        "content": "<blockquote>\n<p>So one solution could be to describe the discriminator and let Inferno figure it out for certification </p>\n</blockquote>\n<p>well, FMG isn't going to approve of that, and inferno couldn't figure it out</p>",
        "id": 262837459,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637964008
    },
    {
        "content": "<p>These value set are not designed to be required as there is not <em>agreement within a context of use that a specified set of codes are the only ones that can be used.</em> and a required bindings on category slice would imply this.    Hopefully we can figure something out.</p>",
        "id": 262848755,
        "sender_full_name": "Eric Haas",
        "timestamp": 1637979862
    },
    {
        "content": "<p>well, you can have an extensible binding. you just can't slice by it</p>",
        "id": 262857282,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637993863
    },
    {
        "content": "<p>what's the details?</p>",
        "id": 262857283,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637993867
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 262897917,
        "sender_full_name": "Eric Haas",
        "timestamp": 1638054703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> <a href=\"#narrow/stream/179252-IG-creation/topic/slicing.20question.20for.20patterns.20on.20bindings/near/262857282\">said</a>:</p>\n<blockquote>\n<p>well, you can have an extensible binding. you just can't slice by it</p>\n</blockquote>\n<p>We have several instances of extensible bindings on if the element <code>category</code> which usually repeats for example <code>DiagnosticReport.category</code> then <em>If an extensible binding is applied to an element with maximum cardinality &gt; 1, the binding applies to all the elements.</em> (<a href=\"http://hl7.org/fhir/R4/terminologies.html#extensible\">http://hl7.org/fhir/R4/terminologies.html#extensible</a>)  That was not our intent and has led to the current situation:</p>\n<ol>\n<li>Our intent is only single repeat be bound to the valueset.  To illustrate this problem , look at <a href=\"http://build.fhir.org/ig/HL7/fhir-sdoh-clinicalcare/StructureDefinition-SDOHCC-Condition.html\">SDOHCC Condition</a> a derived profile from USCore Condition - there <em>SDOH</em> slice which is technically invalid since it does not contain the US Core valueset concepts.    </li>\n<li>In  addition we know our valuesets are incomplete so making it <em>required</em>  prohibits other local valid category concepts.</li>\n</ol>\n<p>I understand the technical difficulty with this but I can imagine defining multiple orthogonal categorization schemes that could be defined with orthogonal not-fully-realized valuesets at time of publishing.</p>",
        "id": 262901107,
        "sender_full_name": "Eric Haas",
        "timestamp": 1638060148
    },
    {
        "content": "<p>The rules with slicing are simple - the discriminators must discriminate.  I.e. no two slices can allow overlapping values for the set of declared discriminators.  Two extensible bindings will <em>always</em> overlap even if the base value sets don't because \"extensible\" means that codes not found within the value set are also allowed. </p>\n<p>The best way to accomplish what you're trying to do is have 0..1 must support slices with required bindings.  That says \"you must be capable of sending and receiving content that looks like this, but it's ok if the category doesn't apply and you're free to send other categories too.  Also, you can't have multiple categories from this value set.\"  (Personally, I think that last statement is questionable - if you're going to say that you must ensure that there's never a circumstance where more than one of the codes could apply at the same time.)</p>",
        "id": 262934018,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638112958
    },
    {
        "content": "<p>generally agree with Lloyd - but it sounds like you really want a pretty general binding and a 'must-support' value set tied to a functional context?</p>",
        "id": 262950857,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638136980
    },
    {
        "content": "<p>Having a required <em>or</em> extensible binding across all category repetitions in US-Core is an error.  That's saying that every repetition must satisfy the binding, which isn't what you want.  If you make category 1..* overall and have a 0..1 required mustSupport slice with your current value set, you'll accomplish your desired outcome.  I.e. \"Must always have a category.  Must send one of our category codes if one of them applies\".</p>",
        "id": 263018834,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638197877
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179252-IG-creation/topic/slicing.20question.20for.20patterns.20on.20bindings/near/263018834\">said</a>:</p>\n<blockquote>\n<p>Having a required <em>or</em> extensible binding across all category repetitions in US-Core is an error.  That's saying that every repetition must satisfy the binding, which isn't what you want.  If you make category 1..* overall and have a 0..1 required mustSupport slice with your current value set, you'll accomplish your desired outcome.  I.e. \"Must always have a category.  Must send one of our category codes if one of them applies\".</p>\n</blockquote>\n<p>I agree and that is what i stated earlier twice and why we are stuck using the more opaque  slicing structure</p>",
        "id": 263022866,
        "sender_full_name": "Eric Haas",
        "timestamp": 1638199673
    },
    {
        "content": "<p>OK after stewing on this over the weekend.</p>\n<p>element 1..*   with 1..* slice on <em>extensible</em> binding ( which we can't do <span aria-label=\"rage\" class=\"emoji emoji-1f621\" role=\"img\" title=\"rage\">:rage:</span>) ~= element 1..*   with 0..* slice on <em>required</em> binding </p>\n<p>The meaning of a required binding is compromised to allow for slicing in this case and folks reading us core are going to see required and have a cow.  We are going to have to document how a required binding slice with a combination of cardinality is really an extensible binding in disguise.</p>",
        "id": 263024568,
        "sender_full_name": "Eric Haas",
        "timestamp": 1638200387
    },
    {
        "content": "<p>I'm confused about the rules for discriminators -- I thought they were technically optional (i.e., without a discriminator, the semantics of slicing still work, just in a less computationally tractable way) per <a href=\"http://build.fhir.org/profiling.html#discriminator\">http://build.fhir.org/profiling.html#discriminator</a> .</p>",
        "id": 263032706,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638203589
    },
    {
        "content": "<p>yes that's right, so why confused?</p>",
        "id": 263050624,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638211288
    },
    {
        "content": "<p>If you just express the rules with a description, you still need to express the rules in a way that can meet the requirements - i.e. every slice can be discriminated and every instance repetition matches against no more than one slice.  If you've got multiple slices with extensible bindings, that's not possible.</p>",
        "id": 263073221,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638223177
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> Not sure what you mean by \"the meaning of a required binding is compromised\".  I don't think there's any compromise here?</p>",
        "id": 263073350,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638223218
    },
    {
        "content": "<p>So there's (intentionally) no way to use slicing to say:</p>\n<ul>\n<li>Need at least one Coding from {\"A\", \"B\", \"C\"}</li>\n<li>Need at least one Coding from {\"C\", \"D\", \"E\"}</li>\n</ul>\n<p>... and satisfy the slicing validator with a single Coding \"C\"?</p>",
        "id": 263073834,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638223472
    },
    {
        "content": "<p>Right.  Slices must be disjoint.</p>",
        "id": 263074016,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638223574
    },
    {
        "content": "<p>Can you help me with the intuition for why? Is it that use cases like the example above don't really exist? Or that supporting such things would introduce  complexities elsewhere?</p>",
        "id": 263074143,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638223644
    },
    {
        "content": "<p>hey no</p>",
        "id": 263075123,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638224118
    },
    {
        "content": "<p>slices don't have to be disjoint, but discriminators have to be disjoint. But slices that are not disjoint are... not anticipated or desired</p>",
        "id": 263075162,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638224143
    },
    {
        "content": "<p>the point of having slices is so that you can describe them differently.</p>",
        "id": 263075319,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638224219
    },
    {
        "content": "<p>the specification does not rule out having over-lapping slices, because we never thought that would be a thing, really. The langauge is written for it not to be a thing, but it's not stated explicitly. E.g. </p>\n<blockquote>\n<p>In this case, the \"code\" element in the target resource can be used to determine which slice that target refers to</p>\n</blockquote>\n<p>It's always singular - an element fits into one slice. But it's only on discriminators that we say:</p>\n<blockquote>\n<p>When a constraining structure designates one or more discriminators, it SHALL ensure that the possible values for each slice are different and non-overlapping, so that the slices can easily be distinguished</p>\n</blockquote>\n<p>Note, though, that the reason is so that slices can <em>easily</em> be distinguished. Not so that they can be distinguished at all, since the language assumes that each element is in at most, one slice. Which is also how the validator is implemented - it allocates elements to slices, and then validates them against their slice (singular)</p>",
        "id": 263075811,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638224492
    },
    {
        "content": "<p>I'm not in a hurry to change that either - slicing is the most difficult code I've ever written (both the snapshot generation, and the validation)</p>",
        "id": 263075840,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638224519
    },
    {
        "content": "<blockquote>\n<p>slices don't have to be disjoint, but discriminators have to be disjoint. But slices that are not disjoint are... not anticipated or desired</p>\n</blockquote>\n<p>How can disjoint discriminators result in nondisjoint slices?  At this point I'm just trying to follow the logic, not arguing for anything in particular.</p>",
        "id": 263075994,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638224593
    },
    {
        "content": "<p>I don't understand how a slice can avoid being disjoint if the discriminators are disjoint?  Can you give an example Grahame?</p>",
        "id": 263076612,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638224941
    },
    {
        "content": "<p>if there is no discriminators</p>",
        "id": 263076771,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638225035
    },
    {
        "content": "<p>the point of discriminators is to discriminate, so if there are any, then conformant slices will be disjoint - they must be. </p>\n<p>but if there's no discriminators, then all bets are off. The spec anticipates that they are still disjoint, but it does not say so explicitly. And the validator implements that they are disjoint, but has no way to test that they are, other than trying to match. I guess I'll have to add a test case to find out what happens to my todo list</p>",
        "id": 263077202,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638225319
    },
    {
        "content": "<p>If there are no discriminators, isn't the discrimination process defined in text - but still expected to actually discriminate?</p>",
        "id": 263080338,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638227230
    },
    {
        "content": "<p>doesn't have to be defined in text. if it's not, then it's purely based on validation against the slices.</p>",
        "id": 263081176,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638227731
    },
    {
        "content": "<p>as for </p>\n<blockquote>\n<p>expected to actually discriminate</p>\n</blockquote>\n<p>yes. it's expected to - at least, we expected it to when we wrote the spec, but we failed to be explicit about it</p>",
        "id": 263081208,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638227762
    },
    {
        "content": "<p><a href=\"http://jira.hl7.org/browse/FHIR-34387\">FHIR#34387</a></p>",
        "id": 263081963,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638228277
    },
    {
        "content": "<p>re \"the meaning of a required binding is compromised\"</p>\n<p>required binding definition: \"The other place where this is used is when profiling resources, and there is agreement within a context of use that a specified set of codes are the only ones that can be used. In these cases, the data type SHALL contain one of the values in the value set.\" ( <a href=\"http://hl7.org/fhir/terminologies.html#required\">http://hl7.org/fhir/terminologies.html#required</a> )</p>\n<p>required binding definition when slicing by valueset : \"The other place where this is used is when slicing by valueset.  Because it is necessary to define disjoint slices only a specified set of codes <em>even if there is not agreement within a context of use that a specified set of codes are the only ones that can be used</em>\"   ( my interpretation.)</p>",
        "id": 263083877,
        "sender_full_name": "Eric Haas",
        "timestamp": 1638229756
    },
    {
        "content": "<p>But the point is - within the slice, it <em>is</em> the only set of codes that can be used.  You just have other slices that allow for other things too.  The meaning of 'required' isn't any different.  You're just using it (appropriately) in a more constrained space.  Outside that space, the 'required' has no force.</p>",
        "id": 263094235,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638238343
    }
]