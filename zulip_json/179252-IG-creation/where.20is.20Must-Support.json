[
    {
        "content": "<p>Is there a well known place in an HL7 IG for a reader to find the definition of Must-Support? Should there be? Are there some good candidates?</p>",
        "id": 255302042,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632864171
    },
    {
        "content": "<p>There's currently no rules.  HRex does theirs <a href=\"https://build.fhir.org/ig/HL7/davinci-ehrx/conformance.html\">here</a>.  US-core does <a href=\"https://build.fhir.org/ig/HL7/US-Core/conformance-expectations.html\">this</a>, so some similarity there.</p>",
        "id": 255325483,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1632877314
    },
    {
        "content": "<p>so those samples show a dedicated, at similar level and navigation as security considerations. I like that. Don't like the name of the page, as I can see some people focusing only on that page as by the name of the page it clearly holds all the conformance criteria.</p>",
        "id": 255387893,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632917740
    },
    {
        "content": "<p>I think I could come to like \"Conformance Expectations\"... Ill try it out.</p>",
        "id": 255389339,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632918422
    },
    {
        "content": "<p>The issue with MS being a narrative definition (we really should have the option to have a ValueSet) is that when you reuse things across IGs users will lose track.</p>",
        "id": 255432221,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1632933919
    },
    {
        "content": "<p>Well, if we have a fixed location like \"Conformance expectations,\" we could at least have the publisher auto-generate links to the conformance expectations for guides you are dependent on.</p>",
        "id": 255434402,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1632934669
    },
    {
        "content": "<p>true if we have a fixed url. I presume that would be a convention, not enforced...?</p>",
        "id": 255442504,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1632937653
    },
    {
        "content": "<p>and I think we should do better than say \"here's all the narratives, go and figure out if one layer is consistent with the other\"</p>",
        "id": 255442696,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1632937717
    },
    {
        "content": "<p>(I presume that is what you implied, <span class=\"user-mention\" data-user-id=\"191380\">@Elliot Silver</span> ?. I think it's a good step, but I think we really should have a structured, coded definition for MS)</p>",
        "id": 255442777,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1632937760
    },
    {
        "content": "<p>I’m not convinced a coded representation is the problem. </p>\n<p>And actually, the more I think about MS, the more it generally scares me. As I’m understanding it now, I think all MS requirements in any IG you implement (or is a dependency of one you implement) apply to any MS element in any profile you implement. It’s like the FHIR equivalent of the GPL open source license—sounds like a good idea, but it infects everything. I hope I’m misunderstanding. </p>\n<p>I also have problems with MS because, unlike all the other profiling controls, I can’t validate an instance against it. We pretend it is computable and flag elements as MS (and coding it would take us further in that direction) but in the end, with anything less than an infinite vocabulary, it comes down to interpreting a narrative that applies to the systems, not to the instances. </p>\n<p>/end rant.</p>",
        "id": 255444739,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1632938481
    },
    {
        "content": "<p>MS doesn't affect downstream 'new' artifacts (unless you declare that your mustSupport rules are the same as an ancestor IG's), but they do affect all derived profiles.</p>\n<p>MS has <em>nothing</em> to do with the instance.  It has to do with the behavior of the systems that produce and/or consume the instance.  We're not pretending it's computable.  mustSupport=true is just a flag that says \"there are rules for what you must be able to do in your system with this element\".</p>\n<p>We <em>could</em> have an optional IG property that indicates the URL of the location where the default mustSupport rules for the IG are set and set the MS flag to link to that.  The tricky bit is that if those are overridden by a particular profile, then you'd want to jump to the text in the profile instead.</p>",
        "id": 255492002,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1632958007
    },
    {
        "content": "<p>I was not looking to solve the problem, just make an incremental improvement. Conformance Expectations is not great, but an attempt to try to get IGs to use a consistent narrative is an incremental improvement. -- which leads me to, increment beyond this would be an element in the IG that is markdown and expresses what must-support means in that IG. IG build magic to have that rendered in the human narrative where the IG author wants it rendered.</p>",
        "id": 255567373,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633006203
    },
    {
        "content": "<p>I see no hope of MS being computable. If anyone was using it for a computable purpose, then we would have a strict functionality like cardinality, or binding, etc.  The use of MS is explicitly not computable rule, but one which the IG could impose..</p>",
        "id": 255567563,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633006284
    },
    {
        "content": "<p>I am a fan of us coming up with something more than binary. I would like a vocabulary, I think we know some MS patterns that we could snap into a vocabulary. Like \"R2/RE\", or \"shall be implemented\"... We now have some experience, we should be able to come up with some vocabulary, with IG defined codes for things not in that extensible vocabulary.</p>",
        "id": 255567895,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633006410
    },
    {
        "content": "<p>strawman: can we add an extension to mustSupport that includes a codeableconcept - and if we want, a (relative) url?</p>",
        "id": 255583487,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1633012044
    },
    {
        "content": "<p>without looking into computable MS, I'd look at whether the differences in MS levels are computable (hence a vocabulary like <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  mentions)</p>",
        "id": 255583839,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1633012157
    },
    {
        "content": "<p>a url or codeing could hold a canonical/vocabulary or locally defined thing.</p>",
        "id": 255584021,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633012217
    },
    {
        "content": "<p>Do you need full-blown CodeableConcept?  My leaning would have been 0..* Coding|string.  Looking at the language in current IGs, I think you'll be hard-pressed to come up with anything computable.  (And I'm not sure what processes would actually try to compute on it?)</p>",
        "id": 255584049,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633012226
    },
    {
        "content": "<p>my \"where is Must-Support\" is not trying to make it computable, but trying to make it definitively findable definition. I think there is some interest in having more than a binary, thus flavors of MS. Even these flavors don't appear to be trying to make them computable (yet). Just findable definitions for each flavor. an IG defined url seems like a reasonable firs step off of binary.</p>",
        "id": 255584652,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633012451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> so your idea would be that the binary MS would still flag simplistically the way it is done today, but an extension in that element could indicate flavors?</p>",
        "id": 255585151,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633012669
    },
    {
        "content": "<p>Right. I don't know if we can change the mustSupport element. But in any case starting with an extension would allow that.</p>",
        "id": 255585541,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1633012803
    },
    {
        "content": "<p>Possibly with an invariant that says that a flavour can only be filled in if the flag is true</p>",
        "id": 255585667,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1633012841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179252-IG-creation/topic/where.20is.20Must-Support/near/255584049\">said</a>:</p>\n<blockquote>\n<p>Do you need full-blown CodeableConcept?  My leaning would have been 0..* Coding|string.  Looking at the language in current IGs, I think you'll be hard-pressed to come up with anything computable.  (And I'm not sure what processes would actually try to compute on it?)</p>\n</blockquote>\n<ul>\n<li>0..* ?</li>\n<li>if we do value[x] which can be Coding | string, is it not better just to have CodeableConcept?</li>\n</ul>",
        "id": 255587271,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1633013420
    },
    {
        "content": "<p>so what would string or CodableConcept.text alone mean? Would that be just a markdown description of THAT instance of MS use?  That seems very unfriendly. I am looking for a few vectors, not infinite vectors.</p>",
        "id": 255587867,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633013635
    },
    {
        "content": "<p>How does an extension on a particular MS flag sync with the idea that MS requirements are not element specific?</p>",
        "id": 255601578,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1633018490
    },
    {
        "content": "<p>The notion of 0..* Coding is that there might be multiple types of support defined \"must capture\", \"must store\", \"must display\", etc.  You can't send those as multiple codings within a CodeableConcept.</p>",
        "id": 255610190,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633021535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191380\">@Elliot Silver</span> MS requirements <em>can</em> be element-specific, profile-specific or IG-specific.  Agree that repeating the requirements on every single element is going to be a maintenance nightmare...</p>",
        "id": 255610364,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633021584
    },
    {
        "content": "<p>My apologies, but my proposal addresses exactly that. It would come as an extension with IG-specific codes. So it is to the IG author to collect the requirements and to sort them a little bit. As a first step not too difficult.</p>",
        "id": 255620952,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633025210
    },
    {
        "content": "<p>IG-specific codes creates no consistency.  Codes would only have value if they could be consistent across IGs</p>",
        "id": 255629023,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633028383
    },
    {
        "content": "<p>I think both are needed. Some commonly agreed to codes (RE/R2, MustImplement, etc), and also IG specific codes.</p>",
        "id": 255629704,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633028618
    },
    {
        "content": "<p>to say that IG specific codes create no consistency is to argue that MS should never be used today in the current form.</p>",
        "id": 255629807,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633028644
    },
    {
        "content": "<p>\"mustimplement\" isn't meaningful, it's just a synonym for mustSupport - if we're going to have codes, they'd need to define <em>what</em> needs to be implemented (storage, display, capture, etc.).  RE doesn't make sense in FHIR because it's combining mustSupport and cardinality.  mustSupport codes (if we have them) can't speak to cardinality at all, only to behavior within the sender or receiver.</p>",
        "id": 255630356,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633028882
    },
    {
        "content": "<p>it is a synonym only in your view. As discussed yesterday that interpretation is not universal.</p>",
        "id": 255630554,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633028958
    },
    {
        "content": "<p>I also think your statement regarding RE is also not universal.</p>",
        "id": 255630731,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633029037
    },
    {
        "content": "<p>\"Required but may be empty\" is absolutely talking about cardinality.  (As all of the v2 conformance codes do, to one extent or other).  If we're going to introduce codes, they ought to have specific meaning that makes clear what needs to be implemented.  The notion of flagging something as \"implementer-relevant\" would be distinct from mustSupport because it will appear on elements where mustSupport is not set.</p>",
        "id": 255632235,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633029651
    },
    {
        "content": "<p>well, I am using MS this way.</p>",
        "id": 255633048,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633029981
    },
    {
        "content": "<p>So you'd put a MS=true on an element that was 0..0?</p>",
        "id": 255633204,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633030045
    },
    {
        "content": "<p>Did I say RE?</p>",
        "id": 255633208,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633030046
    },
    {
        "content": "<p>Nope - John did :)</p>",
        "id": 255633253,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633030063
    },
    {
        "content": "<p>Great. My idea is to have codes for different aspects, ie. axes. As a starting point, select those from IGs, as-is. In a next step one could start with harmonizing.</p>",
        "id": 255633533,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633030168
    },
    {
        "content": "<p>I still cannot see why this should be a bad or unacceptable approach?</p>",
        "id": 255633812,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633030273
    },
    {
        "content": "<p>Yes, I mark optional elements with MS to indicate \"RE\"</p>",
        "id": 255633999,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633030326
    },
    {
        "content": "<p>that is ALL that I use MS for</p>",
        "id": 255634007,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633030332
    },
    {
        "content": "<p>I use MS for all of the attributes in a resource that we are expecting to exchange.  For 1..x fields, that is somewhat obvious since we've said that it always has to be there.  For 0..x fields, it is totally akin to RE since the field is marked as optional, thus the 0 min cardinality, but it is required to send if you have or you should expect to receive it if the server has it.</p>",
        "id": 255635201,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1633030795
    },
    {
        "content": "<p>the distinction I make is that I do still expect recipients to expect to receive all core Resource structure. i don't use MS=false to tell them which items they will not receive.</p>",
        "id": 255636101,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633031134
    },
    {
        "content": "<p>It's possible to have 1..x with MS=false.  (I.e. IG requirements to capture, display, store, etc. don't apply - because there's a fixed value, for example.)</p>",
        "id": 255636412,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633031261
    },
    {
        "content": "<p>MS isn't about what they might or might not receive, it's about what they must actually do something useful with - as opposed to being allowed to throw the data away and do nothing with it.</p>",
        "id": 255636608,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633031334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179252-IG-creation/topic/where.20is.20Must-Support/near/255636608\">said</a>:</p>\n<blockquote>\n<p>MS isn't about what they might or might not receive, it's about what they must actually do something useful with - as opposed to being allowed to throw the data away and do nothing with it.</p>\n</blockquote>\n<p>Here is an interesting conundrum because that's how you are defining it, but I'm defining MS in my guides as what you can expect to specifically receive with the profiles defined in my guides.  For instance, I might define Organization.identifier, name, address, and telecom as MS because those are the elements that want to receive and that I will be sending back when queried.  A client can obviously send the other things in the resource, but my profile says that only those four elements are important to the use cases in my guide.</p>",
        "id": 255640038,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1633032583
    },
    {
        "content": "<p>But you're not marking everything else 0..0 (which is good), and that means that, in theory, they could receive anything.  What you're specifically saying is \"this is the information the sender must be able to expose\" and, maybe \"this is the information the receiver must be able to consume\".  (It's possible to define mustSupport in a US Core-like way where the receiver is free to do what they like.)</p>",
        "id": 255641686,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633033212
    },
    {
        "content": "<p>yup</p>",
        "id": 255673487,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633049729
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> in v2+ we have a mapping table for v2 conformance concepts to FHIR. IMO, \"RE\" must be represented as MS + minCard=0. So, using RE as a precoordinated term for this combination is fine with me, but I know that this is not supported be everyone.</p>",
        "id": 255697912,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633070951
    },
    {
        "content": "<p>A side remark that does not support this thread: The problem with v2 is that it that the conformance concepts and technical details are not 100% equivalent with FHIR. My intent with v2+ is to get this closer, ie. moving v2 with its technical representation.</p>",
        "id": 255698089,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633071071
    },
    {
        "content": "<p>For me it is interesting to see, that you guys are always use good examples what MS means (in a certain IG). All those statements comprise the same elements/aspects. I wonder that we should not be able to extract those. One is action. Store, print and display are always brought forward. Direction is another, ie. sender/receiver. So, why not adding action=print + direction=receiver (as a MS extension) to a specific element to say, that exactly this element/attribute must be printed by the receiver. I know that one can do that by a specific profile for the receiver to denote print elements, but this is overkill from a management perspective. For computation, one can use this management information to generate appropriate technical profiles.</p>",
        "id": 255699160,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633071766
    },
    {
        "content": "<p>note that this is how IHE treats Document Content, and has named options for each of these that a Document Consumer would declare (display, persist, decompose, etc). As in a Document Content profile there is little declared infrastructure, the interop layer would tend to be one of the Document Sharing profiles (XDS, XDR, XCA, XDM, MHD, etc). And a Document Content profile can be used in a larger IG where workflows can be triggered and specific processing defined.  Some workflows or processing requirements may call upon one of the named options from the Document Content IG. This is highly modular approach. The specific mechanism is the ability to have sub-behaviors that can be explicitly named (named options) and invoked by higher level need (systems design or another IG).  - <a href=\"https://www.ihe.net/uploadedFiles/Documents/PCC/IHE_PCC_TF_Vol1.pdf\">https://www.ihe.net/uploadedFiles/Documents/PCC/IHE_PCC_TF_Vol1.pdf</a></p>",
        "id": 255753062,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633098598
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191549\">@Frank Oemig</span> The challenge is that those generic 'theoretical' concepts then hit the real world and you end up with the rather elaborate mustSupport rules described in places like US Core.  (And which they revise almost every release based on feedback.)</p>",
        "id": 255784923,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633111632
    },
    {
        "content": "<p>Ok, so we table this discussion again. .</p>",
        "id": 255793102,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633115334
    },
    {
        "content": "<p>I think there are 2 discussions: </p>\n<ol>\n<li>do we need coded MS</li>\n<li>what are the codes</li>\n</ol>",
        "id": 255793254,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1633115405
    },
    {
        "content": "<p>I think the first one should be had asap otherwise the second will always be difficult</p>",
        "id": 255793301,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1633115427
    },
    {
        "content": "<p>Ad 1: yes<br>\nAd 2: let's start</p>",
        "id": 255793335,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633115442
    },
    {
        "content": "<p>I'm ambivant on this. I think that the most useful aspect of being more specific about must-support is allowing the IG publisher to make a reference to a section in an IG somewhere that explains what must support means for this particular element. I think that if US IG had a way to do different must-support for different elements, things might be a little simpler, because must-support means different things for different elements So I'll certainly support doing something in the IG publisher if we can get enough consensus to come up with some kind of extension.</p>\n<p>I'm less confident that we'll come up with something that has real semantic meaning.  Consider the definition of RE from v2.7:</p>\n<blockquote>\n<p>The element may be missing from the message, but should be sent by the sending application if there is relevant data. A conforming sending application should be capable of populating all \"RE\" elements. A conforming sending application that knows the required values for the element, should send that element. A conforming sending application that does not know the required values, shall omit the element. </p>\n<p>Receiving applications will be expected to process (save/print/archive/etc.) or ignore data contained in the element, but should be able to successfully process the message if the element is omitted (no error message should be generated because the element is missing). </p>\n</blockquote>\n<p>this is all should (not SHOULD!). And all so qualified. \"if there is <em>relevant</em> data? By whose decision? And what is the impact of security and privacy?</p>\n<p>And receiving applications will be expected to do something, or not? What else could they do than something, or not?</p>\n<p>As far as I'm concerned, this definition is as meaningless as anything we've come up with, and I've never understood why anyone would bother with it (long before I started on FHIR)</p>",
        "id": 255797876,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633117655
    },
    {
        "content": "<p>one other note: it's clear that Lloyd has a very stylised way of using must-support that is totally coherent and self-contained (and maybe even to be recommended) but is based on some assumptions that are not explicitly stated in the specification, and I'm pretty sure that not all of us would agree to them</p>",
        "id": 255798021,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633117719
    },
    {
        "content": "<p>If you're going to define codes, I'd encourage starting with a set of 5-6 diverse IGs and see how they've defined mustSupport for their IGs and how you might code that - and then think about what benefits you'd get from representing that information in a coded way.</p>",
        "id": 255830011,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633138177
    },
    {
        "content": "<p>Thx, <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> , this is what I have asked for.</p>",
        "id": 256037795,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633344145
    },
    {
        "content": "<p>Regarding security, this is something one should leave out from any discussion, because we are talking about capabilities.</p>",
        "id": 256037918,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633344230
    },
    {
        "content": "<p>it should be mentioned, so that there's clarity: if a system declines to populate a field because of security concerns, does it meet the RE requirement?</p>",
        "id": 256040504,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633345578
    },
    {
        "content": "<p>I would separate that. In a testing environment there shouldn't be security concerns to properly validate. In real life if you want to validate covering security aspects one has to create appropriate profiles.</p>",
        "id": 256740207,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633700113
    },
    {
        "content": "<p>of course you want to test security. All I'm saying is, we should be clear about our expectations</p>",
        "id": 256782521,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633717053
    },
    {
        "content": "<p>That is not what I have said. Of course you have to test security to see it is working. But you cannot expect to validate against a profile requiring a name and immediately test with security on saying not to send names. <br>\nIf you want to do that you have to work with different profiles...</p>",
        "id": 256960257,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1633876850
    },
    {
        "content": "<p>mustSupport isn't \"requiring\" anything in terms of the instance.  It'll be common for mustSupport to make allowance for business agreements, patient consent, regulation and other restrictions on populating the element.</p>",
        "id": 256968142,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633884448
    }
]