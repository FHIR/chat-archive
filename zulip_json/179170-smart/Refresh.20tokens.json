[
    {
        "content": "<p>Looks like ONC's final rule doesn't give public clients the right to a refresh token -- this is a huge blow for pure-client-side apps like native mobile apps and HTML5/JS Web apps, and I'm frankly puzzled by it</p>\n<p>FYI <span class=\"user-mention\" data-user-id=\"191414\">@Dan Gottlieb</span></p>",
        "id": 190090514,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583772302
    },
    {
        "content": "<p>Does it deny their use?  Or simply not specify?  If the EHR vendor choses to implement, that would be allowed, I'd assume?  </p>\n<p>Without the refresh tokens, it becomes a more transactional access model rather than a streaming 'always on' model.  And probably will drive solutions towards having a PHR store, like Apple Health Records.</p>",
        "id": 190112251,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1583784594
    },
    {
        "content": "<p>Overall, the rules just set a floor -- so nothing precludes use, but in real life, the regulatory floor is often as high as most parties climb.</p>",
        "id": 190114774,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583786007
    },
    {
        "content": "<p>Re: forcing solutions towards a PHR store, yes that's true, but it creates an <em>uneven playing field</em> for PHR stores, if big/important PHR providers can negotiate for refresh tokens, and others can't.</p>",
        "id": 190114852,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583786052
    },
    {
        "content": "<p>Are you sure? </p>\n<blockquote>\n<p>This includes the requirements finalized in ยง170.315(g)(10)(v)(A)(2)(i) that Health IT Modules presented for testing and certification must demonstrate that access is granted to patient data in accordance with the implementation specification adopted in ยง 170.215(a)(3) without requiring re-authorization and re-authentication when a valid refresh token is supplied by the application. It also includes the requirements finalized in ยง 170.315(g)(10)(v)(A)(2)(ii) that an application capable of storing a client secret must be issued a new refresh token valid for a new period of no less than three months.</p>\n</blockquote>\n<p><a href=\"https://www.healthit.gov/cerus/sites/cerus/files/2020-03/ONC_Cures_Act_Final_Rule_03092020.pdf\" target=\"_blank\" title=\"https://www.healthit.gov/cerus/sites/cerus/files/2020-03/ONC_Cures_Act_Final_Rule_03092020.pdf\">pg 403</a></p>",
        "id": 190138986,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1583809900
    },
    {
        "content": "<p>See page 1174:</p>\n<blockquote>\n<p>An application capable of storing a client secret must be issued a refresh token valid for a period of no less than three months.</p>\n</blockquote>",
        "id": 190139118,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583810055
    },
    {
        "content": "<p>in practice though I think the fact that refresh tokens are available for confidential clients will lead to one of two behaviors:</p>\n<ol>\n<li>\n<p>Developers will register native mobile apps as confidential clients, and simply distribute them with a static secret that isn't really a secret.</p>\n</li>\n<li>\n<p>Developers will insert a \"secure\" web server into their process, rather than having the mobile app connect directly to EHR systems. This exposes more surface area to attackers without a security gain.</p>\n</li>\n</ol>\n<p>So if I were an EHR developer I would just allow public clients to get refresh tokens. The SMART specification allows it and ONC allows it (but does not seem to require it).</p>",
        "id": 190139201,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583810197
    },
    {
        "content": "<p>(Oh, sorry, Josh, I misunderstood your original point -- I mistakenly thought you were saying that refresh tokens weren't being mandated at all).</p>",
        "id": 190139219,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1583810272
    },
    {
        "content": "<p>How is the outcome of your #1 different from allowing public clients to have a refresh token?</p>",
        "id": 190139380,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1583810418
    },
    {
        "content": "<p>The outcome really isn't different; I think #1 just introduces ambiguity or confusion about whether things are secrets or not. When we first wrote the smart specification I wanted to avoid that ambiguity so I made it explicit that public clients would not be given fake secrets. The principle being: if something is labeled as a secret in your code and in the protocol then it should be kept secret :-)</p>",
        "id": 190139411,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583810493
    },
    {
        "content": "<p>Also from the perspective of the rules: #1 maybe involves app developers misrepresenting the capabilities of their apps to ensure that they can get refreshed tokens? I'm not sure on this.</p>",
        "id": 190139473,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583810603
    },
    {
        "content": "<p>I totally agree with your principle. Your entire premise is that developers will act in bad faith. Have you read the comment/response section on dyn reg? That's the technical solution, here.</p>",
        "id": 190139525,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1583810680
    },
    {
        "content": "<p>Dynamic registration would be a nice solution here, I agree! (My premise is not that developers would be acting in bad faith; it is that they would take the technical steps required to provide a reasonable user experience. Adding a web server to the mix clearly is not bad faith, but neither does it improve the security.)</p>",
        "id": 190139547,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583810750
    },
    {
        "content": "<p>yes, that's true. Wasn't trying to besmirch you or our hypothetical patient app developer. :)</p>",
        "id": 190139595,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1583810777
    },
    {
        "content": "<p>Also if I think about single device dynamic registration versus just using public clients on those devices, it's really not clear to me that the dynamic registration offers better security properties.</p>",
        "id": 190139599,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583810812
    },
    {
        "content": "<p>where public clients means without persistent access? Yes. Totally.</p>",
        "id": 190139609,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1583810851
    },
    {
        "content": "<p>In other words, the dynamic registration approach does let you keep a secret on the device, but does the secret really improve the security properties? It's generally stored in the same place is that the access tokens and refresh tokens and protected health data are stored...</p>",
        "id": 190139611,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583810857
    },
    {
        "content": "<p>In my comment above when I said public clients I just meant clients that could not keep a static secret; I think these clients are perfectly capable of maintaining persistent access.</p>",
        "id": 190139657,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583810895
    },
    {
        "content": "<p>It's all about the length of data access and the requirement on the user to re-authorize. That's where the security actually lives (for clients that cannot \"keep a secret\").</p>",
        "id": 190139661,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1583810903
    },
    {
        "content": "<p>The user experience is all about that, I agree. But basically any app architecture is capable of supporting refresh tokens, and I'm wondering why you would suggest that a dynamically registered mobile app provides better security when it comes to using those refresh tokens.</p>",
        "id": 190139676,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583810966
    },
    {
        "content": "<p>The issues you listed re: how long the data access lasts for and the requirement to reauthorize -- they apply equally to apps that can keep a secret and to apps that cannot.</p>",
        "id": 190139721,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583811006
    },
    {
        "content": "<p>If a secret is confidential, it serves as a stand-in for the user re-authorizing.</p>",
        "id": 190139751,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1583811103
    },
    {
        "content": "<p>I'm not sure I understand that</p>",
        "id": 190139806,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583811155
    },
    {
        "content": "<p>I could just as well say if a refresh token is confidential it stands in for the user reauthorizing</p>",
        "id": 190139808,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583811165
    },
    {
        "content": "<p>isn't a refresh token typically communicated and, at least temporarily, stored on the insecure client, though? The basic premise here is that the client isn't secure (also, I feel super out of my depth arguing OAuth philosophy with you -- however, it also seems obvious to me that public clients shouldn't be trusted with persistent access).</p>",
        "id": 190140343,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1583812089
    },
    {
        "content": "<p>The refresh token is stored wherever the access token is stored. This could be a client or a server.</p>",
        "id": 190175822,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583849507
    },
    {
        "content": "<p>To dyn reg aspects in relation to native apps - it limits the attack to the specific app install (since it's not a secret that will be shared with all installs). As you point out, that device has places to (typically) securely store data. But if you put a \"shared\" secret in that location, you've exposed the broader platform since there are ways to view that data with access to the physical device.</p>",
        "id": 190194499,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1583858129
    },
    {
        "content": "<p>I agree with this exactly as you've stated, Jenni  -- i.e., you've articulated exactly the benefit of dynreg. But in my estimation it's a pretty modest benefit; and given we have no production support for (or regulatory requirement for) dynreg today, it feels like quite a jump to say \"this is what we need, in order to make native apps safe.\" We already have real-world native apps (e.g., Apple Health) that we trust to make persistent connections to the EHR (even without dynreg).</p>",
        "id": 190195451,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583858626
    },
    {
        "content": "<p>Correct, but Apple also correctly protects that secret as a confidential app. I agree that there's confusion about how to correctly set up a confidential app that can have long term access by providing credentials that prove they're the authorized owner of the refresh token</p>",
        "id": 190196272,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1583859025
    },
    {
        "content": "<p>The public apps not having that capability and being tied to an active session goes with the idea that you're only able to protect <em>that specific session</em> and the app doesn't need that data after the user logs off</p>",
        "id": 190196357,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1583859071
    },
    {
        "content": "<p>typically those types of apps also can't continue to call after they're shut down. Native apps get wonky depending on architecture.</p>",
        "id": 190196429,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1583859113
    },
    {
        "content": "<blockquote>\n<p>Correct, but Apple also correctly protects that secret as a confidential app. </p>\n</blockquote>\n<p>Can you clarify on this? My understanding is that connections go directly from phone to EHR (i.e. \"public client\", even if under the hood there's a \"secret\" issued). This is to say, no access tokens, authorization codes, refresh tokens, or PHI leaves the device, and there's no per-device secrets (no dynreg).</p>",
        "id": 190197702,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583859755
    },
    {
        "content": "<p>We do not need to invent these rules. The IETF community already has \"Best Current Practice\" (bcp212) that has all kinds of these very important rules. We should just leverage that 'standard'... imagine that, a standards organization leveraging another standards organization .   <a href=\"https://tools.ietf.org/html/bcp212\" target=\"_blank\" title=\"https://tools.ietf.org/html/bcp212\">https://tools.ietf.org/html/bcp212</a></p>",
        "id": 190411740,
        "sender_full_name": "John Moehrke",
        "timestamp": 1584030805
    },
    {
        "content": "<p>and are drafting a best current practice for oauth security <a href=\"https://tools.ietf.org/html/draft-ietf-oauth-security-topics-09\" target=\"_blank\" title=\"https://tools.ietf.org/html/draft-ietf-oauth-security-topics-09\">https://tools.ietf.org/html/draft-ietf-oauth-security-topics-09</a></p>",
        "id": 190411998,
        "sender_full_name": "John Moehrke",
        "timestamp": 1584030929
    },
    {
        "content": "<p>John, would you say that sections 8.5 and 8.6 are most relevant here? </p>\n<p><a href=\"https://tools.ietf.org/html/bcp212#section-8.5\" target=\"_blank\" title=\"https://tools.ietf.org/html/bcp212#section-8.5\">https://tools.ietf.org/html/bcp212#section-8.5</a></p>",
        "id": 190412715,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1584031262
    },
    {
        "content": "<p>dyn reg scales awfully bad in products like Keycloak</p>",
        "id": 190448804,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1584049340
    },
    {
        "content": "<p>I think we brought that bcp up/discussed it during one of our oauth threads... but may have ben daVinci? or another accelerator</p>",
        "id": 190462626,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1584062539
    },
    {
        "content": "<p>Definitely has some good things</p>",
        "id": 190462631,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1584062555
    },
    {
        "content": "<p>Picking up on an old thread. </p>\n<p>For a native app to do <a href=\"https://tools.ietf.org/html/bcp212#section-8.5\">trusted dynamic client registration</a> like Isaac, John, and Jenni describe above, the client will need to know where to find the register URL.</p>",
        "id": 217051059,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1605641657
    },
    {
        "content": "<p>Have we discussed this at all yet?</p>",
        "id": 217051096,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1605641676
    },
    {
        "content": "<p>It seems to make sense that it would be in the CapabilityStatement along with the auth and token endpoints.  Is that right?  If so, how would we identity it?</p>",
        "id": 217051209,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1605641741
    },
    {
        "content": "<p>It's discoverable in the .well-known SMART configuration</p>",
        "id": 217051513,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1605641888
    },
    {
        "content": "<p>Oh, hey, there it is!  :)</p>",
        "id": 217051556,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1605641916
    },
    {
        "content": "<p>For anyone who finds this later: <a href=\"http://hl7.org/fhir/smart-app-launch/conformance/index.html#using-well-known\">http://hl7.org/fhir/smart-app-launch/conformance/index.html#using-well-known</a></p>",
        "id": 217051577,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1605641927
    },
    {
        "content": "<p><a href=\"http://hl7.org/fhir/smart-app-launch/conformance/index.html#declaring-support-for-oauth2-endpoints\">http://hl7.org/fhir/smart-app-launch/conformance/index.html#declaring-support-for-oauth2-endpoints</a></p>",
        "id": 217051615,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1605641948
    },
    {
        "content": "<p>From 4.2.1 <br>\nregistration_endpoint: OPTIONAL, if available, URL to the OAuth2 dynamic registration endpoint for this FHIR server.</p>",
        "id": 217051620,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1605641950
    },
    {
        "content": "<p>Thanks Josh.</p>",
        "id": 217051631,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1605641956
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315322\">@Kunal Shah</span> this is what we were talking about earlier.</p>",
        "id": 217051661,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1605641976
    }
]