[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> got a question about pushing data out of an EHR</p>",
        "id": 153914238,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508206354
    },
    {
        "content": "<p>once an EHR has set up a smart on FHIR service, the easiest way to refer a patient to an external service, with data, is via a smart on FHIR app - it loads up, loads data from the EHR, asks any additional questions that are relevant, and then submits the data. There's all sorts of uses for that, and it's way cool that the recipient can write the smart up without really needing to work with the EHR provider to do the integration</p>",
        "id": 153914239,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508206467
    },
    {
        "content": "<p>but what about the following scenario:</p>\n<ul>\n<li>once a clinician has used the SMART on FHIR application once, then additional changes to the patient's problem list or medication list should be pushed to the external recipient</li>\n</ul>",
        "id": 153914240,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508206512
    },
    {
        "content": "<p>(of course, this assumes that appropriate consent etc has been gathered. Let's assume that happens)</p>",
        "id": 153914241,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508206542
    },
    {
        "content": "<p>I can't imagine how the recipient could implement this in smart on fhir application.... they'd be stuck back waiting for custom back end integration from the source EHR... or have I missed something?</p>",
        "id": 153914242,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508206581
    },
    {
        "content": "<p>Definitely a key use case. If I replace the phrase \"should be pushed to\" with \"should be made available to\", then long-term access with refresh tokens can help with this scenario.</p>",
        "id": 153914265,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1508208830
    },
    {
        "content": "<p>umm I don't understand that second bit. How does a long term access /  refresh tokens help?</p>",
        "id": 153914271,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508208992
    },
    {
        "content": "<p>Assuming that there's a way for that application to continuously run. Some SMART on FHIR applications will only live for as long as they are being driven by the web browser instance that they were launched into. If there is any server component to that web application there's no guarantee that it will have any network connection between them and the EHR. The browser effectively acts like a proxy between EHR and whatever other backend the SMART on FHIR application connects to.</p>",
        "id": 153914273,
        "sender_full_name": "David Teirney",
        "timestamp": 1508209055
    },
    {
        "content": "<p>I guess that's where I'm stuck - I can make a long term access token, but where does the app run?</p>",
        "id": 153914275,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508209102
    },
    {
        "content": "<p>We've run into that integration challenge with an application running on a desktop and integrating with an EHR application through FHIR APIs (outside of SMART on FHIR launch). We had feedback that the person using the EHR would like to verify any information that was sent out to our backend (also FHIR based) to ensure only appropriate information was being sent to the other system via that mechanism.</p>",
        "id": 153914281,
        "sender_full_name": "David Teirney",
        "timestamp": 1508209398
    },
    {
        "content": "<p>Are there other parts of the FHIR ecosystem where this challenge resides as well? E.g. CDA push of Patient Summary documents at the end of an encounter within an EHR was hoped to ensure that a bunch of downstream systems were at least updated with core summary information. Not sure where CDA on FHIR is at but is that hoped to cover off part of this?</p>",
        "id": 153914282,
        "sender_full_name": "David Teirney",
        "timestamp": 1508209535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191355\">@Kevin Shekleton</span> <span class=\"user-mention\" data-user-id=\"191368\">@Brett Esler</span> do you guys have arrangement for long running apps?</p>",
        "id": 153914285,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508209664
    },
    {
        "content": "<p>though really, there's a difference here - the UI app is authorised for a single patient. You don't want 1000s of long running apps, one for each patient. This breaks down to a second app using the bulk data interface, I think</p>",
        "id": 153914286,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508209794
    },
    {
        "content": "<p>We don't have any apps used by a practitioner that want to run longer than the user's session. As I'm sure you're already aware, we have a patient facing app (Sync4Science) that is doing this.</p>",
        "id": 153914290,
        "sender_full_name": "Kevin Shekleton",
        "timestamp": 1508210255
    },
    {
        "content": "<p>If you have a long running app like you're describing, the FHIR access needs to be moved to the server rather than the browser</p>",
        "id": 153914291,
        "sender_full_name": "Kevin Shekleton",
        "timestamp": 1508210308
    },
    {
        "content": "<p>.... and you don't currently support that except through the patient facing app? And if I think this through you don't have any infrastructure to link a clinician action to a patient OAuth consent - that'd be 2 entirely separate actions</p>",
        "id": 153914292,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508210440
    },
    {
        "content": "<p>Right now, we just support the really long lived access tokens with patient facing apps (simply because we haven't run into provider facing apps that need this yet)</p>",
        "id": 153914297,
        "sender_full_name": "Kevin Shekleton",
        "timestamp": 1508210806
    },
    {
        "content": "<p>Can you clarify what you mean by \"you don't have any infrastructure to link a clinician action to a patient OAuth consent - that'd be 2 entirely separate actions\"?</p>",
        "id": 153914298,
        "sender_full_name": "Kevin Shekleton",
        "timestamp": 1508210831
    },
    {
        "content": "<p>well, in an ideal world - from the patient's POV - the fact that they consented to the sharing, and did share.. they then start again from scratch with consent and sharing on the patient portal... patient matching... ah....</p>",
        "id": 153914303,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508211412
    },
    {
        "content": "<p>just looking at yet another proposal. The most natural sequence would be:<br>\n- clinician uses a smart app to register a patient with [some clinical repository]<br>\n- the smart app knows the patient portal for the system it's running in, and authorizes the [clinical repository] to access data from the patient portal<br>\n- the patient can revoke that later if they want</p>",
        "id": 153914389,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508236066
    },
    {
        "content": "<p>I think we haven't actually nailed that workflow down, <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span></p>",
        "id": 153914390,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508236078
    },
    {
        "content": "<p>and also, there's a cds-hook that can prompt the clinician to talk to the user about registering an eligible patient</p>",
        "id": 153914392,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508236123
    },
    {
        "content": "<p>(that bit is already all hooked up)</p>",
        "id": 153914398,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508236418
    },
    {
        "content": "<p>We usually think about which user (or organization) is allowing access. In our current SMART approach, the answer is: someone who has access and is able to share. That is typically a provider working at an organization, or a patient -- what you're describing seems to be a hybrid <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, where a provider and <em>then also</em> a patient would need to allow access? Can you explain why this model looks important? If either party alone has the right to share, why require both together to enable the connection?</p>",
        "id": 153914421,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1508247813
    },
    {
        "content": "<p>Well, its more about workflow - the clinician makes the referral, but then data keeps flowing; the patient has control. Better to hand over seamlessly than to make the patient also make the connection again.</p>",
        "id": 153914422,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508248057
    },
    {
        "content": "<p>So this is supported. The way you'd accomplish it would be with two SMART app launches: one from the EHR, which a clinician approves; and the other a Standalone launch which the patient approves. How these two launches are tied together is not something the platform tries to solve. But for example the external registry could send an email to the patient to kick off the process continuation. Or the initiating provider could print out a sheet of paper with instructions on how to continue sign up. Or the clinician could give the patient a tablet for in-office use. Or any other method you could dream up.</p>",
        "id": 153914423,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1508248262
    },
    {
        "content": "<p>I will think about this some more but I feel as though there's something missing from SMART here - and it's come up for me in a different context</p>",
        "id": 153914534,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508279640
    },
    {
        "content": "<p>I think that a smart app should be able to ask the authorization server to clone it's session, so that it can generate a new session that has different (derived) properties.</p>",
        "id": 153914535,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508279683
    },
    {
        "content": "<p>one use where I think this is very pertinent is with cds-hooks, where an application probably doesn't want the cds-hooks server to have all the same rights to access the patient record that it does. In fact, it very likely wants to retain the write level privileges for itself. But as things stand, there's no arrangement for it to get an access token that has different (less) privileges than it has.</p>",
        "id": 153914536,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508279772
    },
    {
        "content": "<p>and then this is another case - generate a long lasting session that has different (less) rights than the initial session</p>",
        "id": 153914537,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508279794
    },
    {
        "content": "<p>a related question that came up for me while thinking about this: the smart app launch spec is not specific about that you can use an authorization token only once...</p>",
        "id": 153914538,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508279890
    },
    {
        "content": "<p>is that meant to be the case? it's the case in my implementation...</p>",
        "id": 153914539,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508279913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> what do you mean that you can only use the authorization token once? That would lie in the purview of the OAuth spec - which says you can use the token until it expires</p>",
        "id": 153914703,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1508347663
    },
    {
        "content": "<p>EG: <a href=\"https://tools.ietf.org/html/rfc6749#section-1.4\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc6749#section-1.4\">https://tools.ietf.org/html/rfc6749#section-1.4</a> and <a href=\"https://tools.ietf.org/html/rfc6750\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc6750\">https://tools.ietf.org/html/rfc6750</a> (since we use Bearer tokens in SMART)</p>",
        "id": 153914709,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1508347877
    },
    {
        "content": "<p>expires or becomes otherwise invalid :) but usually that invalid (in my experience) is based on security features that would disable tokens that were compromised</p>",
        "id": 153914710,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1508347920
    },
    {
        "content": "<p>Something neither SMART nor the OAuth 2 Framework want to describe in detail - how that is controled is usually left up to the implementer. The spec allows you to communicate the expiry (if it applies) and errors if the token becomes otherwise invalid</p>",
        "id": 153914713,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1508347979
    },
    {
        "content": "<p>As to the long running session having less permissions than the initial: Yeah, that's not specifically required by SMART nor OAuth (and I'm not sure if we want it to be), but the authorization server can choose to remove scopes when the token is refreshed, or the app can request fewer scopes when they get a new token.</p>",
        "id": 153914719,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1508348147
    },
    {
        "content": "<p>In the S4S case: the app requests the scopes it needs for the long running session. We use those requested scopes to tell the patient what the app will use. S4S could request fewer scopes later, but we already told the patient they have access to more</p>",
        "id": 153914720,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1508348201
    },
    {
        "content": "<p>If S4S tried to ask for more, our server wouldn't let it, since the patient didn't authorize that (S4S would need to kick off a new authorization request somehow)</p>",
        "id": 153914721,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1508348234
    },
    {
        "content": "<p>Grahame's question of long-running apps and notification of updates actually looks like an issue <span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span> should be considering with his Context Synchronization PSS (not yet approved).</p>",
        "id": 153914772,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1508362087
    },
    {
        "content": "<blockquote>\n<p>once a clinician has used the SMART on FHIR application once, then additional changes to the patient's problem list or medication list should be pushed to the external recipient</p>\n</blockquote>\n<p>In my opinion, S4S's model of periodically polling the FHIR server is technically (and understandably) flawed because it simply made use of the RESTful APIs that were being implemented. I believe strongly that periodic polling for event-based data is almost never the elegant design. </p>\n<p>Rather, the technically correct approach for both S4S, and (I think), the scenario that you're describing, <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> , is for the clinician-launched SMART app to both get a refresh_token and to create a Subscription.</p>",
        "id": 153914791,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1508379825
    },
    {
        "content": "<blockquote>\n<p>I think that a smart app should be able to ask the authorization server to clone it's session, so that it can generate a new session that has different (derived) properties.</p>\n</blockquote>\n<p>This sounds awfully complicated. I'll reiterate <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> 's point that:</p>\n<blockquote>\n<p>The way you'd accomplish it would be with two SMART app launches: one from the EHR, which a clinician approves; and the other … which the patient approves … for example the external registry could send an email to the patient … or the initiating provider could print out a sheet of paper … or the clinician could give the patient a tablet for in-office use </p>\n</blockquote>\n<p>or the provider sends the patient a message from their EHR with a link to the app or the app can be launched from the patient's portal or …</p>",
        "id": 153914792,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1508379876
    },
    {
        "content": "<p>Overall -- </p>\n<ul>\n<li>Subscriptions is a great way to push updates. RESTful queries aren't.</li>\n<li>We already do have a great model for either a clinician or a patient authorizing long-running data access to an app. It's refresh tokens via the SMART launch spec.</li>\n<li>In-browser apps aren't good at long-running access -- this isn't a problem that should be solved by the authorization server. It's a simple matter of the app adding minimal, persistent app storage.</li>\n</ul>",
        "id": 153914793,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1508379932
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span> I mean to refer to 'authorization code' - can you use that more than once. Sorry for that mistake</p>",
        "id": 153914796,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508380207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span>  I think I'd prefer a subscription, but what's the timeline for supporting that? But I think you overlooked an important part of my question - how can an EHR client that is itself an OAuth client invoke a cds-hook and provide it with some access to a server, but not all the access the client itself has? at present, we have no infrastructure for this, and I think this is a big security flaw in cds-hooks as it is</p>",
        "id": 153914797,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508380340
    },
    {
        "content": "<p>nor do I think that the problem of long running apps can be solved by adding minimal, persistent storage. that might be useful, but where does this stuff <em>happen</em>?</p>",
        "id": 153914798,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508380392
    },
    {
        "content": "<p>as for subscriptions.. fine. I like that model... but what's a working model for long term subscriptions from a smart app that's not shot full of security holes or demands for heaps of admnistration?</p>",
        "id": 153914800,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508380438
    },
    {
        "content": "<p>I think the S4S model is not terribly efficient, but administation is certainly simple</p>",
        "id": 153914801,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508380454
    },
    {
        "content": "<p>Grahame, yes, you're definitely right that I'm overlooking the complexity of your scenario and don't know your timelines. Subscriptions is how we should solve this general problem eventually. </p>\n<blockquote>\n<p>what's a working model for long term subscriptions from a smart app that's not shot full of security holes or demands for heaps of administration?</p>\n</blockquote>\n<p>I think that a working model could be that the FHIR server only accepts a new Subscription with an end datetime equal to or less than the expiration date of the app's token. The app would need to refresh or reauthorize to maintain it's subscription past that time.</p>",
        "id": 153914802,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1508380670
    },
    {
        "content": "<p>Not try to change the topic. But I have a question. How complex is to implement Subscriptions in an iOS or web client ? GraphQL vs RESTful vs Subsciptions, which one is better ?</p>",
        "id": 153914805,
        "sender_full_name": "Venkateswara R Davuluri",
        "timestamp": 1508380860
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"192083\">@Venkateswara R Davuluri</span>, there's a couple different \"channel\" methods defined in the <a href=\"https://www.hl7.org/fhir/subscription.html\" target=\"_blank\" title=\"https://www.hl7.org/fhir/subscription.html\">spec</a>, which I think would influence what platform would be better.</p>\n<p>I think that FHIR Subscriptions and REST/GraphQL have different use-cases and naturally complement one another.  Subscriptions is FHIR's pub/sub model.</p>",
        "id": 153914806,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1508381176
    },
    {
        "content": "<p>Dear <span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span> Thank you for response. We are presently working on REST for an iOS application. we tried to use SubScriptions - but constant chaning client IP and How to handle the events in Server side are two limitation, I noticed.  Thank you.</p>",
        "id": 153914853,
        "sender_full_name": "Venkateswara R Davuluri",
        "timestamp": 1508422731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> you may be interested in <a href=\"https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-09\" target=\"_blank\" title=\"https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-09\">https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-09</a> which is an effort at:</p>\n<blockquote>\n<p>defining how to request and obtain security tokens from OAuth 2.0 authorization servers, including security tokens employing impersonation and delegation.</p>\n</blockquote>",
        "id": 153914858,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1508424486
    },
    {
        "content": "<p>It's an interesting area, to be sure.</p>",
        "id": 153914859,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1508424498
    },
    {
        "content": "<p>When it comes to authorization codes: we don't technically require servers to treat these as one-time-use codes, but it is important for servers to prevent inappropriate replay. Our S4S test suite checks to make sure codes don't work more than once, and I think this the right approach. We could definitely add this as guidance.</p>",
        "id": 153914860,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1508424561
    },
    {
        "content": "<p>yes, that rfc is definitely interesting</p>",
        "id": 153915231,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508701843
    },
    {
        "content": "<p>and yes, we should document that authorization codes are one use only.</p>",
        "id": 153915583,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508818677
    }
]