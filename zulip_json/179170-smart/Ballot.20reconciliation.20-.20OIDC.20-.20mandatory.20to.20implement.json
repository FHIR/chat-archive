[
    {
        "content": "<p>Per, <a href=\"http://build.fhir.org/ig/HL7/smart-app-launch/scopes-and-launch-context/index.html#scopes-for-requesting-identity-data\" target=\"_blank\" title=\"http://build.fhir.org/ig/HL7/smart-app-launch/scopes-and-launch-context/index.html#scopes-for-requesting-identity-data\">Scopes for requesting Identity data</a> -&gt; <a href=\"https://openid.net/specs/openid-connect-core-1_0.html#ServerMTI\" target=\"_blank\" title=\"https://openid.net/specs/openid-connect-core-1_0.html#ServerMTI\">OIDC 15.1</a>:</p>\n<blockquote>\n<p>OPs MUST support the prompt parameter, as defined in Section 3.1.2, including the specified user interface behaviors such as none and login.</p>\n</blockquote>",
        "id": 154005913,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1538674402
    },
    {
        "content": "<p>Further, per <a href=\"https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint\" target=\"_blank\" title=\"https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint\">OIDC 3.1.2.1</a> :</p>\n<blockquote>\n<p>prompt<br>\nOPTIONAL. Space delimited, case sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for reauthentication and consent. The defined values are:<br>\nnone<br>\nThe Authorization Server MUST NOT display any authentication or consent user interface pages. An error is returned if an End-User is not already authenticated or the Client does not have pre-configured consent for the requested Claims or does not fulfill other conditions for processing the request. The error code will typically be login_required, interaction_required, or another code defined in Section 3.1.2.6. This can be used as a method to check for existing authentication and/or consent.<br>\nlogin<br>\nThe Authorization Server SHOULD prompt the End-User for reauthentication. If it cannot reauthenticate the End-User, it MUST return an error, typically login_required.<br>\nconsent<br>\nThe Authorization Server SHOULD prompt the End-User for consent before returning information to the Client. If it cannot obtain consent, it MUST return an error, typically consent_required.<br>\nselect_account<br>\nThe Authorization Server SHOULD prompt the End-User to select a user account. This enables an End-User who has multiple accounts at the Authorization Server to select amongst the multiple accounts that they might have current sessions for. If it cannot obtain an account selection choice made by the End-User, it MUST return an error, typically account_selection_required.</p>\n</blockquote>",
        "id": 154005914,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1538674419
    },
    {
        "content": "<p>Enabling advanced features such as prompt and display in order to claim the SMART <code>sso-openid-connect</code> capability feels like a large jump from what's actually implemented and tested at connectathons.</p>",
        "id": 154005915,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1538674440
    },
    {
        "content": "<p>I want to add that I would love to see more widespread support for the <code>prompt</code> parameter: it helps avoid weird saved-state situations logging in to different resource servers that use the same auth server. But I will defer to you EHR folks on whether it makes sense to make it mandatory or not.</p>",
        "id": 154006178,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1538710835
    },
    {
        "content": "<p>For the group here <span class=\"user-mention\" data-user-id=\"191339\">@Pascal Pfiffner</span> can you describe a bit more: what weird behavior do you see, and how does <code>prompt</code> help?</p>",
        "id": 154006348,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1538752600
    },
    {
        "content": "<p>Imagine you want to login to portal A and then login to portal B in order to receive access tokens to download your data. If these portals share the authorization server you may be logged in with portal A credentials when bringing up the login screen for portal B. You may see the username/password fields telling you that you have been logged out, which is confusing. You may also not even see the username/password fields but proceed to a nonfunctional \"Authorize\" page (because the user doesn't exist for portal B). To get out of this state you need to manually sign out and then sign back in with your portal B credentials. This process usually loses OAuth2 context so after entering portal B credentials it's unlikely that the redirect is being called correctly or you end up in the portal, rather than the \"Authorize\" screen. <code>prompt=login</code> can remediate these cases by always forcing a fresh login.</p>",
        "id": 154006913,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1539044533
    },
    {
        "content": "<p>-/-</p>",
        "id": 154006914,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1539044576
    },
    {
        "content": "<p>why is the client asking for that?</p>",
        "id": 154006925,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1539048450
    },
    {
        "content": "<p>Yeah, this feel like a broken authz service out of the gate.</p>",
        "id": 154006926,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1539049832
    },
    {
        "content": "<p>This may be a client that aggregates data from several portals, so you would login to portalA, the token would be used to grab your data, then you would login to portalB and so on. If it's the same authz service then I can see how it would keep a session as to not have the user log in again. I'm not sure the authz service could necessarily know that the already logged-in user doesn't exist for portalB, though I would presume it could (and therefore would prompt to login).</p>",
        "id": 154007064,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1539105300
    }
]