[
    {
        "content": "<p>Have we ever considered/discussed having a well known endpoint for SMART apps? In the past, for FHIR, there has been discussion about capabilityStatements that are app-specific (what capabilities they use/require)... But there's no standard way to host that</p>",
        "id": 211788320,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601484207
    },
    {
        "content": "<p>Similarly, do we think SMART apps will ever want to declare the SMART capabilities they need?</p>",
        "id": 211788660,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601484352
    },
    {
        "content": "<p>Do you have an example of what this would be used for and what it'd look like? I'm not sure if I'm following.</p>",
        "id": 211805477,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1601492585
    },
    {
        "content": "<p>re: declaring capabilities, I guess I'd say maybe. There hasn't been much interest in client CapabilityStatements overall, but maybe some of Grahame's ideas around a \"features\" API would help with this.</p>",
        "id": 211805526,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1601492618
    },
    {
        "content": "<p>One way would be to point to the location of their capabilityStatement and required/implemented SMART features, so that during dynamic registration you could also determine compatibility</p>",
        "id": 211814082,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601496908
    },
    {
        "content": "<p>We're also looking at ways to provide better assurances to patients that the app is \"trustable\" - based on certs as well as the app/website/host \"declaring\" an intent to host the SMART app in some way...</p>",
        "id": 211814235,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601496971
    },
    {
        "content": "<p>(vs, for example, exploiting an open redirect to get a \"trusted\" certificate)</p>",
        "id": 211814290,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601496998
    },
    {
        "content": "<p>Jenni, have ya'll ever looked at <a href=\"http://www.udap.org/udap-certifications-and-endorsements.html\">UDAP's endorsements</a>? (Dennis knows alot about this). It's complicated, and thorough.</p>",
        "id": 211814546,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1601497103
    },
    {
        "content": "<p>I don't think (unless I'm missing it being used outside of registration) that helps with ongoing trust validation/developer identity</p>",
        "id": 211814991,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601497300
    },
    {
        "content": "<p>It does help with compatibility (at least initially) with the auth mechanisms, but won't touch FHIR capabilities</p>",
        "id": 211815067,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601497329
    },
    {
        "content": "<p>but things often \"work\" or can be \"trusted\" when first registered. 5 years down the road, there are different issues</p>",
        "id": 211815111,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601497360
    },
    {
        "content": "<p>(specifically: without requiring \"special effort\" of going through some certifier - and I'm not as worried about the ones that are validated by someone... that's a different level of trust)</p>",
        "id": 211815799,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601497716
    },
    {
        "content": "<p>Hoping <span class=\"user-mention\" data-user-id=\"195299\">@Luis Maas</span> can weigh in here as we (CARIN) like what he has done to establish trust with UDAP endorsements.</p>",
        "id": 211865026,
        "sender_full_name": "Ryan Howells",
        "timestamp": 1601522038
    },
    {
        "content": "<p>To be clear, the type of trust I'm trying to establish here would hopefully not require an app to be validated - that is a different level of trust, and it's not something we can require for 21CC apps</p>",
        "id": 211923224,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601564300
    },
    {
        "content": "<p>This would hopefully be a \"low bar\" approach that a developer could do on their own to essentially \"prove\" they own the URL they're redirecting to, in addition to using the certificates advertised on the URL itself.</p>",
        "id": 211923402,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601564386
    },
    {
        "content": "<p>The certs get us pretty far in what we can tell the patient we know about an app, but there are some scenarios it doesn't account for (eg: hosting platforms, security vulnerabilities like open redirect)</p>",
        "id": 211923569,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601564450
    },
    {
        "content": "<p>And in an ongoing fashion - not just at initial reg</p>",
        "id": 211923627,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601564472
    },
    {
        "content": "<p>And I still think it's useful for an app to have a well known (even if not well_known) like FHIR servers have to declare their functionality and requirements :)</p>",
        "id": 211923811,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601564536
    },
    {
        "content": "<p>I can see wanting to align with UDAP, as those features may be things an org would \"certify\" as well</p>",
        "id": 211923994,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601564602
    },
    {
        "content": "<p>Jenni - I think I understand your goal. A clarification to the above (that Luis is better qualified to make) -- UDAP's self-signed certification is a technical mechanism for an app to make an attestation during registration. </p>\n<p>Back to your goal, I'm sure you're familiar with the variety of non-standard methods used to <a href=\"https://www.google.com/search?q=verify+domain+ownership\">verify domain ownership</a>. It's usually some form of: developer given auto-generated code to place in a specifically named file on their domain. An interesting variation of this is a DNS TXT file containing a one-time generated code <a href=\"https://cloud.google.com/identity/docs/verify-domain-txt\">used by Google Cloud</a>.</p>\n<p>These domain ownership verification methods are intended to be single use though. What have you already considered?</p>",
        "id": 212121090,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1601668658
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span>  yes, and we were curious about something from well known being that \"non-standard\" (but standard for SMART) way to do something like that. That both verifies \"I own this\" AND \"I intended it to host a SMART app\" (open redirect/hosting issues)</p>",
        "id": 212134902,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601676940
    },
    {
        "content": "<p>That is ongoing b/c the certs can be consistently checked/the file that proves intention can be checked (it would need to be more of a signed approach - lowest fi from a server perspective is \"sign this with your private key\" b/c we have the public cert, but that may not be easy for all)</p>",
        "id": 212135081,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1601677049
    }
]