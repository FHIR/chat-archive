[
    {
        "content": "<p>In yesterday's Argo2020 call, we talked about a few different syntaxes for representing granular scopes. <span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span> you shared comments about scope size; do you have specific targets or limits you'd like us to consider, to help us pin down an objective consideration of trade-offs? (And do even our current resource-level scopes meet those targets, or are we already failing?)</p>",
        "id": 199056081,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1590687931
    },
    {
        "content": "<p>The URL length limit comes into play during the authorization request. This varies by browser, and your proxies etc between you and the final target. One I've seen is 2048 (at a tomcat and I think IE use to have this) total for the full URL</p>",
        "id": 199058126,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590688842
    },
    {
        "content": "<p>Current scope string for our app connecting to Cerner is 280 characters (because no * - so list every resource individually)</p>",
        "id": 199058790,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1590689124
    },
    {
        "content": "<p>For the token size, if a server is embedding scopes into the token vs requiring constant call backs to a central service, the size limit again varies. And it varies a lot :) eg: a popular gateway may put a general 25k limit on header size. But apparently apache defaults to 8k... and I thought nginx had some even lower defaults (it's been a while, I'll see if I can find updates) <a href=\"https://stackoverflow.com/questions/686217/maximum-on-http-header-values\">https://stackoverflow.com/questions/686217/maximum-on-http-header-values</a></p>",
        "id": 199058803,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590689131
    },
    {
        "content": "<p>But that header size has to include <em>everything</em> in that token, not just scopes</p>",
        "id": 199058859,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590689148
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span>  yeah, and I think we need to revisit wildcards during our SMART scope discussion :) We haven't implemented it because the spec says it means everything now <em>and in the future</em> that may be available, which is really hard to describe to a patient that is authorizing access. If we went back to \"it's just a shortcut to the scopes I'm authorized for\" that's different :) But a bit out of scope of this thread right now</p>",
        "id": 199059117,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590689273
    },
    {
        "content": "<p>However, even if the URL req could use wildcards,  I wouldn't want to require them, and it won't solve the token header size limit since you would need to know what was actually authorized by the patient</p>",
        "id": 199059235,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590689319
    },
    {
        "content": "<p>There are approaches an auth server can do to reduce size (but still not require resource servers to call back to a central location like introspection), so that is another consideration</p>",
        "id": 199060067,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590689540
    },
    {
        "content": "<p>Re: header size, this is a slightly different issue, since the access token doesn't need to include literal SMART scopes inside (but obviously it's nice if they can).</p>",
        "id": 199068031,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1590693046
    },
    {
        "content": "<p>For an app that's fetching data about dozens of resource types, are the current SMART scopes hitting some practical limits? Or do we just not have experience with apps like that?</p>",
        "id": 199068259,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1590693163
    },
    {
        "content": "<p>Given the relatively small focus of US Core?</p>",
        "id": 199068278,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1590693178
    },
    {
        "content": "<p>Basically I want some way to decide whether we need to so something more extreme about scope size, like having clients send hashes of or references to a full scope list, rather than transmitting full details about scopes in the URL</p>",
        "id": 199068644,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1590693347
    },
    {
        "content": "<p>For example, if we wanted to support a 2048 character URL limit, including space for stuff that is not scopes, we would have maybe a kilobyte to work with for scopes. That clearly breaks down if you are individually listing fhir resources.</p>",
        "id": 199069155,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1590693571
    },
    {
        "content": "<p>If we did that/recommended that, we would likely also want to recommend auth servers actually use the scopes param in the token response to communicate what was actually granted</p>",
        "id": 199069974,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590693882
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> Not following the comment on header - you just mean that (if a server doesn't require callback to central authority) the token wouldn't need to be literal SMART scopes? If so, that may affect what out of the box auth servers you could use (that don't understand SMART first class)</p>",
        "id": 199070304,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590693960
    },
    {
        "content": "<p>Yes, that's all I meant (i.e., we don't specify anything about access token format).</p>",
        "id": 199070821,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1590694137
    },
    {
        "content": "<p>I don't think we need to do things that are extreme, but more want to understand that there are reasons to find a balance between verbosity and compactness :)</p>",
        "id": 199070862,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590694144
    },
    {
        "content": "<p>But for choices that are within a factor of, say .5-1.5x of the size our current approach, I'm having a hard time knowing whether this matters.</p>",
        "id": 199071007,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1590694181
    },
    {
        "content": "<p>On one assessment, our current approach already doesn't scale, and anything we <em>add</em> to it only makes it worse.</p>",
        "id": 199071101,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1590694195
    },
    {
        "content": "<p>yeah, I'm not too worried if it doesn't expand to \"all the things you could query on\" :)</p>",
        "id": 199073842,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590695166
    },
    {
        "content": "<p>Google has some \"longer\" API scopes, but also not sure how common it is for an app to use a bunch</p>",
        "id": 199073915,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590695217
    },
    {
        "content": "<p>Today, we haven't hit limits with the URLs, and we do have some apps that ask for every combination of scope that we offer in sandbox :)</p>",
        "id": 199074015,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590695271
    },
    {
        "content": "<p>That is usually whittled down before prod, so that the \"conflicting\" scopes are no longer requested (eg: both patient/{}.read and user/{}.read don't make sense)</p>",
        "id": 199074159,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1590695337
    },
    {
        "content": "<p>But right now support in your server is limited to a subset of the FHIR API, and some of the generic servers would have many more resource types to contend with. Plus layering on the complexity of sub resource scopes like specific categories or tags... We are obviously going to need more space to express these policies.</p>",
        "id": 199074163,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1590695340
    },
    {
        "content": "<p>I would like to offer that these needs to get more and more comprehensive might be a good reason to help security out with Permission resource. This is a very drafty draft. We have already found many problems with the draft. But the idea of Permission is to carry access control rules.  Meaning, don't bother looking at the Permission resource we have, it is just a first draft placeholder.</p>",
        "id": 199402528,
        "sender_full_name": "John Moehrke",
        "timestamp": 1591034691
    },
    {
        "content": "<p>I hope we can come up with a OAuth scope pattern that meets majority needs, while pushing more detailed needs into a Permission resource. Where that resource might be referenced or contained; where that resource might be used in other ways too</p>",
        "id": 199402785,
        "sender_full_name": "John Moehrke",
        "timestamp": 1591034810
    },
    {
        "content": "<p>how would you represent scopes in a Permission?</p>",
        "id": 199700940,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1591240162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> <a href=\"#narrow/stream/179170-smart/topic/Granular.20scopes/near/199700940\">said</a>:</p>\n<blockquote>\n<p>how would you represent scopes in a Permission?</p>\n</blockquote>\n<p>There have been discussions of having scopes be json encoded. That seems like an opportunity to have the same json be a subset of a Permission resource. If it gets complex enough the scope could be a reference rather than contained in the scope.  --- and key to this is that Permission draft in the spec today is highly drafty and needs major re-design.  I am simply pointing out that the needs of a OAuth scope is the same needs as are driving Permission.</p>",
        "id": 199744834,
        "sender_full_name": "John Moehrke",
        "timestamp": 1591276708
    },
    {
        "content": "<p>I do think that we can do some much more achievable step that doesn't not require json encoding.</p>",
        "id": 199744922,
        "sender_full_name": "John Moehrke",
        "timestamp": 1591276753
    },
    {
        "content": "<p>I'm assuming you have an extra negative in there :-)</p>",
        "id": 199744958,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1591276772
    },
    {
        "content": "<p>For our next Argonaut call I would love it if people could bring additional proposals so that we can compare them to the approach I laid out last week.</p>",
        "id": 199744996,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1591276794
    },
    {
        "content": "<p>I worry we're not exploring this design space effectively yet, And it's hard to discuss things like size requirements in the abstract.</p>",
        "id": 199745165,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1591276863
    },
    {
        "content": "<p>agree. simple achievable next step.</p>",
        "id": 199746467,
        "sender_full_name": "John Moehrke",
        "timestamp": 1591277437
    },
    {
        "content": "<p>The primary concern was the \"unbounded\" scope description using a query</p>",
        "id": 199751016,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591279364
    },
    {
        "content": "<p>eg: I can easily (and we have seen it happen) query for observations \"labs\" using many many loincs just to get at 3 \"basic\" labs (because I try to account for all the different methods that can be pre-coordinated into the code). So many that I immediately blow through typical URL length limits :)</p>",
        "id": 199751269,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591279452
    },
    {
        "content": "<p>I was expecting that with the query syntax model, we would have a well-defined initial set.. not unconstrained. The advantage of having the query model was that it set a pattern that we could grow into as explicit use-case priority needs came up.</p>",
        "id": 199755379,
        "sender_full_name": "John Moehrke",
        "timestamp": 1591281164
    },
    {
        "content": "<p>code was one of the initial examples given :)</p>",
        "id": 199762943,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591284074
    },
    {
        "content": "<p>(eg: limit to a specific type of result) - even though I don't know if that would be original scope</p>",
        "id": 199762987,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591284096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span> in your example here (\"using many many LOINCs\" and blowing through URL length limits)... is this something where developers are hitting length limits in their <code>GET</code>-based FHIR search API calls? Like, with browsers that impose limits not just on window.location length but on AJAX request URLs too? Is this something that they can address with <code>POST</code>-based search?</p>",
        "id": 200122229,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1591633340
    },
    {
        "content": "<p>Is it related to authorization, or just a query example where URL limits come into play?</p>",
        "id": 200122270,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1591633368
    },
    {
        "content": "<p>The example in question was solved for them switching to POST (they hit the limit with the URL when they did a GET), but the concern I had for the scopes was if we allowed something similar, you can't switch that to POST for the authorization request</p>",
        "id": 200144003,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591644077
    },
    {
        "content": "<p>in our case, they hit a tomcat limit, not browser</p>",
        "id": 200144020,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591644086
    },
    {
        "content": "<p>Gotcha. So this week we can talk through approaches like <a href=\"https://tools.ietf.org/html/draft-ietf-oauth-jwsreq-20#section-5.2.2\">https://tools.ietf.org/html/draft-ietf-oauth-jwsreq-20#section-5.2.2</a> to limit size over the wire, specifically for the <code>authorize</code> endpoint.</p>",
        "id": 200147496,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1591645928
    },
    {
        "content": "<p>that looks like it died from an IETF perspective... (it's expired)</p>",
        "id": 200161484,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591653730
    },
    {
        "content": "<p>My coworker pointed out that OpenId Connect allows the authorization to use a form POST</p>",
        "id": 200161663,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591653866
    },
    {
        "content": "<p>which would leave this to be mostly token size issue</p>",
        "id": 200161672,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591653878
    },
    {
        "content": "<p>and I know some cloud providers have special errors they provide when you've asked for scopes that push their token size beyond implementation limits</p>",
        "id": 200161817,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591653991
    },
    {
        "content": "<p>which would imply that you start breaking up your token requests by workflow...</p>",
        "id": 200161837,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591654020
    },
    {
        "content": "<p>and if you're getting so many that it's a concern, that's probably a reasonable thing to do for your own sanity and token managment</p>",
        "id": 200161855,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1591654042
    },
    {
        "content": "<p>\"Hasn't yet been re-re-renewed yet\"' isn't the same as dead. OpenId also already allows for request objects to be passed by request_uri, so this spec is really ietf formalizing that same pattern.</p>",
        "id": 200164002,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1591655610
    },
    {
        "content": "<p>Re: submission via POST, that's a great trick that OIDC already defines (I never knew -- thanks for the heads-up). That takes off the URL size pressure for the request step. For the response step, <a href=\"https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html\">https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html</a> takes off the pressure. Both of these leave things up to client discretion (but obviously clients that will fail on GET, will be incentivized to POST).</p>",
        "id": 200174083,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1591665445
    },
    {
        "content": "<p>That just leaves the authorization header itself, which we've always left out of scope.</p>",
        "id": 200174097,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1591665474
    },
    {
        "content": "<p>A SMART App submits a PATCH Request to change the value of the patient reference in an AllergyIntolerance resource whose current patient value is set to 'Patient/{validPatientID'. The request has an access token with scope = 'patient/AllergyIntolerance.write' and patient=\"Patient/{validPatientID}\". The body of the request contains another valid PatientID. Question #1: Should the request be allowed or denied? Question #2: Should the same request be allowed or denied if the scope='user/AllergyIntolerance.write'?</p>",
        "id": 210084320,
        "sender_full_name": "Dharmesh Patel",
        "timestamp": 1600135951
    },
    {
        "content": "<p>1) the access token has scopes only for patient 1; it shouldn't be able to put allergies in patient 2's compartment</p>",
        "id": 210085699,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1600138072
    },
    {
        "content": "<p>2) assuming the user  in question is allowed to modify records for both patients, then user level write permissions should confer this ability to an app</p>",
        "id": 210085750,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1600138120
    },
    {
        "content": "<p>Note that the smart scope language provides no way to say which users have access to performance operations under the hood...</p>",
        "id": 210085755,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1600138134
    },
    {
        "content": "<p>Thanks Josh.</p>",
        "id": 210095205,
        "sender_full_name": "Dharmesh Patel",
        "timestamp": 1600152385
    }
]