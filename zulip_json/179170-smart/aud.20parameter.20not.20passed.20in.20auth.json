[
    {
        "content": "<p>As I understand, aud parameters is mandatory as per SMART in /auth endpoint. When its not passed by the App (or passed an invalid fhir base url as aud parameter) to the auth server, what's expected behavior? Should that return an error in json with http code 400? Or should it display an error page Or should it call the callback url of client, with error and error details?</p>",
        "id": 224398878,
        "sender_full_name": "Sagar Shah",
        "timestamp": 1611871302
    },
    {
        "content": "<p>We don't specify this, but redirecting to the client's error endpoint seems like the preferred behavior.</p>",
        "id": 224399673,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1611871502
    },
    {
        "content": "<p>From <a href=\"https://tools.ietf.org/html/rfc6749#section-4.1.2.1\">OAuth spec</a>: </p>\n<blockquote>\n<p>If the resource owner denies the access request or if the request<br>\n  fails for reasons other than a missing or invalid redirection URI,<br>\n the authorization server informs the client</p>\n</blockquote>",
        "id": 224399844,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1611871561
    },
    {
        "content": "<p>I was unclear on this too, we do not reject requests without aud specified, but if the aud is specified and the value does not match we reject the request. Is aud widely supplied? I am also unclear on the value of rejecting requests without aud.</p>",
        "id": 224656909,
        "sender_full_name": "Josh Lamb",
        "timestamp": 1612116708
    },
    {
        "content": "<p>From SMART's <a href=\"https://docs.smarthealthit.org/authorization/best-practices/\">guidance page</a>: </p>\n<blockquote>\n<p>2.5.1 To prevent leakage of a genuine bearer token to a counterfeit resource server, the SMART on FHIR Authorization Guide requires that authorization requests include an aud parameter whose value is the URL of the FHIR resource server from which the app wishes to retrieve FHIR data. Authorization servers must validate that the aud parameter is the URL of a known and trusted resource server prior to returning an authorization code to the requester.</p>\n</blockquote>\n<blockquote>\n<p>2.5.2 RFC6750 describes this threat more broadly as “token redirect” – when “an attacker uses a token generated for consumption by one resource server to gain access to a different resource server that mistakenly believes the token to be for it.” To deal with token redirect, it is important for the authorization server to identify the intended recipient (or recipients) of the access token, typically a single RS (or a list of RSs), in the token. This may be done through use of the aud parameter or by some other means devised by the authorization server, in coordination with its RSs. Then, upon receipt of an access token, the RS needs to check to assure that the access token it has received is intended to be used by that RS.</p>\n</blockquote>\n<p>I also noticed that <a href=\"https://fhir.cerner.com/authorization/\">Cerner's docs</a> have a nice explanation of this:</p>\n<blockquote>\n<p>This parameter is utilized by Cerner’s authorization server to protect your application against a form of exploit where an untrusted resource server advertises a legitimate authorization server in its conformance document. Without this feature, a valid, authorized access token could be inadvertently be sent by your application to the untrusted party.</p>\n</blockquote>",
        "id": 224666533,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1612129744
    },
    {
        "content": "<p>Hope this clarifies <span class=\"user-mention\" data-user-id=\"246928\">@Josh Lamb</span> (this is an important field for servers to validate).</p>",
        "id": 224666549,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1612129766
    },
    {
        "content": "<p>Got it! Thanks. The aud check would be duplicatitive in my implementation but I am glad its called out.</p>",
        "id": 224666946,
        "sender_full_name": "Josh Lamb",
        "timestamp": 1612130344
    },
    {
        "content": "<p>Can you explain more about what makes it duplicative? If you are allowing this parameter to be omitted, then you might allow an app to be tricked into sharing its access token with the wrong resource server.</p>",
        "id": 224671904,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1612135480
    },
    {
        "content": "<p>I do not think most servers accept random access tokens. Checks exist but it's not always called aud. I see you point and I like the idea though. It was not consistent before.</p>",
        "id": 224675326,
        "sender_full_name": "Josh Lamb",
        "timestamp": 1612140711
    },
    {
        "content": "<p>The threat isn't about servers accepting a random access token. The threat is a malicious FHIR server advertising lies in its .well-know/smart-configuration doc,  tricking an app into getting a legitimate access token from a legitimate authorization sever and then <em>using</em> the token at the malicious resource server -- at this point, the malicious actor has a valid access token that can be used at the FHIR server associated with the legitimate authorization server.</p>",
        "id": 224678117,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1612144432
    },
    {
        "content": "<p>This is interesting. I am glad I asked this question. As I am working through this thought experiment I also see a similar issue with bad actor applications (who may expose a whole bunch of fake FHIR servers). The way we must accept registrations from apps can make this tricky to detect too. It seems that the only thing in jeopardy is a single consumer's data, so we probably have to address this as consumer education (as policy requires anyway). But we should certainly reject requests without AUD. (Ill hold questions on how OPEN ID works until I do more research lol)</p>",
        "id": 224752267,
        "sender_full_name": "Josh Lamb",
        "timestamp": 1612197037
    }
]