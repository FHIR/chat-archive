[
    {
        "content": "<p>Whats the appropriate response if the Authorization server declines a request for access - 403 forbidden?</p>",
        "id": 153815300,
        "sender_full_name": "David Hay",
        "timestamp": 1457751268
    },
    {
        "content": "<p>Does the request have an authorization token associated with it (and it's simply no good for what the client is trying to access -- e.g. expired)? </p>",
        "id": 153815301,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457751681
    },
    {
        "content": "<p>Or is it a request for a protected resource that just includes no token?</p>",
        "id": 153815302,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457751696
    },
    {
        "content": "<p>The rules are basically (from <a href=\"https://tools.ietf.org/html/rfc6750#section-3.1\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc6750#section-3.1\">https://tools.ietf.org/html/rfc6750#section-3.1</a>):</p>\n<p>1. Missing token: 401<br>\n2. Expired/bad token: 401<br>\n3. Good token, but not appropriate for the requested data: 403</p>",
        "id": 153815303,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457751927
    },
    {
        "content": "<p>These messages should also come with a WWW-Authenticate Response Header response header, and an error code (see the link above)</p>",
        "id": 153815304,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457751973
    },
    {
        "content": "<p>(We haven't gotten deep into testing/expectations on this front though.)</p>",
        "id": 153815305,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457751994
    },
    {
        "content": "<p>FYI <a href=\"http://fhirblog.com/2016/03/13/implementing-smart-on-fhir-in-an-ehr/\" target=\"_blank\" title=\"http://fhirblog.com/2016/03/13/implementing-smart-on-fhir-in-an-ehr/\">http://fhirblog.com/2016/03/13/implementing-smart-on-fhir-in-an-ehr/</a></p>",
        "id": 153815328,
        "sender_full_name": "David Hay",
        "timestamp": 1457809973
    },
    {
        "content": "<p>Awesome! I just retweeted <span class=\"user-mention\" data-user-id=\"191387\">@Keith Boone</span>'s link to your post <span class=\"user-mention\" data-user-id=\"191321\">@David Hay</span>.  Now to actually read past your intro ;) </p>",
        "id": 153815329,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457811867
    },
    {
        "content": "<p><img alt=\":grin:\" class=\"emoji\" src=\"static/third/gemoji/images/emoji/grin.png\" title=\":grin:\">  now I just need to wait and see if I made any mistakes!</p>",
        "id": 153815331,
        "sender_full_name": "David Hay",
        "timestamp": 1457815141
    },
    {
        "content": "<p>Great Article - thank you.  In step 6.1, you are making the 'token' call based off of the entry in the Conformance Statement correct?  Further, any secret information required by the identity provider will be additionally passed in 6.1, correct?</p>",
        "id": 153815515,
        "sender_full_name": "Peter Girard",
        "timestamp": 1457997105
    },
    {
        "content": "<p>well, that's the connection between the Resource Server (RS) and the Authz Server (AS), and as they are both 'inside' the EHR the theory is that it shouldn't need to look the end point up. It represents the RS checking with the AzS that the token is valid. As josh said above there are other ways that that could be done without requiring the call - for example the access token could be signed, so the RS knows it hasn't been tampered with...</p>",
        "id": 153815522,
        "sender_full_name": "David Hay",
        "timestamp": 1458000217
    },
    {
        "content": "<p>And by 6.1 the identity has been resolved (step 3) so no other info should be needed at that point...</p>",
        "id": 153815523,
        "sender_full_name": "David Hay",
        "timestamp": 1458000274
    },
    {
        "content": "<p>Agreed on the token endpoint lookup.  There have been a few identity servers that require extra information during the 'token' call - either a secret (Azure AD) or username/password (Forgerock).  This seems to be the only way to keep the extra information out of SPA apps and still use an Auth Code flow.  Have you run into a scenario where extra information is required during the token call?</p>",
        "id": 153815527,
        "sender_full_name": "Peter Girard",
        "timestamp": 1458003009
    },
    {
        "content": "<p>Would that occur in step 3 of the flow? This was intended to be a simple EHR launch where the identity was known at the time of launch. The scenario sounds more like the standalone launch...</p>",
        "id": 153815533,
        "sender_full_name": "David Hay",
        "timestamp": 1458004000
    },
    {
        "content": "<p>So, as we understand it, the 'authorize' call happens in step 3, but for these products, do not need extra credentials.  That is, it follows exactly the way your flow shows it.  But when implementing confidential clients, Azure requires an extra parameter (client_secret - documented <a href=\"https://msdn.microsoft.com/en-us/library/azure/dn645542.aspx\" target=\"_blank\" title=\"https://msdn.microsoft.com/en-us/library/azure/dn645542.aspx\">https://msdn.microsoft.com/en-us/library/azure/dn645542.aspx</a>).  In an SPA implementation, it makes no sense to store this client secret in the browser app.  So, we have come to the same sequence you have documented, just with the extra information included in the 'token' call.</p>",
        "id": 153815661,
        "sender_full_name": "Peter Girard",
        "timestamp": 1458049797
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197395\">@Peter Girard</span> Whether or not a client secret is required is in scope of OAuth2. Using the code grant flow, the secret must be supplied during the code exchange request <strong>if</strong> one was supplied. You'd usually only supply one to confidential clients, but OAuth2 has been implemented rather liberally in this regard.</p>",
        "id": 153815663,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1458052651
    },
    {
        "content": "<p>One could use dynamic client registration to obtain client key/secret for non-confidential clients, like native apps, so you don't have to embed client key/secret into binaries.</p>",
        "id": 153815664,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1458052690
    },
    {
        "content": "<p>yes, and dynamic client registration is presently not part of smart. And it sounds a ittle scary</p>",
        "id": 153815683,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458062583
    },
    {
        "content": "<p>it is scary... but so too is fixed passwords in apps...  :-)   security is hard.</p>",
        "id": 153815688,
        "sender_full_name": "John Moehrke",
        "timestamp": 1458064142
    },
    {
        "content": "<p>It surely is hard! One of the reasons I think SMART will succeed is that is provides 'recipes' for the common use cases for ordinary developers (like me) to follow in common scenarios...</p>",
        "id": 153815709,
        "sender_full_name": "David Hay",
        "timestamp": 1458071451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197395\">@Peter Girard</span> - many thanks for your comments - I've updated the post to make the type of flow explicit...   (I actually do this stuff so I have something to refer to when I've forgotten the details later!)</p>",
        "id": 153815710,
        "sender_full_name": "David Hay",
        "timestamp": 1458071578
    },
    {
        "content": "<p>Next installment: <a href=\"http://fhirblog.com/2016/03/16/smart-security/\" target=\"_blank\" title=\"http://fhirblog.com/2016/03/16/smart-security/\">http://fhirblog.com/2016/03/16/smart-security/</a></p>",
        "id": 153815747,
        "sender_full_name": "David Hay",
        "timestamp": 1458090990
    },
    {
        "content": "<p>just one more: <a href=\"http://fhirblog.com/2016/03/16/using-smart-to-talk-between-systems/\" target=\"_blank\" title=\"http://fhirblog.com/2016/03/16/using-smart-to-talk-between-systems/\">http://fhirblog.com/2016/03/16/using-smart-to-talk-between-systems/</a></p>",
        "id": 153815753,
        "sender_full_name": "David Hay",
        "timestamp": 1458094708
    },
    {
        "content": "<p>Well, <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, SMART at least _encourages_ using DynReg. Our Swift client automatically does dynamically register itself if a) no client id is given when initializing the client and b) the Conformance statement lists a registration endpoint.<br>\n<a href=\"https://github.com/smart-on-fhir/Swift-SMART/wiki/Client#dynamic-client-registration\" target=\"_blank\" title=\"https://github.com/smart-on-fhir/Swift-SMART/wiki/Client#dynamic-client-registration\">https://github.com/smart-on-fhir/Swift-SMART/wiki/Client#dynamic-client-registration</a></p>",
        "id": 153815772,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1458116365
    },
    {
        "content": "<p>Of course this means anybody can register an app. In C3-PRO we have a mechanism that uses Apple's App Store receipt during client registration, meaning the server can verify with Apple, on a back channel, who this client is.<br>\n<a href=\"https://github.com/chb/c3-pro-ios-framework/tree/master/Sources/DataQueue#dynamic-client-registration\" target=\"_blank\" title=\"https://github.com/chb/c3-pro-ios-framework/tree/master/Sources/DataQueue#dynamic-client-registration\">https://github.com/chb/c3-pro-ios-framework/tree/master/Sources/DataQueue#dynamic-client-registration</a><br>\nThis is also not bullet proof though since it's theoretically possible to download an app, extract its receipt and use in in a different app for registration.</p>",
        "id": 153815773,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1458116592
    }
]