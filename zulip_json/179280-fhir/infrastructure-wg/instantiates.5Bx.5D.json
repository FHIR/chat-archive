[
    {
        "content": "<p>The Event pattern (<a href=\"http://build.fhir.org/event.html\" target=\"_blank\" title=\"http://build.fhir.org/event.html\">http://build.fhir.org/event.html</a>) has this:</p>",
        "id": 166770885,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559087124
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/M3i8swmBkgU9wqr0sKvJGJkN/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/M3i8swmBkgU9wqr0sKvJGJkN/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/M3i8swmBkgU9wqr0sKvJGJkN/pasted_image.png\"></a></div>",
        "id": 166770903,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559087159
    },
    {
        "content": "<p>this pattern is not filling me with pleasure at all. We could have this instead:</p>\n<p><code>instantiates[x] : 0..* canonical | uri </code> except that we have no way to do true type choice in an array in JSON. but we could just declare that it means two separate arrays with types...</p>",
        "id": 166771008,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559087261
    },
    {
        "content": "<p>that would clean up the definitions without changing the problem space at all</p>",
        "id": 166771054,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559087285
    },
    {
        "content": "<p>Though note that I'm not sure that the whole choice between canonical and uri is actually very useful. It's a uri either way, we're just making rules about what the URI can refer to - I feel as though doing that by type is a pretty ham-fisted way to do it</p>",
        "id": 166771099,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559087380
    },
    {
        "content": "<p>this pattern, btw, appears in lots of resources. It's not really the pattern that I can about....</p>",
        "id": 166771169,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559087407
    },
    {
        "content": "<p>Canonical drives code that URI doesn't.  Text instructions don't.  Yes it's ugly, but it's computable.  How are you going to enforce allowed targets, profiles, bundling, etc. if you make it a url across the board?</p>",
        "id": 166776871,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559095084
    },
    {
        "content": "<p>well, it's the target that matters, right?</p>",
        "id": 166776898,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559095169
    },
    {
        "content": "<p>Target(s) and bundled /contained/referenced both matter.</p>",
        "id": 166777042,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559095338
    },
    {
        "content": "<p>sure. so it seems to me that we should be able to deal with this pattern - same literal syntax, but different consequences - more cleanly than we do now</p>",
        "id": 166777064,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559095395
    },
    {
        "content": "<p>Interested to hear proposals...</p>",
        "id": 166777195,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559095583
    },
    {
        "content": "<p>so it's a common pattern beyond just this place: a url that might be a definitional resource, or might be some pdf or published paper. And sometimes we that it must be constrained to a computable definition in the spec itself, and sometimes we want to say that in a profile</p>",
        "id": 166778347,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559097408
    },
    {
        "content": "<p>Agree.  But how do we address it?  Introduce a common parent type?</p>",
        "id": 166778587,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559097814
    },
    {
        "content": "<p>I might rather see \"normal\" references where a system can recognize some values as \"special\"/canonical.</p>",
        "id": 166854965,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559162492
    },
    {
        "content": "<p>(This has come up in our Argonaut discussion of Topics for a subscription.)</p>",
        "id": 166854985,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559162510
    },
    {
        "content": "<p>I don't really know what this means in practice:</p>\n<blockquote>\n<p>I might rather see \"normal\" references where a system can recognize some values as \"special\"/canonical.</p>\n</blockquote>",
        "id": 166855066,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559162548
    },
    {
        "content": "<p>Oh, sorry -- I just mean using <code>instantiates</code> as a reference :)</p>",
        "id": 166855092,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559162580
    },
    {
        "content": "<p>(Or, barring that, settling on <code>instantiatesUri</code>)</p>",
        "id": 166855126,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559162600
    },
    {
        "content": "<p>I assumed that, but still didn't really understand your intent</p>",
        "id": 166855142,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559162617
    },
    {
        "content": "<p>To avoid modeling references to content (whether canonical or not, and whether \"constrained to URIs\" or not) 3 distinct ways.</p>",
        "id": 166855380,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559162773
    },
    {
        "content": "<p>A simple URI doesn't invoke all that fancy behavior where business versioning applies (with the |3.0, or just latest) that Canonical does - which I'm still a little fuzzy on.</p>",
        "id": 167178848,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1559561039
    },
    {
        "content": "<blockquote>\n<p>this pattern is not filling me with pleasure at all. We could have this instead:</p>\n<p><code>instantiates[x] : 0..* canonical | uri </code> except that we have no way to do true type choice in an array in JSON. but we could just declare that it means two separate arrays with types...</p>\n</blockquote>\n<p>Before we pull things apart - is there a real pain we're trying to fix, so we know we end up in a better spot?  It seems that what we have now at least works without introducing new formalisms?</p>",
        "id": 167283192,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1559648340
    },
    {
        "content": "<p>It does but it confuses implementers plenty. Iâ€™m seeking an approach that is less confusing for implementers</p>",
        "id": 167288817,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559652530
    },
    {
        "content": "<p>The only solution I can think of is a common parent concrete type.  Can you think of others <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> ?</p>",
        "id": 167302794,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559660452
    },
    {
        "content": "<p>We have a common parent concrete type, uri is the parent of canonical. But we don't allow substitution - constraining uri to canonical in a profile would meet the requirements, but a big change in our methodology. Also, you could not express the actual type in the instance (in json) when the element repeats.  Creating a new type that contains both representations has deep consequences for resolution (and indexing in servers), and would be a breaking change if we'd have to introduce it in normative resources.</p>",
        "id": 167372636,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1559727707
    },
    {
        "content": "<p>Can't we solve this visually, but not methodologically?  I.e. if its confusing for developers is the problem in how we represent it in the UML/Structure in the spec?</p>",
        "id": 167372701,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1559727748
    },
    {
        "content": "<p>It's actually already quite distinct (choices are nested, Grahame's example above are siblings).</p>",
        "id": 167372757,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1559727797
    },
    {
        "content": "<p>\"but we could just declare that it means two separate arrays with types...\"</p>\n<p>This suggests we want to actually MAKE it look like a choice - it's just that our limit of the json representation forces us into two seperate elements, is that correct?</p>",
        "id": 167372883,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1559727920
    },
    {
        "content": "<p>Just trying to figure out what the confusion is about and what we want to achieve....</p>",
        "id": 167372904,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1559727959
    },
    {
        "content": "<p>back to this... it's unsolved business, and I still feel this is a one area where we can improve</p>",
        "id": 175104716,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567804704
    },
    {
        "content": "<p>it's not like the actual order of things matters here?</p>",
        "id": 175104727,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567804722
    },
    {
        "content": "<p>Order isn't an issue.  It's the difference in type and behavior.</p>",
        "id": 175106527,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1567806336
    },
    {
        "content": "<p>there's no difference in type, really. It's the behavior that matters</p>",
        "id": 175106707,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567806500
    },
    {
        "content": "<p>Right now, the behavior is tied to the type.  And there needs to be a way to distinguish what the expected behavior is.</p>",
        "id": 175106730,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1567806541
    },
    {
        "content": "<p>yes type is a proxy here. I'm wondering if there's a better way. What behaviors do we really care about? <br>\n- it refers to something<br>\n- it refers to something that's actually computable (e.g. a resource)<br>\n- it refers to a particular kind of resource</p>",
        "id": 175106943,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567806777
    },
    {
        "content": "<p>and we care for a receiving system to know whether it should before it follows the link?</p>",
        "id": 175106969,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567806817
    },
    {
        "content": "<p>The canonical can be parsed to extract a base and a version and the retrieval can occur by doing a query of known registries (and local system) using url &amp; version as search parameters rather than resolving - and that search strategy should happen <em>before</em> trying to resolve the URL</p>",
        "id": 175111921,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1567811829
    },
    {
        "content": "<p>On the other hand, the URI isn't expected to resolve to anything computable and if it does resolve, it only does so by hitting the URI</p>",
        "id": 175112054,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1567811894
    }
]