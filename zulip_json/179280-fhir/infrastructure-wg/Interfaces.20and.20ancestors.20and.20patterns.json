[
    {
        "content": "<p>Right now DomainResource is a \"Resource\" and MetadataResource is an \"Interface\".</p>\n<ol>\n<li>\n<p>Is it  accurate to say that both are \"ancestors\" of a resource like <a href=\"http://build.fhir.org/branches/subscriptions2022/subscriptiontopic.html#resource\">http://build.fhir.org/branches/subscriptions2022/subscriptiontopic.html#resource</a>? (I think this is a \"yes\").</p>\n</li>\n<li>\n<p>Per <a href=\"http://build.fhir.org/uml.html#interfaces\">http://build.fhir.org/uml.html#interfaces</a>, \"Any classes the implement the interface redeclare any attributes and associations.\" Is it expected that tooling will do this automatically? For the SuscriptionTopic example above, the tooling says the following are \"defined in Ancestors\", even though the generated snapshots do not include elements like <a href=\"http://build.fhir.org/metadataresource-definitions.html#MetadataResource.editor\"><code>MetadataResource.editor</code></a>. Is this accurate, and if so: would it be valid or invalid to include an <code>editor</code> on a SubscriptionTopic? (I think <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>'s answers are: \"yes accurate\" and \"invalid to include,\" but it's confusing.)</p>\n</li>\n</ol>\n<p><a href=\"/user_uploads/10155/7f1Pt2Cr2YSymJv6Y3sO2SvV/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/7f1Pt2Cr2YSymJv6Y3sO2SvV/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/7f1Pt2Cr2YSymJv6Y3sO2SvV/image.png\"></a></div><ol start=\"3\">\n<li>\n<p>Per <a href=\"http://build.fhir.org/uml.html#interfaces\">http://build.fhir.org/uml.html#interfaces</a>, \"In addition, the resource might not implement the attribute at all - this is equivalent to constraining the attribute to a cardinality of 0..0 - not used with this resource\". For the SubscriptionTopic example above, should the absence of a property from the interface be understood as a choice to \"not implement the attribute,\" and if so should the tooling suppress the claim that the attribute exists?</p>\n</li>\n<li>\n<p>Are there any guidelines for when to \"just inherit all the properties\" vs selectively excluding some when inheriting from an interface?</p>\n</li>\n</ol>",
        "id": 273561459,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1646086153
    },
    {
        "content": "<ol>\n<li>yes</li>\n<li>no, it's not automatic, since the resource can choose not to. And it's technically valid to say that the element is defined by the ancestor, such as editor, even though it's not redeclared in the implementation, because it hasn't gone away, it's just implicitly constrained to 0..0. But that's certainly misleading. As for 'invalid to include'... not sure what you're asking there. Of course the definition could include it if it wanted - that wouldn't be invalid</li>\n<li>yes that's how to understand it. \"the claim that the attribute exists\"... which particular claim. Because it kind of does.</li>\n<li>no there's no guidelines, but per the discussion we just had on the call, I'd rather things inherit all the properties and not exclude something. Really, there should be a good reason to exclude things. But I'm not convinced that the three properties that SubscriptionTopic picks up from MetadataResource are actually quite the same properties, and maybe it should just be a canonical resource</li>\n</ol>",
        "id": 273564772,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1646087963
    },
    {
        "content": "<p>But that is quite confusing, isn't it?  The specification page makes no distinction between the inherited definition for <code>Resource.id</code> and the non-inherited 'definition' of <code>CanonicalResource.version</code>, they are just listed together by element name.</p>\n<p>And I think that's my biggest issue with the current model - a reader has no idea if an element is inherited or not because there is no differentiation between a base definition and an interface.</p>",
        "id": 273567687,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1646089668
    },
    {
        "content": "<p>Agreed, saying that id and editor are both \"defined in Ancestor\" is problematic if the former really exists and can be included in instance data and the latter really doesn't exist and cannot be included in instance data.</p>",
        "id": 273570892,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1646091855
    },
    {
        "content": "<p>I was writing one of my patented novels in Zulip ;-), but in an attempt to \"do better\", I think I have a short version!</p>\n<p>Assuming:</p>\n<ul>\n<li>Interface elements are not inherited by children</li>\n<li>Children are allowed to redefine elements that <em>are</em> defined in an interface parent</li>\n<li>Interfaces inherit from actual definitions and <em>those</em> elements are inherited normally</li>\n</ul>\n<p>Then:</p>\n<ul>\n<li>What is the purpose of 'interface' definitions?</li>\n</ul>\n<p>I guess I am wondering what I am missing - as far as I can tell, this is adding something to R5 that is incorrect/invalid for data-structures (in a  CS context), adds complexity for readers, and the sum total of use is: if you want something defined in it, you have to redefine it anyway.</p>",
        "id": 273667396,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1646151857
    },
    {
        "content": "<p>Looking at <a href=\"http://build.fhir.org/uml.html#abstract\">http://build.fhir.org/uml.html#abstract</a> and the hierarchy here, the page is listed as \"Normative\" but first appeared in late 2019. The <a href=\"https://github.com/HL7/fhir/commits/master/source/uml.html\">commits</a> don't reference Jira tickets and Jira doesn't seem to mention <code>uml.html</code> anywhere (searching by <a href=\"https://jira.hl7.org/issues/?jql=text%20~%20%22uml.html%22\">string</a> or <a href=\"https://jira.hl7.org/issues/?jql=%22Related%20Page(s)%22%20~%20%22UML%22\">referenced page</a>). </p>\n<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> mentioned on our call yesterday that he wasn't thrilled with the design but couldn't get consensus on a better design. Can you help me understand where this conversation happened?</p>",
        "id": 273706711,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1646167179
    },
    {
        "content": "<p><a href=\"http://jira.hl7.org/browse/FHIR-32336\">FHIR-32336</a> is the closest I see to discussion, but given the number of questions about how \"interface\" inheritance works, this is hard to swallow. The actual details here not been published, and outstanding technical corrections like <a href=\"http://jira.hl7.org/browse/FHIR-25568\">FHIR-25568</a> mean that implementers can't well have tried/used it to provide feedback.</p>",
        "id": 273707986,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1646167878
    },
    {
        "content": "<p>(Thanks to <span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> for about 90 minutes of deep dive on this just now -- we understand a lot more than yesterday but are still quite confused.)</p>",
        "id": 273708071,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1646167919
    },
    {
        "content": "<p>Here's my list of thoughts, as it was before discussion today (March 7) on FHIR-I.  Some of the items we have discussed partially, but figured it was easier to post as it was than revise.</p>\n<p>Technical issues:</p>\n<ul>\n<li>\n<p>Inheriting part of a definition is confusing - search parameters (for example) are inherited from interfaces while element definitions are not.  This is very error-prone and makes the FHIR definitions less generically useful.</p>\n<ul>\n<li>\n<p>Example: the <code>Resource Content</code> sections do not distinguish between 'real' and 'undefined' <code>Elements defined in Ancestors</code> (e.g., <br>\n<a href=\"http://build.fhir.org/codesystem.html#resource\">CodeSystem</a>).</p>\n</li>\n<li>\n<p>Related: what does it mean to have a search parameter or invariant defined for an element that is not defined on a resource?</p>\n</li>\n<li>Not knowing about this extension to StructureDefinition results in incorrect processing - if this continues to exist it should at least be a modifier extension.  That said, if this mechanism is being added and is normative it should be an element on the resource and not an extension.</li>\n</ul>\n</li>\n</ul>\n<p>Process issues:</p>\n<ul>\n<li>While <a href=\"http://jira.hl7.org/browse/FHIR-32336\">FHIR-32336</a> explains the theory behind interfaces being normative, the creation of a new class of artifacts that jump straight to normative without feedback does not feel correct.</li>\n<li>We have not been able to find discussion/voting/etc. that led to these changes.</li>\n</ul>\n<p>Theory-based issues:</p>\n<ul>\n<li>Mixing classes of ancestors in an inheritance tree is unfamiliar</li>\n<li>The word <code>interface</code> has meaning in computer science generally and UML specifically (which is used to represent these models).  The current usage does not meet its requirements.</li>\n</ul>",
        "id": 274455973,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1646686622
    },
    {
        "content": "<p>Other notes that I just remembered and did not make it in:</p>\n<ul>\n<li>The build has <code>&lt;&lt;I&gt;&gt;</code> and <code>&lt;&lt;A&gt;&gt;</code> tags wrong (e.g., <code>DomainResource</code> shows an <code>&lt;&lt;I&gt;&gt;</code></li>\n</ul>",
        "id": 274456162,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1646686701
    },
    {
        "content": "<p>The base use-case is that we have a set of resources that will have 'mostly' the same data elements, but there will be (and <em>needs</em> to be) variability.  Some of the concepts simply don't make sense in certain contexts and there will also be variations in terms of what's core vs. extension.  We want systems to be able to write software that handles the \"typically shared\" portions of these resources consistently, primarily for 'read'.  ('Write' is less strong a use-case.  That's possible, but would have to handle situations where certain resources won't allow writing certain data elements.)</p>\n<p>My personal opinion is that class inheritance is <em>not</em> a great way to expose that behavior.  Even where the elements <em>do</em> appear, there can be variations in comments, definitions, etc.  'interface' is a slightly better way, but it needs to be though of as \"we can/will expose getters/setters for these elements, but behind the scenes they'll work differently for different resources\". </p>\n<p>If we can't buy off on that, then we're left with a different 'flavor' of pattern - one where we'll generate (and use) interfaces in the code, but won't have inheritance, nor will we add data elements to every resource just for the sake of complying with the pattern.</p>",
        "id": 274476007,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1646697109
    },
    {
        "content": "<blockquote>\n<p>Such re-declarations will be consistent with the interface but may be a subset of the value domain e.g. the cardinality of an attribute may be 0..* on the interface, and 0..1 on a particular resource</p>\n</blockquote>\n<p>Has this ever happened in real life? If it did, would the resource represent, say, \"author\" with an array of 0..1 ContactDetails, or just a single element?</p>",
        "id": 274583253,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1646763923
    },
    {
        "content": "<p>In patterns, yes.  In this 'tighter' situation, I think the only constraint is from 0..x to 0..0.  I'm not aware of a x..* going to x..1</p>",
        "id": 274591868,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1646767090
    },
    {
        "content": "<p>Okay, thanks -- if that can be formalized it prevents a whole class of instance incompatibility with interfaces.</p>",
        "id": 274592108,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1646767201
    },
    {
        "content": "<p>Apologies for the novel, but I wanted to spend some time exploring with concrete outputs... so I did =).  I created a <a href=\"https://gist.github.com/GinoCanessa/3e593bc56b43dd290ecedbbb431e0447\">gist</a> that has a C# file (.Net 6) and the matching output.  I used C# because I like the tooling - I tried to make examples that port well into TypeScript, Java, and C++.  I <em>think</em> they also port well to Swift and Objective-C, but am a bit rusty. I also tried to make each style as 'good' as possible over several iterations.  I kept the 'best' I could with 'interface in inheritance' but kept two versions of external definitions because it highlights a definitional problem.</p>\n<p>Disclaimers/Assumptions/Context:</p>\n<ul>\n<li>I attempted to give each model 'best effort', but know that I am biased on the topic.  I posted all the source so that someone else can jump in with a better approach.</li>\n<li>Coding each 'style' (in or out of inheritance tree) I used what would be the natural language constructs for doing so.  I made sure to keep to single inheritance in the class hierarchy, and used language interfaces for external interface definitions.</li>\n<li>I am using C#, with a focus on strongly-typed languages.</li>\n<li>I am using classes that differentiate scalar value types from array value types.</li>\n<li>I defined very simplistic models to illustrate points.  I used three 'elements' from a root 'metadata':<ul>\n<li><code>Url</code> is 0..1 in metadata and questionnaire</li>\n<li><code>Author</code> is 0..* in metadata, prohibited in questionnaire</li>\n<li><code>Problematic</code> is 0..* in metadata, 0..1 in questionnaire (this is defined valid, so I wanted to include it)</li>\n</ul>\n</li>\n<li>I went through some basic operations of creating objects and getting or setting elements.  In order to show the differences in where they throw exceptions, I only put try blocks around things that throw in the example.</li>\n<li>Thoughts are based the experience of tinkering with this, etc.</li>\n</ul>\n<p>So, my attempt at collecting thoughts...</p>\n<p>-- 'Profiling' in resource definitions:</p>\n<ul>\n<li>What is the JSON serialization for the <code>Questionnaire.problematic</code> element?  It needs to either be an array or a value, and I have no idea which is 'more correct'<ul>\n<li>If it should be an array, we cannot discover that from the snapshot today - we need to either add more information or we need to parse the interface and apply the logic ourselves.</li>\n<li>If it should be a scalar, developers will need to discern between scalar types and array types in an odd way.</li>\n<li>Either way, if we keep this feature we lose some of the 'magic' of FHIR in how easy it is to 'just use'.</li>\n</ul>\n</li>\n<li>edit: note this can be seen in the <code>...Strict</code> vs. the <code>...Strict2</code> models - I did not do it twice in the 'in tree' model since it ends up so similar and this one was less code.</li>\n</ul>\n<p>-- Interfaces in the class hierarchy:</p>\n<ul>\n<li>I could not figure out a way to have the language enforce not having the Author property on Questionnaire when casted as a parent Metadata object.  The language does not have the ability to prevent setting a value on a parent casted as that type.</li>\n<li>This is consistent with OO in general - a descendent class cannot influence ancestors.</li>\n<li>This results in the ability to generate Questionnaire objects with Authors.<ul>\n<li>It can be caught by the parent class, but requires some serious and painful inversion.</li>\n<li>It can be caught with a custom serializer, but adds a lot of overhead (edit: and relies on developers <em>only</em> using the provided serializers/parsers).</li>\n</ul>\n</li>\n</ul>\n<p>-- General thoughts</p>\n<ul>\n<li>Both models cause: runtime errors, invalid data, or implicitly 'swallowed' data - this must be handled at the application layer regardless of which structure is used (though it is more or less obvious depending on the route taken).</li>\n<li>This makes sense, since we are defining contracts that are not <em>really</em> contracts - the cost of modeling elements that may or may not exist is handling that complexity at runtime.</li>\n<li>Having spent a fair bit of time on this, I am confident I can generate either form of code based on either modeling structure.</li>\n<li>Including interfaces in the modeling inheritance means I <em>have</em> to deal with the strangeness of implied elements, etc. in order to use any model that has one (with the implication that more of these will appear in the future).  Leaving it out means that I only add that complexity if I want to use interfaces.<ul>\n<li>complexity here means both code complexity and runtime cycles</li>\n</ul>\n</li>\n</ul>",
        "id": 275574125,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1647463219
    },
    {
        "content": "<p>Been asked so one more note:</p>\n<ul>\n<li>Common<ul>\n<li><code>PartialResource</code> : base class to root inheritance for all models</li>\n</ul>\n</li>\n<li>Interfaces in inheritance<ul>\n<li><code>PartialMetadataResource</code> : class with the above noted properties for experimentation, child of <code>PartialResource</code></li>\n<li><code>PartialQuestionnaireInherit</code> : child of <code>PartialMetadataResource</code> to show a 'final' class that handles interface properties</li>\n</ul>\n</li>\n<li>Interfaces NOT in inheritance (using language interface constructs)<ul>\n<li><code>IPartialMetadata</code> : Interface exposing same properties for experimentation, for brevity it does not include what would be <code>Resource</code> elements, etc.</li>\n<li><code>PartialQuestionnaireStrict</code> : child of <code>PartialResource</code>, implements interface <code>IPartialMetadata</code> and exposes <code>Problematic</code> property as a single string and serializes it as one.</li>\n<li><code>PartialQuestionnaireStrict2</code> : child of <code>PartialResource</code>, implements interface <code>IPartialMetadata</code> and exposes <code>Problematic</code> property as an array of strings.</li>\n</ul>\n</li>\n</ul>",
        "id": 275579183,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1647465769
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> has written <a href=\"https://docs.google.com/document/d/1YrdzZoChWCBCClynZ_5jLTXXl0_l0MdL2BdUnSWumh4\">https://docs.google.com/document/d/1YrdzZoChWCBCClynZ_5jLTXXl0_l0MdL2BdUnSWumh4</a> to help drive discussion on today's call</p>",
        "id": 276902080,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648486392
    }
]