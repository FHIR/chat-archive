[
    {
        "content": "<p>Paul did some work to get our tests running in Java 11, but I have some local edits to JDBCWholeSystemSeardchTest that I believe to be confirming that we have an issue with our datetime processing</p>",
        "id": 179003307,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571955465
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/IBM/FHIR/issues/305\" target=\"_blank\" title=\"https://github.com/IBM/FHIR/issues/305\">https://github.com/IBM/FHIR/issues/305</a> for this issue, but we can discuss it here</p>",
        "id": 179005158,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571956741
    },
    {
        "content": "<p>I have many of the same questions as you</p>",
        "id": 179008490,
        "sender_full_name": "Paul Bastide",
        "timestamp": 1571960024
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/IBM/FHIR/pull/306/files\" target=\"_blank\" title=\"https://github.com/IBM/FHIR/pull/306/files\">https://github.com/IBM/FHIR/pull/306/files</a> with what seems to be the fix. Not totally sure why it was failing in Java 11 and not Java 8, but we basically just need to avoid using Date when processing the search parameter value.</p>",
        "id": 179010687,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962247
    },
    {
        "content": "<p>Open question:  what should be the behavior when an instant/dateTime has<br>\nsome number of ms digits and the search has less precision?<br>\nThis PR introduces tests for this scenario too, but I've commented them out for now. Should we handle it as part of #305 or open some issue for the future?</p>",
        "id": 179010853,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962477
    },
    {
        "content": "<p>Good question... it's a hard one need to think about the various scenarios</p>",
        "id": 179010873,
        "sender_full_name": "Paul Bastide",
        "timestamp": 1571962524
    },
    {
        "content": "<p>i think my second commit to <a href=\"https://github.com/IBM/FHIR/pull/306\" target=\"_blank\" title=\"https://github.com/IBM/FHIR/pull/306\">https://github.com/IBM/FHIR/pull/306</a> outlines the scenarios pretty well: <a href=\"https://github.com/IBM/FHIR/pull/306/commits/64ab697f7dd7cf034628a5dfc7048b5314151851\" target=\"_blank\" title=\"https://github.com/IBM/FHIR/pull/306/commits/64ab697f7dd7cf034628a5dfc7048b5314151851\">https://github.com/IBM/FHIR/pull/306/commits/64ab697f7dd7cf034628a5dfc7048b5314151851</a></p>",
        "id": 179010885,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962553
    },
    {
        "content": "<p>the commented out tests are the ones that are failing now</p>",
        "id": 179010940,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962609
    },
    {
        "content": "<p>&lt;check/&gt;</p>",
        "id": 179010951,
        "sender_full_name": "Paul Bastide",
        "timestamp": 1571962624
    },
    {
        "content": "<p>in my opinion, those should all be passing.  to make it happen, i think we'd need to handle almost every search as an implicit range.  so <code>_lastUpdated=2019-01-01T12:00:01Z</code> should become  <code>WHERE x &gt;= 2019-01-01 12:00:01 AND x &lt; 2019-01-01 12:00:02</code></p>",
        "id": 179011019,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962696
    },
    {
        "content": "<p>we'd only use \"exact match\" semantics for search parameter values with a full 6 digit ms field</p>",
        "id": 179011042,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962738
    },
    {
        "content": "<p>right we'll have to do some dance to build the range</p>",
        "id": 179011056,
        "sender_full_name": "Paul Bastide",
        "timestamp": 1571962763
    },
    {
        "content": "<p>we already do similar for computing the end date of implicit ranges for Year, Month, and Day precision</p>",
        "id": 179011062,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962779
    },
    {
        "content": "<p><a href=\"https://www.hl7.org/fhir/search.html#date\" target=\"_blank\" title=\"https://www.hl7.org/fhir/search.html#date\">https://www.hl7.org/fhir/search.html#date</a> is pretty clear with those</p>",
        "id": 179011071,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962793
    },
    {
        "content": "<p>its just odd that it doesn't even mention fractional seconds</p>",
        "id": 179011115,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962804
    },
    {
        "content": "<p>in fact, if you strictly adhered to the description in this section, you'd think fractional seconds aren't even allowed</p>",
        "id": 179011187,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962857
    },
    {
        "content": "<blockquote>\n<p>The date parameter format is yyyy-mm-ddThh:mm:ss[Z|(+|-)hh:mm] (the standard XML format).</p>\n</blockquote>",
        "id": 179011189,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962860
    },
    {
        "content": "<p>but then the very next paragraph says </p>\n<blockquote>\n<p>Any degree of precision can be provided</p>\n</blockquote>",
        "id": 179011348,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571962985
    },
    {
        "content": "<p>on a related note, i think we actually lose precision of these fractional seconds in the model:</p>\n<div class=\"codehilite\"><pre><span></span>Basic basic = Basic.builder()\n    .code(CodeableConcept.builder().text(string(&quot;test&quot;)).build())\n    .extension(Extension.builder()\n        .url(&quot;http://example.com&quot;)\n        .value(DateTime.of(&quot;0001-01-01T01:01:01.100000Z&quot;))\n        .build())\n    .build();\nSystem.out.println(basic);\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>{\n    &quot;resourceType&quot;: &quot;Basic&quot;,\n    &quot;extension&quot;: [\n        {\n            &quot;url&quot;: &quot;http://example.com&quot;,\n            &quot;valueDateTime&quot;: &quot;0001-01-01T01:01:01.1Z&quot;\n        }\n    ],\n    &quot;code&quot;: {\n        &quot;text&quot;: &quot;test&quot;\n    }\n}\n</pre></div>",
        "id": 179012536,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571964021
    },
    {
        "content": "<p>i.e. no way to determine the number of digits provided from a parsed dateTime</p>",
        "id": 179012557,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571964057
    },
    {
        "content": "<p>interesting, probably not preferred</p>",
        "id": 179012559,
        "sender_full_name": "Paul Bastide",
        "timestamp": 1571964059
    },
    {
        "content": "<p>i doubt it matters much for 99% of use cases</p>",
        "id": 179012570,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571964072
    },
    {
        "content": "<p>I think John gave me some code to do so using parseBest</p>",
        "id": 179012574,
        "sender_full_name": "Paul Bastide",
        "timestamp": 1571964078
    },
    {
        "content": "<p>but still interesting</p>",
        "id": 179012575,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571964079
    },
    {
        "content": "<p>it just means we can't tell the difference between a search for <code>0001-01-01T01:01:01.1Z</code> (which i'd like to handle as <code>x &gt;= 0001-01-01T01:01:01.1Z and x &lt; 0001-01-01T01:01:01.2Z</code>) vs <code>0001-01-01T01:01:01.100000Z</code> (which should only match if x is exactly <code>0001-01-01T01:01:01.100000Z</code>)</p>",
        "id": 179012728,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1571964252
    },
    {
        "content": "<p>I spoke with <span class=\"user-mention\" data-user-id=\"192334\">@John Timm</span> on this one and here's what I'm thinking we should do:</p>\n<ol>\n<li>continue storing fractional seconds in db</li>\n<li>convert hh:mm:ss query param value into range queries on the db (e.g. [01:01:01,01:01:02))</li>\n<li>continue to allow searches to come in with fractional seconds, and treat those as \"exact matches\" with infinite precision (01:01:01.1 would not find 01:01:01.100001)</li>\n</ol>",
        "id": 179052831,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1572012757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192334\">@John Timm</span> <span class=\"user-mention\" data-user-id=\"192632\">@Paul Bastide</span> I just pushed an update that implements this proposal:  <a href=\"https://github.com/IBM/FHIR/pull/307\" target=\"_blank\" title=\"https://github.com/IBM/FHIR/pull/307\">https://github.com/IBM/FHIR/pull/307</a><br>\nI also updated the Conformance.md to document the behavior.  Please review when you have a minute.</p>",
        "id": 179083110,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1572033126
    },
    {
        "content": "<p>LGTM</p>",
        "id": 179083265,
        "sender_full_name": "Paul Bastide",
        "timestamp": 1572033260
    },
    {
        "content": "<p>merged</p>",
        "id": 179085286,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1572034620
    }
]