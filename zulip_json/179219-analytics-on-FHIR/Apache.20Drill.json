[
    {
        "content": "<p>Apache Drill â€“ Direct Clinical BI on FHIR , seems like an interesting project . <br>\nAt the end of this page http:/amia.analystseim.com/ <br>\nThere is a query for Patient's family name, gender, birth date: <br>\n<code>SELECT P.'name'[0].family AS family_name, P.gender, P.birthDate FROM dfs.'/synthea/json/patient' P LIMIT 10</code><br>\nSo will it be used just to implement FHIR search parameter ? Confused about the Analytics part on that ...</p>",
        "id": 153886445,
        "sender_full_name": "Fahim Shariar",
        "timestamp": 1493417577
    },
    {
        "content": "<p>Use case with SQL tools such apache drill are:<br>\n- search in the dataset, say build a cohort<br>\n- BI, allow explore the data aggregate result, tables, plots<br>\n- apply any FHIR tool over the ressources, data visualization...</p>\n<p>all would benefit from a common data model</p>",
        "id": 153886483,
        "sender_full_name": "natus",
        "timestamp": 1493536085
    },
    {
        "content": "<p>The project you pointed (<a href=\"http://amia.analystseim.com/guide.html\" target=\"_blank\" title=\"http://amia.analystseim.com/guide.html\">http://amia.analystseim.com/guide.html</a>) does not satisfy FHIR specification:</p>\n<blockquote>\n<p>References and JOIN<br>\nFHIR reference are formatted as ResourceType/id, e.g. Patient/1234. This means that &gt;to link an Encounter to the associated patient, one must join:<br>\nEncounter.patient.reference to 'Patient/' || <a href=\"http://Patient.id\" target=\"_blank\" title=\"http://Patient.id\">Patient.id</a><br>\nPossible, but slow. To speed things, in the parquet files we've added:<br>\nPatient.patient_reference<br>\nEncounter.encounter_reference</p>\n</blockquote>\n<p>Then, they added encounter_reference element in the Encounter resource and so on<br>\nTo me, this is a problem. Any better idea \"FHIR compatible\" to deal with that ?</p>",
        "id": 153886484,
        "sender_full_name": "natus",
        "timestamp": 1493536712
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> is best to comment about this</p>",
        "id": 153886502,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493601569
    },
    {
        "content": "<p>There's no requirement to optimize the references - as I mentioned one could add the concatenation in the query's join condition directly. </p>",
        "id": 153886506,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1493608699
    },
    {
        "content": "<p>In practice, we generally use Drill to create optimized intermediate sets from the native FHIR datasets. If that's not acceptable in your use case, additional processing power could be brought to bear.</p>",
        "id": 153886507,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1493608868
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193690\">@Fahim Shariar</span> - \"analytics\" comes with significantly more complex queries. Baby steps! </p>",
        "id": 153886508,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1493608966
    },
    {
        "content": "<blockquote>\n<p>There's no requirement to optimize the references - as I mentioned one could add the concatenation in the query's join condition directly.</p>\n</blockquote>\n<p>Our requirement is to help drill users to join tables. Concatenation leads to errors when the reference is subject (Patient or Group) such encounter. Moreover this leads to overhead of scripting, and hardware consumption. <br>\nThe workaround of using new elements such \"patient.patient_refereence\" is great but sadly resources are not FHIR compatible anymore.<br>\nWhat about adding extension for this purpose? eg :</p>\n<blockquote>\n<p>\"extension\": [<br>\n   {<br>\n    \"url\": \"<a href=\"http://example/patient_id/\" target=\"_blank\" title=\"http://example/patient_id/\">http://example/patient_id/</a>\",<br>\n    \"valueid\": 16624 <br>\n   }<br>\n   ]</p>\n</blockquote>",
        "id": 153886544,
        "sender_full_name": "natus",
        "timestamp": 1493630509
    },
    {
        "content": "<p>Unfortunately that just moves the complexity around.  Most resources won't include that extension, so you'd have to pre-process the data to ensure consistent inclusion, a much more complex (though very possible) process on a large set.<br>\nConcatenation can work without error - the concatenation happens on the \"target\" side, not the \"referencing\" side:<br>\n<code>X.ResourceName || '/' || X.id AS ResourceRelativeURI</code><br>\nIf multiple resources are possible in the reference, either you must make two (or more) outer joins, or you access all resources in the same scope.</p>",
        "id": 153886553,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1493643520
    },
    {
        "content": "<p>You are right, using the concatenation just works.  But it decreases DRILL performances (I am talking about FHIR datasets with multiple billion of observations ) a lot comparing to both methods:<br>\n1) adding a new element as you(?) have made and described there <a href=\"http://amia.analystseim.com/guide.html\" target=\"_blank\" title=\"http://amia.analystseim.com/guide.html\">http://amia.analystseim.com/guide.html</a> . But this is not FHIR compatible.<br>\n2) adding an extension as I described in this thread. This is FHIR compatible.</p>\n<blockquote></blockquote>\n<p>By FHIR compatible I mean resources can be pushed in any FHIR tool, such vizualisation, validation and more. Both methods need a pre-processing step. At least moving json files into parquet is  a pre-processing step. So while transforming into parquet format one can add those extensions. And the dataset is still FHIR compatible. Does this  make sense ? </p>",
        "id": 153886556,
        "sender_full_name": "natus",
        "timestamp": 1493649102
    },
    {
        "content": "<p><code>SELECT COUNT(*) FROM dfs.pq.'Condition' WHERE 'Condition'.'code'.coding[0].'code' = '44054006'</code> that just caught my attention . Are you assuming there will only be just one Code in the whole CodableConcept array . There could be multiple , right ? what about that ? <br>\n<span class=\"user-mention\" data-user-id=\"193729\">@natus</span>  does Drill SQL query supports quering JSON arrays ?</p>",
        "id": 153886592,
        "sender_full_name": "Fahim Shariar",
        "timestamp": 1493672606
    },
    {
        "content": "<p>in RDF, there's a special relationship for this purpose </p>",
        "id": 153886593,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493672615
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193690\">@Fahim Shariar</span>  I guess so :  the drill function flatten does the job in case of array (<a href=\"https://drill.apache.org/docs/flatten/\" target=\"_blank\" title=\"https://drill.apache.org/docs/flatten/\">https://drill.apache.org/docs/flatten/</a>)</p>\n<blockquote>\n<p>SELECT <a href=\"http://d.id\" target=\"_blank\" title=\"http://d.id\">d.id</a> FROM (SELECT *, flatten(C.<code>code</code>.<code>coding</code>) f FROM <code>condition.json</code> C) d WHERE d.<code>f</code>.<code>code</code> = '44054006';</p>\n</blockquote>\n<p>would match a condition that would have many code (tested and approved)</p>",
        "id": 153886622,
        "sender_full_name": "natus",
        "timestamp": 1493676301
    },
    {
        "content": "<p>Anyone interested in playing with Drill can use the demo environment for the FHIR Connectathon for the next 48 hours.  Setup instructions here:  <a href=\"http://amia.analystseim.com/setup.html\" target=\"_blank\" title=\"http://amia.analystseim.com/setup.html\">http://amia.analystseim.com/setup.html</a></p>",
        "id": 153887452,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1494059395
    },
    {
        "content": "<p>Hi Chris,<br>\nTHis works out of the box. What is your drillbit platform configuration ?  5 nodes cluster ?<br>\nThanks</p>",
        "id": 153887703,
        "sender_full_name": "natus",
        "timestamp": 1494096432
    },
    {
        "content": "<p>6 nodes, m4.4xlarge on AWS EC2.</p>",
        "id": 153888023,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1494157610
    },
    {
        "content": "<p>I have made some tests about the references.</p>\n<blockquote>\n<p>SELECT count(1)<br>\nFROM dfs.pq.<code>Patient</code> P<br>\nJOIN dfs.pq.<code>Encounter</code> E ON (P.resourceType || '/' || <a href=\"http://P.id\" target=\"_blank\" title=\"http://P.id\">P.id</a> = E.patient.reference);</p>\n</blockquote>\n<p>First of all, there is no performance impact when using the <code>P.patient_reference = E.patient.reference</code> or <code>ON (P.resourceType || '/' || P.ide = E.patient.reference)</code> .  Result is between 16 and 20 seconds in each way.</p>\n<p>Then the only advantage to add the patient_reference = 'Patient/0001' element is a syntactic sugar. </p>\n<blockquote></blockquote>\n<p>BTW, sadly the id regex definition is [A-Za-z0-9\\-\\.]{1,64} (from  <a href=\"https://www.hl7.org/fhir/datatypes.html#id\" target=\"_blank\" title=\"https://www.hl7.org/fhir/datatypes.html#id\">https://www.hl7.org/fhir/datatypes.html#id</a>) . It does not allows assigning <a href=\"http://Patient.id\" target=\"_blank\" title=\"http://Patient.id\">Patient.id</a> = 'Patient/001' . This would be great to extend id definition to  [A-Za-z0-9\\-\\.<strong>\\/</strong>]{1,64}<br>\nAllowing slash in id regex  would allow native easy join writing :  <code>P.id = E.patient.reference</code></p>",
        "id": 153888047,
        "sender_full_name": "natus",
        "timestamp": 1494166978
    },
    {
        "content": "<p>No performance penalty for Drill until it will get some indexes functionality  :)</p>",
        "id": 153888053,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1494169601
    },
    {
        "content": "<p>This is sadly true</p>\n<blockquote></blockquote>\n<p>In the meantime, if one want to join resources in any system, integers (1999) is the most effective way. (compared to string version \"Patient/1999\"). So your FHIR not friendly method is better (I mean adding to Encounter a patient element such `P.id = <a href=\"http://E.patient.id\" target=\"_blank\" title=\"http://E.patient.id\">E.patient.id</a> Ì€ is the join method).</p>",
        "id": 153888061,
        "sender_full_name": "natus",
        "timestamp": 1494178263
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-email=\"niparisco@gmail.com\" data-user-id=\"2424\">@natus</span> Can you write in sentence what are you trying to achieve that you wrote via Query . I can guess something like , Count number of encounter that every patient has ? and you said that \"Result is between 16 and 20 seconds in each way.\" is it the query runtime ? and what the total number of records that you are joining and searching ? <br>\nIt will be helpful if you provide some information about the dataset and your progress :)</p>",
        "id": 153889821,
        "sender_full_name": "Fahim Shariar",
        "timestamp": 1494679840
    },
    {
        "content": "<p>I was testing the dataset provided by the fhir hackaton analytics. The query was a simple test of join performances. I cannot remember exactly the resulting number of rows, but more than 10 milions. Conclusion was performances are definitively good with FHIR native model.</p>",
        "id": 153889831,
        "sender_full_name": "natus",
        "timestamp": 1494708813
    }
]