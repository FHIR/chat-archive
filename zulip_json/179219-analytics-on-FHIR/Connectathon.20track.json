[
    {
        "content": "<p>David Hay asked us to formulate scenarios for track!</p>\n<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"194833\">@Patrik Sundberg</span> we want to do the same with postgresql and fhirbase. So people will be able compare bigquery and postgresql :).  May be <span class=\"user-mention\" data-user-id=\"193657\">@Ryan Brush</span> can do the same with spark and bunsen. Then we can discuss common subset of SQL for FHIR.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"194833\">@Patrik Sundberg</span> <span class=\"user-mention\" data-user-id=\"193657\">@Ryan Brush</span> <span class=\"user-mention\" data-user-id=\"195380\">@Kenny Blanchette</span></p>",
        "id": 153987527,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1534421673
    },
    {
        "content": "<p>Here is what we tried to do on previous one - <a href=\"https://github.com/fhir-fuel/fhir-storage-and-analytics-track\" target=\"_blank\" title=\"https://github.com/fhir-fuel/fhir-storage-and-analytics-track\">https://github.com/fhir-fuel/fhir-storage-and-analytics-track</a></p>",
        "id": 153987532,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1534422340
    },
    {
        "content": "<p>For track we have to have a leader.  <span class=\"user-mention\" data-user-id=\"194833\">@Patrik Sundberg</span>  would you like to lead us?</p>",
        "id": 153987534,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1534422467
    },
    {
        "content": "<p>There is an idea to integrate this track with bulk load api and for track provide bulk loader for each specific database. Participants will be able to load data from existing FHIR server and start playing with SQL. (<a href=\"https://github.com/fhir-fuel/fhir-storage-and-analytics-track/issues/6\" target=\"_blank\" title=\"https://github.com/fhir-fuel/fhir-storage-and-analytics-track/issues/6\">https://github.com/fhir-fuel/fhir-storage-and-analytics-track/issues/6</a>)</p>",
        "id": 153987535,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1534422667
    },
    {
        "content": "<p>We can work on scenarios as github issues in <a href=\"https://github.com/fhir-fuel/fhir-storage-and-analytics-track/issues\" target=\"_blank\" title=\"https://github.com/fhir-fuel/fhir-storage-and-analytics-track/issues\">https://github.com/fhir-fuel/fhir-storage-and-analytics-track/issues</a></p>",
        "id": 153987539,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1534423233
    },
    {
        "content": "<p>I'll be coming to your connectathon track, although my interests are a little different from your main thrust. I am interested in getting FHIR in and out of legacy relational databases; generating the transforms, and generating  the required SQL from a RESTFul FHIR search. So I may be watching and  learning more than doing.</p>",
        "id": 153999072,
        "sender_full_name": "robert worden",
        "timestamp": 1537552049
    },
    {
        "content": "<p>Here is online demo of fhirbase you can try - <a href=\"https://fbdemo.aidbox.app/\" target=\"_blank\" title=\"https://fbdemo.aidbox.app/\">https://fbdemo.aidbox.app/</a></p>",
        "id": 154001574,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1538231751
    },
    {
        "content": "<p>The (very) experimental representation of the CMS CQL content in SQL that we had discussed earlier an be found here: <a href=\"https://gist.github.com/rbrush/61243822298dc077659028bb36c1b02d\" target=\"_blank\" title=\"https://gist.github.com/rbrush/61243822298dc077659028bb36c1b02d\">https://gist.github.com/rbrush/61243822298dc077659028bb36c1b02d</a>.</p>",
        "id": 154001973,
        "sender_full_name": "Ryan Brush",
        "timestamp": 1538244490
    },
    {
        "content": "<p>SQL on FHIR breakout in the President's Room  on 15:00 - join us!</p>",
        "id": 154001980,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1538244592
    },
    {
        "content": "<p><a href=\"https://github.com/cqframework/healthedecisions/tree/master/tooling/framework/SQL.Translation\" target=\"_blank\" title=\"https://github.com/cqframework/healthedecisions/tree/master/tooling/framework/SQL.Translation\">https://github.com/cqframework/healthedecisions/tree/master/tooling/framework/SQL.Translation</a></p>",
        "id": 154002440,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1538255566
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193657\">@Ryan Brush</span>  and <span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> , this is the ELM-to-SQL translator we were talking about it.</p>",
        "id": 154002444,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1538255603
    },
    {
        "content": "<p>Some notes from today's discussions:</p>\n<p>There are two related but distinct projects here: One is a simplified projection of FHIR for SQL and analytic use. This should offer an excellent user experience to anyone looking to ask questions over large FHIR datasets, or create new knowledge for them. The second is a lossless storage format that is more efficient and easier to work with than the current JSON/NDJSON models. </p>\n<p>Some notes on the simplified projections for SQL, which is my current focus:</p>\n<ul>\n<li>\n<p>They can be lossy when needed to improve the experience of the data science users. For instance: <br>\n    * id fields may be omitted<br>\n    * Numeric values are represented a NUMERIC or DECIMAL types in the projection (so the original precision might be unknown)<br>\n    * Dates and times may be represented using date and datetime types in the projection, to simplify use of database-provided functionality.</p>\n</li>\n<li>\n<p>Systems should offer a way to retrieve the original, authoritative data in lossless JSON if they need to know what the original data was. (We do not yet specify how to retrieve that, since we want to offer some flexibility to find the best approach.)</p>\n</li>\n<li>Each projected table SQL schema is generated based on a given set of Profiles. </li>\n<li>Extensions are projected as first-class fields based on the slice name of the projection. For instance, the US Core Patient profile has a first-class “race” field that can be queried like any other.</li>\n<li>Similarly, slicing should be used as appropriate for codes defined in profiles. So US Core Observation.code would explicitly have a loinc field, rather than the convention of the LOINC code being in Observation.code.coding[0]</li>\n<li>The SQL projections should be considered transient — so they can be discarded and re-recreated as needed, possibly with updated profiles (and corresponding extension fields).</li>\n<li>The SQL schema used should follow conventions of the documentation on <a href=\"http://fhir.hl7.org\" target=\"_blank\" title=\"http://fhir.hl7.org\">fhir.hl7.org</a>. Ideally, our analytic users should be able to simply use that web site as a reference for all of their SQL queries.</li>\n<li>Inline with the above, field names should use camelCase and exactly match the structures on <a href=\"http://fhir.hl7.org\" target=\"_blank\" title=\"http://fhir.hl7.org\">fhir.hl7.org</a>, as seen in that documentation.</li>\n</ul>\n<p>Open questions include how close the projections should stick with the NDJSON format, allowing queries directly over that, or whether that will be improved with a future storage representation. For instance, whether option types should be stored as distinct fields like valueQuantity, valueString, and so on — or as nested fields such as value.quantity, value.string, etc. This is a tradeoff between consistency with the JSON model and the ability to easily to check for NULL choice types in SQL.</p>\n<p>I didn’t go into the physical storage considerations here since the above is my current focus, but welcome others to comment on that.</p>",
        "id": 154002548,
        "sender_full_name": "Ryan Brush",
        "timestamp": 1538257689
    },
    {
        "content": "<p>\"Extensions are projected as first-class fields based on the slice name of the projection. For instance, the US Core Patient profile has a first-class “race” field that can be queried like any other.\" - interestingly, this is the approach I took when presenting a 'logical' view of a profile intended for clincian use...  Here's US Core patient for example: <a href=\"/user_uploads/10155/8hiAZG9gReSJW4mH7TcdGJBy/Screen-Shot-2018-09-30-at-6.46.11-AM.png\" target=\"_blank\" title=\"Screen-Shot-2018-09-30-at-6.46.11-AM.png\">Screen-Shot-2018-09-30-at-6.46.11-AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/8hiAZG9gReSJW4mH7TcdGJBy/Screen-Shot-2018-09-30-at-6.46.11-AM.png\" target=\"_blank\" title=\"Screen-Shot-2018-09-30-at-6.46.11-AM.png\"><img src=\"/user_uploads/10155/8hiAZG9gReSJW4mH7TcdGJBy/Screen-Shot-2018-09-30-at-6.46.11-AM.png\"></a></div>",
        "id": 154002627,
        "sender_full_name": "David Hay",
        "timestamp": 1538304408
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191321\">@David Hay</span> As you probably know, Forge re-orders elements for display, listing extensions _after_ standard elements. Maybe the 'logical' view in ClinFhir could also follow this convention, if that makes sense?</p>",
        "id": 154002886,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538319271
    },
    {
        "content": "<p>I used to list extensions afterwards in some of the generated IG views, but got some strong pushback</p>",
        "id": 154002913,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1538319812
    },
    {
        "content": "<p>Interesting. I've never received any push back about Forge's custom rendering order. I could easily implement a configuration option to toggle this behavior, however no user ever asked for it...?</p>",
        "id": 154002975,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538321203
    },
    {
        "content": "<p>I would definitely like Forge to allow views that are consistent with how things need to appear in the instance.  It's confused several of my users.</p>",
        "id": 154003008,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538321826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> thank you, that is good to know. Definitely makes the case for implementing a configuration option.</p>",
        "id": 154003042,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538322401
    },
    {
        "content": "<p>I agree with Ryan's summary and the proposed direction. It will be helpful to consider the analyst view of the data separately from the storage format for now, but there are obvious similarities. Longer term, we might find ways to combine the two approaches.</p>\n<p>We discussed query rewrites in the session yesterday; can we transform simple queries containing terms like \"observation.code.loinc\" to a longer, more complex query over a generic data format? This is tempting for various reasons, but i believe it's ultimately impractical because most tools will not have natural plugins for such transformations, so any workflow that needs to use transformations will be burdensome.</p>\n<p>Instead, I believe we should focus on tools that make it easy to go from (Resource.ndjson, StructureDefinition) pairs into files suitable for direct queries by standard database engines. This conversion can and should be lossy for simplicity. It should inline extensions like Ryan mentioned before, and it should map primitive types to single fields. We've implement parts of this in our github repo, for example, here's a sample protobuf definition (ObservationGenetics) with a fair number of inlined extensions: <a href=\"https://github.com/google/fhir/blob/master/proto/stu3/profiles.proto#L233\" target=\"_blank\" title=\"https://github.com/google/fhir/blob/master/proto/stu3/profiles.proto#L233\">https://github.com/google/fhir/blob/master/proto/stu3/profiles.proto#L233</a> .</p>\n<p>Key items left to formally decide in my opinion are:</p>",
        "id": 154003242,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538330756
    },
    {
        "content": "<ul>\n<li>how do we name extensions?<ul>\n<li>proposal: use slice names (this seems to be mostly agreed upon)</li>\n</ul>\n</li>\n</ul>",
        "id": 154003243,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538330767
    },
    {
        "content": "<ul>\n<li>how do we handle choice types?<ul>\n<li>proposal: observation.value.quantity instead of observation.valueQuantity</li>\n</ul>\n</li>\n</ul>",
        "id": 154003244,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538330779
    },
    {
        "content": "<ul>\n<li>how do we represent decimal?<ul>\n<li>proposal: as a native number, discarding precision (lossy conversion)</li>\n</ul>\n</li>\n</ul>",
        "id": 154003246,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538330787
    },
    {
        "content": "<ul>\n<li>how do we represent dates?<ul>\n<li>proposal: as ISO8601 string, with timezone as appropriate</li>\n</ul>\n</li>\n</ul>",
        "id": 154003247,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538330794
    },
    {
        "content": "<ul>\n<li>how do we handle unknown extensions (those not explicitly listed in the input profile)?<ul>\n<li>proposal: drop on the floor (lossy)</li>\n<li>proposal: keep, for queries of the type \"count extension types in use group by extension_url\"</li>\n</ul>\n</li>\n</ul>",
        "id": 154003248,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538330801
    },
    {
        "content": "<ul>\n<li>how do we handle ids and extensions on primitive fields?<ul>\n<li>proposal: drop on the floor (lossy)</li>\n</ul>\n</li>\n</ul>",
        "id": 154003249,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538330807
    },
    {
        "content": "<ul>\n<li>how do we handle nested recursive types?<ul>\n<li>proposal: define a max nesting level somewhere</li>\n<li>proposal: use avro files and built-in avro support</li>\n</ul>\n</li>\n</ul>",
        "id": 154003250,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538330812
    },
    {
        "content": "<ul>\n<li>do we duplicate sliced data (extensions, observation.code.loinc, etc), leaving it in the raw fields?<ul>\n<li>proposal: no</li>\n<li>proposal: yes</li>\n</ul>\n</li>\n</ul>",
        "id": 154003251,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538330818
    },
    {
        "content": "<ul>\n<li>how do we handle situations where some resources do not comply with the profile, such as when querying for vitals in an observation table<ul>\n<li>proposal: filter on resources that match the profile</li>\n</ul>\n</li>\n</ul>",
        "id": 154003332,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538333389
    },
    {
        "content": "<ul>\n<li>how do we represent a primitive field with a declared extension<ul>\n<li>proposal: as a new type, where the original value is accessed as \"value\"</li>\n</ul>\n</li>\n</ul>",
        "id": 154003333,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538333435
    },
    {
        "content": "<p>Thanks for this thoughtful enumeration of current considerations! On all items with a single proposal, I agree with the approach. I'll comment on a couple of the others...</p>\n<blockquote>\n<ul>\n<li>how do we handle nested recursive types?<ul>\n<li>proposal: define a max nesting level somewhere</li>\n<li>proposal: use avro files and built-in avro support</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>While Avro and ProtoBuf allow for arbitrarily recursive structures, we still need to apply a max depth when creating an SQL-based view of the data for Spark or Presto (and for other analytic tools as well.) So I think the best we can do is to base that depth based on the data that exists, but tools SHOULD re-create that schema with further depth if new data is discovered that demands it.</p>",
        "id": 154003348,
        "sender_full_name": "Ryan Brush",
        "timestamp": 1538334109
    },
    {
        "content": "<blockquote>\n<ul>\n<li>do we duplicate sliced data (extensions, observation.code.loinc, etc), leaving it in the raw fields?<ul>\n<li>proposal: no</li>\n<li>proposal: yes</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>After an offline discussion, I think our current best option is to leave in the raw fields. This makes it easier for users to explore who may not be interested in the specific slices, and keeps it consistent with the documentation published on <a href=\"http://fhir.hl7.org\" target=\"_blank\" title=\"http://fhir.hl7.org\">fhir.hl7.org</a></p>",
        "id": 154003349,
        "sender_full_name": "Ryan Brush",
        "timestamp": 1538334168
    },
    {
        "content": "<blockquote>\n<ul>\n<li>how do we handle unknown extensions (those not explicitly listed in the input profile)?<ul>\n<li>proposal: drop on the floor (lossy)</li>\n<li>proposal: keep, for queries of the type \"count extension types in use group by extension_url\"</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>Similarly, we discussed that keeping these extensions is worthwhile to support users doing exploration of the data, making sure their schemas cover all the extensions they need.</p>",
        "id": 154003352,
        "sender_full_name": "Ryan Brush",
        "timestamp": 1538334246
    },
    {
        "content": "<p>Missed one:</p>\n<ul>\n<li>how do we handle references?<ul>\n<li>proposal: split typed references (\"Patient/ABC\") into subfields, e.g. patient_id</li>\n</ul>\n</li>\n</ul>",
        "id": 154003358,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538335185
    },
    {
        "content": "<ul>\n<li>how do we handle choice types?<ul>\n<li>proposal: observation.value.quantity instead of observation.valueQuantity</li>\n<li>consider observation.value.Quantity vs observation.value.quantity. What with CodeableConcept or DateTime ? codeableconcept?</li>\n</ul>\n</li>\n</ul>",
        "id": 154003359,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1538335265
    },
    {
        "content": "<ul>\n<li>reference &amp; choice types meta attribute : <code>reference: {patient_id: ...., type: 'Patient'}, choice: {quantity: ..., type: 'Quantity'}</code></li>\n</ul>",
        "id": 154003360,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1538335343
    },
    {
        "content": "<p>fyi here's the protobuf current Observation.value: <a href=\"https://github.com/google/fhir/blob/master/proto/stu3/resources.proto#L11657\" target=\"_blank\" title=\"https://github.com/google/fhir/blob/master/proto/stu3/resources.proto#L11657\">https://github.com/google/fhir/blob/master/proto/stu3/resources.proto#L11657</a></p>",
        "id": 154003366,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538335537
    },
    {
        "content": "<ul>\n<li>how do we handle contained resources?<ul>\n<li>proposal: drop on the floor</li>\n</ul>\n</li>\n</ul>",
        "id": 154003370,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538335684
    },
    {
        "content": "<p>* externalise<br>\n  * move into reference (we do this using custom resource attribute in Reference)</p>",
        "id": 154003376,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1538335880
    },
    {
        "content": "<ul>\n<li>how do we represent a primitive field with a declared extension<ul>\n<li>proposal: as a new type, where the original value is accessed as \"value\"</li>\n<li>move it into another element: birthDate.extension =&gt;  birthDateTime</li>\n</ul>\n</li>\n</ul>",
        "id": 154003379,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1538336003
    },
    {
        "content": "<p>If you move the extension to a sibling element, and the original element repeats - how do you correlate the extension values to the elements they were originally contained in?</p>",
        "id": 154003382,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1538336255
    },
    {
        "content": "<p>I do not know, but semantically this is a new element :)</p>",
        "id": 154003387,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1538336385
    },
    {
        "content": "<p>I think our current proposal is that extensions are duplicated to sibling elements for convenience (to make it easy to query patient.race, for instance), but still preserve them in their original form as well. This seems like the \"Least Surprising Behavior\", offering an additional field for convenience while preserving the content of the original fields as much as possible.</p>",
        "id": 154003426,
        "sender_full_name": "Ryan Brush",
        "timestamp": 1538338581
    },
    {
        "content": "<p>I took a pass at incorporating the above proposals into the SQL on FHIR markdown document. Much of the above was already reflected in the document, but you can see the changes in the pull request here: <a href=\"https://github.com/rbrush/sql-on-fhir/pull/9/files\" target=\"_blank\" title=\"https://github.com/rbrush/sql-on-fhir/pull/9/files\">https://github.com/rbrush/sql-on-fhir/pull/9/files</a>.</p>",
        "id": 154003440,
        "sender_full_name": "Ryan Brush",
        "timestamp": 1538339248
    },
    {
        "content": "<p>Please feel free to make any comments or suggestions on that pull request. The document is still a work in progress and will surely change, but I think this gets us close enough to start building early systems on this specification. </p>\n<p>The biggest course change we've made is to accept this is a lossy projection of the underlying FHIR data to create a great experience for analysts looking to explore FHIR data. In most cases the information loss won't matter to these users, but the original data should be available as well for users who need to know the exact precision used for each numeric field, for instance.</p>",
        "id": 154003446,
        "sender_full_name": "Ryan Brush",
        "timestamp": 1538339440
    },
    {
        "content": "<p>This does not attempt to define an approach to a non-lossy, efficient physical representation. However, this should be a useful reference for physical representations to ensure they can be easily projected onto the model described here.</p>",
        "id": 154003452,
        "sender_full_name": "Ryan Brush",
        "timestamp": 1538339523
    },
    {
        "content": "<p>fwiw this example: <a href=\"https://github.com/google/fhir/tree/master/examples/bigquery\" target=\"_blank\" title=\"https://github.com/google/fhir/tree/master/examples/bigquery\">https://github.com/google/fhir/tree/master/examples/bigquery</a><br>\nexposes a few of these issues in practice. the schema in use here is not the lossy, profile-specific one discussed in this connectathon, but i will change it to be.</p>",
        "id": 154003506,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1538341791
    },
    {
        "content": "<p>Proto of CMS metric in postgresql - <a href=\"https://fbdemo.aidbox.app/\" target=\"_blank\" title=\"https://fbdemo.aidbox.app/\">https://fbdemo.aidbox.app/</a> - see CMS snippet</p>",
        "id": 154003519,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1538354837
    },
    {
        "content": "<p>I went ahead and merged the pull request I mentioned to <a href=\"https://github.com/rbrush/sql-on-fhir\" target=\"_blank\" title=\"https://github.com/rbrush/sql-on-fhir\">https://github.com/rbrush/sql-on-fhir</a> that reflects our discussions here. We'll continue to update that document as further changes emerge.</p>\n<p>One additional topic did come up:</p>\n<ul>\n<li>How to deal with extensions that are unknown when generating the SQL schema?<ul>\n<li>Proposal:  when generating the schema, users specify the profiles/extensions they are interested in querying. Additional extensions in the data will be visible as URLs in the projection so they can be detected, but won't have schema generated for them. </li>\n</ul>\n</li>\n</ul>\n<p>This assumes the schema can be easily re-generated if there is a desire to query these new extensions.</p>",
        "id": 154003806,
        "sender_full_name": "Ryan Brush",
        "timestamp": 1538411462
    },
    {
        "content": "<blockquote>\n<p>how do we handle contained resources?<br>\nproposal: drop on the floor</p>\n</blockquote>\n<p>That's my favorite idea, if only it was a realistic one</p>",
        "id": 154006228,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1538736623
    },
    {
        "content": "<p>i think, exporter can have options - drop, externalise, internalise</p>",
        "id": 154006309,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1538749052
    }
]