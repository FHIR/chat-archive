[
    {
        "content": "<p>Another discovered issue from the Australian connectathon around Lab testing: the lab test omits the DiagnosticReport. That's.. potentially problematic.  Long term, we think it will be necessary to  provide some kind of link in or next to the jwks.json that refers to a service where the issuer may provide some additional services to (a) renew cards and (b) get more information about the cards for authorised users</p>",
        "id": 262409174,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637638919
    },
    {
        "content": "<p>Worth writing up some use cases here -- very interesting area (and significant complexity, but if labs are willing to invest, we can support with specs).</p>",
        "id": 262465665,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1637679053
    },
    {
        "content": "<p>well, so far, I have two particular cases. One featured very prominently in this weeks podcast of The Dropout (about the fall of Elizabeth Holmes and Theranos, which is recommended listening for anyone working in health it and interested in the intersection between business, tech, and health): you never share lab results with a patient with out some context or guidance. mostly, this is left to the doctor who requested the test, but that's not how SHCs work, and so labs will want to - and may have regulatory obligations to - provide the patient with a path for advice / guidance / treatment pathways / etc. As featured in the podcast, in the absence of this, patients often don't seek advice / follow up at all, which is <em>very bad</em> or they decide that they should, but pursue it through the wrong channels (e.g. business sales support for the lab provider).</p>\n<p>But this isn't unique to labs. Any provision of a healthcare fact raises the same conceptual issues (though not necessarily the same regulatory requirements).  So any number of workflows beyond lab would benefit from a standard arrangement where the provider published, along with their key, the URL of a service to seek more information about the card. When invoking that service, the client submits the card, and... something happens. </p>\n<p>Also, if the card is revoked (this is my second case), then the service can automatically offer a replacement (if they deem it is appropriate). or they can provide further advice as appropriate based on clinical context</p>\n<p>For me this is also a sales thing: like branding your SHC, and turning the SHC into a branded channel. Feedback to me (general feedback about APIs, not SHCs) is that this is critical to getting CEO / business buy in to sending SHCs. (See also this card from the Australian connectathon yesterday):</p>\n<p><a href=\"/user_uploads/10155/AqqHmpwV4MmjwcGu6sjuk20I/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/AqqHmpwV4MmjwcGu6sjuk20I/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/AqqHmpwV4MmjwcGu6sjuk20I/image.png\"></a></div><p>So I think it would be really useful for the issuer of the card to have a URL with a name, declared at the &lt;&lt;issuer&gt;&gt; that a client would submit the card to, and then... magic would happen. Obviously I haven't worked through that but what follows smells suspiciously look a CDS Hooks kind of thing - one of a number of cards could be returned. The invocation context is kind of different, so CDS Hooks might need some context, but it's pretty much the same thing, right?</p>",
        "id": 262654104,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1637799228
    },
    {
        "content": "<p>smart/health-cards</p>",
        "id": 262765148,
        "sender_full_name": "Salvador Mendoza",
        "timestamp": 1637909523
    },
    {
        "content": "<p>I think it would be nicer to define a framework to consume cards (e.g. Trust Registry for Verifiers) as opposed to let the issuer dictate where to go for more information. For instance, a Lab Result should be consumed by a Clinic/Hospital that would not only be liable to have the appropriate understanding of the payload but are also in tune with the latest scientific knowledge and public health policy of the region to provide individualized medical recommendations upon request. Having a fixed URL from the issuer might block use-cases that are outside the purview of that issuer, e.g. multi-jurisdiction use cases. Also, let's try to avoid mixing the lab results are are designed to go straight to consumers (COVID testing, pregnancy test, etc) from the lab results that clinicians request.</p>",
        "id": 262951351,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638137669
    },
    {
        "content": "<blockquote>\n<p>Also, let's try to avoid mixing the lab results are are designed to go straight to consumers (COVID testing, pregnancy test, etc) from the lab results that clinicians request.</p>\n</blockquote>\n<p>Sure. but a lab result that goes to the patient is likely to go to a clinic next. But sure, it's not the same thing. </p>\n<blockquote>\n<p>Having a fixed URL from the issuer might block use-cases</p>\n</blockquote>\n<p>how? It doesn't stop the client from doing whatever, it just makes it easy for the client to ask the issuer as well as anything else</p>",
        "id": 262965575,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638159294
    },
    {
        "content": "<p>It depends on who is the client. if the client is the wallet of the Patient, then it shouldn't be a problem, but if the client is any other verifier, then there is a massive privacy issue. Verifiers should not be allowed to communicate with issuers directly. That's the whole point of verifiable credentials. If they are allowed to ping the issuer then suddenly the payload doesn't even need to be signed anymore.</p>",
        "id": 263008543,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638192860
    },
    {
        "content": "<p>Agree with Vitor here about the privacy concern. There may be some capabilities that are helpful to advertise, but we definitely do not want to get in the game of enabling back channels between a verifier and issuer <em>for the purpose of verification</em> or <em>with a consequence of trekking individual credential use</em>.</p>",
        "id": 263018929,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638197908
    },
    {
        "content": "<p>I really don't understand why we would <em>forbid</em> communication. I really don't understand why defining a channel to allow follow up suddenly becomes 'you must follow up' or why you suddenly don't need to verify the payload. </p>\n<p>The point of a follow up channel is (a) the user doesn't need to use it and (b) the client only uses it if someone asks to and (c) privacy and security still need to be right on the channel</p>",
        "id": 263052409,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638212060
    },
    {
        "content": "<p>It establishes preconditions for verifiers and issuers to communicate without input from (or visibility to) the individuali.</p>",
        "id": 263074028,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638223582
    },
    {
        "content": "<p>I do not see how it's better that they can't communicate at all.</p>",
        "id": 263076675,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638224986
    },
    {
        "content": "<p>Because then the individual has a better concept of what is being shared. Specifically: the things they decided to share. </p>\n<p>I'm not saying there is no use case for advertising more endpoints and details in an issuer specific way, but this is something we want to be very cautious about.</p>",
        "id": 263079276,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638226619
    },
    {
        "content": "<p>I don't really understand. If you don't standardise this, then institutions will do one of two things, since the use case is genuine:</p>\n<ul>\n<li>use something other than SHC that don't have any privacy properties at all</li>\n<li>make custom arrangements that happen behind the scenes</li>\n</ul>\n<p>Better to describe how to do it properly and create conformance expectations about privacy.</p>",
        "id": 263079466,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638226723
    },
    {
        "content": "<p>At least one of the use cases you mentioned above was about an endpoint for providing information directly to patients. There is no problem with those kinds of patterns. It's something we are starting to explore in our directory metadata, and something that we could easily push into a standardized discovery file if it turns out to be useful.</p>\n<p>The concerns are about discovery data that expect and allow for direct communication behind an individual's back.</p>",
        "id": 263080132,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638227111
    },
    {
        "content": "<p>well, I don't want to expect communication behind an individuals back, but I don't see how you're going to stop allowing it. But if you describe it, you can also describe how to make it require an individuals authorisation, or at least, to ensure that they get a notification if it's used</p>",
        "id": 263080558,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638227387
    },
    {
        "content": "<p>These are all good points</p>",
        "id": 263080791,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638227497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> It would be nice to have a very specific/real use case for adding the link.</p>",
        "id": 263087970,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638232756
    },
    {
        "content": "<p>you've dismissed the ones I provided above?</p>",
        "id": 263088065,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638232803
    },
    {
        "content": "<p>I meant a real use case with actual payload and links. The ones you provided are still very abstract.</p>",
        "id": 263088547,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638233092
    },
    {
        "content": "<p>let's start with the case where the card that's been issued has an expiry date, or the key it was signed with has been revoked. Getting a new one is technically straight forward, but administratively difficult. And particularly in the case of key revocation, likely to be extremely embarrassing - I'm going about my business, some one scans my QR code, and then, bingo, it's not valid. Whoever scanned my code isn't going to think that there's a problem with the infrastructure; they're going to think that I'm lying to them. And most people will just be angry and confused because what happened is nothing to do with them, but their life is disrupted - potentially very severely</p>\n<p>To extend this, if I was asked to break the SHC system, this is precisely where I'd try first: if I can entice the issuer into thinking that their key has been compromised, then they'll revoke the key, and suddenly 100k's of users will have invalid SHCs that they are rightly convinced are valid, and keep showing, because they don't have the time or knowledge to go through the adminstrative processes to get themselves a new card. And bingo, trust in the SHC system collapses, and I can present any card I made up and claim that it really is valid, it's not my fault</p>\n<p>So I think that a good system to re-issue cards seamlessly is very necessary. And that's the first use case I had. There'd be a link \"get a new card\" when it's not valid, and upon proper authentication, the user would get a new card (delivered immediately or mailed or emailed or whatever). </p>\n<p>so the issuer would have .well-known/links.json:</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span>\n  <span class=\"nt\">\"re-issue\"</span> <span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">\"link\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"http://www.acme.com/shc/re-issue\"</span><span class=\"p\">,</span>\n   <span class=\"nt\">\"name\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"Get a new card\"</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>And when the card fails, and the holder of the card (assumes that the software understands from it's context that the card it has is on behalf of the user), clicks on/touches \"Get a new card\", then the software posts the card to <a href=\"http://www.acme.com/shc/re-issue\">http://www.acme.com/shc/re-issue</a>, and the response is a CDS Hook card:</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span>\n  <span class=\"nt\">\"cards\"</span> <span class=\"p\">:</span> <span class=\"p\">[{</span>\n    <span class=\"nt\">\"summary\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"The key used to sign the card was revoked. The holder of the card can get a new card.\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"indicator\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"info\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"source\"</span> <span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"nt\">\"label\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"ACME Patient Services\"</span>\n    <span class=\"p\">}</span>\n    <span class=\"nt\">\"links\"</span> <span class=\"p\">:</span> <span class=\"p\">[{</span>\n      <span class=\"nt\">\"label\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"if you have a digital account and can log in, choose this to get a new card immediately\"</span><span class=\"p\">,</span>\n      <span class=\"nt\">\"url\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"http://acme.com/patient/login\"</span><span class=\"p\">,</span>\n      <span class=\"nt\">\"type\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"absolute\"</span>\n    <span class=\"p\">},{</span>\n      <span class=\"nt\">\"label\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"Alternatively, get a new card mailed to your home\"</span><span class=\"p\">,</span>\n      <span class=\"nt\">\"url\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"http://acme.com/patient/request-card-mailed\"</span><span class=\"p\">,</span>\n      <span class=\"nt\">\"type\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"absolute\"</span>\n    <span class=\"p\">}]</span>\n  <span class=\"p\">}]</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 263091261,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638235220
    },
    {
        "content": "<p>We do have a \"website\" metadata item in the VCI directory  for this purpose. It is intended to be a link that a consumer can follow to get information about how to obtain a health card from a given issuer. ( In general, we're looking at metadata in the directory as a kind of trial ground for things that we might want to standardize and push up to issuer based discovery endpoints.)</p>",
        "id": 263091377,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638235334
    },
    {
        "content": "<p>so the key difference for me is to make this slicker: they don't have to go somewhere else to find that out, and the card is posted back to the issuer to transfer the context.</p>",
        "id": 263091435,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638235414
    },
    {
        "content": "<p>(I should also know that for issuers of supporting smart on fhir, it would typically be a wallet app responsible for checking and obtaining any available credentials on some regular basis, or when a credential  issuer key is discovered to have been revoked.  For other issuers, we certainly encourage them to proactively reach out to individual VC holders anytime. They are about to revoke a key or otherwise invalidate longstanding credentials.  These don't take away from the utility of advertising in metadata, but they are worth knowing about)</p>",
        "id": 263091439,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638235423
    },
    {
        "content": "<p>Re: a protocol for reissuing credentials (\"here's my old SHC; please return a new one  that has been signed by a key that isn't revoked  <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>\")... Certainly this could be defined, but it starts to overlap pretty quickly with the FHIR API for issuance we have today, and so far the issuers we have seen using non FHIR approaches don't offer an API at all, but rather want to interact with a consumer to have them verify control of a phone number or email address before issuing a card to them.</p>",
        "id": 263091586,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638235549
    },
    {
        "content": "<blockquote>\n<p>it would typically be a wallet app responsible for checking and obtaining any available credentials on some regular basis</p>\n</blockquote>\n<p>What wallet app? each issuer has their own so they know how to do it? THat's pretty much what I'm trying to talk about, making interop possible here</p>",
        "id": 263091793,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638235729
    },
    {
        "content": "<p>No, I'm talking about apps like Apple or Common health here, which can fetch credentials using the SMART on FHIR issuance API</p>",
        "id": 263091824,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638235764
    },
    {
        "content": "<p>that's not the only way that those apps get the cards in the first place. in fact, it's unlikely to be how they get them at all - at least in Australia, where push to consumer exists widely, but the authentication infrastructure for smart on fhir exists very rarely</p>",
        "id": 263091918,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638235851
    },
    {
        "content": "<p>(Although to your point, issuer-specific apps like MyChart  of course can help with these details as well.)</p>",
        "id": 263091921,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638235857
    },
    {
        "content": "<p>it doesn't make any difference to me whether the link is at the issuer URL, or in the vci directory, though in general I think it should be secondary in the vci directory</p>",
        "id": 263092043,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638235992
    },
    {
        "content": "<p>There's a lot more that you would want in a protocol like this. If you wanted to expose an API where anyone could trade in a copy of a card that was signed with a bad key and obtain a new card signed with a good key...  You need some binding to a verifiable identity claim or a decentralized identifier that allows verifiable presentations, etc. It's worth checking out the VC API work happening in W3C <a href=\"https://github.com/w3c-ccg/vc-api\">https://github.com/w3c-ccg/vc-api</a>  for a sense of what is involved here</p>",
        "id": 263092147,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638236070
    },
    {
        "content": "<p>ah what? I don't want any of those things. I'm assuming that they reissue based on the original issuing protocol - I don't think that needs any of that complexity. Passing the card just passes along the administrative context to kick the process off in the right context</p>",
        "id": 263092254,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638236172
    },
    {
        "content": "<p>So the protocol is:  anyone in the world can post a SMART Health Card to the issuer's \"get the rightful holder of this card a new copy\" endpoint,  and then the issuer wakes up and reaches out proactively to the individual  holder through some channel  that the issuer chooses?</p>",
        "id": 263092324,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638236273
    },
    {
        "content": "<p>or redirects them to a login if it thinks that the individual holder can/might login</p>",
        "id": 263092385,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638236313
    },
    {
        "content": "<p>but yes</p>",
        "id": 263092386,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638236316
    },
    {
        "content": "<p>Okay. I mean that's certainly workable. We just haven't seen a convergence of 1) issuers that want to support HTTP APIs, 2) issuers that don't want to do SMART on FHIR --  but  if this is the case for Australia, it could be a good place to start.</p>\n<p>I take your point that if supporting some very narrow APIs was dead simple, the group in (1)  could theoretically be much bigger</p>",
        "id": 263092575,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638236546
    },
    {
        "content": "<p>right. there's often no interest in something that doesn't exist</p>",
        "id": 263092608,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638236606
    },
    {
        "content": "<p>but you're right that there's an underlying assumption of non smart on fhir distribution channels in my thinking</p>",
        "id": 263092624,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638236636
    },
    {
        "content": "<p>Thanks for the example. I think that information could easily be part of the Keys file that the issuer exposes. We can even break down by card type if needed. It doesn't need to be signed in the QR itself.</p>",
        "id": 263095896,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638240287
    },
    {
        "content": "<p>no I don't think this should be in the card - I'm not proposing that</p>",
        "id": 263098087,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638242895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> are you specifically looking for an API automation for re-issuing? Meaning the server at the API can use more robust algorithms to prove that the old card \"was\" issued properly, so it issues a new card? If this is just an api to create a \"fresh\" card given an old card; then there is not much downside... but the new card should not invalidate the old, the old should stand on its own. Meaning this should not be an method for a malicious actor to scan a targets card, send that card to the API, so that the target is now holding a revoked card. The re-fresh API should not affect the old card status; while it is fully based on the old card authenticity.</p>",
        "id": 263140828,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638277649
    },
    {
        "content": "<p>so constant re-freshing should have no downside except as a DOS against that API... which it can/should/shall protect itself.</p>",
        "id": 263140992,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638277729
    },
    {
        "content": "<p>Also, let's make sure the information to perform a login in this API is not included in the card. A simple form with Name + DOB + ID should not be acceptable.</p>",
        "id": 263143753,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638278989
    },
    {
        "content": "<p>the old card should be sufficient. no need to have the request extract these into api parameters.. right? The card already has them, and has a signature... even if the issuing certificate has expired or been revoked, the issuing service can look at the signature \"in context\" of the issuing time, and understanding why/when a revocation happened. Thus this old card was validly issued at a time when the signing cert was not in question, so a new card can be issued based solely on the old card.</p>",
        "id": 263144735,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638279434
    },
    {
        "content": "<p>No, otherwise Verifier databases will keep refreshing their cards at will. We don't want verifiers to be able to refresh a card without the holder's permission.</p>",
        "id": 263145048,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638279581
    },
    {
        "content": "<p>I think the \"we\" in your sentence is fundimentally different than the use-case Grahame is presenting. but I might be wrong.</p>",
        "id": 263145197,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638279643
    },
    {
        "content": "<p>If that is what they want, then they don't need any signature. Just ping the other server and download all the info. There's no need for smart health cards.</p>",
        "id": 263145291,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638279684
    },
    {
        "content": "<p>The idea of expiring cards exist exactly to block verifiers from using the information beyond what they need it for. A COVID pass is only valid for 2 days not because the person is not protected after the two days, but because holders don't want verifiers to use that information outside that time window.</p>",
        "id": 263145892,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638279963
    },
    {
        "content": "<p>that sounds like a reasonable policy that a server that needs to enforce can enforce. but that policy does not need to prevent the API from existing to support policies and use-cases such as Grahame (I think) has presented.</p>",
        "id": 263147500,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638280628
    },
    {
        "content": "<p>The problem is that broadening the support for these use cases defeats the purpose of the entire spec. There are a lot of options that allow verifiers to talk directly to issuers. Grahame can choose any of them. What makes a Verifiable Credential different is exactly the fact that the communication between an issuer and a verifier is MEDIATED by the holder at all times. If you don't want that, you don't need a verifiable credential. There are simpler, faster, better ways to develop that communication outside the Verifiable Credential ecosystem. </p>\n<p>If you want credit cards to behave like cash, just use cash. It's a better solution :)</p>",
        "id": 263148533,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638280996
    },
    {
        "content": "<p>when a credit card is revoked, that card issuer sends me a new card.... Thus, this is exactly what I read is what Grahame is looking for.</p>",
        "id": 263151469,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638282159
    },
    {
        "content": "<p>His use-cases, in my read, is focused on support of Patients when an issuing certificate is revoked due to a later exposure. Supporting re-issuing a fresh card.</p>",
        "id": 263151586,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638282222
    },
    {
        "content": "<p>The thing is, when your credit card is revoked the issuer knows this fact and just sends you new card. They don't wait for a third party app to come by and make an API call requesting it <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> So Grahame's use case here is a bit different. It's about cases where the issuer isn't willing to or can't just proactively send out a new card  and  instead is waiting for a  third party  app to trigger this step  (I'm not sure why? Maybe because the issuers don't know an email or SMS or physical street address where they can send a new SHC?  Or to account for cases where proactive sending was attempted but didn't really work and the user still needs help?).</p>",
        "id": 263155230,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638283708
    },
    {
        "content": "<p>proactive sending might be a useful \"best current practice\" that could be informatively said.... not clear to me that Grahame's use-case would not like that solution.</p>",
        "id": 263156694,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638284330
    },
    {
        "content": "<p>The UX problem here (the user needs help renewing their cards) is real and very common. There are many ways to solve it: One could allow the verifier to get a new card for the holder, a very convenient UX for the holder but one that breaks the triangle of trust model; or we can just extend the wallet/issuer requirements to include an API for the holder to do that by him/herself.  The more we empower the holder, the better the system gets.</p>",
        "id": 263160532,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638285985
    },
    {
        "content": "<p>Agree with this principle <span class=\"user-mention\" data-user-id=\"458846\">@Vitor Pamplona</span> ; to Grahame's point, some kinds of API endpoints that an issuer advertises fall into this category (individual holder requesting reissuance does) and others don't (e.g., \"is card X [still] valid?).   The mechanism of discovery is the same.</p>",
        "id": 263163590,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638287265
    },
    {
        "content": "<p>To take this discussion forward, I think it would make sense to add an \"extensions\" or \"rfcs\" folder to our spec repository outside of the core spec content, akin to the FAQs we have today at <a href=\"https://github.com/smart-on-fhir/health-cards/tree/main/FAQ\">https://github.com/smart-on-fhir/health-cards/tree/main/FAQ</a>...  where we try to outline a spec for this kind of discovery and see what serve adoption we can get. I don't want to start cramming new functionality into the specification unless someone in the real world wants to support it, but I understand there's a catch 22 here and I think there may be some common ground.  Anybody interested in drafting such a thing? Otherwise I can take a crack.</p>",
        "id": 263163838,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638287383
    },
    {
        "content": "<p>I wonder if there is a way to generalize this spec in the same way the SHC spec just says use a FHIR Bundle as model. I am not sure it needs to be an SHC document.</p>",
        "id": 263164335,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638287592
    },
    {
        "content": "<p>it does seem adjacent, or \"trial\"... yup. I just don't agree that having this specific kind of API is  contrary to SHC. Grahame has indicated the use-case is about a proper use of SHC, but where the issuing cert is revoked. That is why it is within SHC.  I would agree that this is not just an API for checking status, but why would a \"check status\" use-case of this same API be contrary to SHC?  Yes, a dominant design requirement of SHC is off-line-proofing, which an online \"check status\" is clearly contrary to; but the format of the card issued can be SHC and the validation from the point of the API returning can be the same SHC processing.... more important is that a service can explicitly reject \"check status\" if that instance of the service has a policy forbidding that use-case, while that service instance allows for \"re-issue card that was invalidated by a issuing cert revocation\".</p>",
        "id": 263164598,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638287701
    },
    {
        "content": "<p>FYI, the WHO DDCC spec does have a \"ping issuer to check status and re-download the cert\" feature which will be developed in the upcoming months. Maybe this whole thing evolves into something every Verifiable Credential standard can use.</p>",
        "id": 263164656,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638287724
    },
    {
        "content": "<p>If that's the goal, I would strongly encourage participation in <a href=\"https://github.com/w3c-ccg/vc-api\">https://github.com/w3c-ccg/vc-api</a></p>",
        "id": 263164740,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638287757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> it is not my interest to have the card automatically re-issued. Just to make a smooth UX for re-issue possible in an interoperable way. </p>\n<p>And yes, I'm assuming that an issuer that revokes a key that invalidates several million cards will not proactively reissue all of them because of cost and various other factors (including not knowing which ones are worth re-issuing)</p>",
        "id": 263197019,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638301003
    },
    {
        "content": "<p>I was not the one proposing automatic re-issuing. I was not indicating WHY the api would be triggered. Just that once called, with an old cert, the service could validate, follow local policy, and return a new.</p>",
        "id": 263212602,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638308368
    },
    {
        "content": "<p>and those local polices would be designed to protect the api from abuse, and misuse.</p>",
        "id": 263212723,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638308421
    },
    {
        "content": "<blockquote>\n<p>Just that once called, with an old cert, the service could validate, follow local policy, and return a new.</p>\n</blockquote>\n<p>This is  slightlydiffeent from the service Grahame was describing, where the API would be \"once called, begin a re-issuance flow in an issuer-determined fashion\".</p>",
        "id": 263228619,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638317919
    },
    {
        "content": "<p>I've done a write-up of what I'm <em>hearing</em> as the use case, to try to move this ahead...</p>\n<p><a href=\"https://github.com/smart-on-fhir/health-cards/blob/main/rfcs/001-reissuance-endpoint.md\">https://github.com/smart-on-fhir/health-cards/blob/main/rfcs/001-reissuance-endpoint.md</a></p>\n<p>Feedback welcome here or in <a href=\"https://github.com/smart-on-fhir/health-cards/discussions\">https://github.com/smart-on-fhir/health-cards/discussions</a></p>",
        "id": 263228747,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638318008
    },
    {
        "content": "<p>Hum.. why is the name of the file so big?  <code>smart-health-cards-configuration</code>? :)</p>",
        "id": 263236723,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638325094
    },
    {
        "content": "<p>I know :-)</p>",
        "id": 263236735,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638325110
    },
    {
        "content": "<p>shc-config.json?</p>",
        "id": 263236854,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638325238
    },
    {
        "content": "<p>(General structure and leaving off the .json  suffix is following the convention of openid-configuration and smart-configuration established in those published specs.)</p>",
        "id": 263236930,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638325350
    },
    {
        "content": "<p>Maybe clarify that the URL is a UI URL to be open in a WebView or directly in a browser. Some people might think this is an API call.</p>",
        "id": 263236979,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638325442
    },
    {
        "content": "<p>I am not sure if I like sending the Credential in the URL. There is some potential to steal the information from the Credential in transit, even when using a HTTPS call.</p>",
        "id": 263237270,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638325757
    },
    {
        "content": "<p>That's true for any submission protocol (in URL or otherwise), right? I do call this out in drawbacks... and I agree it's a concern</p>",
        "id": 263237338,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638325813
    },
    {
        "content": "<p>But yes, if we want to introduce an API step we could have a protocol where you POST an SHC (or an empty context) and get back an opaque URL to navigate the user to. That avoids having a SHC touch the browser at least.</p>",
        "id": 263237370,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638325894
    },
    {
        "content": "<p>Besides the man-in-the-middle HTTPS attacks and potential downgrade to HTTP, GET parameters are part of the url, and appear in the server logs, your browser history, website analytics, the page printing, an antivirus analysis of the page, etc.</p>",
        "id": 263237437,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638325953
    },
    {
        "content": "<p>Maybe POST is a must.</p>",
        "id": 263237445,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638325963
    },
    {
        "content": "<p><code>#</code> avoids query parameters and isn't submitted to the server fwiw</p>",
        "id": 263237468,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638325999
    },
    {
        "content": "<p>true</p>",
        "id": 263237588,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638326107
    },
    {
        "content": "<p>What if we encrypt the card with the public key of the issuer in such a way that only the private key can decrypt it?</p>",
        "id": 263237612,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638326140
    },
    {
        "content": "<p>Current public keys in SHC protocol are only guaranteed to work for signing, not encryption. We could introduce more keys but I don't think it's worthwhile here.</p>\n<p>I'll think on this and may update the proposal to \"POST to issuance url and get back a 303 with an opaque location header\" -- so apps can make this call, extract the location header, and open a browser context to that URL. Severs can populate this in a safe way (e.g., with opaque identifies).</p>",
        "id": 263237788,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638326309
    },
    {
        "content": "<p>Or just don't submit the card.</p>",
        "id": 263237927,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638326469
    },
    {
        "content": "<p>Let the user login with other info to re-download it.</p>",
        "id": 263237933,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638326483
    },
    {
        "content": "<p>Most sites already implement some form of login without the card anyway..</p>",
        "id": 263237942,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638326506
    },
    {
        "content": "<p>That works fine if there's a login. It doesn't work if there isn't. What's important to me is the UX of passing the card to the issuer to establish the context of which card needs re-issuing, instead of trying to figure out how to describe that in human language</p>",
        "id": 263238020,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638326584
    },
    {
        "content": "<p>There should always be a login</p>",
        "id": 263238099,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638326669
    },
    {
        "content": "<p>Otherwise the server will be spammed by all verifiers.</p>",
        "id": 263238111,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638326694
    },
    {
        "content": "<p>Maybe a SHA-256 of the card?</p>",
        "id": 263238117,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638326704
    },
    {
        "content": "<p>If the Issuer stores the card, a SHA-256 would be sufficient to look up the record.</p>",
        "id": 263238131,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638326733
    },
    {
        "content": "<p>that would work for me</p>",
        "id": 263238923,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638327675
    },
    {
        "content": "<p>there is other solutions to spamming than login</p>",
        "id": 263238928,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638327685
    },
    {
        "content": "<p>I've updated the proposal to define a submission step via POST before the interaction, to avoid the concerns about whether cards need to be submitted into a browser context. Will revert if folks don't prefer :-)</p>",
        "id": 263239595,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638328528
    },
    {
        "content": "<p>When we land the revocation protocol, we could submit an <code>rid</code> here instead of an SHC :-)</p>",
        "id": 263239601,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638328550
    },
    {
        "content": "<p>we could, and I considered proposing that, but rids do not always identify the card, only an revocation scope</p>",
        "id": 263248850,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638339277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"458846\">Vitor Pamplona</span> <a href=\"#narrow/stream/284830-smart.2Fhealth-cards/topic/Card.20Follow.20up/near/263237612\">said</a>:</p>\n<blockquote>\n<p>What if we encrypt the card with the public key of the issuer in such a way that only the private key can decrypt it?</p>\n</blockquote>\n<p>No. The use-case is where the issuer cert has been revoked.. so using it as the encryption key is clearly a NO.</p>",
        "id": 263282098,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638361908
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"458846\">@Vitor Pamplona</span> meant the current key</p>",
        "id": 263282180,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638361945
    },
    {
        "content": "<p>do we expect issuers to archive everything they have ever issued? Or do we think the design of SHC is such that they don't need to archive every card issued? I would hope the second. Not saying that they must not archive, but if the design requires archive of all issued cards then we move into needing to define functional and non-functional requirements of that archive.</p>",
        "id": 263282283,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638362019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> <a href=\"#narrow/stream/284830-smart.2Fhealth-cards/topic/Card.20Follow.20up/near/263282180\">said</a>:</p>\n<blockquote>\n<p>I think <span class=\"user-mention silent\" data-user-id=\"458846\">Vitor Pamplona</span> meant the current key</p>\n</blockquote>\n<p>how do you get the 'current key'?<br>\nNote that https (TLS) will already be negotiating the current TLS keys, and using that to support encryption of the channel. Thus you get this for free. (recognizing the MITM risk if one does not do TLS (BCP195))</p>",
        "id": 263282484,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638362121
    },
    {
        "content": "<p>current key is {issuer}/.well-known/jwks.json. If you can't get that, you can't communicate with them.</p>",
        "id": 263282525,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638362156
    },
    {
        "content": "<p>okay, but you used TLS to get that... so... Why not just use TLS for things that TLS is useful for? Why invent a message security layer that is special for us? NO</p>",
        "id": 263282651,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638362223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> mostly to avoid URL tracking issues (and thus payload decoding) that TLS doesn't solve.</p>",
        "id": 263286403,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638364050
    },
    {
        "content": "<p>so you are worried about a SHC issuer that has poor audit log management? This is such a ridiculous argument. Stop the fallacy promotion.</p>",
        "id": 263286961,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638364304
    },
    {
        "content": "<p>We have actually seen it. It's not a fallacy. Issuers of COVID credentials have been pretty bad.</p>",
        "id": 263287120,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638364364
    },
    {
        "content": "<p>But I am more concerned with those issues on the client level.</p>",
        "id": 263287149,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638364381
    },
    {
        "content": "<p>so you would trust the client to be currently holding the card, and able to properly encrypt it... but you don't trust what? We are a standards organization, we should use the standards that the specialists (security) in that domain have produced. If we don't use others proven standards, why do we think we have any creditability to produce standards that others should trust of us?<br>\nThe argument that \"we have actually seen it [poor implementations]\"... is not as helpful to your point as you might think it is.</p>",
        "id": 263288458,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638364903
    },
    {
        "content": "<p>I don't trust anything. Not the client, not the server.</p>",
        "id": 263289132,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638365202
    },
    {
        "content": "<p>If you think TLS solves everything, you clearly have never talked to a security specialist. There's a reason most hospitals use their own VPN and not rely on TLS.</p>",
        "id": 263289268,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638365276
    },
    {
        "content": "<p>Appreciate the discussion here; would love feedback on the updated proposal at <a href=\"https://github.com/smart-on-fhir/health-cards/blob/main/rfcs/001-reissuance-endpoint.md\">https://github.com/smart-on-fhir/health-cards/blob/main/rfcs/001-reissuance-endpoint.md</a> which:</p>\n<ul>\n<li>Provides zero or more complete SHCs as context</li>\n<li>Avoids putting SHCs into URLs so they're not part of browser history</li>\n<li>Avoids introducing any new keys or encryption schemes</li>\n</ul>",
        "id": 263293071,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638366912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> Looking good!</p>",
        "id": 263294444,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638367372
    },
    {
        "content": "<p>On <code>Should we also stipulate that (for context-less requests) a user can navigate directy to the issuance URL in a browser context?</code> I think the answer is an easy yes.</p>",
        "id": 263294482,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638367387
    },
    {
        "content": "<p>Given that the result will always be a Reject or Redirect to a browser interactive session.... what is the benefit of not just starting with a browser interactive session? I am not saying I have totally lost track of the value-add; but am unclear on specifically what that value is.</p>",
        "id": 263295142,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638367676
    },
    {
        "content": "<p>When the wallet submits the credential, it saves 1 screen of the interactive process (choosing which credential to renew)</p>",
        "id": 263295651,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638367881
    },
    {
        "content": "<p>but it is optional.. and the wording around that card is \"as a hint\".   -- Reiterate, just feeling like the value vs going direct to interactive session seems small.</p>",
        "id": 263295936,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638368019
    },
    {
        "content": "<p>The value is big if the issuer outputs several types of credentials</p>",
        "id": 263296062,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638368063
    },
    {
        "content": "<p>If the issuer only issues one type, then there is no need to know which credential the holder is trying to renew.</p>",
        "id": 263296115,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638368089
    },
    {
        "content": "<p>good improvement.</p>",
        "id": 263296404,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638368194
    },
    {
        "content": "<p>Should the spec say something like: Issuers should not re-pack the incoming payload and simply re-sign it. Invalid cards are invalid for a reason (leaked keys, operator errors, etc) and thus incoming credential payloads are all untrusted.</p>",
        "id": 263296515,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638368249
    },
    {
        "content": "<p>it likely helps the automation that might be initiated by a VC app. Allowing the VC app to do what it can to kickstart the workflow. right?</p>",
        "id": 263296525,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638368253
    },
    {
        "content": "<p>wouldn't the server be well positioned to figure that out better than the client?</p>",
        "id": 263296614,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638368285
    },
    {
        "content": "<blockquote>\n<p>I am not saying I have totally lost track of the value-add; but am unclear on specifically what that value is.</p>\n</blockquote>\n<p>The value is providing a specific workflow without having to submit the credential in a browser context; the credential can be shared between a mobile app and the issuer, and then the user can be safely transferred to a browser context where they don't have to supply any sensitive information in the URL</p>",
        "id": 263296677,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638368316
    },
    {
        "content": "<p>I agree. that is not clear in the text.</p>",
        "id": 263296748,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638368356
    },
    {
        "content": "<p>Not adding the credential to the URL also makes it impossible for people to share the link on their WhatsApp groups <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 263296775,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638368369
    },
    {
        "content": "<p>I fully get why it should be optional.</p>",
        "id": 263296838,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638368395
    },
    {
        "content": "<blockquote>\n<p>I agree. that is not clear in the text.</p>\n</blockquote>\n<p>That's fair, I call it out in the considerations or trade-off section but we can elevate it to the spec language.</p>\n<blockquote>\n<p>Should the spec say something like: Issuers should not re-pack the incoming payload and simply re-sign it. Invalid cards are invalid for a reason (leaked keys, operator errors, etc) and thus incoming credential payloads are all untrusted.</p>\n</blockquote>\n<p>Sure, some note to this effect would be good.</p>",
        "id": 263296927,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638368417
    },
    {
        "content": "<p>failure-mode -- service determines the card is good?</p>",
        "id": 263296938,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638368423
    },
    {
        "content": "<p>If the service thinks the card is still good, it can nevertheless honor a reissance request. I think the server should treat this as a request to issue new card (s)</p>",
        "id": 263297049,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638368481
    },
    {
        "content": "<p>But keep in mind here, the fact that this is an interactive session is our friend. The service can say to the user \"the card you supplied initially is perfectly valid, do you still want to proceed?\"</p>",
        "id": 263297088,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638368506
    },
    {
        "content": "<p>that is where I was back a day or so, but I was shouted down.</p>",
        "id": 263297236,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638368544
    },
    {
        "content": "<p>Then eventually we have caught up to you <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 263297276,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638368558
    },
    {
        "content": "<p>(seriously though, it can often be difficult to understand somebody's idea until you rediscover the reasoning for it yourself...)</p>",
        "id": 263297343,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638368587
    },
    {
        "content": "<p>more likely my spinning brain might have caught up to the context of design you all share</p>",
        "id": 263297378,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638368597
    },
    {
        "content": "<p>no problem</p>",
        "id": 263297428,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638368615
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> not to overcomplicate things, but this configuration file could be a credential on itself, signed by the public key on the same directory. Why? It makes sure that the config file was not changed without authorization (say, man in the middle attack). In order to hack the system, the attacker needs to also replace the key file, which will activate alarms at the Trust Registry level.</p>",
        "id": 263297950,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638368822
    },
    {
        "content": "<p>We could do that but in all of the scenarios I know where an attacker can replace this configuration file, the attacker could also replace the sibling file called jwks.json (which is not signed) and introduce a new public key, so I'm not sure what this accomplishes.</p>",
        "id": 263298240,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638368955
    },
    {
        "content": "<p>correct, but the key file is being tracked by the Trust Registry verfiriers use.</p>",
        "id": 263298306,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638368989
    },
    {
        "content": "<p>If the key changes, it triggers several procedures to re-trust the issuer</p>",
        "id": 263298370,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638369007
    },
    {
        "content": "<p>Trust registries could also watch the config file for changes, but it's easier for them if it's all bound to the same anchor point (the key file)</p>",
        "id": 263298494,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638369054
    },
    {
        "content": "<p>If we introduce a new configuration file, the registry can also track that.  Anyway, I think this is an interesting idea for an enhancement, but  it would be great to get some more feedback on the basics here.</p>",
        "id": 263298593,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638369101
    },
    {
        "content": "<p>Agree</p>",
        "id": 263298624,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638369116
    },
    {
        "content": "<p>It's just a common request I make to everyone :)  (everything should be a credential)</p>",
        "id": 263298802,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638369180
    },
    {
        "content": "<p>on that note <a href=\"https://datatracker.ietf.org/doc/html/rfc8414#section-2.1\">https://datatracker.ietf.org/doc/html/rfc8414#section-2.1</a>  is good precident for this general concept of signed metadata inside of a discovery file while also supplying\"plain\" values;  other techniques replace the entire file with a credential.</p>",
        "id": 263298999,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638369257
    },
    {
        "content": "<p>I am going to be adding the re-issuance endpoint to our registry and getting other standards to follow this spec.</p>",
        "id": 263299537,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638369470
    },
    {
        "content": "<p>For other specs, there might be use cases beyond invalid cards. A common one is a valid (signature is valid, keys are good), but expired health status credential. I think they can all use the same entry point.</p>",
        "id": 263300771,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638369946
    },
    {
        "content": "<p>Absolutely agree. I tried to use invalid cards as just a motivating example here.</p>",
        "id": 263302214,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638370503
    },
    {
        "content": "<p>Is there any other information in this config file?</p>",
        "id": 263304013,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371167
    },
    {
        "content": "<p>Not yet, but I'm expecting we're going to identify more use cases for discoverable configuration. There are a few candidates currently under discussion in the VCI directory which include things like informational websites, types of issue</p>",
        "id": 263304187,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638371269
    },
    {
        "content": "<p>I'd love to get the issuer's Display Name, Display Logo (Squared SVG) and Info Website for the wallet UI.</p>",
        "id": 263304203,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371275
    },
    {
        "content": "<p>Exactly that kind of stuff.</p>",
        "id": 263304217,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638371283
    },
    {
        "content": "<p>We've been so far trying to discuss these metadata items in the context of the directory and then migrate them out to this kind of configuration, so I'm glad to be getting a scaffold for that in place here.</p>",
        "id": 263304279,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638371300
    },
    {
        "content": "<p>Nice! The only problem I foresee is if those display fields are per key. then the config file might not be a good fit.</p>",
        "id": 263304451,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371382
    },
    {
        "content": "<p>Indeed. So far we have been putting any key specific information in JWKS.json, which so far has just been revocation details</p>",
        "id": 263304548,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638371408
    },
    {
        "content": "<p>Trust Registry-wise, we learned that every additional annotated information should be per key and not per issuer.</p>",
        "id": 263304759,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371490
    },
    {
        "content": "<p>Can you help me understand what you mean here? Like the issuer name, for example? The way we have defined an issuer in health cards, and issuer would have one name and multiple keys  as it rotates them over time. But I might be missing something among your lessons learned.</p>",
        "id": 263304885,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638371530
    },
    {
        "content": "<p>There's generally a reason to have multiple keys and holders generally benefit from knowing that reason.</p>",
        "id": 263305085,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371636
    },
    {
        "content": "<p>For instance, let's say a state breaks keys per county. The signer is not the state, but a given county.</p>",
        "id": 263305154,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371657
    },
    {
        "content": "<p>The state is just providing the general software infrastructure to help the counties.</p>",
        "id": 263305201,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371683
    },
    {
        "content": "<p>Other systems assign keys to different levels of confidence. Keys for doctors, keys for nurses, keys for church leaders. The payload is all the same (immunization record) but it is granted with a different levels of legal/regulatory authority</p>",
        "id": 263305345,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371753
    },
    {
        "content": "<p>Wallet and Verifier systems would love to expose those details to their users.</p>",
        "id": 263305519,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371814
    },
    {
        "content": "<p>In the Health Cards context,  We don't make any guarantees about an issuance hierarchy. So from your example either you have state-based issuance (perhaps with a national trust  that ties these together); or you have national issuance. </p>\n<p>Issueres are free to rotate keys or segregate keys as they see fit, and the abstraction barrier is such that consumers can be oblivious to this. I understand now the tension between this model and what you are describing.</p>",
        "id": 263305564,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638371820
    },
    {
        "content": "<p>I don't think you should have defined hierarchies.</p>",
        "id": 263305661,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371853
    },
    {
        "content": "<p>But you could allow them to give hints of their work per key</p>",
        "id": 263305701,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638371871
    },
    {
        "content": "<p>Understood.  But I don't think these would replace the top level issuer label, in this case; for example, a directory might only vet the top level issuer label, and any sub-issuer key-specific labels would be below the abstraction barrier. Of course, you could publish  such metadata on each key and it might be worth exploring this.  But I don't think it would obviate the need to do it at the top level, and the sort of metadata you would publish per key might be more in the realm of the hints. Anyway, probably worth starting a separate thread or proposal for this <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 263306280,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638372034
    },
    {
        "content": "<p>The EU registry, for instance is quite interesting. Some countries have just one key. Those are easy. Others give individual keys to private corps that will in turn issue credentials. The EU Gateway also does not provide any information at the registry level beyond the keys themselves. Verifiers have to manually FIND and ask those companies for the appropriate way to represent the Issuer Name in their own certificates.</p>",
        "id": 263306430,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638372099
    },
    {
        "content": "<p>Anyway, it's certainly a much bigger discussion.</p>",
        "id": 263306461,
        "sender_full_name": "Vitor Pamplona",
        "timestamp": 1638372117
    },
    {
        "content": "<p>I would be in favor of packaging up some top level metadata that support wallet UI, and would prioritize that work over key-specific metadata, but these are separate points.</p>",
        "id": 263306504,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638372124
    }
]