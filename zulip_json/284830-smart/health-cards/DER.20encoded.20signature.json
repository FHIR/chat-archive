[
    {
        "content": "<p>We've leveraged AWS KMS to provision the EC keys for JWS signing. When we try to validate using the MS Smarthealth Card Validation SDK, this is the error we receive:</p>\n<p>root@d79fd1cb1c55:/usr/src/app# node . --path /inputs/jws.smart-health-card --type jws<br>\nSMART Health Card Validation SDK v1.0.0-1</p>\n<p>JWS-compact<br>\n   │<br>\n   ├─ Warning<br>\n   │    · Issuer key endpoint does not contain a 'access-control-allow-origin' header for Cross-Origin Resource Sharing (CORS)<br>\n   │<br>\n   ├─ Error<br>\n   │    · Schema: {\"instancePath\":\"\",\"schemaPath\":\"#/pattern\",\"keyword\":\"pattern\",\"params\":{\"pattern\":\"^[a-zA-Z0-9_-]+\\\\.[a-zA-Z0-9_-]+\\\\.[a-zA-Z0-9_-]+$\"},\"message\":\"must match pattern \\\"^[a-zA-Z0-9_-]+\\\\.[a-zA-Z0-9_-]+\\\\.[a-zA-Z0-9_-]+$\\\"\"}<br>\n   │    · Can't parse JWS header as JSON.<br>\n   │<br>\n   │    · Signature appears to be in DER encoded form. Signature is expected to be 64-byte r||s concatenated form.<br>\n   │      See <a href=\"https://tools.ietf.org/html/rfc7515#appendix-A.3\">https://tools.ietf.org/html/rfc7515#appendix-A.3</a> for expected ES256 signature form.<br>\n   │<br>\n   └─ JWS.payload<br>\n         │<br>\n         └─ FhirBundle</p>\n<p>Validation completed</p>\n<p>Has anyone come across these errors seen above?</p>",
        "id": 239778038,
        "sender_full_name": "Stephen Whitney",
        "timestamp": 1621614504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"269724\">Stephen Whitney</span> <a href=\"#narrow/stream/284830-smart.2Fhealth-cards/topic/DER.20encoded.20signature/near/239778038\">said</a>:</p>\n<blockquote>\n<p>We've leveraged AWS KMS to provision the EC keys for JWS signing. Has anyone come across these errors seen above?</p>\n</blockquote>\n<p>I get the same. The cited <a href=\"https://datatracker.ietf.org/doc/html/rfc7515#appendix-A.3\">appendix 3</a> describe the proper encoding for the signature. How are you generating the JWS signature? (language, API, pseudocode?) We can help to see if that's the proper way to create it.</p>",
        "id": 239781025,
        "sender_full_name": "Christian Paquin",
        "timestamp": 1621615882
    },
    {
        "content": "<p>We're using boto3 python SDK:</p>\n<div class=\"codehilite\"><pre><span></span><code>def _set_jws(self):\n    if environ not in [\n        &quot;test&quot;,\n    ]:\n        signature = self._sign_token(self.key_id, self.message)\n        verification = self._verify_signature(self.key_id, self.message, signature)\n        signed = (\n            self.message\n\n            + b&quot;.&quot;\n            + base64.urlsafe_b64encode(signature).replace(b&quot;=&quot;, b&quot;&quot;)\n        )\n        return signed\n    else:\n        return self.message\n\ndef _sign_token(self, key_id, message):\n    signature = kms_client.sign(\n        KeyId=key_id,\n        Message=message,\n        MessageType=&quot;RAW&quot;,\n        SigningAlgorithm=&quot;ECDSA_SHA_256&quot;,\n    )\n    logger.log(msg=signature, level=cl.log_level)\n    return signature[&quot;Signature&quot;]\n</code></pre></div>",
        "id": 239782387,
        "sender_full_name": "Stephen Whitney",
        "timestamp": 1621616521
    },
    {
        "content": "<p>Looks like the <a href=\"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/kms.html#KMS.Client.sign\">boto3 sign</a> API returns a DER encoded signature:</p>\n<div class=\"codehilite\"><pre><span></span><code>When used with the ECDSA_SHA_256 , ECDSA_SHA_384 , or ECDSA_SHA_512 signing algorithms,\nthis value is a DER-encoded object as defined by ANS X9.62–2005 and RFC 3279 Section 2.2.3 .\nThis is the most commonly used signature format and is appropriate for most uses.\n</code></pre></div>\n<p>This will need to be converted to the raw <code>r</code> and <code>s</code> values expected in the JWS signature format. I'm not sure what is the best way to do this in python; I'll take a look...</p>",
        "id": 239786052,
        "sender_full_name": "Christian Paquin",
        "timestamp": 1621618215
    },
    {
        "content": "<p>This post shows the code needed to unmarshall DER into raw R and S using Go. We're going to start a chat with AWS to see if they can help us in python.</p>\n<p><a href=\"https://aws.amazon.com/blogs/security/how-to-verify-aws-kms-signatures-in-decoupled-architectures-at-scale/\">https://aws.amazon.com/blogs/security/how-to-verify-aws-kms-signatures-in-decoupled-architectures-at-scale/</a></p>",
        "id": 239790465,
        "sender_full_name": "Stephen Whitney",
        "timestamp": 1621620236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"269724\">Stephen Whitney</span> <a href=\"#narrow/stream/284830-smart.2Fhealth-cards/topic/DER.20encoded.20signature/near/239790465\">said</a>:</p>\n<blockquote>\n<p>This post shows the code needed to unmarshall DER into raw R and S using Go. We're going to start a chat with AWS to see if they can help us in python.</p>\n<p><a href=\"https://aws.amazon.com/blogs/security/how-to-verify-aws-kms-signatures-in-decoupled-architectures-at-scale/\">https://aws.amazon.com/blogs/security/how-to-verify-aws-kms-signatures-in-decoupled-architectures-at-scale/</a></p>\n</blockquote>\n<p>Yes, you'd need to do the same in python (perhaps with <a href=\"https://python-asn1.readthedocs.io/en/latest/\">this lib</a>?) The ASN.1 encoding of an ECDSA sig is fairly simple (see <a href=\"https://datatracker.ietf.org/doc/html/rfc3279#section-2.2.3\">section 2.2.3 of RFC 3279</a>):</p>\n<div class=\"codehilite\"><pre><span></span><code>Ecdsa-Sig-Value  ::=  SEQUENCE  {\n           r     INTEGER,\n           s     INTEGER  }\n</code></pre></div>",
        "id": 239799411,
        "sender_full_name": "Christian Paquin",
        "timestamp": 1621624354
    },
    {
        "content": "<p>We ran into something similar with our Ruby implementation. This GitHub PR (<a href=\"https://github.com/jpadilla/pyjwt/pull/158\">https://github.com/jpadilla/pyjwt/pull/158</a>) in <code>pyjwt</code> deals with this and has a python DER to Raw (and vice-versa) implementation thats pretty simple.</p>",
        "id": 239806120,
        "sender_full_name": "Reece Adamson",
        "timestamp": 1621627519
    },
    {
        "content": "<p>thank you <span class=\"user-mention\" data-user-id=\"197651\">@Reece Adamson</span> and <span class=\"user-mention\" data-user-id=\"385047\">@Christian Paquin</span> . I'm so close now. I just need to figure out this last hurdle:</p>\n<p>Signature is 69-bytes. Signature is expected to be 64-bytes</p>\n<p>My guess is that it has to do with this:</p>\n<p><a href=\"https://github.com/jpadilla/pyjwt/blob/e0a288017d945f8dd7da2fa13d5defb85192e38a/jwt/utils.py#L60\">https://github.com/jpadilla/pyjwt/blob/e0a288017d945f8dd7da2fa13d5defb85192e38a/jwt/utils.py#L60</a></p>\n<p>Update: It's all good. Thank you again!</p>",
        "id": 239815952,
        "sender_full_name": "Stephen Whitney",
        "timestamp": 1621632973
    }
]