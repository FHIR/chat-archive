[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> we've beed discussing the SNOMED CT canonical CodeSystem resource at <a href=\"https://confluence.ihtsdotools.org/display/FHIR/SNOMED+CT+canonical+CodeSystem+resource\" target=\"_blank\" title=\"https://confluence.ihtsdotools.org/display/FHIR/SNOMED+CT+canonical+CodeSystem+resource\">https://confluence.ihtsdotools.org/display/FHIR/SNOMED+CT+canonical+CodeSystem+resource</a>.</p>\n<p>One of the topics has been the filters, and the two filters \"expression\" and \"expressions\" came up. Firstly there was concern that these are very similar - one character different. We discussed potential name changes, conceding that the \"expression\" filter is already used a fair bit and it would be disruptive to change it.</p>\n<p>However this led to a longer discussion about any practical use of, and the intent of the \"expressions\" filter. It seems to operate more like something that should be part of an expansion profile - whether to include post coordinated content in the expansion or not, which could come from a ValueSet or a ValueSet composed in as part of its definition.</p>\n<p>We tried to find more about its intended use etc from the spec, but it tracks all the way back to early version and there's no tracker item we could find to help determine why it is there. It looks like it predates the expansion profile stuff.</p>\n<p>Can you help with its history and any suggestions on what you think its future might be?</p>\n<p>Thanks,<br>\nDion</p>",
        "id": 153964238,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527043558
    },
    {
        "content": "<p>I don't know how much it's used. But the idea for me is that very few people - experts only - will get into something like an expression constraint, or ECL, or whatever. But almost everybody is going to need to say 'I can't deal with expressions, don't give them to me'</p>",
        "id": 153964239,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527043722
    },
    {
        "content": "<p>with regard to expansion profile Vocab decided in Cologne that this resource is going to be deleted - we're just going to take parameters. But I think that that this is <em>value set</em> thing, not a parameter - whether or not you wnat post-coordinated expressions is pretty fundamental to the way the value set is defined</p>",
        "id": 153964242,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527043808
    },
    {
        "content": "<p>Thanks, good to know about expansion profiles.</p>\n<p>There's a couple of things at play here...</p>\n<p>First the expression filter which allows you to define the content of a ValueSet using ECL - very, very useful. ValueSets can be defined using this that can then be combined more simply by other ValueSets using include and exclude which is more approachable. I don't think there's an issue here.</p>\n<p>Second is whether a ValueSet contains post-coordinated expressions (i.e. not constraints which define a set, but post coordinated expressions each defining a concept). That can be declarative, or part of the expansion request at run time - i.e. \"this ValueSet does/doesn't contain post-coordinated expressions\" versus \"expand this value set and do/don't give be post-coordinated expressions in the result if they are present in the expansion\".</p>\n<p>So with regard to this second point, which is really the issue, I don't think the current \"expressions\" CodeSystem filter achieves the aim. Depending upon which case we're trying to enable you could have</p>\n<ul>\n<li>a property of a ValueSet that indicates whether it does or doesn't contain post-coordinated expressions...you'd then expect its expansion to never contain them, but it does raise other validation questions. For example if ValueSet A declares post-coordination=false but it includes ValueSet B that contains post-coordination is that an error, or do those expressions just get filtered (perhaps silently?) at runtime. More rules would be required to define this behaviour and what is and isn't valid to do for predictability.</li>\n<li>a parameter for a ValueSet expansion which could optionally include or omit any pos-coordinated expressions...although excluding them if they've been designed into the content may not be a good thing and using that parameter might need to be cautioned with some forethought required</li>\n</ul>\n<p>Are you thinking this is a declarative statement about the ValueSet (former) rather than parameter (latter), or both? Did you have thoughts on how this might work from a validation perspective? That's something we can also discuss further this week.</p>",
        "id": 153964254,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527045962
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> and <span class=\"user-mention\" data-user-id=\"191376\">@Jim Steel</span>  might also have opinions and might not have spotted this yet...</p>",
        "id": 153964255,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527046261
    },
    {
        "content": "<p>As I understand it, <code>expressions</code> is a <em>filter</em>, not a declarative statement at the ValueSet-level about the CLD; it is saying that this <code>include</code> (or <code>exclude</code>) allows (or not) post coordinated codes.</p>\n<p>This is orthogonal to the client saying - 'don't give me any post coordinated things in the expansion'</p>\n<p>I expect there's also another dimension which comes from the <code>TerminologyCapabilities</code> side where a server can say whether it even supports post coordination for a given <code>CodeSystem</code></p>",
        "id": 153964257,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527047743
    },
    {
        "content": "<p>There's a parameter on valueset/$epand: excludePostCoordinated - that's Dion's second.</p>",
        "id": 153964278,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527057672
    },
    {
        "content": "<p>yes, it's a filter, not a declarative statement</p>",
        "id": 153964279,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527057684
    },
    {
        "content": "<p>Michael's 3rd is TerminologyCapabilities.codeSystem.version.compositional</p>",
        "id": 153964281,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527057806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> or <span class=\"user-mention\" data-user-id=\"191337\">@Dion McMurtrie</span> do you have an example of a ValueSet containing post coordinated SCT expressions that you'd be willing to share?  It would be extra helpful if this only contained concepts from the International Edition.</p>",
        "id": 153964465,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1527107383
    },
    {
        "content": "<p>Not an in-the-wild / real-world one, no.</p>",
        "id": 153964501,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527117424
    },
    {
        "content": "<p>No, I don't have a real world example either.</p>\n<p>So we have</p>\n<ul>\n<li>$expand: excludePostCoordinated for runtime expansion filtering of post coordinated expressions</li>\n<li>TerminologyCapabilities.codeSystem.version.compositional to declare a server's support for post coordination for a code system</li>\n</ul>\n<p>From the discussion above we're missing (if we actually need it at all?) the ability for a ValueSet definition to declaratively say it doesn't (or does) contain post coordination. I'm not sure that the \"expressions\" filter is the right tool for that if we did decide we want to be able to say that, or if it is how it would work.</p>\n<p>What is the intended use of the \"expressions\" filter? Is there an example of how it might be used?</p>",
        "id": 153964503,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527123781
    },
    {
        "content": "<p>Firstly, I'm not sure that a ValueSet needs to be able to say 'I do/don't contain post coordinated expressions'</p>",
        "id": 153964507,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527126370
    },
    {
        "content": "<p>No, I'm not sure it does either, but I'm keen to hear if anyone can come up with a use case for that.</p>",
        "id": 153964508,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527126429
    },
    {
        "content": "<p>Regarding examples for <code>expressions</code>, one might consider:</p>\n<div class=\"codehilite\"><pre><span></span>    <span class=\"s2\">&quot;include&quot;</span><span class=\"err\">:</span> <span class=\"p\">[</span>\n      <span class=\"p\">{</span>\n        <span class=\"nt\">&quot;filter&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n          <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;property&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;expressions&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;op&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;=&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;false&quot;</span>\n          <span class=\"p\">}</span>\n        <span class=\"p\">],</span>\n        <span class=\"nt\">&quot;valueSet&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n          <span class=\"s2\">&quot;http://snomed.info/sct?fhir_vs&quot;</span>\n        <span class=\"p\">]</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">]</span>\n</pre></div>\n\n\n<p>which would mean all pre-coordinated SNOMED codes</p>\n<p>But equally, that <code>valueSet</code> inclusion could be some other <code>ValueSet</code> instance that explicitly lists some pre- and post-coordinated codes</p>",
        "id": 153964509,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527126553
    },
    {
        "content": "<p>(It's actually a way of expressing excludePostCoordinated via a wrapper-ValueSet)</p>",
        "id": 153964510,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527126599
    },
    {
        "content": "<p>A usage scenario might be a search like <code>/Condition?code:in=http://example.com/myPrimitiveCodesValueSet</code> which would only find Conditions where the code was not post-coordinated.  (I'm not sure why you'd want t do this)</p>",
        "id": 153964511,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527126883
    },
    {
        "content": "<p>and here's a more realistic definition for <code>http://example.com/myPrimitiveCodesValueSet</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"s2\">&quot;include&quot;</span><span class=\"err\">:</span> <span class=\"p\">[</span>\n      <span class=\"p\">{</span>\n        <span class=\"nt\">&quot;filter&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n          <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;property&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;expressions&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;op&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;=&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;false&quot;</span>\n          <span class=\"p\">},</span>\n          <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;property&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;concept&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;op&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;is-a&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;1234567&quot;</span>\n          <span class=\"p\">}</span>\n        <span class=\"p\">],</span>\n        <span class=\"nt\">&quot;system&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;http://snomed.info/sct&quot;</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">]</span>\n</pre></div>",
        "id": 153964512,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527126941
    },
    {
        "content": "<p>the main use I thought it would have would be <br>\n- include all clinical findings <br>\n- but only pre-coordinated ones</p>",
        "id": 153964515,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527130902
    },
    {
        "content": "<p>but it would make perfect sense to say <br>\n+ include all pre-coordinated liver disease concepts<br>\n+ these specific 2 post-coordinated codes <br>\n- 1 few specific pre-coordinated codes</p>",
        "id": 153964516,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527131007
    },
    {
        "content": "<blockquote>\n<p>and here's a more realistic definition for <code>http://example.com/myPrimitiveCodesValueSet</code>:</p>\n</blockquote>\n<p>But isn't the expressions=false redundant in that definition? By definition SNOMED CT releases contain only precoordinated concepts, only instance data would contain post coordinated expressions, so if I expanded that definition I'd get no post coordinated expressions. I can only see  expressions=false suppressing expressions that come from the inclusion of other ValueSet's content that contain explicitly enumerated expressions.</p>\n<p>Aside from expansion...in the code:in example, the server would need to subsumption test all instances of Condition.code to be subtypes of 1234567 and be the most trivial expression - a single concept id - is that right? That's probably going to be much more expensive than expanding the ValueSet and joining it to the instance data, but expressions would never be properly supported that way. Is that your expectation of what servers do (or should do)?</p>\n<p>But I guess this is the way to find all Conditions where the code is not precoordinated if that's a requirement, although I'm not clear why you'd want to do that?</p>",
        "id": 153964519,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527132095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> can't you define a ValueSet to include all pre-coordinated liver disease concepts plus a list of specific post-coordinated expressions minus a fee specific pre-coordinated codes entirely without using \"expressions=false\"?</p>",
        "id": 153964520,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527132197
    },
    {
        "content": "<p>If you look at what <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> 's server does when you try to expand <code>http://snomed.info/sct?fhir_vs</code> you'll see it refuses because it is technically unbounded - all codes in SCT includes all post coordinated codes.</p>",
        "id": 153964523,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527132450
    },
    {
        "content": "<p>Right...so expansion of all codes in SNOMED CT includes all possible valid post coordinated expressions, which is very big (but finite). Taking that to its logical extension...what if I expand </p>\n<div class=\"codehilite\"><pre><span></span> <span class=\"s2\">&quot;filter&quot;</span><span class=\"err\">:</span> <span class=\"p\">[</span>\n          <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;property&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;concept&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;op&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;is-a&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;1234567&quot;</span>\n          <span class=\"p\">}</span>\n<span class=\"p\">]</span>\n</pre></div>\n\n\n<p>Does that also implicitly contain (and should return) all possible valid post coordinated expressions that evaluate as sub types of 1234567? That doesn't seem very practical.</p>",
        "id": 153964524,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527133538
    },
    {
        "content": "<p>Has <em>anyone</em> seen a post coordinated expression returned in response to a FHIR ValueSet $expand request and, if so, are they willing to share the request URL?</p>",
        "id": 153964526,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1527136524
    },
    {
        "content": "<p>my server will expand post-coordinateds if specifically defined by won't do as an expansion of a subsumption</p>",
        "id": 153964528,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527137903
    },
    {
        "content": "<p>but to be clear: all clinical findings includes everything, not just pre-coordinated codes</p>",
        "id": 153964529,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527137998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191337\">@Dion McMurtrie</span> \" can't you define a ValueSet to include all pre-coordinated liver disease concepts plus a list of specific post-coordinated expressions minus a fee specific pre-coordinated codes entirely without using \"expressions=false\"?\" It's not obvious to me how without using ECL. And that alone would be justification for having it</p>",
        "id": 153964530,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527138045
    },
    {
        "content": "<blockquote>\n<p>but to be clear: all clinical findings includes everything, not just pre-coordinated codes</p>\n</blockquote>\n<p>agreed, but this begs the question as to why your server returns the 'too costly' response for the 'all of snomed' ValueSet, but not for a <code>?fhir_vs=isa/[sctid]</code> style ValueSet</p>",
        "id": 153964741,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527202387
    },
    {
        "content": "<p>because my implementation is inconsistent</p>",
        "id": 153964742,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527202559
    },
    {
        "content": "<p>and wrong in the second case</p>",
        "id": 153964743,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527202564
    },
    {
        "content": "<p>but pragmatic &amp; useful</p>",
        "id": 153964747,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527202896
    },
    {
        "content": "<p>don't agree. I should return too costly unless the client specifically says that it's ok to return a subset</p>",
        "id": 153964748,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527202953
    },
    {
        "content": "<p>or unless we redefine the value set template</p>",
        "id": 153964749,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527202967
    },
    {
        "content": "<p>I don't think we should redefine the template</p>",
        "id": 153964750,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527203182
    },
    {
        "content": "<p>I agree</p>",
        "id": 153964751,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527203227
    },
    {
        "content": "<p>I wonder how many systems would break if I \"fixed\" our server to enumerate the infinite set of codes (using paging)</p>",
        "id": 153964752,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527203304
    },
    {
        "content": "<p>it sounds like fun watching you try</p>",
        "id": 153964753,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527203337
    },
    {
        "content": "<p>It would be enough to trivially enumerate the combinatorial explosion of |situation with explicit content| and &gt;= 1 associated finding</p>",
        "id": 153964754,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527203868
    },
    {
        "content": "<p>so I my question</p>\n<blockquote>\n<p>can't you define a ValueSet to include all pre-coordinated liver disease concepts plus a list of specific post-coordinated expressions minus a fee specific pre-coordinated codes entirely without using \"expressions=false\"?</p>\n</blockquote>\n<p>I was referring to $expand, which probably hits at my confusion with this issue, compared to code:in</p>\n<p>So my preconception was that if you're expanding a ValueSet against a SNOMED CT edition, then the expansion results contains only matching pre-coordinated concepts defined in that edition of SNOMED CT. Therefore saying \"expressions=false\" or \"expressions=true\" makes no difference to $expand, because the underlying code system doesn't statically define any expressions, unlike instance data which might.</p>\n<p>I think there is a practical problem having \"expressions=true\" for $expand against something like a SNOMED CT edition (or UCUM too) and expecting that to contain not only every precoordinated code but every possible post-coordinated expression. I think technically it is a finite set, but it is pretty big, expensive to calculate and not very useful in the response of $expand. I think a response of too costly is fair enough in that context.</p>\n<p>So for me the big question is should (if a server actually calculates it) a $expand of /ValueSet/$expand?url=http://snomed.info/sct?fhir_vs return only precoordinated things or all possible post-coordinated expressions as well? Ontoserver says this is too costly, but if a count=10 is added it returns a set with a total of 561,387 from SCT-AU, which is going to be the former, not the latter. I think that's sensible.</p>\n<p>This begs the question, what is the default for \"expressions\" if no value is given? False I assume?</p>\n<p>Perhaps that makes it OK...except that when doing code:in you more than likely want to find any instance data where the code _or expression_ matches the ValueSet definition.</p>\n<p>Therefore the definition of the ValueSet that is useful most of the time in code:in isn't something that would lend itself to $expand. And if I'm right about the default value of \"expressions\" being false if not stated, most of the definitions for ValueSets for SNOMED CT floating around probably won't give people what they expect for code:in if instance data exists including expressions. If I'm wrong and the default is expressions=true then most of the server's expansion results are wrong at the moment, and a ValueSet defined and useful for code:in will be problematic for $expand.</p>\n<p>Note this doesn't just affect SNOMED CT but code systems with grammars - what about UCUM for example?</p>\n<p>My head hurts...what's the default for \"expressions\" if not stated and how is the difference between $expand and code:in use of a ValueSet definition reconciled with regard to the expressions filter and its behaviour?</p>",
        "id": 153965069,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527468407
    },
    {
        "content": "<p>ucum is a bit different because most people just support a set of known expressions, but everyone actually supports expressions because you have no choice.</p>",
        "id": 153965077,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527485459
    },
    {
        "content": "<p>the default value for expressions is true</p>",
        "id": 153965079,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527485489
    },
    {
        "content": "<p>so...that means that Ontoserver's expansion of SNOMED CT value sets is currently wrong, i.e. <a href=\"http://ontoserver.csiro.au/stu3-latest/ValueSet/$expand?url=http://snomed.info/sct?fhir_vs=isa/243796009\" target=\"_blank\" title=\"http://ontoserver.csiro.au/stu3-latest/ValueSet/$expand?url=http://snomed.info/sct?fhir_vs=isa/243796009\">http://ontoserver.csiro.au/stu3-latest/ValueSet/$expand?url=http://snomed.info/sct?fhir_vs=isa/243796009</a> should actually return all possible post-coordinated expressions as well as all the precoordinated content as it currently does?</p>",
        "id": 153965087,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527485919
    },
    {
        "content": "<p>I could argue that we just support a set of known expressions</p>",
        "id": 153965088,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527486031
    },
    {
        "content": "<p>i.e. just the precoordinated ones?</p>\n<p>I guess from an interoperability perspective this is a bit of an issue if server behaviour would vary that wildly</p>",
        "id": 153965089,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527486102
    },
    {
        "content": "<p>Fortunately(?), at the moment, most servers support the same set of known expressions.</p>",
        "id": 153965090,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527486255
    },
    {
        "content": "<p>i.e. none? (aka the precoordinated ones)?</p>",
        "id": 153965091,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1527486284
    },
    {
        "content": "<p>Yes, the pre-coordinated ones :)</p>",
        "id": 153965108,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527504677
    },
    {
        "content": "<p>For clarity - I'm drawing an analogy here between servers supporting a 'known set of codes' in the infinite code system ucum, and the corresponding behaviour of supporting pre-coordinated concepts in snomed</p>",
        "id": 153965349,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527628998
    },
    {
        "content": "<p>servers can do that, and they should declare that they do this in their terminology capabilities</p>",
        "id": 153965353,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527629114
    },
    {
        "content": "<p>More broadly, I think the key goals here are for interoperability of different terminology server implementations (so clients can have reasonable expectations), and usefulness of behaviour (if it's not useful, then why care).</p>\n<p>So this leads me to the questions:<br>\n1. is it useful for a server to return TooCostly for expansion of <a href=\"http://snomed.info/sct?fhir_vs\" target=\"_blank\" title=\"http://snomed.info/sct?fhir_vs\">http://snomed.info/sct?fhir_vs</a> <br>\n2. is it useful for a server to return TooCostly for expansion of ValueSets like  <a href=\"http://snomed.info/sct?fhir_vs=isa/1234567\" target=\"_blank\" title=\"http://snomed.info/sct?fhir_vs=isa/1234567\">http://snomed.info/sct?fhir_vs=isa/1234567</a></p>",
        "id": 153965354,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527629204
    },
    {
        "content": "<p>we say that if the server is not going to return the entire expansion, then it should return an error unless the client has advised that it's happy to get a partial expansion in the return. and then, when the server does return a partial, it must say that it's partial</p>",
        "id": 153965359,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527629330
    },
    {
        "content": "<p>what we haven't said is whether the same rule applies for compositional grammars if the server declares that it does not support compositional grammar</p>",
        "id": 153965362,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527629380
    },
    {
        "content": "<p>which doesn't answer the question as to whether this is useful behaviour when the partial-ness is due to composition grammars</p>",
        "id": 153965363,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527629424
    },
    {
        "content": "<p>well, things that are useful are sometimes unexpected. which means that different people have different views about it's usefulness</p>",
        "id": 153965364,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527629461
    },
    {
        "content": "<p>(aside: \"support compositional grammar\" is not a binary state)</p>",
        "id": 153965366,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527629469
    },
    {
        "content": "<p>no it's not.</p>",
        "id": 153965367,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527629475
    },
    {
        "content": "<p>but we've simplified it to that....</p>",
        "id": 153965368,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527629482
    },
    {
        "content": "<p>SNOMED ECL has the notion of a \"substrate\" - the context in which the ECL is evaluated. For a simple $expand, this would default to the pre-coordinated codes. But for a $validate-code or code:in search, it would (hopefully) include any actual post-coordinated expressions.</p>",
        "id": 153965373,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527629658
    },
    {
        "content": "<p>Isn't this a statement of the rule for compositional grammars?</p>\n<blockquote>\n<p>If the value set itself is unbounded due to the inclusion of post-coordinated value sets (e.g. SNOMED CT, UCUM), then the extension <a href=\"http://hl7.org/fhir/StructureDefinition/valueset-unclosed\" target=\"_blank\" title=\"http://hl7.org/fhir/StructureDefinition/valueset-unclosed\">http://hl7.org/fhir/StructureDefinition/valueset-unclosed</a> can be used to indicate that the expansion is incomplete</p>\n</blockquote>",
        "id": 153965376,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527629827
    },
    {
        "content": "<p>Another wrinkle/corner case - for code systems that support subsumption where there may be equivalent codes (and in the SNOMED case, this includes post-coordination, but there may be code systems with equivalent codes that don't have grammars).  If a ValueSet includes one of these codes, should the expansion include the equivalent codes?</p>",
        "id": 153965432,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527643134
    },
    {
        "content": "<p>Catching up on this and need some help figuring out the scope and boundries of the discussion: Are you all in agreement that a value set that has at least one concept drawn from a code system that is based on compositional grammar is in fact defining all potential equivalent post-coordinated expressions that could be made using the grammar, for every concept identified by the base CLD? If that is not where you are, then what are you in agreement on? </p>\n<p>You might sense I don't think that should be the approach we take. In fact, I would say that a value set must explicitly define the exact grammatic expression that can be used to create post-coordinated expressions that are to be in the expansion. If you don't expressly include an expression as part of the CLD, then you can not get post-coordinated expansion members in the expansion. </p>\n<p>Keep in mind the infamous 80% rule here...</p>",
        "id": 153965550,
        "sender_full_name": "Robert McClure",
        "timestamp": 1527688556
    },
    {
        "content": "<p>it depends how the value set is defined. If the value set is defined by enumerating codes, then this is not a discussion.</p>",
        "id": 153965558,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527688720
    },
    {
        "content": "<p>but if the value set set says 'all clinical findings' then any post-coordinated expression that is a clinical finding is in the value set</p>",
        "id": 153965560,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527688750
    },
    {
        "content": "<p>I think we need use carefully selected words here. what do you mean by \"says all clinical findings\"? Do you mean the CLD says (404684003 = Clinical finding):</p>\n<div class=\"codehilite\"><pre><span></span>&lt;compose&gt;\n        &lt;include&gt;\n            &lt;system value=&quot;http://snomed.info/sct&quot;/&gt;\n           &lt;filter&gt;\n             &lt;property value=&quot;concept&quot;/&gt;\n             &lt;op value=&quot;is-a&quot;/&gt;\n             &lt;value value=&quot;404684003&quot;/&gt;\n          &lt;/filter&gt;\n        &lt;/include&gt;\n&lt;/compose&gt;\n</pre></div>\n\n\n<p>because if that is what you all are agreeing to, I am not in agreement and am <strong>very</strong> concerned with this assumption for basic functionality.</p>",
        "id": 153965619,
        "sender_full_name": "Robert McClure",
        "timestamp": 1527690014
    },
    {
        "content": "<p>Well, part of the issue is that \"is in the value set\" in this case isn't entirely clear and has some context dependency.   Some of the related discussion on the SNOMED on FHIR call yesterday (and maybe also elsewhere?) was that there likely needs to be different expectations depending on, in particular, if we are talking about the behavior for $expand vs. $validate-code.  The discussions seemed to be leaning toward for $expand to only return the <strong>published</strong> codes or expressions (assuming that sometimes expressions may be published), so in that context only those officially published artifacts would be considered to be \"in\" the value set, but for $validate-code the desired behavior would be to recognize any valid post-coordinated expression (user created, typically) that logically meets the criteria of the definition (VSD) as being valid and therefore \"in\" the value set.  I think that may be a useful approach, and we need to consider it in our discussion and any decisions that we make.  <span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span>, I'm not sure if or how that affects your disagreement or agreement with what Grahame said?</p>",
        "id": 153965716,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1527701873
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span> , are you claiming that post coordinated expressions cannot have an is-a relationship with clinical finding? (I hope not)</p>",
        "id": 153965745,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527709959
    },
    {
        "content": "<p>I would still like to see actual examples of a SNOMED CT Reference Set, or FHIR Value Set, containing post coordinated expressions. From an implementation perspective, until it's clear how this content is actually requested by, and delivered to, clients, post coordination remains one of those things that people talk about, but nobody actually does!</p>",
        "id": 153965760,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1527710744
    },
    {
        "content": "<p>we have examples,  mostly involving laterality</p>",
        "id": 153965772,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527711875
    },
    {
        "content": "<p>Where - any links?</p>",
        "id": 153965803,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1527713974
    },
    {
        "content": "<p>I don't think they're public... unless the agency wants to publish any - I just don't think they've moved past concept stage on this (<span class=\"user-mention\" data-user-id=\"191337\">@Dion McMurtrie</span> - there's some implicit value sets like this in the CDA specs, but we haven't turned them into real fhir value sets)</p>",
        "id": 153965807,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527714721
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> No, I'm not saying that at all. What I'm saying is something aligned with what <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> is referring to: I.E.: the set of members in a value set expansion should be \"well defined\" and I agree with the proposal Rob outlines for $expand. If the approach is to have a different behavior for $validate-code then I find that interesting but worry that it will mean lots of variation across FHIR servers because very few would ever try to validate any possible expression that \"belongs in the value set.\" In particular if we go beyond testing for <strong>exact expression equivalence</strong> - by this I <strong>do not</strong> mean subsumption/is-a - when testing an expression as a member of a value set, I have real concerns. This will muddy the water with what is actually a member of the value set, I.E.; the expansion set. Rob - was the discussion about $validate-code interested in testing for subsumption, or for testing <em>equivalence</em>? I'm fine with it supporting the latter including expressions. I'm <em>not</em> fine with the former. That should be a different operation, #subsume?</p>",
        "id": 153965828,
        "sender_full_name": "Robert McClure",
        "timestamp": 1527718543
    },
    {
        "content": "<p>I think that's all confused. If the definition of a value set is \"all concepts that have an is-a relationship with X\", then the membership of the set is is \"all concepts that have an is-a relationship with X' and the correct expansion is all those concepts</p>",
        "id": 153965952,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527719250
    },
    {
        "content": "<p>I don't see the equivalence issue has to do with this?</p>",
        "id": 153965953,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527719272
    },
    {
        "content": "<p>but all this is why there's a filter for snomed to say 'no expressions', because expressions are difficult and not well supported, and if you mean 'no expressions' you should just say so, and we could stop circling on this</p>",
        "id": 153965954,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527719329
    },
    {
        "content": "<p>Yes, I was just getting ready to say something similar.  Most of the time with intensional definitions we will be dealing with subsumption.  And some systems can or will be able to support that with expressions.</p>",
        "id": 153965961,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1527719638
    },
    {
        "content": "<p>Looking at Section 4.2.1.0.7  of the spec \"SNOMED CT Filters\" <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span>, just to be 100% clear, are you referring to intensional definitions that are expression constraints (4.2.1.0.7.3) in addition to those that are <em>simple</em> is-a operations (4.2.1.0.7.1)?</p>",
        "id": 153965969,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1527720669
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> are you saying that for a <code>ValueSet</code>, <code>urn:vs</code>, that is defined as including the specific code <code>74400008 |Appendicitis|</code>, then a search for <code>/Condition?code:in=urn:vs</code> and a <code>Condition</code> resource that has <code>code</code> = <code>64572001:{116676008=23583003,363698007=66754008</code> it would not be a match?  i.e., <code>:in</code> semantics is about lexical code matching and not code equivalence? (This seems to be what <span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span> is advocating if I understand correctly.)</p>",
        "id": 153965994,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527724889
    },
    {
        "content": "<p>if the definition of the code system is based on subsumption testing, then the test should be based on subsumption so that should be a match</p>",
        "id": 153966030,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527753128
    },
    {
        "content": "<p>that's my personal opinion. Unless the value set says that it doesn't include post-coordinates.</p>",
        "id": 153966031,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527753143
    },
    {
        "content": "<p>phew - I was expecting it should be a match</p>",
        "id": 153966041,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527754217
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Let's make sure we are talking about like things. To be sure, you understand that in compositional code systems there is a difference between expression equivalence and subsumption, right? A value set CLD is defining a query to find all the concepts in the namespace that <strong>are equivalent</strong> to the expression in the CLD. Set aside the idea of a CLD using subsumption, that is secondary to the point I'm making because it's simply a (very) special case of graph traversal that includes transitive closure as a way of defining \"equivalence\" (you might think that's a stretch but let's just assume it's one way of saying this.)  So, for a CLD that does not use subsumption, <strong>and</strong> the value set \"supports the inclusion of expressions as members in the expansion\" we would say that any concept with a normal form that <em>is equivalent</em> to the expression in the CLD, should be a member of the expansion (ie, is in the value set.) This is complicated by the structure of the CLD, but one way to think of it is find all the precoordinated concepts, transform them to normal form, then any expression that can also be transformed to a normal form you already have, is also a member. If you add into the mix a CLD that includes subsumption, then you would first define the subsumption root into normal form, then include all concepts that have an equivalent normal form <strong>or one that is subsumed</strong> as members. <strong>BUT</strong> remember that SNOMED CT (not sure how this plays out in UCUM) is not <em>well formed</em> because there are many primatives that screw with using normal form as the only source for determining concept \"inclusion\" so you'd really have to go get all the subsumed precoordinated concepts and do this normal form comparison for each one. At least that is my understanding - <span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span>  am I not understanding how this would work?</p>",
        "id": 153966087,
        "sender_full_name": "Robert McClure",
        "timestamp": 1527781549
    },
    {
        "content": "<p>I think it depends how it's defined. if the definition is by enumeration, then equivalent expressions would not be in the value set, just like aliases would not be in the value set</p>",
        "id": 153966115,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527798908
    },
    {
        "content": "<p>if the definition is 'all codes = to this code' then they would be in the value set</p>",
        "id": 153966116,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527798932
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> the catch for me here is the (apparently) subtle differences between the semantics of <code>$validate-code(code,valueset)</code>, is <code>code</code> a member of <code>$expand(valueset)</code>, and the search <code>code:in=valueset</code> (for code systems supporting composition or other aliasing that allows for code equivalence).</p>",
        "id": 153966147,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527805115
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span> for me, <em>equivalent</em> codes are any codes <code>A</code> and <code>B</code> such that the subsume each other.  Converting to normal form works for some kinds of subsumption semantics, but not all; it is a form of structural subsumption. It used to be sufficient for SNOMED, but is no longer a sufficient mechanism.</p>",
        "id": 153966152,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527805358
    },
    {
        "content": "<p>Also, I don't understand your claims about SNOMED being not well-formed.</p>",
        "id": 153966153,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527805392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> To be clear, you are saying <code>A</code> subsumes <code>B</code> <strong><em>AND</em></strong> <code>B</code> subsumes <code>A</code> == Equivalent. You <strong><em>are also</em></strong> saying that if  <code>A</code> subsumes <code>B</code> <strong><em>AND NOT</em></strong> <code>B</code> subsumes <code>A</code>, meaning <code>B</code> is a descendant of <code>A</code>, they are <strong><em>NOT equivalent</em></strong>. Correct?</p>",
        "id": 153966168,
        "sender_full_name": "Robert McClure",
        "timestamp": 1527805988
    },
    {
        "content": "<p>Yes for the first case.  The second case may depend on whether you have open or closed world semantics in effect.  That is, you may know that <code>A</code> subsumes <code>B</code>and also not be able to infer that <code>B</code> subsumes <code>A</code>, but that's not the same as knowing <em>NOT</em> <code>B</code> subsumes <code>A</code>.  That is, just because you can't prove something doesn't make it false.  So, all you can conclude is that you don't know the equivalence status of <code>A</code> and <code>B</code>.  Of course, the effect is then the same.</p>",
        "id": 153966187,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527807865
    },
    {
        "content": "<p>Are there any equivalent pre-coordinated concepts in the International Edition of SNOMED CT?  In the generated transitive closure table, I don't see any instances where one concept is both the subtype and supertype of another concept.</p>",
        "id": 153966261,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1527816165
    },
    {
        "content": "<p>SNOMED International has an editorial rule that this will never be the case (for active concepts).  If it happens, then they retire one concept and add an entry in an historical-association map.</p>",
        "id": 153966262,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527816268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> My point was to clarify where it is <strong>provable</strong> that <code>B</code> is subsumed by <code>A</code>, as is true for all the current hierarchies in published SCT. This get's back to the original $expand and what concepts are members. In re-reading I may have mis-stated my position. I would agree that if the CLD has an \"is-a\" in the compose, then any concept that is subsumed by that concept is in the expansion and the only way to not have to deal with expressions right now is to set <code>excludePostCoordinated</code> as <code>T</code> in the $expand operation.  Seems to me we might want to add another element in Compose that is the same thing (default to T if that is possible) so that default behaviors would be tractable. Does that make sense?</p>\n<p>My concern in this discussion is that we agree that only by including  transitive closure requirement inside the compose (<code>op value=\"is-a\"/</code> or similar) can subsumed expressions be included within the expand. All other expressions will be <strong>exactly equivalent to a defined value set member using the A&gt;B and B&gt;A test.</strong></p>",
        "id": 153966586,
        "sender_full_name": "Robert McClure",
        "timestamp": 1527972127
    },
    {
        "content": "<p>Actually, we already have such a control in compose, and we are discussing it's use</p>",
        "id": 153966588,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527973251
    },
    {
        "content": "<p>What control? I don't see it in the spec.</p>",
        "id": 153966814,
        "sender_full_name": "Robert McClure",
        "timestamp": 1528155378
    },
    {
        "content": "<p><a href=\"http://build.fhir.org/snomedct.html#4.2.1.0.7.4\" target=\"_blank\" title=\"http://build.fhir.org/snomedct.html#4.2.1.0.7.4\">http://build.fhir.org/snomedct.html#4.2.1.0.7.4</a></p>",
        "id": 153966815,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528155498
    },
    {
        "content": "<p>Ok, yes, I've gotten lost as we have wandered a bit in this discussion and I was lost: \"Expressions\" is available for SCT in compose. So I assume that if this is not included in the compose, then the value set MUST generate post-coordinated expressions in the $expand? I have to admit, making \"Expressions\" a <strong>filter</strong> is a bit weird because it normally would apply for the entire compose but that would not be true of other filters would it?</p>",
        "id": 153967152,
        "sender_full_name": "Robert McClure",
        "timestamp": 1528229228
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span> - are you referring to SCT expressions or expression constraints?  From a practical perspective, I'm still trying to ascertain where an implementer might find post-coordinated expressions. So far, no one has been able to show me an instance of a SNOMED CT Reference Set or a FHIR Value Set that contains post-coordinated expressions.</p>",
        "id": 153967160,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528230575
    },
    {
        "content": "<p>I agree with what I think <span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span> is questioning regarding how we understand and use the \"expressions\" filter and what it means if it is or isn't present and whether its value is true or false within one or more instances of 'include' or 'exclude' in ValueSet.compose.  I expect we have a fair bit more work to do to understand and explain it (among ourselves and to others).</p>",
        "id": 153967196,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528239352
    },
    {
        "content": "<p>Which SCT filter is being discussed here -  4.2.1.0.7.3 By SNOMED Expression Constraint  (property name =\"constraint\") and/or 4.2.1.0.7.4 By whether post-coordination is allowed (property name = \"expressions\")?</p>",
        "id": 153967205,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528241023
    },
    {
        "content": "<p>I was referring to 4.2.1.0.7.4</p>",
        "id": 153967207,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528242612
    },
    {
        "content": "<p>you'd mix filters. e.g. this value set includes (clinical findings + expressions = true), then that includes post-coordinated expression as well as pre-coordinated ones. Where as (clinical findings + expressions = false) means that post-coordinated expressions are not allowed.</p>",
        "id": 153967223,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528254585
    },
    {
        "content": "<p><a href=\"http://build.fhir.org/snomedct-usage.html\" target=\"_blank\" title=\"http://build.fhir.org/snomedct-usage.html\">http://build.fhir.org/snomedct-usage.html</a> - there's no post-coordinated value sets. the Australian CDA specs have one for laterality</p>",
        "id": 153967224,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528254679
    },
    {
        "content": "<p>Which CDA spec is that?</p>",
        "id": 153967273,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528266667
    },
    {
        "content": "<p>discharge summary? Note that it doesn't feature in the value set in the CDA framework  but it would in the FHIR equivalent</p>",
        "id": 153967275,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528267738
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191364\">@Peter Jordan</span> Is this the sort of thing you want?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span>\n  <span class=\"nt\">&quot;resourceType&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;ValueSet&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;url&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;urn:postcoordination-test&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;version&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;0.0.1&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;name&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;ValueSet with post coordination&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;status&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;draft&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;compose&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">&quot;include&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n      <span class=\"p\">{</span>\n        <span class=\"nt\">&quot;system&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;http://snomed.info/sct&quot;</span><span class=\"p\">,</span>\n        <span class=\"nt\">&quot;concept&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n          <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;code&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;71341001:272741003=7771000&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;display&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;Left femur&quot;</span>\n          <span class=\"p\">}</span>\n        <span class=\"p\">]</span>\n      <span class=\"p\">},</span>\n      <span class=\"p\">{</span>\n        <span class=\"nt\">&quot;system&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;http://snomed.info/sct&quot;</span><span class=\"p\">,</span>\n        <span class=\"nt\">&quot;filter&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n          <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;property&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;concept&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;op&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;is-a&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;71341001&quot;</span>\n          <span class=\"p\">},</span>\n          <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;property&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;expressions&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;op&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;=&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;false&quot;</span>\n          <span class=\"p\">}</span>\n        <span class=\"p\">]</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">]</span>\n  <span class=\"p\">},</span>\n  <span class=\"nt\">&quot;text&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">&quot;status&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;generated&quot;</span><span class=\"p\">,</span>\n    <span class=\"nt\">&quot;div&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;&lt;div xmlns=\\&quot;http://www.w3.org/1999/xhtml\\&quot;&gt;&lt;h2&gt;ValueSet with post coordination&lt;/h2&gt;&lt;tt&gt;urn:postcoordination-test&lt;/tt&gt;&lt;/div&gt;&quot;</span>\n  <span class=\"p\">},</span>\n  <span class=\"nt\">&quot;experimental&quot;</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;publisher&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;CSIRO&quot;</span>\n<span class=\"p\">}</span>\n</pre></div>",
        "id": 153967277,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528267889
    },
    {
        "content": "<p>that's an interesting combination....</p>",
        "id": 153967278,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528268044
    },
    {
        "content": "<p>but a good test case for expansion - <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> can we capture this for the connectathon?</p>",
        "id": 153967279,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528268065
    },
    {
        "content": "<p>ValueSet above = femur, all (pre-coordinated) sub-types, plus left femur (post-coordinated)</p>",
        "id": 153967280,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528268094
    },
    {
        "content": "<p>Here's another</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span>\n  <span class=\"nt\">&quot;resourceType&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;ValueSet&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;url&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;urn:postcoordination-test2&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;version&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;0.0.1&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;name&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;ValueSet with post coordination - 2&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;status&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;draft&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;compose&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">&quot;include&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n      <span class=\"p\">{</span>\n        <span class=\"nt\">&quot;system&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;http://snomed.info/sct&quot;</span><span class=\"p\">,</span>\n        <span class=\"nt\">&quot;filter&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n          <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;property&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;concept&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;op&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;is-a&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;71341001:272741003=7771000&quot;</span>\n          <span class=\"p\">},</span>\n          <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;property&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;expressions&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;op&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;=&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;true&quot;</span>\n          <span class=\"p\">}</span>\n        <span class=\"p\">]</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">]</span>\n  <span class=\"p\">},</span>\n  <span class=\"nt\">&quot;text&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">&quot;status&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;generated&quot;</span><span class=\"p\">,</span>\n    <span class=\"nt\">&quot;div&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;&lt;div xmlns=\\&quot;http://www.w3.org/1999/xhtml\\&quot;&gt;&lt;h2&gt;ValueSet with post coordination&lt;/h2&gt;&lt;tt&gt;urn:postcoordination-test&lt;/tt&gt;&lt;/div&gt;&quot;</span>\n  <span class=\"p\">},</span>\n  <span class=\"nt\">&quot;experimental&quot;</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;publisher&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;CSIRO&quot;</span>\n<span class=\"p\">}</span>\n</pre></div>",
        "id": 153967281,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528268194
    },
    {
        "content": "<p>right. no way to enumerate that, but you can test membership</p>",
        "id": 153967283,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528268359
    },
    {
        "content": "<p>Interesting examples <span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span>!  I'm not quite sure if expanding the second example would produce anything other than a post coordinated concept that matches the expression in the filter value?</p>",
        "id": 153967289,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528271688
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> You described the second one as \"femur, all (<strong>pre-coordinated</strong>) sub-types, plus left femur (post-coordinated)\" - I think that's not quite what you intended to say (or I'm misunderstanding how we/you think the expressions filter works)?</p>",
        "id": 153967379,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528296008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191364\">@Peter Jordan</span> when I say SCT expressions, I mean post-coordinated expressions as ways of representing clinical information in a patient record, and therefore would be of use as a single \"concept\" in a value set. When I say <strong>expression constraint</strong> statement, I'm think of those occurring all the time in a value set CLD - it would be the way we define the value set membership, i.e.; a refset definition. But these things are all so squishy in the theoretical space because of all the things 'one could do' when using expression-based statements and the exact same expression constrain could be used in both places. I'm not sure how to definitely make a clean separation.</p>",
        "id": 153967383,
        "sender_full_name": "Robert McClure",
        "timestamp": 1528297329
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> sorry, that was a description of the first ValueSet</p>",
        "id": 153967531,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528315005
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span>.  The distinction is reasonably clear to me...<br>\nSCT expression = definition of an individual concept<br>\nSCT expression constraint = computable rules to define sets of concepts - invoked by Expression Constraint Language (ECL) queries<br>\nThe problem is when the term \"expression\" is used to cover both cases  (and I'm a guilty party here) and, unless the upcoming SNOMED Query Language subsumes ECL, then this will continue to cause issues between terminologists and implementers.</p>",
        "id": 153967619,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528325226
    },
    {
        "content": "<p>I don't mind if we want to clarify the terminology but I think that we need the functionality</p>",
        "id": 153967620,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528325398
    },
    {
        "content": "<blockquote>\n<p>I don't think they're public... unless the agency wants to publish any - I just don't think they've moved past concept stage on this (<span class=\"user-mention\" data-user-id=\"191337\">@Dion McMurtrie</span> - there's some implicit value sets like this in the CDA specs, but we haven't turned them into real fhir value sets)</p>\n</blockquote>\n<p>WRT to SNOMED CT the short answer is no, all the value sets being used for bindings are implicit value sets referring to reference sets in SNOMED CT-AU. There is a grow set of other value sets <a href=\"https://api.healthterminologies.gov.au/integration/v2/fhir/ValueSet\" target=\"_blank\" title=\"https://api.healthterminologies.gov.au/integration/v2/fhir/ValueSet\">https://api.healthterminologies.gov.au/integration/v2/fhir/ValueSet</a></p>\n<p>There's also somewhat of an anti pattern there, in that the implicit value set <a href=\"http://snomed.info/sct?fhir_vs=refset/32570071000036102\" target=\"_blank\" title=\"http://snomed.info/sct?fhir_vs=refset/32570071000036102\">http://snomed.info/sct?fhir_vs=refset/32570071000036102</a> is what has been used, but for the purposes of expressions in code:in and validate-code we really mean <a href=\"http://snomed.info/sct?fhir_vs=ecl/&lt;&lt;(^32570071000036102)\" target=\"_blank\" title=\"http://snomed.info/sct?fhir_vs=ecl/&lt;&lt;(^32570071000036102)\">http://snomed.info/sct?fhir_vs=ecl/&lt;&lt;(^32570071000036102)</a> . That is all concepts/expressions subsumed by the concepts in the reference set, not just the set of concepts in the reference set itself...but that's a whole other discussion.</p>",
        "id": 153967741,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528356387
    },
    {
        "content": "<p>I think it is worth coming back to the original discussion which is what is practical and useful to do with $expand and expressions, versus $validate-code or code:in. I think it is reconcilable.</p>\n<p>There are two possible positions for what $expand against <a href=\"http://snomed.info/sct?fhir_vs=isa/404684003\" target=\"_blank\" title=\"http://snomed.info/sct?fhir_vs=isa/404684003\">http://snomed.info/sct?fhir_vs=isa/404684003</a> (clinical finding) should return<br>\n1. all pre-coordinated concepts in the SNOMED CT version the terminology server has loaded that are sub types of 404684003<br>\n2. all pre-coordinated concepts in the SNOMED CT version the terminology server has loaded that are sub types of 404684003 <strong>and</strong> all possible post-coordinated expressions valid for the SNOMED CT version's grammar and pre-coordinated content that are sub types of 404684003</p>\n<p>I think 1 is practical and useful - in fact that's what most of the servers around actually do and are used for right now.</p>\n<p>I think 2 isn't practical (calculating all the possible valid expressions wouldn't be easy and would be expensive), and isn't useful (what would the use case be for getting all the possible post-coordinated expressions?).</p>\n<p>I don't think anyone (I hope) is arguing about the behaviour of $validate-code or code:in - they should admit or return true for any expression that meets the definition of the ValueSet. In this example, if an expression is a subtype of 404684003 $validate-code should return true, code:in should admit it. The filter \"expressions=false\" can be used by the ValueSet definition to explicitly prevent this, although I'm not really clear why someone would want to (I don't mean by that there isn't a good reason, I just don't know it).</p>\n<p>To me this is down to the definition of what we are asking $expand to do. In my mind behaviour 1 above is justifiable because we are asking the server to expand the definition of the ValueSet against a specific version of the terminology (even if we don't specify one the server must pick one). That specific version of the terminology has a set of statically published content and that forms the \"substrate\" (as <span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> referred to it as) for the expansion.</p>\n<p>So it seems entirely reasonable that the definition of $expand be that a server applies the rules in the ValueSet definition to that set of statically published content and returns what matches. For Michael's example that explicitly included a specific post-coordinated expression in the ValueSet definition, I'd expect to get that back too. If SNOMED CT started to publish a library of statically defined post-coordinated expressions, I'd expect to see them in the result too...but not any possible post-coordinated expression given the grammar and content.</p>\n<p>For $validate-code and code:in the context is different. They are being passed some finite set of instance data to test against the ValueSet definition which may or may not contain post-coordinated expression. I think (hope) we are all on the same page with this part...</p>",
        "id": 153967742,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528356658
    },
    {
        "content": "<p>so it might just be terminology, but there has seemed to be a deeper disagreement than this.</p>",
        "id": 153967743,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357096
    },
    {
        "content": "<p>for instance, there was a question about whether post-coordinated terms were even 'in' the value set</p>",
        "id": 153967744,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357119
    },
    {
        "content": "<p>if we want to say that in cases where a SNOMED CT value set allows a grammar, expand is implicitly known to return a subset, and the client doesn't need to say explicitly that that's ok, well... ok. I can deal with that.</p>",
        "id": 153967745,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357174
    },
    {
        "content": "<p>but we should not say that this is a property of $expand itself, since I think that would be a wrong thing in some other code systems that have grammar.</p>",
        "id": 153967746,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357213
    },
    {
        "content": "<p>but if we say that a server can <em>not</em> return some of the members of the value set, is a server now wrong if it does choose to post-coordinate and return some of them?</p>",
        "id": 153967747,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357255
    },
    {
        "content": "<p>I think at the last SNOMED CT FHIR meeting we were looking for consistency and utility, and where we landed was that $expand makes sense to evaluate against the static content of the code system, while code:in and $validate-code are being asked a different question which was already constrained to a finite set of post-coordination.</p>",
        "id": 153967749,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528357376
    },
    {
        "content": "<p>so you're saying that a server cannot return any post-coordinated content that is not explicit in the value set? that sounds ..... difficult.</p>",
        "id": 153967750,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357419
    },
    {
        "content": "<p>We did agree that for UCUM for instance that there was a set of well known expressions that servers actually currently implement - but it isn't the complete set of all possible UCUM expressions (because that isn't useful). So we agreed it would be useful to specify this set to give clients and servers some consistency.</p>",
        "id": 153967752,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528357458
    },
    {
        "content": "<p>\"we\"? SNomed CT is making rules about UCUM?</p>",
        "id": 153967753,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357483
    },
    {
        "content": "<p>and it might be useful, but it would be rather dificult.</p>",
        "id": 153967754,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357504
    },
    {
        "content": "<p>LOL, no, \"we\" that SNOMED FHIR group has no powers over anything - even SNOMED CT and FHIR</p>",
        "id": 153967755,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528357516
    },
    {
        "content": "<p>I think it might have some influence there</p>",
        "id": 153967756,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357566
    },
    {
        "content": "<p>We were discussing the behaviour generally and trying to determine what was useful for a terminology server to do. We were looking for some sort of consistency which may help server implementers and server clients - and the interoperability of them</p>",
        "id": 153967757,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528357606
    },
    {
        "content": "<p>well, i challenge that notion with regard to UCUM: can anyone identify this 'set of well known expressions'?</p>",
        "id": 153967758,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357673
    },
    {
        "content": "<p>if I expand the same ValueSet definition against two different terminology servers loaded with the same terminology versions I'd like to think we shoot for the position where I'd get the same result (maybe different order but same overall expansion content)</p>",
        "id": 153967759,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528357675
    },
    {
        "content": "<p>Sure, I'm far from a UCUM expert, but we were searching for what could possibly be defined in an effort to bring consistency and predictability</p>",
        "id": 153967760,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528357726
    },
    {
        "content": "<p>because all roads will lead to one of 3 places: <br>\n- the infoway one (with errors)<br>\n- the loinc one(with errors)<br>\n- the one I build fro them and the google data set that is not otherwise published. and for which I have received <em>0</em> comments</p>",
        "id": 153967761,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357733
    },
    {
        "content": "<p>so I don't think either of the 3 of them have production use</p>",
        "id": 153967762,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357761
    },
    {
        "content": "<p>I'd actually say pick one, put it in the spec and change manage it based on feedback - better a consistent list that people disagree about than fragmented confusion</p>",
        "id": 153967763,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528357794
    },
    {
        "content": "<p>I think if w're going to say: don't return post-coordinated terms unless... X.... that will be a problem twice over: once getting a useful definition of X and then finding all the things that breaks over time</p>",
        "id": 153967764,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357813
    },
    {
        "content": "<p>I think it is more we are saying that when you $expand you are expanding against something - return all the things predefined in that something.</p>",
        "id": 153967765,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528357851
    },
    {
        "content": "<p>the 'predefined' is the problem. it isn't what we said until now, and the 'something' is a problem</p>",
        "id": 153967766,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357887
    },
    {
        "content": "<p>and I think it's critical to know: is this $expand that I have, is that all the valid codes, or just some of them? so to this point, we've said:<br>\n- if the client doesn't ask, it gets all or an error<br>\n- the client says it's ok, the server can return a subset for practical reasons, <em>with a clear indication that it's a subset</em></p>",
        "id": 153967767,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357949
    },
    {
        "content": "<p>and then the server can choose the grounds on which it's a subset.</p>",
        "id": 153967768,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357974
    },
    {
        "content": "<p>I don't see why this isn't an acceptable solution for expanding and post-coordinates in SCT value sets</p>",
        "id": 153967769,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528357997
    },
    {
        "content": "<p>well the something is possibly code system dependent, but there's already different definitions for specific well known code systems. For SNOMED CT we're proposing (we being the people on the call last week, not a formal group) that be all the statically published pre-coordinated concepts in the SNOMED CT version that is the subject of the expansion....if SNOMED CT adds libraries of expressions in publications in the future that may need to be revisited.</p>",
        "id": 153967770,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528357997
    },
    {
        "content": "<p>I think this is an issue because people definitely have use cases for getting the pre-coordinated content that matches a ValueSet definition.</p>\n<p>We've not yet heard of any real use cases for getting all possible post-coordinated expression matching the ValueSet definition...and yet that's the default, or rather an error message is, as no server is actually going to return all the post-coordinated expressions - it is too expensive and not useful.</p>",
        "id": 153967771,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528358199
    },
    {
        "content": "<p>It also isn't a subset, depending upon the way you want to look at it. It is likely a complete set of the matching pre-coordinated codes in the relevant SNOMED CT version...which is of course a subset of all of the possible post-coordinated expressions which we're pretty sure the client doesn't want</p>",
        "id": 153967772,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528358305
    },
    {
        "content": "<p>and so there's a way to get all the pre-coordinated content</p>",
        "id": 153967773,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528358312
    },
    {
        "content": "<p>yes, but the intuitive thing to do (that most of us have been doing naively without knowing until now) results in an error</p>",
        "id": 153967774,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528358361
    },
    {
        "content": "<p>and I can see why you'd say that getting an error for value sets that might include post coordinated terms if less than optimal, but replacing it with a rule that you can't include them is must less optimal</p>",
        "id": 153967775,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528358365
    },
    {
        "content": "<p>what is the use case for including all possible matching post-coordinated expressions for a ValueSet definition in an expansion?</p>",
        "id": 153967776,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528358404
    },
    {
        "content": "<p>it would make sense (to me) for that to be the non-default behaviour activated by an optional parameter that most servers are going to respond to with an error</p>",
        "id": 153967777,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528358459
    },
    {
        "content": "<p>I'm ok in principle with it not being the default behaviour. But I don't see a clear path to a specified behaviour that is safe and predictable and reasonable. I believe that the current behavior is safe and predicable but not reasonable. I'm not really interested in giving up safety and predictability though</p>",
        "id": 153967778,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528358714
    },
    {
        "content": "<p>in particular, laterality is where I'm going to hang my hat on. If a server identifies that a concept has laterality, it <em>should</em> be at least able to auto-post-coordinate that term with left and right. (if not <em>should</em> outright)</p>",
        "id": 153967779,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528358773
    },
    {
        "content": "<p>OK...but there goes predictability. Where's the set of things that should and shouldn't be auto-post-coordinated? If you do laterality and don't do others, what does the absence of those others in the result mean to the client and how does it know?</p>\n<p>How does the client even use the auto-post-coordinated lateralised expression? What's the use case?</p>",
        "id": 153967780,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528358897
    },
    {
        "content": "<p>I'm also not really sure about the safety angle, can you elaborate on that too?</p>",
        "id": 153967781,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528358957
    },
    {
        "content": "<p>unpredictable = unsafe. Though if the only predictable option is also not useful, I think that's a shallow victory at best</p>",
        "id": 153967784,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528359277
    },
    {
        "content": "<p>so not as significant as I first thought</p>",
        "id": 153967785,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528359300
    },
    {
        "content": "<p>still... I remain concerned about this, and banning post-coordination isn't making me happy</p>",
        "id": 153967786,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528359328
    },
    {
        "content": "<p>I think that's what we're shooting for too, predictable, but perhaps we're coming at it from different angles? Maybe talking about it in person at the next SNOMED CT FHIR call on Wednesday morning may be easer to make faster progress?</p>",
        "id": 153967787,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528359401
    },
    {
        "content": "<p>BTW the aim isn't to ban post-coordination. It is to make the default behaviour of servers useful, tractable and predictable for server implementers and clients, otherwise we lose interoperability...and possibly safety as you mentioned.</p>",
        "id": 153967789,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528359570
    },
    {
        "content": "<p>I can join next week.</p>",
        "id": 153967790,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528359764
    },
    {
        "content": "<p>ok great - anyone else on this thread that's interested is of course welcome. It is an open group<br>\nTuesday 12th 20:00 UTC for 90 minutes<br>\nOnline: <a href=\"https://snomed.zoom.us/my/snomedhl7\" target=\"_blank\" title=\"https://snomed.zoom.us/my/snomedhl7\">https://snomed.zoom.us/my/snomedhl7</a><br>\nPhone: See <a href=\"https://zoom.us/zoomconference\" target=\"_blank\" title=\"https://zoom.us/zoomconference\">https://zoom.us/zoomconference</a> for available phone numbers (meeting id 242-348-6949)</p>",
        "id": 153967792,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528360165
    },
    {
        "content": "<p>There's usually a meeting page which hasn't been created yet at <a href=\"https://confluence.ihtsdotools.org/display/FHIR/2018+Meetings\" target=\"_blank\" title=\"https://confluence.ihtsdotools.org/display/FHIR/2018+Meetings\">https://confluence.ihtsdotools.org/display/FHIR/2018+Meetings</a> with the details too <span class=\"user-mention\" data-user-id=\"192993\">@Peter Williams</span> or <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> can maybe post that when it is up?</p>",
        "id": 153967793,
        "sender_full_name": "Dion McMurtrie",
        "timestamp": 1528360213
    },
    {
        "content": "<blockquote>\n<p>and I think it's critical to know: is this $expand that I have, is that all the valid codes, or just some of them? so to this point, we've said:<br>\n- if the client doesn't ask, it gets all or an error<br>\n- the client says it's ok, the server can return a subset for practical reasons, <em>with a clear indication that it's a subset</em></p>\n</blockquote>\n<p>Just catching up on the thread here - it seems to me that the only real dispute here is whether the default should be client has to choose, or server gets to choose if client doesn't specify.</p>\n<p>The key thing for me is that the client needs to be able to say \"I'm happy with a (server defined) subset\" without being forced to say/only being able to say \"Only give me pre-coordinated things\".  At the moment there is <code>limitedExpansion</code> and <code>excludePostCoordinated</code> (in R4) which seems to cover it.  However, most servers seem to, in most cases, behave as though <code>limitedExpansion</code> defaults to <code>true</code> rather than <code>false</code></p>",
        "id": 153967797,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528361868
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> your laterality example is good - I had been toying with something like this myself</p>",
        "id": 153967798,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528361946
    },
    {
        "content": "<p>The only thing that slowed me down was something in the spec that I remember (I can't find it just now) that seemed to say that post coordinated codes don't / can't have display text</p>",
        "id": 153967800,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528362228
    },
    {
        "content": "<p>what we say is that they're not defined. If SCT wants to define them... sensational</p>",
        "id": 153967802,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528362313
    },
    {
        "content": "<p>It would be.  Would it also be okay if a terminology server did its own thing in the meantime?</p>",
        "id": 153967806,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528362386
    },
    {
        "content": "<p>sure, here's what we do say:</p>\n<blockquote>\n<p>SNOMED International does not define terms for expressions. If a SNOMED terminology producer publishes human-readable terms for expressions in an expression repository, this term may be used as the display. Similarly, if a SNOMED terminology producer publishes an official template for generating terms from an expression, a term generated using the template may be used as the display. If no term or description template has been published, the full expression with terms embedded may be used</p>\n</blockquote>",
        "id": 153967807,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528362435
    },
    {
        "content": "<p>given that... we don't say anything about not doing anything</p>",
        "id": 153967808,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528362448
    },
    {
        "content": "<p>I can work with all of that</p>",
        "id": 153967810,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528362480
    },
    {
        "content": "<p>Here's the page for next week's SNOMED on FHIR Terminology Services call:<br>\n<a href=\"https://confluence.ihtsdotools.org/pages/viewpage.action?pageId=64260509\" target=\"_blank\" title=\"https://confluence.ihtsdotools.org/pages/viewpage.action?pageId=64260509\">https://confluence.ihtsdotools.org/pages/viewpage.action?pageId=64260509</a></p>",
        "id": 153967852,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528385502
    },
    {
        "content": "<p>Some random comments on post-coordination (but <em>not</em> a vote for abolition)...</p>\n<ul>\n<li>Laterality is an interesting choice as the 'poster child' for post-coordination given that there are now around 4,700 active pre-coordinated concepts in the 20180131 version of International Edition of SCT with laterality attributes - although I'm not sure if that's actually a drop in the proverbial ocean.</li>\n<li>From an EHR/PHR UI perspective - without a human readable term, post-coordinated concepts have little value.</li>\n<li>Many/most/all client systems will have to make significant changes to handle post-coordinated concept identifiers.</li>\n<li>Once equivalence testing requires the use of a classifier, it's hard to envisage endpoint systems creating their own post-coordinated expressions without a Terminology Server.</li>\n<li>The big challenge, as I see it, for the Terminology Server developers is to figure out a way to persist post-coordinated expressions alongside RF2-formatted content in a way that facilitates single queries to implement $expansion requests.  I'm guessing that's one of the things that <span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> is working on and it will be good to discuss this at the upcoming HL7NZ Event. My initial thought, for a RDBMS schema, is to treat it as a local concept with it's own SCTID and add a nvarchar(max) field to the Concept Table to hold the expression.</li>\n<li>I wonder if anyone has tried to perform a $lookup operation on a post-coordinated SCT concept?</li>\n</ul>",
        "id": 153967931,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528417725
    },
    {
        "content": "<p>I haven't really gone through and implemented post-coordination. but with regard to this:</p>\n<blockquote>\n<p>Many/most/all client systems will have to make significant changes to handle post-coordinated concept identifiers.</p>\n</blockquote>\n<p>Not if they're using a terminology service. If you're using a terminology service that handles it, then that's completely opaque to you</p>",
        "id": 153967932,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528417935
    },
    {
        "content": "<blockquote>\n<p>The big challenge, as I see it, for the Terminology Server developers is to figure out a way to persist post-coordinated expressions alongside RF2-formatted content</p>\n</blockquote>\n<p>Depends how you implement - for me, it's a logic challenge not a persistence challenge. but why not go through and generate a bunch of relevent/likely post-coordinations....</p>",
        "id": 153967933,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528418032
    },
    {
        "content": "<p>Agree that post-coordination requires the use of a terminology service - but if an NZ General Practice PMS receives a post-coordinated SCT code in a GP2GP transfer, it will break the bank.<br>\nNot sure if your implementation of SCT is typical :). If there are obvious candidates for post-coordination, surely they should be promoted to pre-coordinated concepts in the International Edition?</p>",
        "id": 153967934,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528418045
    },
    {
        "content": "<p>if we move systems to using terminology servers, then that will no longer be true. but since it is currently true, that's why you can specify value sets and say that they do not include post-coordination</p>",
        "id": 153967935,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528418235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191364\">@Peter Jordan</span> why the need to allocate a local ID?  the expression is its own identifier.  ie. it <strong>is</strong> the local code</p>",
        "id": 153967936,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528418287
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> - it might be neater to use a 19 character SCTID for linking to the other RF2 tables, rather than a long expression. I struggle to see a long post-coordinated expression as an identifier - makes a GUID look elegant!</p>",
        "id": 153967938,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528418498
    },
    {
        "content": "<p>URIs are identifiers and often very long; if you need to \"understand\" the identifier (expression), then that's what the services part of Terminology Services provides</p>",
        "id": 153967939,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528418622
    },
    {
        "content": "<p>Can you tell me what specifically would be improved by using a 19char SCTID?</p>",
        "id": 153967941,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528418892
    },
    {
        "content": "<p>consistent internal indexing?</p>",
        "id": 153967942,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528418929
    },
    {
        "content": "<p>Is that something to do with having a bounded length?  That's normally solved with a good hash algorithm, and it's should also be a low-level implementation detail</p>",
        "id": 153967944,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528419128
    },
    {
        "content": "<p>I've had a career-long preference for surrogate primary keys in RDBMS. Even though there are meaningful elements in SCTIDs, they are strong candidates for primary keys - IMHO, post-coordinated expressions are poor candidates (and are they guaranteed to be immutable??). BTW, had a re-think on where I would store the expression, within the RF2 format - as the Fully-Specified name.</p>",
        "id": 153967946,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528419580
    },
    {
        "content": "<p>Sure, but you don't exchange surrogate keys; they're an internal construct</p>",
        "id": 153967948,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528419640
    },
    {
        "content": "<p>Not necessarily true, in NZ anyway. We use GUIDs as Entry Identifiers in CDA instances and these are persisted and used by endpoint systems to identify returning records, for example in GP2GP.  Basically, they're required in any replication use case. The thing is that they shouldn't be presented to end users - from that perspective they are 'internal', but they can have a life outside of DBMS.</p>",
        "id": 153967949,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528420277
    },
    {
        "content": "<p>Ah, but in that case they only carry 'identity' and the instance itself is still exchange (ie the inputs to the key).  If you replace an expression by a local code then you're no longer exchanging the expression</p>",
        "id": 153967950,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528420442
    },
    {
        "content": "<p>Would the endpoint system care?  Most would be happy with the preferred term and a concept identifier that they can persist within a fixed-length field. If they are interested in the expression - then request a $lookup, as they would do if they are interested in viewing the expression for a pre-coordinated code.</p>",
        "id": 153967951,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528420745
    },
    {
        "content": "<p>then it becomes a question about interop between terminology servers.</p>",
        "id": 153967952,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528420778
    },
    {
        "content": "<p>because to everyone else, the identifier is opaque.</p>",
        "id": 153967953,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528420789
    },
    {
        "content": "<p>and that's what the expression format is for... unless we decide to use supplements to distribute assigned identifiers for expressions</p>",
        "id": 153967954,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528420831
    },
    {
        "content": "<p>that might be something to consider</p>",
        "id": 153967955,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528420859
    },
    {
        "content": "<p>now i should wash my mouth out for merely suggesting the possibility. Syntax switches don't solve semantic problems...</p>",
        "id": 153967956,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528420903
    },
    {
        "content": "<p>mind you, you could say that about quite of things that happen in SCT</p>",
        "id": 153967957,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528420927
    },
    {
        "content": "<p>sure</p>",
        "id": 153967958,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528420941
    },
    {
        "content": "<p>that's my point - the identifier (the code) is opaque.  It's also of unbounded length.  If brown-fields backends can't deal, then they can use expression libraries, but I don't see a use</p>",
        "id": 153967959,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528420959
    },
    {
        "content": "<p>I don't disagree - I was going to mention expression libraries, but they probably don't really solve anything</p>",
        "id": 153967960,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528421057
    },
    {
        "content": "<p>My perspective is a little different - pre or post-coordinated, these are all concepts defined by expressions and, as far as possible, should be treated in the same way. In practical terms, what's the difference between a post-coordinated concept and a locally-created concept?  Placing expressions in a library looks like a poor solution to me.</p>",
        "id": 153967961,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528421343
    },
    {
        "content": "<p>the bottom line I think is that for post-coordination to catch on we'll have to come up with some sufficiently robust and realistic prototype implementations - and test in connectathons and elsewhere - so that people can finally see something that's tangible and have their \"aha\" moment and catch on to how it can practically work (using terminology services)<br>\nmaybe you've already done or started doing a good bit of that in Australia, but I don't know for sure how far you really are with it</p>",
        "id": 153967962,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528421364
    },
    {
        "content": "<p>it would be a good connectathon to have at a SNOMED CT event rather than an HL7 event</p>",
        "id": 153967963,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528421400
    },
    {
        "content": "<p>There was a terminology connectathon after the london snomed international business meeting</p>",
        "id": 153967964,
        "sender_full_name": "Jim Steel",
        "timestamp": 1528421436
    },
    {
        "content": "<p>Anyone else going to Vancouver in October?</p>",
        "id": 153967965,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528421441
    },
    {
        "content": "<p>not me</p>",
        "id": 153967966,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528421449
    },
    {
        "content": "<p>yes, that makes sense - it's not something I've ever seen at a SNOMED event, but maybe it could be done<br>\nthe London connectathon didn't really begin to approach anything like that, but it might set a bit of a precedent</p>",
        "id": 153967968,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528421491
    },
    {
        "content": "<p>I'll be there</p>",
        "id": 153967969,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528421495
    },
    {
        "content": "<p>We'll be in Vancouver.<br>\nI'd also be very interested in anyone with real examples of SNOMED post coordination in actual data</p>",
        "id": 153967970,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528421498
    },
    {
        "content": "<p>if you don't know of them already, Michael, I'm guessing they may not exist</p>",
        "id": 153967971,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528421554
    },
    {
        "content": "<p>It's a bit like the old adage about teenage s**</p>",
        "id": 153967972,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528421593
    },
    {
        "content": "<p>so in the Australian CDA discharge summary, we're using CD.qualifier for laterality. In the FHIR equivalent, that's post-coordination. Note that I don't think anyone actually has done this because the interface terminologies have this pre-coordinated, and no one has translated this one to SCT to my knowledge. But there we are...</p>",
        "id": 153967973,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528421598
    },
    {
        "content": "<p>should we think about something we could still propose at this point for Vancouver?  we might be too late for anything very official, but I don't know</p>",
        "id": 153967974,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528421669
    },
    {
        "content": "<p>Ah, that's interesting, so the CD does pc itself.  Interesting that that maps to pc in FHIR and not another information model element</p>",
        "id": 153967975,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528421693
    },
    {
        "content": "<p>CD.qualifier is post-coordination done badly. I retired that in everything we've done since....</p>",
        "id": 153967976,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528421726
    },
    {
        "content": "<p>well, we did that later in V3, too (like FHIR) - but CDA stayed with the earlier approach</p>",
        "id": 153967977,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528421740
    },
    {
        "content": "<p>y. that's right. but the CD.qualfiier approach is awful if you try to actually make it work. the information model definitions work against the pc definitions in snomed ct</p>",
        "id": 153967978,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528421785
    },
    {
        "content": "<p>totally agree</p>",
        "id": 153967979,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528421797
    },
    {
        "content": "<p>that's why it got dropped</p>",
        "id": 153967980,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528421810
    },
    {
        "content": "<p>so ironically I  just ran into another code system that has composition in it today, and now I'm wondering what to do for an $expand request for the specification itself.</p>",
        "id": 153968193,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528547276
    },
    {
        "content": "<p>the code system is... mime types. (url = urn:ietf:bcp:13)</p>",
        "id": 153968194,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528547313
    },
    {
        "content": "<p>I would think that $expand should return the list of registered (pre-coordinated) mime types - of whatever version(s) the server is aware.  I don't think it would make sense to compute and return any additional unregistered compositional combinations.</p>",
        "id": 153968228,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528596397
    },
    {
        "content": "<p>unregistered with.... who?</p>",
        "id": 153968231,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528602666
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  I'm a bit late back to the party here and was going to comment on your statement that terminology servers will solve this and implied that yours already had solved the problem of supporting the use of PCE (Post-Coordinated Expressions) in records. Given the subsequent discussion it should be be clear that we have a long way to go before calling this \"solved\" - need I mention versioning?</p>\n<p>It's interesting that much of this discussion is a re-hash of material Linda Bird and I put together in 2016  with the eventual conclusion that expression libraries were the only current practical way of supporting \"Expressions in the wild.\" I don't think that document was ever circulated but we evaluated a range of approaches - I really wanted to make a hash work - and all other solutions came up short. Perhaps we can get SCT Int to release the document? </p>\n<p>And yes - the mime types is another compositional code system. Actually the one HL7 uses is considered an <strong>internal</strong> to HL7 code system because the selected format and content is what HL7 decided we needed and is not all that can be done based on BCP 13.</p>",
        "id": 153968236,
        "sender_full_name": "Robert McClure",
        "timestamp": 1528642905
    },
    {
        "content": "<p>I was thinking of unregistered = not registered with IANA (as bcp13 describes)</p>",
        "id": 153968243,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528661110
    },
    {
        "content": "<blockquote>\n<p>Actually the one HL7 uses is considered an internal to HL7 code system because the selected format and content is what HL7 decided we needed and is not all that can be done based on BCP 13</p>\n</blockquote>\n<p>I don't believe that this is true in the FHIR context; that's a v3 special. But only because we didn't have the max value set concept in v3</p>",
        "id": 153968245,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528661306
    },
    {
        "content": "<p>There are (probably) a bunch \"well known\" X- mime types that would be useful to return</p>",
        "id": 153968250,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528690693
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span> So where would this \"expression library\" live and how would the Terminology Service know about it / interact with it?</p>",
        "id": 153968251,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528692248
    },
    {
        "content": "<p>I think it smells like a code system supplement</p>",
        "id": 153968254,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528695060
    },
    {
        "content": "<p>For better of for worse, our practical proposal was that SNOMED CT would host and manage it - so a central repository. I think it could be decentralized if consistently implemented but the approach required 24/7 availability so that any organization that created or received an identifier for an expression could resolve it. In essence as I remember it (I need to go back and re-read it) this proposal built upon our existing SCT usability, the only thing you did not get when compared to the published precoordinated set was  consistent naming and guaranteed (initially) non-equivalence with another expression.</p>",
        "id": 153968422,
        "sender_full_name": "Robert McClure",
        "timestamp": 1528736475
    },
    {
        "content": "<p>There was certainly considerable discussion about expression library(s) for a while, but not much (if any) that I'm aware of recently.  So I'm assuming that there is no current resourcing for it from SNOMED Int. at this point?  There is also the possibility that local institutions can develop their own libraries (Univ. of Nebraska comes to mind).  I agree that if it's done in FHIR a code system supplement would seem likely.</p>",
        "id": 153968426,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528738964
    },
    {
        "content": "<p>My understanding is that supplements are for adding designations and properties to code systems - not concepts.</p>",
        "id": 153968539,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528749965
    },
    {
        "content": "<p>we did say that, but this is not about defining concepts... just code aliases... not a differentiation we had previously made...</p>",
        "id": 153968571,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528758120
    },
    {
        "content": "<p>We may be at cross-purposes. I'm referring to post-coordinated SCT concepts, not MIME types.</p>",
        "id": 153968573,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528758264
    },
    {
        "content": "<p>so was I</p>",
        "id": 153968584,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528759387
    },
    {
        "content": "<p>In which case, I don't see how creating post-coordinated concepts isn't, in effect, defining new concepts?</p>",
        "id": 153968590,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528766649
    },
    {
        "content": "<p>Why not a  ValueSet that enumerates a list of post-coordinated codes as an expression library?</p>",
        "id": 153968591,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1528767013
    },
    {
        "content": "<p>That still begs the question of how one might query across both pre and post-coordinated concepts (e.g. ECL queries, subsumption tests, etc.). Surely that would be easier if the post-coordinated concepts were stored as local extensions in RF2 Format? The idea of an international Expression Library also baffles me - why not just promote them to pre-coordinated concepts and add them to the International Edition? I guess that sounds almost too simple, so I must be missing something? :)</p>",
        "id": 153968592,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528769794
    },
    {
        "content": "<p>value set doesn't solve the problem for re-use of the library in other value sets</p>",
        "id": 153968604,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528779835
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191364\">@Peter Jordan</span> Your question is indeed the one we had too, and the answer is these expressions are not curated while promoted ones are. That is the primary distinction between them. In part, it's all about resourcing - by allowing expressions to flourish (in the wild!) without requiring curation, we get something useful (but a bit unruly.) From that, sea of goods, some may be promoted...</p>",
        "id": 153968804,
        "sender_full_name": "Robert McClure",
        "timestamp": 1528848006
    },
    {
        "content": "<p>or, in my language, the governance criteria are lower</p>",
        "id": 153968805,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528848153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span> That sounds like my approach to gardening, the risk is that the good stuff gets buried in the weeds.</p>",
        "id": 153968822,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528852496
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> recent discussions, have left me wondering if I'm heading to the left of this scenario... <a href=\"https://imgur.com/gallery/LTYjp\" target=\"_blank\" title=\"https://imgur.com/gallery/LTYjp\">https://imgur.com/gallery/LTYjp</a></p>",
        "id": 153968883,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528869391
    },
    {
        "content": "<p>that's my new favourite false dichotomy</p>",
        "id": 153968885,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528869622
    },
    {
        "content": "<p>is the cartoon itself going left or right?</p>",
        "id": 153968886,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528869637
    },
    {
        "content": "<p>I'm just concerned about falling over the cliff!  :)</p>",
        "id": 153968887,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528869717
    },
    {
        "content": "<p>well, thats one thing the cartoon is right about... both paths go off the cliff....</p>",
        "id": 153968888,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528869761
    },
    {
        "content": "<p>...not sure if that's the intention, but it certainly looks that way.</p>",
        "id": 153968889,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528869974
    },
    {
        "content": "<p>...but I believe the intention is that the complex path goes down the cliff in a controlled fashion :)</p>",
        "id": 153969113,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528912191
    },
    {
        "content": "<p>of course, you get to experience going to the cliff alone, instead of a with a group.</p>",
        "id": 153969200,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528926757
    }
]