[
    {
        "content": "<p>We're getting a lot of feedback from HL7 committees: We really really hate git, and we're totally powerless to deal with it</p>",
        "id": 256651246,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633641292
    },
    {
        "content": "<p>and when we try to ask for help, experts just tell us that we're using the wrong git client, but that doesn't actually help at all</p>",
        "id": 256651330,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633641319
    },
    {
        "content": "<p>we need to do something about this. But what?</p>",
        "id": 256651392,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633641356
    },
    {
        "content": "<p>I'm terrified of git conflicts - it's super stressful because I might merge wrong, and git's language is totally confusing. Perhaps I'm just stupid but in my head, there's other people's changes, my changes, and the product. Git gives me 'base', 'merge-head', and 'head'. Which of those is which, and could they choose less useful language?</p>",
        "id": 256651580,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633641427
    },
    {
        "content": "<p>so you can imagine how committee members feel.</p>",
        "id": 256651858,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633641547
    },
    {
        "content": "<p>and then, after a merge, git tells you you're committing hundreds of files. Did you change them? Is that a whoopsie?</p>",
        "id": 256652070,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633641626
    },
    {
        "content": "<p>I don't think the problem is git per se...  We are building a product via many async distributed 'teams' that have varying levels of comfort with the tools.  Version management is a hard problem, even more so for people not used to dealing with it.  Short of something like a custom software platform for editing the FHIR spec (which I can't imagine being feasible), I don't know how much of a difference the tooling can make.</p>\n<p>But, we should be able to reduce the burden.</p>\n<p>First, I'd suggest identifying the 'repeat offenders' to see if they can be removed/not checked-in, e.g.:</p>\n<ul>\n<li>Adding resources often causes conflicts in the 'top level' files (e.g., <code>oids.ini</code>, <code>resourcelist.html</code>, etc.) - can we move these out of 'normal' editing, make them generated files, etc.?</li>\n<li>I often have conflicts with things like cache files (e.g., <code>null.cache</code>) - they are nice to have, but I would be willing to trade a longer 'first build' for not dealing with those conflicts.</li>\n<li>There is a lot of 'build' stuff as well as the actual content source.  If those files cause problems, they could be split into different repos (e.g., if people are making changes for local builds and accidentally causing problems).</li>\n</ul>\n<p>Second, I'm guessing that some educational content would go a long way.  Everything from 'setting up your environment correctly' to things like 'how to deal with long-lived branches' to 'how to add a new resource/operation/etc.'.  I'm guessing a lot of frustration comes from not knowing.</p>\n<p>After mulling for a bit (but not wanting to rewrite all the above =), another possibility would be to have someone (paid) responsible for managing the repo.  Merging branches, warning people of long-lived ones, deleting stale ones, etc. ... localize the pain to a single person/team and compensate them for dealing with it (e.g., ops).</p>",
        "id": 256657225,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1633644223
    },
    {
        "content": "<p>i was writing up a bunch of stuff and then Gino posted and that was a lot of what I was going to say. :)</p>\n<p>can I step back and ask why you decided on Git as your version control platform?  Git imposes a certain way of thinking about your source files and how they are managed and that has been imposed on us because of the decision to use Git.</p>\n<p>the other question is what alternative would we use if we decided to move away from Git?</p>\n<p>I do think that treating the FHIR specification as set of source files was a good decision.  And if you do that, then you need a way to manage and control the source files.   But it is a different way of thinking then many specification developers at HL7 are used to thinking.   I agree with Gino's suggestions on reducing the burden - identify files that are pain points, provide some education to new committers, single out repository managers who can help and/or do some of the required tasks in managing a repository of this size.</p>",
        "id": 256658371,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1633644847
    },
    {
        "content": "<p>the files that are the pain points that I've heard about are the txCache files, but they don't really matter - fix them however way. It's source merge conflicts that are the real problem from what I've heard, since they matter</p>",
        "id": 256659244,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633645369
    },
    {
        "content": "<p>note that the build is 3hours + longer when I rebuild the txCache. I don't think we want to have build times like that</p>",
        "id": 256659281,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633645395
    },
    {
        "content": "<p>why choose git? because of the workflows around it , and in the hope that we could manage it. The second has turned out to not be true</p>",
        "id": 256668269,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633650965
    },
    {
        "content": "<p>There are quite a few things to unpack here.</p>\n<ol>\n<li>\n<p>Git != GitHub. Are the beneficial workflows those of git mainly, or the add-ons of GitHub?</p>\n</li>\n<li>\n<p>Related to the previous - are our needs better served by <a href=\"https://nvie.com/posts/a-successful-git-branching-model/\">git-flow</a> or <a href=\"https://guides.github.com/introduction/flow/\">GitHub flow</a></p>\n</li>\n<li>\n<p>The creator of Git has stated that <a href=\"https://lore.kernel.org/lkml/CAHk-=wjbtip559HcMG9VQLGPmkurh5Kc50y5BceL8Q8=aL0H3Q@mail.gmail.com/\">GitHub \"creates absolutely useless garbage merges, and you should never ever use the github interfaces to merge anything\"</a> - could that be one of the reasons merges are such an issue?</p>\n</li>\n<li>\n<p>There are multiple ways to do the same things - e.g. pull requests from branches, vs. pull requests from forks. Is one better than the others?</p>\n</li>\n<li>\n<p>Should all merges be done without fast-forward (--no-ff parameter)?</p>\n</li>\n<li>\n<p>Do git clients provide sufficient added value compared to the command line interface?</p>\n</li>\n</ol>",
        "id": 256670066,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1633652259
    },
    {
        "content": "<p>(On 3, I don't think Linus's gripes are things we particularly worry about. They're to do with things like signatures which haven't been a pain point for us, not about the graph structure of the repository history.)</p>",
        "id": 256670859,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1633652822
    },
    {
        "content": "<p>On the txCache files, would adding a step after the local build to add any new files generated due to the build, and then commit them and any modified existing ones with auto-add? I think the problems occur when these files are not updated after the build, is that the case?</p>",
        "id": 256675469,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1633656596
    },
    {
        "content": "<p>I think that the txcache files really are the source of most of the merge issues that I have had and have heard of - probably even up to 80-90% of them?  I think those cache files are still changing far too often (and often apparently unnecessarily), and any diffs on them to see what has changed and why it has changed are for the most part completely useless.  I agree with Gino that it may be better to trade a longer 'first build' for avoiding having to deal with those conflicts - add the folder to .gitignore and manage it entirely locally.  And Vassil I think is also right that many times these files are not being checked in consistently - and then when someone does check them in that probably means that the changes and the potential conflicts are greater.  But the easiest way may be to not check them in at all.</p>",
        "id": 256737484,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1633698865
    },
    {
        "content": "<p>I think asking people to use command line is a non-starter.  Some of the GUI tools aren't that intuitive, but the commandline is far worse.</p>",
        "id": 256768229,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633711337
    },
    {
        "content": "<p>i actually have no problem with the commandline.  it's pretty much dead simple since there is quite a restricted set of commands you're going to use</p>",
        "id": 256770299,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1633712255
    },
    {
        "content": "<p>Yes, but you're not an example of someone who struggles with Git :)</p>",
        "id": 256775803,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633714355
    },
    {
        "content": "<p>I tend to stick with the git command line, rather than trying to second-guess what some GUI tool might actually be doing.</p>",
        "id": 256780603,
        "sender_full_name": "Joel Schneider",
        "timestamp": 1633716237
    },
    {
        "content": "<p>I'm also one who from my experience finds it often easier and more straightforward to work with the command line rather than the various tools that I've used so far (e.g., GitKraken, TortoiseGit).</p>",
        "id": 256786185,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1633718483
    },
    {
        "content": "<p>As someone without much knowledge of the process (and in your target audience), I actually prefer the command line to a tool provided that there is a clear set of steps I can follow (and better yet, cut and paste). Too many menu choices in most of the tools I've tried out.</p>",
        "id": 256786442,
        "sender_full_name": "Craig Newman",
        "timestamp": 1633718611
    },
    {
        "content": "<p>I haven't wanted to or found a need to use any of the tools for quite some time (although I started by trying GitKraken).</p>",
        "id": 256786482,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1633718633
    },
    {
        "content": "<p>I can't stand the command line. so much typing of file names - what a waste of time</p>",
        "id": 256790506,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633720227
    },
    {
        "content": "<p>and you might like saying to make the first build last longer - very much longer, but you all like that I can wear that pain once for all of you. otherwise I'll periodically wipe your cache and you'll all have three hour builds.</p>",
        "id": 256790640,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633720293
    },
    {
        "content": "<p>You very rarely need to type out full file names with tab completion :-)</p>\n<p>But I'm not trying to say that there is a one size fits all solution.</p>",
        "id": 256790818,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1633720371
    },
    {
        "content": "<p>I do think it would be helpful to have an in-depth technical discussion, maybe a live conversation, about the overall caching strategies so that we could explore whether other options might be able to meet the needs.</p>",
        "id": 256790886,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1633720403
    },
    {
        "content": "<p>well, i deleted my entire vscache directory to see how long it would take and I just got a timeout so I couldn't check :)</p>",
        "id": 256792408,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1633721075
    },
    {
        "content": "<p>okay i'm trying with just deleting the files in the vscache directory and not the entire directory :)</p>",
        "id": 256793793,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1633721698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> <a href=\"#narrow/stream/179293-committers.2Fgit-help/topic/Git.20help.20needed/near/256790640\">said</a>:</p>\n<blockquote>\n<p>and you might like saying to make the first build last longer - very much longer, but you all like that I can wear that pain once for all of you. otherwise I'll periodically wipe your cache and you'll all have three hour builds.</p>\n</blockquote>\n<p>I'd argue it's not we 'all'... but yeah, that's usually what users/customers want.  They are asking someone else to take on pain so they don't have to.</p>\n<p>The tradeoff doesn't have to be paid in longer build times - for example, it can be paid in development time (though I worry that right now, it's still asking you to bear most of the pain - but that's another discussion).  There are lots of options here: make txCache something that only updates from the main branch builds with another directory for 'local' changes; move txCache into another repo/project/package altogether; make it so that local builds don't modify txCache and just build the local things they need on the fly each time; or if it's only an issue in your environment, identify a process that keeps a 'local' copy of the txCache to swap in and out; etc..</p>\n<p>I don't know enough about the caching mechanism of the build process to know what would be the simplest to implement.  But, if the majority of conflicts are in the txCache, then that seems like the best place to start addressing it.</p>\n<p>But to my knowledge, there is no tool that allows different people to work on the same files at the same time, has a 'branching' concept for building/testing/exploring, and does not have to deal with merge conflicts.  I don't think it's a tool limitation, but rather a process one (or a physics one, if you want to blame it on linear time =).</p>",
        "id": 256801168,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1633725084
    },
    {
        "content": "<p>Could we have a dual-layer cache - one generated locally and not committed, and one generated by the CI build and auto-committed?  Because there are two layers, we wouldn't have conflicts and everyone would get the benefit of the CI-build maintained cache.</p>",
        "id": 256804401,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633726497
    },
    {
        "content": "<p>Wouldn't that mean a 3-hour CI build?</p>",
        "id": 256826657,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1633741561
    },
    {
        "content": "<p>The CI build can support caching strategies. I think the main thing (for me anyway) is to understand the problem better.</p>",
        "id": 256826886,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1633741786
    },
    {
        "content": "<p>The CI build wouldn't have to rebuild from scratch.  It would retain its own cache (which it commits) and would simply update it.  The complexity would be in managing a 2-level cache.</p>",
        "id": 256828711,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633743553
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222054\">Gino Canessa</span> <a href=\"#narrow/stream/179293-committers.2Fgit-help/topic/Git.20help.20needed/near/256801168\">said</a>:</p>\n<blockquote>\n<p>But to my knowledge, there is no tool that allows different people to work on the same files at the same time, has a 'branching' concept for building/testing/exploring, and does not have to deal with merge conflicts.  I don't think it's a tool limitation, but rather a process one (or a physics one, if you want to blame it on linear time =).</p>\n</blockquote>\n<p>I think that the merge conflicts are exacerbated by:<br>\na) we have a lot of people making PRs<br>\nb) the length of time that our checks take when a PR is submitted is much longer than normal<br>\nIn previous and current projects that I'm on, the checks run the tests and they take no more than 10 minutes, so the time from a PR request to merging it is short.</p>",
        "id": 256828805,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1633743636
    },
    {
        "content": "<p>Only issue would be the CI-build colliding with itself.  If that happened, I think it'd just revert and not bother committing the cache updates and leave it to the next CI build that didn't collide to commit.</p>",
        "id": 256828811,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633743643
    },
    {
        "content": "<p>I'm still interested in understanding whether there's an approach to caching that would avoid version control conflicts altogether.</p>",
        "id": 256830070,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1633744874
    },
    {
        "content": "<p>the thing about the txCache files is that it's easy to resolve - just abandon one or the other and move on. It's the other merges that matter. And while it's true that non-locking version control programs lead to merge, I was never afraid of svn merges, and I'm always afraid of git merges</p>",
        "id": 256835589,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633750728
    },
    {
        "content": "<p>why would you be afraid of merges via git vs svn?  i'm more afraid of svn merges because of the way that svn treats branches.  as well, I don't think that the concept of a pull request where you can run pre-update checks before a merge occurs exists in SVN.  It didn't back when I was using SVN and a quick web search seems to imply that it doesn't.</p>",
        "id": 256849969,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1633765739
    },
    {
        "content": "<p>well, our infrastructure is better. It's a lot quicker to build without the cache. But it doesn't work - I have some bugs to find and fix</p>",
        "id": 257129879,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633996097
    },
    {
        "content": "<p>A couple of notes reflecting on this thread:</p>\n<ul>\n<li>\n<p>Before migrating FHIR from svn to git (and this was a primary motivation for the migration), we had a broken build in svn a lot of the time. People would by necessity push their possibly-broken updates onto the already broken head of the repo, which compounded the problem. We don't have that anymore; our main branch in git is protected by pre-merge checks that are really pretty effective. (Yes, this has a cost in the effort of managing these merges, which I'm not trying to minimize.)</p>\n</li>\n<li>\n<p>Grahame when you encounter a situation with a scary merge, maybe jot down the commit hashes of the branches you're merging, and share here; without trying to intervene midstream, we can review after the fact and see if there are any workflow improvements to suggest.</p>\n</li>\n</ul>",
        "id": 257130435,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1633996538
    },
    {
        "content": "<p>well, most of them are java code, but sure, I can do that</p>",
        "id": 257130741,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633996792
    },
    {
        "content": "<p>Cool. (The actual java semantics involved in the merge process wouldn't be different between svn and git, right?)</p>",
        "id": 257131197,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1633997110
    },
    {
        "content": "<p>probably not.</p>",
        "id": 257131433,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633997301
    },
    {
        "content": "<p>it may be the UI - I just can't tell what it's doing line wise. But sometimes, I have no idea what it's even showing me. I had one last week - the diff showed fundamantal change to the structure, but none of the recent commits had anything like that. I just reverted the repo and made my changes again.</p>",
        "id": 257131489,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633997371
    },
    {
        "content": "<p>oh - and I'm doing this locally as well</p>",
        "id": 257132447,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633998173
    },
    {
        "content": "<p>Locally resolving is good (but cases where the parent branches exist in GitHub will make the best examples for us to review after the fact).</p>",
        "id": 257133839,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1633999452
    },
    {
        "content": "<p>besides the vscache and other \"files that I didn't change, so I don't know what I should do with\"..... The other issue I come up against is just understanding the \"right\" way to do something. These \"somethings\" might seem obvious to the GIT elite, but I am never quite sure what to do when I am told things like my branch being behind blah blah... these \"somethings\" should be identified and a set of visual tutorials (we started this github process with some nice visual tutorials).</p>",
        "id": 257261143,
        "sender_full_name": "John Moehrke",
        "timestamp": 1634068026
    },
    {
        "content": "<p>follow up on this. We could free up a few $$ to pay someone to document 'standard procedures' to resolve common challenges for editors. Would this be useful?</p>",
        "id": 257452762,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1634166298
    },
    {
        "content": "<p>(irrespective of what else we do about cache files)</p>",
        "id": 257452791,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1634166314
    },
    {
        "content": "<p>I am writing up some expanded wording and diagrams on this, but I don't know exactly what are \"common challenges\". Would it be useful to investigate your current 202110 branch?</p>",
        "id": 257468604,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1634177369
    },
    {
        "content": "<p>don't know. possibly not - there's a lot of moving parts on that one and it's highly abnormal</p>",
        "id": 257468697,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1634177431
    },
    {
        "content": "<p>Here are some of the points I am trying to address</p>\n<ul>\n<li>The slight difference between creating pull requests from a branch vs from a fork</li>\n<li>Regularly merge master/main into the local feature branch</li>\n<li>Suggest use of kdiff3 to resolve conflicts.</li>\n<li>How to commit large number of modified files without typing the file names</li>\n</ul>",
        "id": 257469468,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1634178118
    },
    {
        "content": "<p>I think I have identified an issue that can explain at least some of the unexpected problems when merging things. I also think that it can be mitigated with some creative scripting.</p>\n<p>The problem: All along we have been advising people to clone <code>master</code> and then to run the publish process. This makes sense, as we want to make sure that the local setup is done correctly,  and the build can succeed. The problem is that the build modifies tracked files - the famous vscache files, but on occasion others, for example tools/tx/snomed/snomed.xml. This results in a set of files that are modified relative to the <code>master</code> branch but not part of it. If we now create a new branch locally, these modified files are mixing with the new branch. In most(?) cases that is OK, but I think it is a source of endless aggravation of the \"death by a thousand cuts\" type.</p>\n<ul>\n<li>\n<p>Possible mitigation 1 </p>\n<ul>\n<li>\n<p>Change the steps for making changes to be:</p>\n<ol>\n<li>clone <code>master</code> locally</li>\n<li>create the <em>feature</em> branch</li>\n<li>run the build in the <em>feature</em> branch</li>\n<li>make changes</li>\n<li>run the build</li>\n<li>...etc.</li>\n</ol>\n</li>\n<li>\n<p>change the build script to not allow the build to run in the <code>master</code> branch</p>\n</li>\n<li>change the build script to auto commit the changes to any uncommitted files after the build</li>\n</ul>\n</li>\n<li>\n<p>Possible mitigation 2</p>\n<ul>\n<li>Disallow direct branching and pull requests from branches, forcing all PRs to be from a fork. I think this will do more damage than good.</li>\n<li>change the build script to auto commit the changes to any uncommitted files after the build</li>\n</ul>\n</li>\n</ul>\n<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> <span class=\"user-mention\" data-user-id=\"248736\">@Mark Iantorno</span></p>",
        "id": 259583128,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1635541472
    },
    {
        "content": "<blockquote>\n<p>This results in a set of files that are modified relative to the master branch but not part of it. If we now create a new branch locally, these modified files are mixing with the new branch</p>\n</blockquote>\n<p>I don't know what those sentences mean</p>",
        "id": 259583925,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1635541961
    },
    {
        "content": "<p>Let's take tools/tx/snomed/snomed.xml - somehow the single quote in a description (cow's milk) got mangled into a sequence of the characters  '?' '&#8364;' '&#8482;' - before the build the euro and tm characters were represented by the corresponding entity codes, after the build they were converted to the actual characters. The file is now marked as modified. <code>git status</code> will show it as modified, but not staged for commit.</p>\n<p>If you create a branch: <code>git checkout -b test_branch</code> all the modified files that are not staged for commit will be in the new branch. <code>git status</code> will show them as part of the current branch. In most cases that is not a problem - if you now commit the modified files while in the <code>test_branch</code>, they will not show up in the <code>master</code> branch as modified. </p>\n<p>I think the problems may arise when not everything is properly committed, or things get committed by mistake in the <code>master</code> branch instead of the <code>test_branch</code>.</p>",
        "id": 259586275,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1635543392
    },
    {
        "content": "<p>I don't understand why changing the branch makes any difference. You still have a modified file to do something about</p>",
        "id": 259586383,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1635543477
    },
    {
        "content": "<p>True, but are the modifications from the first build run necessary after your run the build after you make changes? Does it matter if you commit them before you run your next build?</p>\n<p>I think the more we limit the chances of confusion of which branch we are modifying, the less will people experience edge cases that are hard to resolve.</p>",
        "id": 259587127,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1635544053
    },
    {
        "content": "<p>it means someone else should have committed them</p>",
        "id": 259587998,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1635544713
    },
    {
        "content": "<blockquote>\n<p>are the modifications from the first build run necessary after your run the build after you make changes? </p>\n</blockquote>\n<p>no. they'll just keep getting made </p>\n<blockquote>\n<p>Does it matter if you commit them before you run your next build?</p>\n</blockquote>\n<p>no</p>",
        "id": 259916991,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1635798759
    },
    {
        "content": "<p>so it presently takes my build 17 minutes longer to run without the vsCache. I can get rid of the files in vsCache, which means that </p>\n<ul>\n<li>everybody's first build of a new checkout will get ~20mins longer</li>\n<li>the ci-build will get 20min longer</li>\n</ul>",
        "id": 259917215,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1635798843
    },
    {
        "content": "<p>I think it is fairly straight forward to force committing any changes in vscache, source, and tools as part of the build script. That will save the 20 minutes of build, and will avoid issues with missing generated files.</p>",
        "id": 259918226,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1635799313
    },
    {
        "content": "<p>I will create a PR to modify <a href=\"http://publish.sh\">publish.sh</a></p>",
        "id": 259918313,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1635799337
    },
    {
        "content": "<p>I don't understand how a build script can force people to commit something when it doesn't cover the commit?</p>",
        "id": 259918667,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1635799519
    },
    {
        "content": "<p>The script will list all new files that have not been added into the \"stage\" (i.e. no <code>git add</code>). Then it will loop through them, and if they are under  one of tools/ vscache/ or source/ it will do a <code>git add</code> to them. After that, a <code>git commit -am \"Auto-commit courtesy to the publish script\"</code> will commit both those, and any modified but not committed files.</p>",
        "id": 259919817,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1635800018
    },
    {
        "content": "<p>wooah so git commits everything any time the build runs?</p>",
        "id": 259919959,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1635800068
    },
    {
        "content": "<p>Under certain folders. It can be limited to vscache/ only. <br>\nWhat is the use case for not committing everything that goes into the build?</p>",
        "id": 259922381,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1635801198
    },
    {
        "content": "<p>I'm working on some stuff, and I run the build to see if it works.</p>",
        "id": 259923642,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1635801917
    },
    {
        "content": "<p>What's the downside of having committed it?</p>",
        "id": 259923753,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1635801982
    },
    {
        "content": "<p>Commits should generally reflect an intent, and the commit history should tell a story (not just the story \"Then I built. Then I built. Then I built...\").</p>",
        "id": 259948825,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1635822417
    },
    {
        "content": "<p>But if there were really practical wins in abandoning this ideal... I think they'd be worth evaluating.</p>",
        "id": 259948852,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1635822459
    },
    {
        "content": "<p>looks likely that I'm going to replace vsCache altogether anyway, and they'll no longer be in version control. Josh and I worked out an alternative approach that will work better, actually, and it doesn't have merge clashes.</p>",
        "id": 260235806,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1636010008
    },
    {
        "content": "<p>I'm not going to describe it quite yet - still doing research whether it's feasible. But if it is... than those files will disappear (main build first, and then, when that's bedded down, the IGs as well)</p>",
        "id": 260235867,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1636010052
    },
    {
        "content": "<p>Another possible source of merge clashes might be the use of <code>rebase</code> instead of <code>merge</code>. While we never mention <code>rebase</code> in  any of the instructions, there was at least one mention of it in previous answers to git questions.</p>\n<p>Anyone seeing an issue with explicitly stating in the instructions not to use <code>rebase</code> for PRs?</p>",
        "id": 260270629,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1636033300
    },
    {
        "content": "<p>I don't know what it is and would never do it</p>",
        "id": 260312879,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1636049957
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  Rebase definitely has its uses.  I just used it to streamline our commits (primarily consolidating and removing all of the excess \"update txcache\" commits) and then moving only the needed updates from our IPS development (i.e. 'connectathon*') branches into the CI build.  The interactive rebase worked quite well for that.  But typically you do <strong>not</strong> want to do that (or at least do it <strong>very</strong> judiciously) with any commits that have been pushed to a central repository and others may have accessed and are using.  I agree with <span class=\"user-mention\" data-user-id=\"192685\">@Vassil Peytchev</span> that inappropriate use of rebase would certainly be a source of merge conflicts.</p>",
        "id": 260314702,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1636050742
    },
    {
        "content": "<p>Yeah, I wouldn't \"forbid\" rebasing for users that want to take this upon themselves during branch development on their own machines, but we've (since the beginning) configured the GitHub web interface for the FHIR repo to only allow merges, not rebases: </p>\n<p><a href=\"/user_uploads/10155/66pQIu4UkMlzoy2lhIsGscyy/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/66pQIu4UkMlzoy2lhIsGscyy/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/66pQIu4UkMlzoy2lhIsGscyy/image.png\"></a></div>",
        "id": 260315237,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1636051002
    },
    {
        "content": "<p>How about the step before - locally merge master into feature branch?</p>",
        "id": 260315631,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1636051189
    },
    {
        "content": "<p>This is something developers can control how they want to do on their own side. I think our recommendations should be just to do simple merges, but if a developer wants to rebase for some reason it's really up to them, or I would say it's below the abstraction barrier because we don't have direct insight into what happens there.</p>",
        "id": 260318998,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1636052628
    },
    {
        "content": "<p>Agree.</p>",
        "id": 260319637,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1636052918
    },
    {
        "content": "<p>I think using rebase to pull changes  from master into the feature branch since the branch was created is dangerous. I want to put a warning <a href=\"https://github.com/hl7/fhir/wiki/Get-Started-with-FHIR-on-GitHub\">on step 8 here</a> not to use <code>rebase</code>.</p>",
        "id": 260321484,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1636053890
    },
    {
        "content": "<p>see <a href=\"#narrow/stream/179165-committers/topic/txCache.20is.20out\">https://chat.fhir.org/#narrow/stream/179165-committers/topic/txCache.20is.20out</a> about the tx-cache</p>",
        "id": 260950067,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1636525039
    },
    {
        "content": "<p>Fine by me to add a warning; folks should not use rebase unless they know what they're doing and why</p>",
        "id": 261001514,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1636556350
    },
    {
        "content": "<p>who is using rebase without knowing what it is or why... I certainly don't have a clue</p>",
        "id": 261018326,
        "sender_full_name": "John Moehrke",
        "timestamp": 1636563126
    },
    {
        "content": "<p>For individuals, rebasing makes a lot of sense <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> see <a href=\"https://medium.datadriveninvestor.com/git-rebase-vs-merge-cc5199edd77c\">https://medium.datadriveninvestor.com/git-rebase-vs-merge-cc5199edd77c</a>. i often us it for ig development before merging it into the main to have  the history streamlined.</p>",
        "id": 261051494,
        "sender_full_name": "Oliver Egger",
        "timestamp": 1636576783
    },
    {
        "content": "<p>Key paragraph from the link, and, AFAIK, reflecting generally accepted best practices (emphasis mine):</p>\n<blockquote>\n<p>If the feature branch you are getting changes from is <strong>shared with other developers</strong>, rebasing is <strong>not recommended</strong>, because the rebasing process will create <strong>inconsistent repositories</strong>. For individuals, rebasing makes a lot of sense.</p>\n</blockquote>\n<p>Since pull requests need to pass the build checks, I view these branches as <strong>shared with other developers</strong>. But mainly, the step when you merge <code>master</code> into the feature branch in order to run the build locally and confirm that nothing is broken, should never be a rebase.</p>",
        "id": 261054365,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1636578190
    }
]