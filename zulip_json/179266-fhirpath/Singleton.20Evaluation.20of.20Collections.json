[
    {
        "content": "<p>I have a question about the rules outlined in <a href=\"http://hl7.org/fhirpath/N1/#singleton-evaluation-of-collections\" title=\"http://hl7.org/fhirpath/N1/#singleton-evaluation-of-collections\">http://hl7.org/fhirpath/N1/#singleton-evaluation-of-collections</a></p>\n<p>From the rules I gather \"true and 'foo'\" evaluates to true. <strong>What about \"(true | 'foo').allTrue()\"?</strong> In this case I don't believe 'foo' is an argument of allTrue() so I wouldn't expect it to be treated as true. However, that leaves us with two seemly equivalent expressions that evaluate to different results. Is my interpretation of the rules outlined in Singleton Evaluation of Collections incorrect? Specifically the limitation that the rules only apply \"when a collection is passed as an argument to a function or operator that expects a single item as input\" which I believe would preclude it's application in the case of allTrue().</p>",
        "id": 195996524,
        "sender_full_name": "Aaron Nash",
        "timestamp": 1588359616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252986\">Aaron Nash</span> <a href=\"#narrow/stream/179266-fhirpath/topic/Singleton.20Evaluation.20of.20Collections/near/195996524\" title=\"#narrow/stream/179266-fhirpath/topic/Singleton.20Evaluation.20of.20Collections/near/195996524\">said</a>:</p>\n<blockquote>\n<p>From the rules I gather \"true and 'foo'\" evaluates to true.</p>\n</blockquote>\n<p>That does not look correct to me.  The <a href=\"http://hl7.org/fhirpath/N1/#and\" title=\"http://hl7.org/fhirpath/N1/#and\">\"and\" operator</a> requires both operands to evaluate to true, and 'foo' is not a string that converts to true.  Also, string to boolean conversion is explicit, so you would need to call toBoolean() on it.</p>",
        "id": 196006977,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1588365478
    },
    {
        "content": "<p>right. My engine says \"(true and 'foo').empty()\"</p>",
        "id": 196007139,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588365573
    },
    {
        "content": "<p>That seems to contradict the rules under Singleton Evaluation of Collections where it states, \"when a collection is passed as an argument to a function or operator that expects a single item as input\" then \"[...] IF the collection contains a single node AND the expected input type is Boolean THEN The collection evaluates to true\"</p>",
        "id": 196008095,
        "sender_full_name": "Aaron Nash",
        "timestamp": 1588366098
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/a7pFAVQLUsrb8QaOKUbJRUzD/fhirpath-snippet.png\" title=\"fhirpath-snippet.png\">Example from spec</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/a7pFAVQLUsrb8QaOKUbJRUzD/fhirpath-snippet.png\" title=\"Example from spec\"><img src=\"/user_uploads/10155/a7pFAVQLUsrb8QaOKUbJRUzD/fhirpath-snippet.png\"></a></div>",
        "id": 196008695,
        "sender_full_name": "Aaron Nash",
        "timestamp": 1588366403
    },
    {
        "content": "<p>I see.  In \"true and 'foo'\", the 'foo' is a collection of a single node that is not convertible to Boolean, yet the expected type of \"and\" is Boolean, so per the spec you quoted, that collection ('foo') should evaluate to true in this context.</p>",
        "id": 196009104,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1588366613
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> ?</p>",
        "id": 196009315,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1588366730
    },
    {
        "content": "<p>Yes, that is the intent of that language in the spec, and the behavior is tested with <a href=\"https://github.com/HL7/FHIRPath/blob/master/tests/r4/tests-fhir-r4.xml#L8\" title=\"https://github.com/HL7/FHIRPath/blob/master/tests/r4/tests-fhir-r4.xml#L8\">testPatientHasBirthDate</a> (though there clearly ought to be a test like the one you're suggesting <code>true and 'foo'</code>. The intent was to make it more intuitive to express some constraints, but the spec intentionally does not support converting any singleton value to a <code>true</code> boolean, the behavior only applies when evaluating a collection as input to a boolean-valued argument.</p>",
        "id": 196063950,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1588443826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> Are you saying that <code>true and 'foo'</code> should evaluate to <code>true</code>, <code>false</code> or <code>empty</code>?</p>",
        "id": 196198259,
        "sender_full_name": "John Timm",
        "timestamp": 1588606608
    },
    {
        "content": "<p>Should the statement \"true and 'foo'\" care about the singleton rules at all? Isn't 'foo' a string literal and not a collection? it seems to me that this particular line is a bad way of testing out singleton evaluations..</p>",
        "id": 196207775,
        "sender_full_name": "ryan moehrke",
        "timestamp": 1588610628
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192334\">@John Timm</span> I believe Bryn is saying <code>true and 'foo'</code>should evaluate to <code>true</code>. He responded \"yes\" to Paul's question that specifically asked if 'foo' should evaluate to true in that context.</p>",
        "id": 196208534,
        "sender_full_name": "Aaron Nash",
        "timestamp": 1588611017
    },
    {
        "content": "<p>Even <code>'foo'</code> is a collection, so you can do <code>'foo'.last()</code> if you wanted.  And <code>Patient.name = 'ewout'</code> would compare two collections.</p>",
        "id": 196208590,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1588611042
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> With your answer in mind, would <code>(true | 'foo').allTrue()</code> evaluate to <code>true</code>? That's less clear to me.</p>",
        "id": 196208917,
        "sender_full_name": "Aaron Nash",
        "timestamp": 1588611189
    },
    {
        "content": "<p>what about (true and 'false')?<br>\n'false' is convertable to a Boolean</p>",
        "id": 196212891,
        "sender_full_name": "John Timm",
        "timestamp": 1588613118
    },
    {
        "content": "<p>Yes, <code>true and 'foo'</code> would evaluate to true, but <code>(true | 'foo').allTrue()</code> would be an error because 'foo' cannot be converted to a boolean value, and the allTrue() operation expects a collection of boolean values.</p>",
        "id": 196213836,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1588613572
    },
    {
        "content": "<p>And <code>(true | 'foo').where($this)</code>? The documentation for where() states that each element is evaluated \"consistent with singleton evaluation of collections behavior.\" Given that expected type for each element is a boolean and the rules state that if \"the collection contains a single node AND the expected input type is Boolean\" I would expect that expression to evaluate to <code>true</code>. Though depending how I read the rest of the documentation, I could see that statement being qualified by the requirement that the element is a Boolean prior to following the rules for singleton evaluation of collections.</p>",
        "id": 196216461,
        "sender_full_name": "Aaron Nash",
        "timestamp": 1588614939
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192334\">@John Timm</span> A String does not implicitly convert to a Boolean so <code>(true and 'false')</code> evaluates to <code>true</code> just as <code>(true and 'foo')</code> (see <a href=\"http://hl7.org/fhirpath/N1/#conversion\" title=\"http://hl7.org/fhirpath/N1/#conversion\">http://hl7.org/fhirpath/N1/#conversion</a>)</p>",
        "id": 196216853,
        "sender_full_name": "Aaron Nash",
        "timestamp": 1588615116
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252986\">@Aaron Nash</span> The spec says:</p>\n<div class=\"codehilite\"><pre><span></span><code>IF the collection contains a single node AND the node&#39;s value can be converted to the expected input type THEN\n</code></pre></div>\n\n\n<p>It doesn't say <code>implicitly</code> or <code>explicitly</code> just \"can be converted\". <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> what say you?</p>",
        "id": 196220867,
        "sender_full_name": "John Timm",
        "timestamp": 1588616913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252986\">@Aaron Nash</span> This is a test case in the suite:</p>\n<div class=\"codehilite\"><pre><span></span><code>(0).not() = true\n</code></pre></div>\n\n\n<p>It would appear that the expectation is that <code>0</code> is converted <code>implicitly</code> to a boolean false. This is, of course, despite what the table says here:<br>\n<a href=\"http://hl7.org/fhirpath/N1/#conversion\" title=\"http://hl7.org/fhirpath/N1/#conversion\">http://hl7.org/fhirpath/N1/#conversion</a></p>",
        "id": 196221487,
        "sender_full_name": "John Timm",
        "timestamp": 1588617197
    },
    {
        "content": "<p>In the <a href=\"http://hl7.org/fhirpath/#conversion\" title=\"http://hl7.org/fhirpath/#conversion\">Conversion</a> topic, it defines implicit vs explicit as implicit \"happens automatically\" as opposed to explicit which \"require\" use of the conversion function. On that read, <code>true and 'false'</code> would indeed be true, but there is room in the wording for Singleton Evaluation of collections to interpret that \"can be converted\" as either implicitly or explicitly, since it's a different context than just function argument evaluation. That seems to me to be need a clarification, and would lean heavily on what implementations currently do to provide that clarification.</p>",
        "id": 196221892,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1588617398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> There are several examples in the test suite that indicate <code>implicit</code> conversion is the expectation. Our implementation currently uses implicit conversion.</p>",
        "id": 196222116,
        "sender_full_name": "John Timm",
        "timestamp": 1588617525
    },
    {
        "content": "<p>It's implicit in my .NET implementation.</p>",
        "id": 196223051,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1588617908
    },
    {
        "content": "<p>I would find it confusing if the conversion table says the conversion is \"explicit\" but then there are cases where it happens implicitly.</p>",
        "id": 196250445,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1588633253
    },
    {
        "content": "<p>In addition, allowing a singleton evaluation of a collection to preform \"explicit\" conversions significantly erodes the language's ability to use its type system to catch user mistakes. Any function that accepts a String would then be able to accept any primitive. That might be desirable in some situations but given the existence of the implicit/explicit conversion table it seems like that was not the original intention when the spec was written.</p>",
        "id": 196253220,
        "sender_full_name": "Aaron Nash",
        "timestamp": 1588635867
    },
    {
        "content": "<p>I agree, and can say with confidence that is the intent of defining implicit vs explicit conversions. <span class=\"user-mention\" data-user-id=\"252986\">@Aaron Nash</span> , would you be willing to submit a tracker to request clarification for this item?</p>",
        "id": 196330535,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1588695544
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> Sure. I'll take care of that this afternoon.</p>",
        "id": 196330995,
        "sender_full_name": "Aaron Nash",
        "timestamp": 1588695769
    },
    {
        "content": "<p><a href=\"https://jira.hl7.org/browse/FHIR-27033\" title=\"https://jira.hl7.org/browse/FHIR-27033\">https://jira.hl7.org/browse/FHIR-27033</a></p>",
        "id": 196339703,
        "sender_full_name": "Aaron Nash",
        "timestamp": 1588699793
    },
    {
        "content": "<p>In the R4 tests, there is \"(0).not() = true\".   Is that in error?  I did not see mention in the above tracker item about correcting that.  Conversion between Integers and Booleans is Explicit, so per the resolution of that tracker item, I would expect that test to return false.</p>",
        "id": 229774416,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1615423765
    },
    {
        "content": "<p>That's my interpretation of that tracker as well, the implicit conversion to boolean there is not allowed and that causes <code>(0).not()</code> to return false (because the singleton evaluation is effectively an exists test when used in a boolean context).</p>",
        "id": 229953669,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1615508948
    }
]