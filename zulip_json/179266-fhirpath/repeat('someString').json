[
    {
        "content": "<p>repeat takes an expression, which could be a constant.  What should the behavior be in that case?  If you have a collection \"a\", and call a.repeat('blue'), would you expect to get one blue for each item in 'a', or one blue in total?  (I am not suggesting this is a useful thing to do, but trying to nail down what the correct behavior would be.)</p>",
        "id": 276259415,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1647985590
    },
    {
        "content": "<p>The definition says:</p>\n<blockquote>\n<p>as long as the projection yields new items</p>\n</blockquote>\n<p>So if you call <code>a.repeat('blue')</code>, let's say initially <code>a</code> refers to a collection like<code>[1,2,3]</code>. The way I read it, the processing would be:</p>\n<h3>Begin Round 1 with inputs = <code>[1, 2, 3]</code></h3>\n<ul>\n<li>Evaluate <code>'blue'</code> for the input item <code>1</code><ul>\n<li>--&gt; evaluated items is <code>[1]</code></li>\n<li>--&gt; Round 1 output is <code>['blue']</code></li>\n</ul>\n</li>\n<li>Evaluate <code>'blue'</code> for the input item <code>2</code><ul>\n<li>--&gt; evaluated items is <code>[1, 2]</code></li>\n<li>--&gt; output is <code>['blue']</code>  (tried adding a 2nd time but it's not unique!)</li>\n</ul>\n</li>\n<li>Evaluate <code>'blue'</code> for the input item <code>3</code><ul>\n<li>--&gt; evaluated items is <code>[1, 2, 3]</code></li>\n<li>--&gt; output is <code>['blue']</code>(tried adding a 3nd time but it's not unique!)</li>\n</ul>\n</li>\n</ul>\n<h3>Round 1 complete, and the (outputs - evaluated) is not empty, so... begin Round 2 with inputs = <code>['blue']</code> (from Round 1's outputs)</h3>\n<ul>\n<li>Evaluate <code>'blue'</code> for the input item <code>'blue'</code><ul>\n<li>--&gt; evaluated items is <code>[1, 2, 3, 'blue']</code></li>\n<li>--&gt; output is <code>['blue']</code>(tried adding a 4th time but it's not unique!)</li>\n</ul>\n</li>\n</ul>\n<h3>Round 2 complete and (outputs - evaluated) is empty, so ... we're done!</h3>",
        "id": 276271148,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1647993837
    },
    {
        "content": "<p>Ooh, I see BTW why you're asking -- the <a href=\"https://hl7.github.io/fhirpath.js\">https://hl7.github.io/fhirpath.js</a> crashes when you ask it to evaluate <code>Patient.name.repeat('test')</code> ;-)</p>",
        "id": 276271352,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1647993972
    },
    {
        "content": "<p>Indeed it does.  I came across this when I accidentally wrote Questionnaire.repeat('item') instead of Questionnaire.repeat(item).</p>",
        "id": 276386847,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1648063273
    },
    {
        "content": "<p>It is not clear to me from the documentation that the check for existing items occurs after each item or after each round, and I am not sure which is the better approach because it is hard to image a use case for doing this.  Anyway, as Bryn agrees with your interpretation, I will file a tracker item to add a clarification.  Thanks for the very clear example.</p>",
        "id": 276387654,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1648063697
    },
    {
        "content": "<p><a href=\"http://jira.hl7.org/browse/FHIR-36588\">FHIR-36588</a></p>",
        "id": 276388801,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1648064288
    },
    {
        "content": "<p>p.s. That kills the dotnet fhirpath engine too. It never checks if the new node already existed (using <code>=</code>) so execution never stops.<br>\nThis is where that code is in the donet SDK, will log it.<br>\n<a href=\"https://github.com/FirelyTeam/firely-net-common/blob/ba31e20d00dd0f2c5e0d56ceefa4fff4d686b309/src/Hl7.FhirPath/FhirPath/Expressions/SymbolTableInit.cs#L347\">https://github.com/FirelyTeam/firely-net-common/blob/ba31e20d00dd0f2c5e0d56ceefa4fff4d686b309/src/Hl7.FhirPath/FhirPath/Expressions/SymbolTableInit.cs#L347</a></p>",
        "id": 276545313,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1648159402
    },
    {
        "content": "<p><a href=\"https://github.com/FirelyTeam/firely-net-sdk/issues/2018\">https://github.com/FirelyTeam/firely-net-sdk/issues/2018</a></p>",
        "id": 276552468,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1648164306
    },
    {
        "content": "<p>that also did it for the Java engine as well. Fixed next release</p>",
        "id": 277219763,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648686698
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span>  We made a change to add the uniqueness check in your algorithm above, but I am having some doubts about that.  I think if you write Questionnaire.repeat(extension), you just want all of the extensions, and don't care whether they are unique or not.</p>",
        "id": 277436862,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1648827599
    },
    {
        "content": "<p>Thinking about a FHIR Questionnaire as a tree of nodes.... you're saying you want to see <em>the same node</em> more than once? Or just that if semantically equivalent nodes appear at different positions in the tree, you'd want to see all of those?</p>",
        "id": 277450878,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648833555
    },
    {
        "content": "<p>The latter.  I don't think repeat could find the exact same node in a tree more than once.</p>",
        "id": 277450938,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1648833595
    },
    {
        "content": "<p>However, the specification does say it stops when the projection does not yield \"new items (as determined by the = (Equals) (=) operator).\", so I don't see how my example of Questionnaire.repeat(extension) could be expected to return a complete list of the extensions on the root of the Questionnaire.   In other words, I am withdrawing my question about the algorithm.</p>",
        "id": 277481554,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1648849336
    },
    {
        "content": "<p>The requirement to do an Equals comparison means doing deep equals for Questionnaire items, and the complexity of the algorithm is O(n**2).  On one test Questionnaire with 772 questions, it was faster to call descendants() than to call repeat(item).  For a short questionnaire with only 10 items, descendants() and repeat(item) were about the same, which is disappointing, because I've been thinking repeat(item) should be much faster.   It is also a bit frustrating since in this case the items should all be unique due to their linkIds, and the uniqueness check is just a waste of time. We are looking at possibly building a hash to speed up comparisons, at least when there are a large of number of items.</p>",
        "id": 277490542,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1648855824
    },
    {
        "content": "<p>And if you're doing that on questionnaireresponse. Item, you could legitimately have dups, but this might remove them. I'm not sure if that's sensible, but if that's what the response has, it wouldn't return it.</p>",
        "id": 277513439,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1648885328
    },
    {
        "content": "<p>Maybe we should have repeat(...) and repeatUnique(...)?</p>",
        "id": 277743043,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1649084165
    },
    {
        "content": "<p>I am not sure there is really a need for the uniqueness check, except as a way to avoid endless loops like repeat('someString').  If someone wanted uniqueness, they could always call repeat(something).distinct().</p>",
        "id": 277743644,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1649084402
    },
    {
        "content": "<p>I like that concept, and engines could just have (effectively) a \"stack depth limit\" or \"iteration limit\" that could prevent <em>actual endless loops</em> in unbounded or pathological cases.</p>",
        "id": 277752076,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1649087610
    },
    {
        "content": "<p>but this would be a breaking change to normative content.</p>",
        "id": 277795690,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1649107403
    },
    {
        "content": "<p>so you'd really have to propose adding a .repeatNonUnique(xxx)</p>",
        "id": 277795715,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1649107425
    },
    {
        "content": "<p>And to propose deprecating the old one</p>",
        "id": 277804733,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1649112806
    },
    {
        "content": "<p>I'll propose some tests with expected results to conoare/discuss.<br>\n(for unit testing the implementations with)</p>",
        "id": 277816641,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1649121626
    },
    {
        "content": "<p>why deprecate ?</p>",
        "id": 277818339,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1649123641
    },
    {
        "content": "<p>If (from the discussion above) all known use cases are accounted for by other invocations and performance with the old definition is likely to be an issue.</p>",
        "id": 277824370,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1649130397
    },
    {
        "content": "<p>but it still works, so why force people to change?</p>",
        "id": 277824743,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1649130937
    },
    {
        "content": "<p>If it works reliably, no reason. If it's a performance pitfall that people will hit when they least expect, that's a reason.</p>",
        "id": 277826392,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1649132913
    },
    {
        "content": "<p>it does work reliably and it's the right thing to do in many cases. Paul found one case where it's slower than an alternative, but that's no grounds to deprecate it</p>",
        "id": 277826675,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1649133271
    },
    {
        "content": "<p>Created <a href=\"http://jira.hl7.org/browse/FHIR-36708\">FHIR-36708</a> for \"repeatNonUnique\".</p>",
        "id": 277937052,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1649189467
    }
]