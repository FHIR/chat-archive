[
    {
        "content": "<p>Did the rules around = and ~ for partial DateTime and Time change between <a href=\"http://hl7.org/fhirpath/\" target=\"_blank\" title=\"http://hl7.org/fhirpath/\">http://hl7.org/fhirpath/</a> and <a href=\"http://hl7.org/fhirpath/2018Sep/\" target=\"_blank\" title=\"http://hl7.org/fhirpath/2018Sep/\">http://hl7.org/fhirpath/2018Sep/</a>, or was it simply clarified in the latter?  Also, in the latter, there seem to be two contradictory statements (from 6.1.1. = (Equals)):</p>\n<p>1) \"For Date, DateTime and Time equality, the comparison is performed at the unit with the most precision of either input.\" (which suggests that comparison between two DateTimes of differing precision should be attempted)</p>\n<p>2) \"If the input values have different levels of precision, the result is empty ({ }).\" (which says the comparison between two DateTimes of differing precision should always result in empty).</p>",
        "id": 160328241,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1552081315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span></p>",
        "id": 160468538,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1552301863
    },
    {
        "content": "<p>The rules for equality were brought into alignment with what the various engines were doing. There was variability in the behaviors, and the spec wasn't as clear as it could have been, so we clarified in the 2018Sep ballot, and have since clarified further. If you look at the 2019May draft: <a href=\"https://github.com/FHIR/fluentpath/blob/master/spec/2019May/index.adoc#equality\" target=\"_blank\" title=\"https://github.com/FHIR/fluentpath/blob/master/spec/2019May/index.adoc#equality\">https://github.com/FHIR/fluentpath/blob/master/spec/2019May/index.adoc#equality</a> that's the clarified description (though there may still be some minor edits as I finish applying the trackers over the next few days).</p>",
        "id": 160634487,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1552451794
    },
    {
        "content": "<p>Per the link provided by <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> for the May version, the algorithm for determining equality would result in:</p>\n<div class=\"codehilite\"><pre><span></span>2012-01 = 2012 // empty\n2012-01 = 2011 // false\n2012-01 ~ 2012 // false\n</pre></div>\n\n\n<p>Questions:<br>\n1) Is that the desired behavior?<br>\n2) How is returning empty in the above case (instead of false due to the differing precision) useful?</p>\n<p>Comment:  It would be more efficient to return empty whenever the precision differed, and only otherwise proceed to checking equality, because only a single check for equality would be needed.</p>",
        "id": 160881729,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1552661414
    },
    {
        "content": "<p>Because the first equality comparison is asking whether some day in the month of January of 2012 is equal to some day in the year 2012, and how can we know whether that's the case?</p>",
        "id": 160882534,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1552661976
    },
    {
        "content": "<p>And what does 2012-01 ~ 2012 ask?</p>",
        "id": 160882677,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1552662055
    },
    {
        "content": "<p>Where they are equivalent, in which case we don't care about the uncertainty.</p>",
        "id": 160882742,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1552662114
    },
    {
        "content": "<p>Does that help?</p>",
        "id": 160884507,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1552663279
    },
    {
        "content": "<p>Yes, although I am confused about the motivation for this behavior.   It would be helpful if the spec could include some use cases to support it, because it is not the only behavior one could imagine.  For instance, \"2012-01-14 = 2012\" could be asking the question \"is there overlap between the two implied ranges of time\" or \"are they equal to the common precision\".   I am not saying that that functionality is needed, but I would have expected = or ~ to support that.</p>",
        "id": 160889423,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1552666679
    },
    {
        "content": "<p>I can see using <code>=</code> for \"are they equal to the common precision\", but that's a less general operation and so would want to see a different operation that specifically did that (comparison to a specified precision). I have a hard time seeing <code>=</code> being a reasonable symbol to use to ask the question \"is there overlap between the two implied ranges of time\" though.</p>",
        "id": 160925639,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1552697128
    },
    {
        "content": "<p>The defined behaviour for = and ~ in dates makes sense to me. <br>\nIt seems that some more date functions are needed; maybe <br>\noverlapDate(date,date):boolean - returns true when, after truncating the more precise date to be the same as the less precise date, the results are equal.  <br>\nand<br>\ntruncDate(date, precision):date</p>",
        "id": 161021266,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1552867720
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span>  With the algorithm outlined in the <a href=\"https://github.com/FHIR/fluentpath/blob/master/spec/2019May/index.adoc#equality\" target=\"_blank\" title=\"https://github.com/FHIR/fluentpath/blob/master/spec/2019May/index.adoc#equality\">May version</a>, what is the result of:</p>\n<div class=\"codehilite\"><pre><span></span>@2018-02-03T22-04:00 = @2018-02-04T06:01+04:00\n</pre></div>\n\n\n<p>This is the same date time, expressed in different time zones, and at different precisions.  I think the answer will clarify what \"respecting timezone offsets\" means in the phrase, \"the comparison is performed by considering each precision in order, beginning with years (or hours for time values), and respecting timezone offsets\".  My first attempt to follow that resulted in a comparison of \"2018\" at -04:00 with \"2018\" at +04:00, which would be false, but I think the answer for the expression above is supposed to be \"empty\".</p>",
        "id": 161351199,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1553179186
    },
    {
        "content": "<p>Right, for comparisons, if either or both of the inputs have a timezone offset, the values have to be converted to a common timezone offset prior to running the comparison, which would then result in empty because the values have differing precision.</p>",
        "id": 161352470,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1553179858
    }
]