[
    {
        "content": "<p>The validator is blowing up saying that toDate is 'not done yet' with this expression:<br>\n((now().toDate() - $this) &lt;= 24 months) or value.length()=4</p>\n<p>(context is Patient.birthDate)</p>\n<p>Is there a way I can perform this function without using toDate()?  (If I just remove it, the publisher yells that you can't use the '-' operator with two different types - dateTime and date. )</p>",
        "id": 216042556,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1604895256
    },
    {
        "content": "<p>Could you make them strings?</p>",
        "id": 216045002,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1604899527
    },
    {
        "content": "<p><span aria-label=\"nauseated\" class=\"emoji emoji-1f922\" role=\"img\" title=\"nauseated\">:nauseated:</span></p>",
        "id": 216045005,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1604899546
    },
    {
        "content": "<p>looks like there's a today() instead of now() does that work for you? <a href=\"http://hl7.org/fhirpath/#current-date-and-time-functions\">http://hl7.org/fhirpath/#current-date-and-time-functions</a></p>",
        "id": 216096613,
        "sender_full_name": "ryan moehrke",
        "timestamp": 1604934565
    },
    {
        "content": "<p>Awesome!  Never thought to look for a date-specific function.  That fixed my issue.  Thanks <span class=\"user-mention\" data-user-id=\"237342\">@ryan moehrke</span></p>",
        "id": 216133941,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1604950857
    },
    {
        "content": "<p>With the date math functions, I'm adding support for this into the dotnet libs and have an issue with  <code>@2016 + 365 days</code> adding to return <code>365</code>. (defined in this section in the spec <a href=\"http://hl7.org/fhirpath/N1/#addition-2\">http://hl7.org/fhirpath/N1/#addition-2</a>)<br>\nwhere is the \"standard year length\" defined, and is there a standard month length too?<br>\nWhat would happen if we said <code>@2016-01 + 365 days</code> should that also return the same value?<br>\nHow about <code>@2016-02 + 28 days</code>?<br>\nThe fhirpathjs engine returns <code>2016</code> which is what my initial implementation has done too, and <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> pointed out that it was wrong...</p>\n<p>I know this doesn't have the partial date semantics either, but...<br>\n<a href=\"https://www.timeanddate.com/date/dateadded.html?d1=01&amp;m1=01&amp;y1=2016&amp;type=add&amp;ay=&amp;am=&amp;aw=&amp;ad=365&amp;rec=\">https://www.timeanddate.com/date/dateadded.html?d1=01&amp;m1=01&amp;y1=2016&amp;type=add&amp;ay=&amp;am=&amp;aw=&amp;ad=365&amp;rec=</a></p>",
        "id": 261116609,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1636626997
    },
    {
        "content": "<p>I personally think this should do what I (and what I assume the fhirpathjs implementation have done) for partials, assume was 1st of Jan that year (or whatever partial it was) perform the addition, then trim the days/months off (whatever the original precision was)<br>\nThis magic average year surprised me - and there isn't a magic month length defined also...</p>",
        "id": 261118348,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1636628055
    },
    {
        "content": "<p>there does seem to be a conversion table defined<br>\n<a href=\"http://hl7.org/fhirpath/N1/#quantity-conversion-functions\">http://hl7.org/fhirpath/N1/#quantity-conversion-functions</a><br>\nso according to this a standard month is 30 days</p>",
        "id": 261150305,
        "sender_full_name": "ryan moehrke",
        "timestamp": 1636645959
    },
    {
        "content": "<p>but it does seem rather strange that the spec requires you respecting variable length periods for when precision matches (?) but once there is a precision mismatch just use a standard conversion table, I'm not sure I understand the reasoning behind that decision</p>",
        "id": 261150516,
        "sender_full_name": "ryan moehrke",
        "timestamp": 1636646052
    },
    {
        "content": "<p>The motivation was to provide a consistent algorithm for applying to date/time arithmetic when the precision of the date/time value was lower than the precision of the time quantity being added. It does result in some surprises like those examples, but that's why we added those example specifically, to illustrate that behavior. The only time we can guarantee calendar arithmetic semantics is when the time quantity can be anchored to the date/time value, and that requires at least the precision of the time quantity.</p>",
        "id": 261167715,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1636654465
    },
    {
        "content": "<p>Thanks Bryn, at least I see the full conversion routines now.<br>\n<span class=\"user-mention\" data-user-id=\"195344\">@Paul Lynch</span> I guess we need to update the fhirpathjs implementation too here.<br>\nAre those specific examples in the fhirpath test suite? (and the Java implementation also doing the same thing)</p>",
        "id": 261186472,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1636666107
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> -- Yes, thanks for pointing that out. I will add a ticket for it.</p>",
        "id": 261279421,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1636735697
    },
    {
        "content": "<p>In implementing the date math on a partial month value, there is no logic defined on how to add weeks...<br>\nAs I see it there are 2 choices here:</p>\n<div class=\"codehilite\"><pre><span></span><code>case &quot;weeks&quot;:\n           if (dateValue.Precision == DateTimePrecision.Year)\n                dto = dateValue._parsedValue.AddYears((int)(addValue.Value / 52));\n           else if (dateValue.Precision == DateTimePrecision.Month)\n                dto = dateValue._parsedValue.AddMonths((int)(addValue.Value * 7 / 30)); // convert to days in a week over a month\n            else\n                dto = dateValue._parsedValue.AddDays(((int)addValue.Value) * 7);\n            break;\n</code></pre></div>\n<p>or </p>\n<div class=\"codehilite\"><pre><span></span><code>case &quot;weeks&quot;:\n           if (dateValue.Precision == DateTimePrecision.Year)\n                dto = dateValue._parsedValue.AddYears((int)(addValue.Value / 52));\n           else if (dateValue.Precision == DateTimePrecision.Month)\n                dto = dateValue._parsedValue.AddMonths((int)(addValue.Value/52*12)); // convert to weeks in the year over a month\n            else\n                dto = dateValue._parsedValue.AddDays(((int)addValue.Value) * 7);\n            break;\n</code></pre></div>\n<p>the latter of these makes more sense to me.</p>",
        "id": 261565424,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1637013455
    },
    {
        "content": "<p>The spec has language that talks about dealing with weeks as 7 days, so I think it would make sense to say, multiply the weeks value by 7 and then do the same thing you would do with days.</p>",
        "id": 261571228,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1637016240
    },
    {
        "content": "<p>(checking with Excel) the difference between the 2 options gives different answer at 30 and 43 under 52, but when you go over 100 weeks the 2 options give the same result only 50%(ish) of the time.<br>\nSo I think we should get this defined...<br>\nI'll log a tracker, and I do think given the way the others are defined, we should go with the more accurate intention of average weeks in a year.<br>\nAnd beyond 377 weeks, they are never the same</p>",
        "id": 261591830,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1637031263
    },
    {
        "content": "<p><a href=\"https://jira.hl7.org/browse/FHIR-34315\">https://jira.hl7.org/browse/FHIR-34315</a></p>",
        "id": 261598558,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1637039172
    },
    {
        "content": "<p>Is there a reason not to handle it the same as days? i.e. always treat it like weeks * 7?</p>",
        "id": 261655868,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1637075880
    },
    {
        "content": "<p>Accuracy? Ave days in a month is less precise than avg weeks in a month, it's all feeling very random to me.<br>\n(you don't have days precision, and you haven't provided days precision)</p>",
        "id": 261720821,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1637103989
    },
    {
        "content": "<p>Do they work better with the value for weeks in a year not being 52, but being 365/7 (~52.143) or 365.25/7 (~52.179)?</p>",
        "id": 261730939,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1637110564
    },
    {
        "content": "<p>We already don't have accuracy with un-anchored calendar calculations. Seems like consistency with days behavior is preferable, especially given that we say in the spec \"Calculations involving weeks are equivalent to multiplying the number of weeks by 7 and performing the calculation for the resulting number of days.\"</p>",
        "id": 261792722,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1637159940
    },
    {
        "content": "<p>Ok. That's what I'll put in the dotnet implementation then l, and reference back to the tracker.<br>\nSeems that's what you and Ewout both concluded too.</p>",
        "id": 261827836,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1637174016
    },
    {
        "content": "<p>In updating the dotnet implementation to handle the date math, we fixed the handling quite a lot and in doing so we've come across a few unit tests from the spec that are failing now that we believe are actually wrong according to the spec.</p>\n<p>==== Running tests from file 'TestData\\fhirpath\\tests-fhir-r4.xml' ====<br>\nFAIL: testTypes - testStringQuantityDayLiteralToQuantity: '1 day'.toQuantity() = 1 'd'<br>\n       (AssertFailedException) Assert.Fail failed. Expected a non-empty result</p>\n<p>According to the fhirpath spec, 1 year is approximately 1 a, not equivalent, and same with <code>day</code>(calendar) and <code>d</code> (UCUM)<br>\n<a href=\"http://hl7.org/fhirpath/N1/#time-valued-quantities\">http://hl7.org/fhirpath/N1/#time-valued-quantities</a><br>\n<code>1 year'.toQuantity() = 1 'a'</code></p>\n<p>And this one too - under what basis does the <code>toString</code> on the quantity do this conversion?<br>\n(as the fhir type Quantity can hold both, and thus needs to be able to hold it and why would a to string on a fhir type produce something different? - note that we couldn't spot anything in the spec explicitly saying that it SHOULD do this)<br>\nFAIL: testTypes - testQuantityLiteralWeekToString: 1 week.toString()<br>\n       (AssertFailedException) Assert.AreEqual failed. Expected:&lt;1 'wk'&gt;. Actual:&lt;1 'week'&gt;</p>",
        "id": 262567270,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1637748002
    },
    {
        "content": "<p>Note that there is also this section that talks about using quantity too, which further confuses the issue. <a href=\"http://hl7.org/fhir/fhirpath.html#quantity\">http://hl7.org/fhir/fhirpath.html#quantity</a><br>\nIf they are forced to be calendar based - then there are issues with the equivalence to equality operations defined in the core spec...</p>",
        "id": 262567658,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1637748168
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> - I remembered we discussed this some time ago, and I found the tracker: <a href=\"https://jira.hl7.org/browse/FHIR-28144\">https://jira.hl7.org/browse/FHIR-28144</a></p>",
        "id": 262572288,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1637751070
    },
    {
        "content": "<p>And the previous discussion: <a href=\"#narrow/stream/179266-fhirpath/topic/Date.2FTime.20comparison.20vs.20equality\">https://chat.fhir.org/#narrow/stream/179266-fhirpath/topic/Date.2FTime.20comparison.20vs.20equality</a></p>",
        "id": 262572328,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1637751104
    },
    {
        "content": "<p>This also means updates to this table: <a href=\"https://hl7.org/fhirpath/#time-valued-quantities\">https://hl7.org/fhirpath/#time-valued-quantities</a>.</p>",
        "id": 262572622,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1637751281
    },
    {
        "content": "<p>So does the outcome then mean that there is no difference between equivalence and equality?<br>\n(as they are considered the same, and always forced to calendar units?)</p>",
        "id": 262572680,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1637751327
    },
    {
        "content": "<p>The difference remains for units above weeks (so month and year)</p>",
        "id": 262574889,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1637752561
    },
    {
        "content": "<p>It does not explain why  <code>(1 week).ToString()</code> should return the string \"1 'wk'\" according to the unit tests.  They may be considered equal under the \"=\" operator, but does this mean <code>ToString()</code> does a normalization to UCUM?</p>",
        "id": 262575151,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1637752704
    },
    {
        "content": "<p>I don't understand how 1 year to quantity compares equal to 1a and not equivalent.</p>",
        "id": 262576059,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1637753240
    },
    {
        "content": "<p>It's not equal (=), but it is equivalent (~), which was already the case.</p>\n<p>I think the new table looks like this:</p>",
        "id": 262579647,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1637755755
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/EZHPMUfNnoTUD95nQoE7bs51/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/EZHPMUfNnoTUD95nQoE7bs51/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/EZHPMUfNnoTUD95nQoE7bs51/image.png\"></a></div>",
        "id": 262579675,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1637755779
    },
    {
        "content": "<p>As an extension, I guess then that date addition is now also allowable for mo/month, wk/week, etc ?</p>",
        "id": 262579761,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1637755818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191328\">Ewout Kramer</span> <a href=\"#narrow/stream/179266-fhirpath/topic/date.20math/near/262579761\">said</a>:</p>\n<blockquote>\n<p>As an extension, I guess then that date addition is now also allowable for mo/month, wk/week, etc ?</p>\n</blockquote>\n<p>You are referring to a tracker item (<a href=\"http://jira.hl7.org/browse/FHIR-28144\">FHIR-28144</a>) that is in a Triaged state, and not yet approved.  If it is approved (as seems likely, but when is less clear), will that affect N1, or a future release of FHIRPath?  We are trying to correct the fhirpath.js behavior, and I am not sure whether we should follow the current specification or the tracker item.</p>",
        "id": 263465603,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1638463412
    },
    {
        "content": "<p>That tracker is a technical correction, so it is auto-approved, I'd follow the tracker on that.</p>",
        "id": 263664265,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1638572166
    }
]