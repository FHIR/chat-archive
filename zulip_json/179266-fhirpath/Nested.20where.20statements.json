[
    {
        "content": "<p>...are they allowed, and if they are, how can the expression in the inner statement refer to the current element of the outer statement?</p>",
        "id": 175923829,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1568738000
    },
    {
        "content": "<p>Can you provide a more concrete example of what you're trying to do (e.g., demonstrating what you mean by \"nested\" where statements)?</p>",
        "id": 175927750,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1568740666
    },
    {
        "content": "<p>I stumbled over it by trying to get a list of all mustSupport Elements on a Profile, which was quite straight-forward:<br>\n<code>StructureDefinition.snapshot.element.where(mustSupport = true).path</code><br>\nwhich gave me a collection like this:</p>\n<div class=\"codehilite\"><pre><span></span>- Claim.status\n- Claim.subType\n- Claim.patient\n- Claim.created\n- Claim.insurer\n- Claim.insurer.identifier\n- Claim.organization\n- Claim.organization.identifier\n- Claim.related\n</pre></div>\n\n\n<p>But the purpose of the list was to estimate the complexity of implementation and for that, I'd want to get rid of the duplicates, like <br>\n- Claim.insurer<br>\n- Claim.insurer.identifier<br>\nmeans youactually only have to implement Claim.insurer.identifier, whereas Claim.insurer is just a bit higher up in the hierarchy.</p>\n<p>Of course that could be easily accomplished outside FHIRPath, but I got curious about whether it was possible to do with a FHIRPath statement by testing for each element in the Collection whether it was a substring of any other element of the collection, and the only way I could come up with to do that was with a nested <code>where</code>...</p>",
        "id": 175932668,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1568743543
    },
    {
        "content": "<p>it would have been something like </p>\n<div class=\"codehilite\"><pre><span></span>StructureDefinition.snapshot.element.where(\n    mustSupport = true\n    and StructureDefinition.snapshot.element.where(\n           mustSupport=true and path.startsWith($this)).exists().not())\n</pre></div>\n\n\n<p>...except this could only work if I could somehow make $this resolve to the current element of the outer loop...<br>\nI admit, that this use case is weird and could be easily solved outside FHIRPath, but I got curious because the spec doesn't say anything about nesting...</p>\n<p>edit: sorry, took a couple of edits for this expression to reflect what I'm trying to do</p>",
        "id": 175933404,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1568744004
    },
    {
        "content": "<p>To make this work, we'd need to introduce lambda syntax.  We've so far avoided that, since it would add complexity to the grammar and type system. E.g. when we added the aggregate function.  Anyway, if we would add lambda's it could look like:</p>\n<p><code>......where( $outer -&gt; mustSupport = true and ...... part.startsWith($outer)....</code></p>\n<p>This would be a natural extension, though, since internally, my parser is treating the current where in FHIR path as</p>\n<p><code>....where ( $this -&gt; .....) </code></p>",
        "id": 175943617,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1568750759
    },
    {
        "content": "<p>To add to <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span>'s comments, this is supported in CQL queries and the underlying ELM -- so it seems there should be a way forward (given the relationship between CQL/ELM and FHIRPath). I like Ewout's syntax.</p>",
        "id": 175945348,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1568752000
    },
    {
        "content": "<p>and you can't implement without having stack of contexts, so this doesn't seem radical to name them</p>",
        "id": 175987424,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568799488
    }
]