[
    {
        "content": "<p>Current thoughts on <a href=\"https://fhirblog.com/2019/07/09/thoughts-about-updating-registries/\" target=\"_blank\" title=\"https://fhirblog.com/2019/07/09/thoughts-about-updating-registries/\">updating the NHI</a> (and, likely the HPI also)</p>\n<p>feedback welcomed!</p>",
        "id": 169909955,
        "sender_full_name": "David Hay",
        "timestamp": 1562625069
    },
    {
        "content": "<p>Given that the underlying DB Schema of the NHI Patient Repository is a fairly simple one, I'd question the need to create custom operations to perform basic CRUD tasks. Using 'vanilla' RESTful commands would certainly create an API that's simpler than the existing SOAP interface to the NHI. I'm concerned that what's being proposed in David's Blog Post would make it more complex.</p>",
        "id": 170411793,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1562629785
    },
    {
        "content": "<p>Well, it's certainly a different style as I pointed out in the post - but the  update documents are quite straightforward to build, and get around the issue of having to submit (and the server process) an entire resource when you only want to change part of it. (And there were the issues with patch that I mentioned). But - would be good to get the perspective of the implementer community - which is why I wrote the post in the first place...</p>",
        "id": 170415498,
        "sender_full_name": "David Hay",
        "timestamp": 1562634599
    },
    {
        "content": "<p>Given how custom it is, not sure on the benefit of using fhir for updates there. It's custom anyway.</p>",
        "id": 170434242,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1562661542
    },
    {
        "content": "<p>You don't agree with using FHIR operations for this? Part of the issue is that not all of the elements in the resource can be updated by all users (like the general practitioner for example). Using standard rest for, say, an address update would mean that the client would need to read the current resource, update the address, PUT the resource to the server which would need to strip out the elements that can't be updated by the user and update the ones that can be. </p>\n<p>Clearly defined operations seemed the simpler (and clearer) approach...</p>",
        "id": 170435177,
        "sender_full_name": "David Hay",
        "timestamp": 1562662389
    },
    {
        "content": "<p>Because the NHI Repository is a 'single source of truth' for NZ patient demographic data, with (eventually) inputs from all healthcare facilities, there are many complex server-side rules around updates. My inclination would be to leave this complexity where it belongs - on the central server - and allow the client to make PUT requests containing complete patient resources to the Server for potential updates.</p>",
        "id": 170496160,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1562711668
    },
    {
        "content": "<p>Will be good to get the input of the development team about just how complex this logic will be. In principle that's the simplest approach (and the one most commonly used generally) but the existing system is service (operations) based - and I wonder how complex this logic will be to implement - especially for some of the edge cases and repeating fields. For every update operation the server will need to compare what is in the submitted resource with the all data in the back end systems (not FHIR of course) to determine what has changed. Next, it must determine whether the changed field/s's can be updated at all and whether the current user has the rights to make that change. Finally the change can be applied, and the user notified. </p>\n<p>All do-able of course, but what will it take to do so, and what's the performance impact? Having specific operations reduces that complexity (as the nature of the update is specified) and I do wonder just how much more complex it is to the client. They already know what the change is they wish to make, so the resource PUT approach means updating the resource and submitting it, and the operations approach means specifying the change and submitting that.</p>\n<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> - how are other jurisdictions managing FHIR updates to registry data?</p>",
        "id": 170497342,
        "sender_full_name": "David Hay",
        "timestamp": 1562713066
    },
    {
        "content": "<p>They are done out of band as a request, then processed in.<br>\nWe do this in our EPD product, just a simple update for the client, and all the hard work done on our end.<br>\nThe Submitter just sends what they know complete and is curated into the central record.<br>\nAnd many of them don't use fhir to update either.<br>\nWhat you have there is making the job easier for their dev, but more work for everyone else. They can't just send what they have, and let the registry worry about merging all the data together.</p>",
        "id": 170497884,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1562713566
    },
    {
        "content": "<p>So any other comments (particularly from implementers)?. To summarise, we're looking at 2 'styles' of update:</p>\n<ul>\n<li>One where there are specific update operations (address, ethnicity, name) etc that the client calls as required.</li>\n<li>The other where an updated resource is submitted and the server figures out what changes were made</li>\n</ul>\n<p>In both cases validation, security and access control is applied, so the update may not proceed (an OperationOutcome with the issues will be returned)</p>",
        "id": 170656459,
        "sender_full_name": "David Hay",
        "timestamp": 1562867843
    },
    {
        "content": "<p>Taking a closer look at PATCH: <a href=\"https://fhirblog.com/2019/08/13/updating-a-resource-using-patch/\" target=\"_blank\" title=\"https://fhirblog.com/2019/08/13/updating-a-resource-using-patch/\">https://fhirblog.com/2019/08/13/updating-a-resource-using-patch/</a> . (Actually, Grahame suggested this right back at the beginning - just getting round to taking a closer look now. Silly me...)</p>",
        "id": 173054979,
        "sender_full_name": "David Hay",
        "timestamp": 1565640117
    },
    {
        "content": "<p>That looks like a much better solution than custom operations!</p>",
        "id": 173058674,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1565642592
    },
    {
        "content": "<p>Yeah - I kinda kick myself for not taking a closer look earlier...</p>",
        "id": 173064990,
        "sender_full_name": "David Hay",
        "timestamp": 1565646848
    },
    {
        "content": "<p>Interesting in your address example you insert the collection first otherwise it would fail /as you noted)<br>\nHowever this wouldn't be a problem as you need to know the state of the resource before to know that you're not creating a dup address.<br>\nGreat write up though.</p>",
        "id": 173065530,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1565647329
    },
    {
        "content": "<p>exactly. (and thanks!) - a better solution than custom operations do you think?</p>",
        "id": 173065740,
        "sender_full_name": "David Hay",
        "timestamp": 1565647535
    },
    {
        "content": "<p>Hi David, Thanks for your thoughts on this. I think that the PATCH verb is easier to support than custom operations. The only reservation is around the manipulation of collections such as addresses - I can see scenarios where a client app is submitting  a \"stale\" PATCH i.e. where the data has been updated by a third party in the time between the client reading it, the user making the change, and the client resubmitting.<br>\nWould atomic operations on collections be a better alternative  - such as requiring ALL addresses to be submitted.</p>",
        "id": 179477535,
        "sender_full_name": "David Moorhouse",
        "timestamp": 1572469722
    },
    {
        "content": "<p>Thanks for that David. Are you concerned about, say, 2 users trying to remove the same address at different times? I did make the comment below - would that help to resolve this? I am assuming / requiring a read / update using optimistic locking to avoid collisions...</p>\n<blockquote>\n<p>So for adjusting the array, you need to know the position of the element in the array to remove. This shouldnâ€™t be a problem as the client will have just loaded the patient, and optimistic locking ensures that no-one else has changed it in the interim.</p>\n</blockquote>\n<p>cheers...</p>",
        "id": 179497017,
        "sender_full_name": "David Hay",
        "timestamp": 1572489750
    }
]