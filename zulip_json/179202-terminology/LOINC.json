[
    {
        "content": "<p>Is it possible to extract whole LOINC from <a href=\"http://tx.fhir.org\">tx.fhir.org</a> via REST as FHIR CodeSystem resource?</p>",
        "id": 275485168,
        "sender_full_name": "Gabriel Kleinoscheg",
        "timestamp": 1647422925
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span></p>",
        "id": 275512305,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1647438504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"376049\">@Gabriel Kleinoscheg</span> LOINC isn't managed as a CodeSystem resource instance on <a href=\"http://tx.fhir.org\">tx.fhir.org</a>.  Theoretically that could be done, but I doubt that anyone is doing it as it's going to be rather impractically large for handling as a resource instance.  We don't generally expect the CodeSystem resource to be used for managing the contents for the larger code systems (e.g., SNOMED CT, LOINC, etc.).</p>",
        "id": 275513215,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1647438946
    },
    {
        "content": "<p>Terminz serves CodeSystem resources for LOINC, SNOMED CT, etc. but with the content set to 'not-present' and, internally, these are created from classes which also contain methods to respond to operation requests. I would expect other TS providers to do something similar, particularly those who store the content in databases, rather than in-memory like <a href=\"http://tx.fhir.org\">tx.fhir.org</a>.  If a terminology server doesn't provide CodeSystem resource instances, then I'm guessing it has to provide information such as version, properties and filters in a TerminologyCapabilities resource?</p>",
        "id": 275578359,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1647465371
    },
    {
        "content": "<p>FWIW this is the kind of thing <span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> manages with a concept table and I think being able to distribute the details in a standard fashion would be great.</p>",
        "id": 275591088,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1647473989
    },
    {
        "content": "<p>Packing an entire large terminology into a CodeSystem is likely to present challenges (owing to size, perhaps memory constraints on parsing). But a Concept resource could help, or even just a long list of \"CodeSystem Partial\" resources (each conveying somewhere between a one concept and 10MB of concepts belonging to a single CodeSystem) as lines in an ndjson file would be pretty easy to parse.</p>",
        "id": 275591274,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1647474156
    },
    {
        "content": "<p>We support some pretty big CodeSystem resources (~0.5G JSON) but if represented as ndjson would likely be much larger due to the need to repeatedly state things like the system URI for every Concept, along with the basic Resource boilerplate.<br>\nI think an extension that allowed for CodeSystem fragments to be stitched together might work as a kind of \"CodeSystem Partial\".<br>\nAlso, the Concept resource would need to address code system versions</p>",
        "id": 275596632,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1647479000
    },
    {
        "content": "<p>I don't think you'd want to repeat stuff in the context of this (half baked) \"CodeSystem Partial\" serialization scheme (though if you did, the repeating stretches compress super well, so .ndjson.gz file).</p>",
        "id": 275598741,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1647481420
    },
    {
        "content": "<p>Sorry, re-reading my message I realise I left out key context.  I meant if representing as a giant ndjson of hypothetical Concept resources, then it would be much larger than just a raw CodeSystem resource.</p>",
        "id": 275599511,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1647482351
    },
    {
        "content": "<p>I'd focus on compressed size FWIW</p>",
        "id": 275600049,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1647482946
    },
    {
        "content": "<p>size of decompressed file may be less important than the total memory requirements when reading it (i.e. how easy is it to steam)</p>",
        "id": 275600087,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1647483002
    },
    {
        "content": "<p>Yep!  380k concept CodeSystem is 380MB of unformatted JSON but only 13M when gzipped.  Not that that helps when parsed and the validator kicks in :)</p>",
        "id": 275601398,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1647484583
    },
    {
        "content": "<p>you could distributes them as a set of fragments</p>",
        "id": 277085191,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648604628
    },
    {
        "content": "<p>vocab voted the Concept resource down. I rate that as one of our mistakes, but it was a big meeting so it'll be pretty hard to overturn</p>",
        "id": 277085243,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648604660
    },
    {
        "content": "<p>but <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> this whole area... be careful of the hammer / nail thing. Sure, it will help some people if you have code system resources for a few big code systems, but not most people since they have their own more efficient distribution based on their exact internal process/model</p>",
        "id": 277085291,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648604734
    },
    {
        "content": "<p>That is a very fair and wise cautionary note! To be clear I have no interest in changing or challenging the efficient distribution processes that already exist; I'd just love to have some well defined efficient distribution processes for greenfield/newcomers/my-own-self.</p>",
        "id": 277086036,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648605564
    },
    {
        "content": "<p>well, my strong advice for such newcomers is : use a terminology server and figure out how to incorporate the services it provides into your framework. They do all sorts of genuinely hard things, and the API exists to serve you</p>",
        "id": 277086195,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648605640
    },
    {
        "content": "<p>I think using one could mean building one (for many deployments scenarios), so commoditizing these inputs makes good sense.</p>",
        "id": 277086635,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648606102
    },
    {
        "content": "<p>Why build when you can buy :-)</p>",
        "id": 277104246,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1648625694
    },
    {
        "content": "<p>I can stand up any number of FHIR servers that have varying terminology capabilities. Actually finding, downloading, manipulating, and loading a bunch of different code systems' data into any one is difficult work. Not to mention maintaining them afterwards. </p>\n<p>Having a standard, generic format for distribution/import/export of codesystems seems like it would be a good thing for all involved.</p>",
        "id": 277180899,
        "sender_full_name": "Craig McClendon",
        "timestamp": 1648661936
    },
    {
        "content": "<p>Yes, Craig said what I was trying to -- and  much more eloquently.</p>",
        "id": 277188759,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648665537
    },
    {
        "content": "<blockquote>\n<p>Having a standard, generic format for distribution/import/export of codesystems seems like it would be a good thing for all involved.</p>\n</blockquote>\n<p>well, we do have one, and we use it as much as we can. There's just a few very big code systems that are widely supported where we don't.</p>",
        "id": 277200511,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648672195
    },
    {
        "content": "<p>What about a hybrid ndjson structure where the first row is a CodeSystem (sans codes) and subsequent rows are CodeSystem.concept BackboneElement JSONs?  You would need to use <a href=\"http://CodeSystem.concept.property\">CodeSystem.concept.property</a> to denote hierarchical relationships and not CodeSystem.concept.concept for this to work.<br>\nI could see adding custom operations to a FHIR server that could export/import such structures.</p>",
        "id": 277204384,
        "sender_full_name": "Craig McClendon",
        "timestamp": 1648674664
    },
    {
        "content": "<p>but why would that better? Sounds way bigger and less efficient to me</p>",
        "id": 277205548,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648675181
    },
    {
        "content": "<p>So, we're looking for a standard rendering, JSON-based with a large set of concept objects and some metadata for the code system itself, and then we're going to transform all the random other formats into it and load into a terminology server - that looks a hell of a lot like a FHIR CodeSystem to me.  Furthermore, it is exactly what we do for Ontoserver, in production, and it scales up to really large things like dm+d.</p>\n<p>Wrt an ndjson form, I don't really understand the advantage of stripping off two []s and moving a } which is pretty much what it would amount to.</p>",
        "id": 277205702,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1648675269
    },
    {
        "content": "<p>The advantage I was thinking of is that ndjson is more amenable to streaming rather than transmitting the whole thing in one go.</p>",
        "id": 277206082,
        "sender_full_name": "Craig McClendon",
        "timestamp": 1648675516
    },
    {
        "content": "<p>Isn't this issue just the using of streaming serializers on the json (or XML) rather than document based processing?<br>\n(to resolve the issue of the space in memory required)<br>\nthe Firely SDK has streaming options on the XML (haven't checked the json, but know that it's possible)<br>\nthey just don't validate while they're going - which I don't think any of the suggestions here is proposing either.</p>",
        "id": 277206085,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1648675517
    },
    {
        "content": "<p>As I describe at <a href=\"https://github.com/jmandel/fhir-concept-publication-demo#fhir-concept-publication-demo\">https://github.com/jmandel/fhir-concept-publication-demo#fhir-concept-publication-demo</a>, I think supporting a standard FHIR CodeSystem is a great idea. There is also some value in having a simple \"shell\" and a pointer to a pile of concepts, so the \"shell\" can be posted to a server in a lightweight way, and the concepts fetched in the background. In any case these details are a bit beside the point (the point is to have the content ready and available for all the code systems people care about).</p>\n<p>(Re: streaming processing, <a href=\"https://github.com/jmandel/fhir-concept-publication-demo#fhir-concept-publication-demo\">https://github.com/jmandel/fhir-concept-publication-demo#fhir-concept-publication-demo</a> <em>possible</em> to do with arbitrary JSON but <em>trivial</em> with newlines delimiting objects.)</p>",
        "id": 277212058,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648679878
    },
    {
        "content": "<p>I'm with Michael in failing to understand why moving some [] makes such a big difference, and what happens to nesting?</p>",
        "id": 277212290,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648680058
    },
    {
        "content": "<blockquote>\n<p>There is also some value in having a simple \"shell\" and a pointer to a pile of concepts, so the \"shell\" can be posted to a server in a lightweight way, and the concepts fetched in the background.</p>\n</blockquote>\n<p>sounds like you're describing fragments</p>",
        "id": 277212323,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648680098
    },
    {
        "content": "<p>Again, let's leave the ndjson question aside. As I said, there should be a standard resource in any case.</p>",
        "id": 277212526,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648680260
    },
    {
        "content": "<p>I don't know what \"fragments\" means; can you clarify?</p>",
        "id": 277212576,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648680302
    },
    {
        "content": "<p>(a Google search turns up <a href=\"https://build.fhir.org/ig/HL7/UTG/external_terminologies_csf.html\">https://build.fhir.org/ig/HL7/UTG/external_terminologies_csf.html</a> but that didn't help me.)</p>",
        "id": 277212611,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648680331
    },
    {
        "content": "<p>(to me, \"fragments\" sounds less than complete; I'm hoping for something complete.)</p>",
        "id": 277212724,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648680429
    },
    {
        "content": "<p><a href=\"http://build.fhir.org/codesystem-codesystem-content-mode.html#codesystem-content-mode-fragment\">http://build.fhir.org/codesystem-codesystem-content-mode.html#codesystem-content-mode-fragment</a></p>\n<blockquote>\n<p>\"fragments\" sounds less than complete; I'm hoping for something complete.</p>\n</blockquote>\n<p>and here was me thinking you were asking for something incomplete because complete is too big. I just don't see a general case here. Seems like you're just 'fixing' RxNorm.</p>",
        "id": 277213134,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648680787
    },
    {
        "content": "<p>I'm not following</p>",
        "id": 277214433,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648681866
    },
    {
        "content": "<p>I'm trying to avoid the repeated work of everyone having to wrangle source formatted data into FHIR, by having a good, consistent pile of ready-made FHIR content that expresses concept designations, properties, and relationships.</p>",
        "id": 277214527,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648681954
    },
    {
        "content": "<p>This is not about providing a \"curated subset\" of concepts.</p>",
        "id": 277214589,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648682013
    },
    {
        "content": "<p>the general case is fhir core, hl7.terminology, and <a href=\"http://fhir.tx.support\">fhir.tx.support</a> - anything open should already be in one of those, and contributions are welcome. </p>\n<p>What's left appears to be the 3 you talked about, which are too big when represented as code system, or UCUM, and several IETF terminologies, which are too complex to represent as code systems in a useful way</p>",
        "id": 277216279,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648683605
    },
    {
        "content": "<p>and propretary terminologies which are someone else's problem.</p>",
        "id": 277216299,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648683639
    },
    {
        "content": "<p>As for</p>\n<blockquote>\n<p>I'm trying to avoid the repeated work of everyone having to wrangle source formatted data into FHIR</p>\n</blockquote>\n<p>I feel that you're still in the hammer/nail space and you don't yet fully understand the complexities you will shipwreck on in the future, since you haven't really listened to me about API instead of JSON. I didn't say that for nothing</p>",
        "id": 277216414,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648683747
    },
    {
        "content": "<p>Our strategy at CSIRO for this has been to engage with the owners of the code systems where possible and convince them to take ownership of publishing their content in FHIR CodeSystem form (which is in their interest for consistency and uptake), and otherwise to develop appropriate transforms that do the conversion -- see <a href=\"https://github.com/aehrc/fhir-tx-transforms\">https://github.com/aehrc/fhir-tx-transforms</a> <a href=\"https://github.com/aehrc/fhir-owl\">https://github.com/aehrc/fhir-owl</a> <a href=\"https://github.com/aehrc/fhir-hgnc\">https://github.com/aehrc/fhir-hgnc</a> as examples</p>\n<p>Note that a FHIR CodeSystem for SNOMED CT will only ever be of limited value because a SNOMED release also includes data for (in FHIR parlance) ValueSets and ConceptMaps, and then there's post coordination and ECL to deal with.</p>",
        "id": 277219202,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1648686184
    },
    {
        "content": "<p>I feel like my perspective  is getting lost in translation here. Is it helpful if I re-frame as \"what's the redundant work that every [terminology] server developer winds up repeating? What does it look like to shrink this?\"</p>\n<p>Of course terminology releases might require CodeSystem <em>and</em> ValueSet resources to properly represent them; that's still representable as a standardized pile of files. Having upstream owners publish in a standardized way is ideal; closing the gaps with openly maintained community scripts/mappings in the meantime may be a good way to address the long tail.</p>",
        "id": 277219619,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648686562
    },
    {
        "content": "<p>I think the position that <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> and I are coming from is that there doesn't need to be a large number of \"terminology server developers\"; you just need to pick a sufficiently good existing implementation and use its API.<br>\nRephrasing to answer your question, the redundant work <strong>is</strong> implementing terminology server semantics rather than using the existing APIs to support the terminology semantics required by <code>_search</code>.  Ultimately, this means that developers need to understand how to optimise these interactions, especially with respect to <code>:in</code>.  Fortunately that mostly resolves down to cache maintenance.</p>",
        "id": 277220099,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1648687057
    },
    {
        "content": "<p>I do think there's value and a sweet spot in defining a simple ECL-alike for FHIR ValueSets so that it can be easily packed into an implicit ValueSet URI, but it's a bonus, not a prerequisite for the above.</p>",
        "id": 277220216,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1648687191
    },
    {
        "content": "<blockquote>\n<p>\"what's the redundant work that every [terminology] server developer winds up repeating? What does it look like to shrink this?\"</p>\n</blockquote>\n<p>sure. you can do that. but the way I implement this is to have an internal API and then multiple providers that provide code system services based on whatever native form is available. And the process of loading the content from whatever form is available is a small fraction of the work I do, and standardising on an inefficient format wouldn't help me with that. What I really need to do is the code system specific logic. Which is what my point about shipwrecks above is</p>",
        "id": 277220694,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648687759
    },
    {
        "content": "<p>rxnorm is somewhat unique for me because I simply load it and map it directly. For all the other code systems, I do much more work than that.</p>",
        "id": 277220835,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648687908
    },
    {
        "content": "<p>Are there examples of the kind of work you do for LOINC?</p>",
        "id": 277221140,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1648688225
    },
    {
        "content": "<p>looking through my code... mostly cross-indexing, gathering all the files into a single set of tables and sorting the langauge stuff out</p>",
        "id": 277221971,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648689069
    },
    {
        "content": "<p>less logic than I thought</p>",
        "id": 277221980,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648689082
    },
    {
        "content": "<p>Interesting. I guess I've found wrangling source codesystems into a FHIR server to more painful than some of you. <br>\nI'm not talking about even developing a terminology server, just loading them into an existing server. </p>\n<p>Here is a list of the sizes (concept count) of various larger terminologies I have (many pulled from Athena, some loaded in other ways) which arguably don't fit well into a single CodeSytem document. </p>\n<p>RxNorm Extension :: 2095063<br>\nNDC :: 1086608<br>\nSNOMED :: 1035027<br>\nRxNorm :: 300300<br>\nLOINC :: 258836<br>\nOSM :: 203339<br>\nICD10PCS :: 194981<br>\nGene Variant :: 121446<br>\nOMOP Genomic :: 120991<br>\nICD10CM :: 97114<br>\nICDO3 :: 64471<br>\nICD9CM :: 17564<br>\nICD10 :: 16519<br>\nGene :: 13591<br>\nHCPCS :: 10793<br>\nClinVar :: 8072<br>\nATC :: 6740<br>\nVariant by Impact :: 4846<br>\nICD9Proc :: 4657<br>\nGene by Impact :: 2466<br>\nCDM :: 1045<br>\nUCUM :: 1008</p>\n<p>If I could \"zap\" all these out to file with a utility or custom operation in a common format, and zap them into another server - I would find that very useful - for new deployments, test environments, etc. <br>\nMoreso if they were published from the source in a common format so I could add new ones and update existing with minimal effort. I don't quite understand the hesitancy here.</p>",
        "id": 277314235,
        "sender_full_name": "Craig McClendon",
        "timestamp": 1648747589
    },
    {
        "content": "<p>Several of these, like ICD-10-CM, ICD-10-PCS and ATC (and likely some others), we do have as FHIR CodeSystem resource instances (on <a href=\"http://tx.fhir.org\">tx.fhir.org</a>).</p>",
        "id": 277318551,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1648749755
    },
    {
        "content": "<p>you're welcome to contribute any of these to <a href=\"http://fhir.tx.support\">fhir.tx.support</a> that you can, as CodeSystem resources. But you've only counted concepts, and not factored in properties and alteranate designations, which also matter, so <a href=\"http://fhir.tx.support\">fhir.tx.support</a> doesn't include the top few CodeSystems. </p>\n<p>Which existing server are you talking about?</p>",
        "id": 277332611,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648756899
    },
    {
        "content": "<p>Something strange going on here with dates and versions?<br>\n<a href=\"/user_uploads/10155/hmzCKSo8wgWROOF6vcz4foMp/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/hmzCKSo8wgWROOF6vcz4foMp/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/hmzCKSo8wgWROOF6vcz4foMp/image.png\"></a></div>",
        "id": 277368528,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1648785690
    },
    {
        "content": "<p>that's pretty strange</p>",
        "id": 277369319,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648786702
    },
    {
        "content": "<p>but I can tell you what happened</p>",
        "id": 277369355,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648786781
    },
    {
        "content": "<p>the date given is the date that the package was uploaded. And back in January we did a round of work on the packages (see #tooling, I think) and packages that hadn't been uploaded got uploaded</p>",
        "id": 277369409,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648786830
    },
    {
        "content": "<p>I guessed it would be something like that - technical date vs \"business date\"</p>",
        "id": 277369519,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1648787004
    },
    {
        "content": "<p>Catching up: A couple of interesting threads in this. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"191343\">Michael Lawley</span> <a href=\"#narrow/stream/179202-terminology/topic/LOINC/near/277220099\">said</a>:</p>\n<blockquote>\n<p>I think the position that <span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> and I are coming from is that there doesn't need to be a large number of \"terminology server developers\"; you just need to pick a sufficiently good existing implementation and use its API.<br>\nRephrasing to answer your question, the redundant work <strong>is</strong> implementing terminology server semantics rather than using the existing APIs to support the terminology semantics required by <code>_search</code>.  Ultimately, this means that developers need to understand how to optimise these interactions, especially with respect to <code>:in</code>.  Fortunately that mostly resolves down to cache maintenance.</p>\n</blockquote>\n<p>I agree we need to have robust common-access FHIR terminology servers that can be used <em>by all</em> so that users of all types can view, directly reference (IE: include in IGs), access <strong>run-time</strong>, and I'd assume utilize in production systems, any content they have IP rights to (so we need to have a way to confirm this.) This scenario needs to be <strong>one</strong> of our goals. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"191343\">Michael Lawley</span> confirms our alignment on this goal by pointing out that one of the unmet requirements to support this when he <a href=\"#narrow/stream/179202-terminology/topic/LOINC/near/277220216\">said</a>:</p>\n<blockquote>\n<p>I do think there's value and a sweet spot in defining a simple ECL-alike for FHIR ValueSets so that it can be easily packed into an implicit ValueSet URI, but it's a bonus, not a prerequisite for the above.</p>\n</blockquote>\n<p>We need to keep in mind that FHIR code system representation <em>is not optimized for complexity</em> and as I see it the API-orientation will always be focused on making terminology content available for use, <strong>not</strong> for internal storage, sharing, complete representation.</p>\n<p><strong>BUT</strong> I agree with other sentiments that practically developers, IG creators, and many others will need to stand up their own terminology servers, purchased or not. That does mean that improvements in how we package and consume seem like a worthwhile activity. But will volunteers make it happen?</p>",
        "id": 277425850,
        "sender_full_name": "Robert McClure",
        "timestamp": 1648823109
    },
    {
        "content": "<p>well, anyone can stand up a clone of <a href=\"http://tx.fhir.org\">tx.fhir.org</a>. That's something that volunteers made happen</p>",
        "id": 277471509,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1648843684
    }
]