[
    {
        "content": "<p>It is common for an OWL Ontology to import pieces from other OWL Ontologies (eg A imports B).<br>\nIf I am creating a CodeSystem for A, then what should I do with the concepts defined in B?  Must I also have a CodeSystem for B and have the implicit ValueSet for A also import the concepts from B, or do I just include them all in A (in which case, if I do ever have a CodeSystem for B, then I have duplicate codes, or if there's another ontology with C imports B, I also get \"duplicates\" - \"equal\" codes).</p>",
        "id": 153837869,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1468380001
    },
    {
        "content": "<p>I find this question confusing because you haven't started with why a code system includes another code system</p>",
        "id": 153837872,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468380173
    },
    {
        "content": "<p>OWL has the notion of \"import\" - it does this because you're actually extending the set of concepts with a) additional concepts, and b) additional axioms (\"relationships\").  (In theory) this encourages modularity, re-use, etc<br>\nWe have to work with some of these, eg the Human Phenotype Ontology, which imports, among many things, the Gene Ontology and ChEBI (Chemical Entities)</p>",
        "id": 153837877,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1468380819
    },
    {
        "content": "<p>ok, so what's the question? </p>",
        "id": 153837879,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468381952
    },
    {
        "content": "<p>is it, how do you create those ontologies as code systems? or is it, how do you convert fhir code systems to ontologies?</p>",
        "id": 153837880,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468381987
    },
    {
        "content": "<p>It's the former - I have the OWL Ontology and I want to represent it as a CodeSystem (or several)</p>",
        "id": 153837888,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1468382634
    },
    {
        "content": "<p>interesting question, really. </p>",
        "id": 153837889,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468382998
    },
    {
        "content": "<p>there's 2 different questions you might be asking:<br>\n- I want to make the concepts available on the API<br>\n- I want to create a code system resource for the ontology</p>",
        "id": 153837890,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468383132
    },
    {
        "content": "<p>different questions....</p>",
        "id": 153837891,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468383144
    },
    {
        "content": "<p>If you import an ontology in OWL, it's still (in most or all respects) a separate ontology.  You can certainly reason across the combination, and that's why you do it, but the individual contributions are still separately identifiable (and separable).  I think we can probably take a similar approach with code systems.  Define each one individually, and then combine them however you need to in the value set(s) that you want to use. </p>",
        "id": 153837892,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1468383679
    },
    {
        "content": "<p>there's probably a couple of places where this manifests - properties that come from other code systems (even parents), and some places in the operations where we clearly say, 'one system only', e.g. $subsumes and this might make reasoning difficult</p>",
        "id": 153837893,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468383773
    },
    {
        "content": "<p>I guess we can do properties from other code systems - property of type Coding</p>",
        "id": 153837894,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468383812
    },
    {
        "content": "<p>so it's in the API where the problems might arise </p>",
        "id": 153837895,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468383825
    },
    {
        "content": "<p>Yes.  OWL is all about reasoning, whereas code systems in general don't have quite the same level and consistency of relationship infrastructure or expectations that they do.  I'm not sure if we want to try to replicate capabilities similar to OWL here.  If you combine two or more truly distinct code systems, then you may not necessarily be able to expect that subsumption would hold coherently across the combination.  However, there are some cases where that should be possible and would be expected - the SNOMED CT - LOINC integration comes to mind.  We probably should be able to handle subsumption across that combination, and we can't rely on the value set for that.  So I'm not quite sure what we should do with this.</p>",
        "id": 153837899,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1468384582
    },
    {
        "content": "<p>well, you are allowed to reason across concept maps. and I think that will be appropriate for LOINC/SCT</p>",
        "id": 153837900,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468384709
    },
    {
        "content": "<p>Michael's talking about going a step deeper than that</p>",
        "id": 153837901,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468384727
    },
    {
        "content": "<p>right - the concept map reasoning makes sense for this<br>\nand I know Michael is looking at a step deeper - maybe it's a step too far for what we should do here?</p>",
        "id": 153837905,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1468385155
    },
    {
        "content": "<p>don't know. you do have to call it a day somewhere. but we could look at speciifc examples....</p>",
        "id": 153837907,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468385203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I'm not really sure how you \"make the concepts available on the API\" without creating a <code>CodeSystem</code> resource.  The API requires at least a ValueSet and that references a CodeSystem and these are all now explicit (even for things like SNOMED CT and LOINC).</p>",
        "id": 153837918,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1468390421
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> The reason we can't just create two <code>CodeSystem</code>s and then combine in a <code>ValueSet</code> is that the combination also brings in axioms (ie the stuff that allows us to reason), and they induce cross-system parent/child relationships.  As <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> observes, this breaks in $lookup and other places where a single code system is assumed.</p>",
        "id": 153837919,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1468390587
    },
    {
        "content": "<p>well,. sure, you need to know how to refer to to in a value set, but you don't need an explicit code system</p>",
        "id": 153837920,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468390845
    },
    {
        "content": "<p>like sct and loinc</p>",
        "id": 153837921,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468390851
    },
    {
        "content": "<p>but you do need to know what the value for <code>system</code> is (and we always have a <code>CodeSystem</code> for a known (supported) <code>system</code>)</p>",
        "id": 153837922,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1468390946
    },
    {
        "content": "<p>we don't always have a code system for a supported system </p>",
        "id": 153837923,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468391494
    },
    {
        "content": "<p>I've never even seen one for SCT LOINC RxNORM UCUM NDFRT UNII BCP13 BCP47 </p>",
        "id": 153837924,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468391540
    },
    {
        "content": "<p>and those are the most important uses of the API</p>",
        "id": 153837925,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468391552
    },
    {
        "content": "<p>Is this not a code system for SCT-AU? <a href=\"http://ontoserver.csiro.au/stu3/CodeSystem/32506021000036107-20160630\" target=\"_blank\" title=\"http://ontoserver.csiro.au/stu3/CodeSystem/32506021000036107-20160630\">http://ontoserver.csiro.au/stu3/CodeSystem/32506021000036107-20160630</a><br>\n(and by \"we\" I meant \"Ontoserver\")</p>",
        "id": 153838061,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1468448311
    },
    {
        "content": "<p>well, now I can't claim that I haven't seen an SCT one</p>",
        "id": 153838064,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468448838
    },
    {
        "content": "<p>i think it needs more work, but yes, that's what it would look like </p>",
        "id": 153838065,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1468448865
    }
]