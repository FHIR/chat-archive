[
    {
        "content": "<p>We have <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14539\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14539\">GF#14539</a> on the agenda for a vote on the next Vocab Main call next Thursday (2/22).  We agreed on the last call (2/8) on the principle that CodeSystem documents the capabilities of the code system itself and that the declaration of the server implementation and capabilities for a code system in regard to the terminology service operations will be documented and accessed in a designated instance of the TerminologyCapabilities resource (see CodeSystem definition in <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14726\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14726\">GF#14726</a>).  The situation with TerminologyCapabilities is analogous to the general server capability statement that is documented in a CapabilityStatement resource and accessed through the /metadata endpoint.  But for TerminologyCapabilities we haven't yet defined what the endpoint should be, and we need to decide that so we can move forward with it.  Here are some possibilities that I've heard or considered:</p>\n<ul>\n<li>\n<p>We could define a new endpoint specifically for this (name to be determined)<br>\n    If we take this approach and end up defining multiple types of services we will also end up with a multiplicity of capabilities endpoints.</p>\n</li>\n<li>\n<p>Link to the more detailed terminology capabilities from somewhere in the required general server capability statement<br>\n   With this approach we would be able to access all capabilities from the single /metadata endpoint, but there would be a level of indirection to get to the detailed service-specific capabilities.  Flavors of this might include:</p>\n<ul>\n<li>Create a new element that provides a reference to the designated TerminologyCapabilities resource.</li>\n<li>Attempt to use the existing CapabilityStatement.instantiates element (uri data type) to reference the designated TerminologyCapabilities resource.<br>\n    But Grahame has indicated that this kind of use is not the intent for 'instantiates'.</li>\n</ul>\n</li>\n</ul>\n<p>Let's have some discussion on this and see if we can come to a conclusion by next week.</p>",
        "id": 153938009,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1518739810
    },
    {
        "content": "<p>I certainly expected this \"Create a new element that provides a reference to the designated TerminologyCapabilities resource.\". I think that we should stick to having a single entry point (/metadata) to the capabilities of the server</p>",
        "id": 153938014,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1518740771
    },
    {
        "content": "<p>That sounds good to me.</p>",
        "id": 153938030,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1518741510
    },
    {
        "content": "<p>I got the list indenting fixed.  Sorry if that was a little confusing before.</p>",
        "id": 153938031,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1518741672
    },
    {
        "content": "<p>I am quite wary of the second option that would always require two round-trips to get at terminology server capabilities.<br>\nI have several clients that rely on querying the general /metadata endpoint and for some servers this is <em>very</em> slow.<br>\nIf there are lots more service types, I expect they'll all get their own [Service]Capabilities resource type, so I don't think it would be too much of a burden to settle on a pattern like /[Service]Capabilities/metadata.</p>",
        "id": 153938328,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1518858718
    },
    {
        "content": "<p>I can see the value in that approach, and it seems reasonable.  I like the fact that it retains the 'metadata' endpoint, but applies it in a more specialized context.</p>",
        "id": 153938333,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1518876449
    },
    {
        "content": "<p>The TerminologyCapabilities hasn't been approved as a resource yet.  And I can't imagine it getting approval until we figure out a solution that <em>won't</em> mean the creation of a separate resource for every type of service we might come up with.</p>",
        "id": 153938336,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1518880795
    },
    {
        "content": "<p>well, we could define some kind of generic name value pair thing. or we could use basic. Or you could start being serious</p>",
        "id": 153938341,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1518898225
    },
    {
        "content": "<p>Is there a list of other hypothetical services?  I wasn't expecting that there would be a long list.</p>",
        "id": 153938360,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1518920872
    },
    {
        "content": "<p>I'm quite serious when I say I'd prefer a name-value pair thing to a separate resource per service.  We're talking 20+ services.  Maybe considerably more.  Having a resource for each is not sustainable.</p>",
        "id": 153938367,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1518926923
    },
    {
        "content": "<p>we've talked about<br>\n- terminology service<br>\n- conformance service<br>\n- testing service<br>\n- booking service<br>\n- many many variants of decision support services<br>\n- patient identification service<br>\n- personal health record services<br>\n- EHR services</p>",
        "id": 153938368,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1518926936
    },
    {
        "content": "<p>only the first has got into anything written, and the second has some draft ideas</p>",
        "id": 153938369,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1518926960
    },
    {
        "content": "<p>why is it not sustainable? It's too hard to come to agreement? or there's some other problem that not having a resource will actually solve?</p>",
        "id": 153938371,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1518926989
    },
    {
        "content": "<p>The problem is every single service gets its own resource.  That allows no consistency of implementation approach.  It also means we end up with a whole bunch of resources that are essentially doing the same thing.  The number of resources we have is already getting borderline too high.  Doing something like this (and setting the precedent of something like this) is going to lead to unsustainable numbers.</p>",
        "id": 153938374,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1518927117
    },
    {
        "content": "<p>Whether the others have something written doesn't really matter.  We know they'll exist at some point.</p>",
        "id": 153938375,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1518927148
    },
    {
        "content": "<p>there's some magic number of resources beyond which a problem gets harder to solve? As for consistency... there's multiple ways to ensure that. but each service has a different set of problems. Abstracting that into a tree of name value pairs just moves the problem around.  As for all doing the same thing.... if they are doing the same thing, they should be the same. But if you look at terminology capabilities as it is now, it's quite terminology engine specific</p>",
        "id": 153938381,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1518927267
    }
]