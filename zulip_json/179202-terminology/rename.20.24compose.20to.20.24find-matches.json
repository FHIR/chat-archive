[
    {
        "content": "<p><a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=15956\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=15956\">GF#15956</a> said, in the disposition, to actually rename $compose as previously agreed. But when I went through the records, I discovered that agreed that we would rename it, but not what we would rename it to. So I have renamed it to $find-matches. Opinions welcome</p>",
        "id": 153978260,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532599502
    },
    {
        "content": "<p>I can't find the original thread relating to this either, but recall suggesting $match without gaining any support. I did implement this, in part for exact matches in SNOMED CT, but that's possibly  been superseded by the new ecl query option for implicit value sets. It would be interesting to hear if others have implemented and found value in this operation.</p>",
        "id": 153978262,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1532600446
    },
    {
        "content": "<p>I note that the operation is showing a maturity level of 5 - clearly this is an oversight</p>",
        "id": 153978263,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1532600730
    },
    {
        "content": "<p>We have not implemented the operation, and have not had anyone ask us for this functionality. As Peter says, it's largely obviated by ECL for snomed ct (augmented by a text search capability).  I suspect that it might be useful for LOINC, but we've seen little use of loinc with Ontoserver so far.<br>\nI would welcome any use cases from people that could help with validating ImplementatiIna of the current proposal.</p>",
        "id": 153978265,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1532601122
    },
    {
        "content": "<p>Just a note that Patient describes a $match operation too, that was intended to potentially be generic too (nothing really specific to patient)<br>\n<a href=\"http://hl7.org/fhir/patient-operations.html#match\" target=\"_blank\" title=\"http://hl7.org/fhir/patient-operations.html#match\">http://hl7.org/fhir/patient-operations.html#match</a><br>\nYou pass it an instance (or partial) and the operation will treat it like a search, and find instances that are potential matches for it</p>",
        "id": 153978274,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1532602935
    },
    {
        "content": "<p>I would've called it $match if it wasn't for that. And I don't see how ECL obviates the need for the API. personally.</p>",
        "id": 153978275,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532603005
    },
    {
        "content": "<p>it might be logical way to implement it for SCT...</p>",
        "id": 153978276,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532603020
    },
    {
        "content": "<p>$find-matches seems probably as reasonable as anything and should accomplish the goal of not being confused with ValueSet.compose</p>",
        "id": 153978313,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1532609478
    },
    {
        "content": "<p>Only obviated for SCT, not for CodeSystem in general.  I like $find-matches; for me it's much more indicative of its behaviour</p>",
        "id": 153978356,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1532614639
    },
    {
        "content": "<p>I still don't understand how you think ECL obviates an API operation. Perhaps it's more than I think...</p>",
        "id": 153978530,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532646972
    },
    {
        "content": "<p>The (SCT-only) question for me is what might a $find-matches operation be able to return that can't be found using an ECL-based filter in the (implicit) ValueSet $expand operation?</p>",
        "id": 153978543,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1532651469
    },
    {
        "content": "<p>if you have precise sct properties values, then probably nothing. Except that client has to know how to construct the ECL</p>",
        "id": 153978544,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532651586
    },
    {
        "content": "<p>where as with the find matches API, the client assembles what it has, and delegates the whole lot to the server, and can accept possible matches. This is quite a different thing</p>",
        "id": 153978545,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532651623
    },
    {
        "content": "<p>Understood, but the client still has to have a certain degree of knowledge about SCT properties, including relationship groups, to make a $find-matches request. For this, or ECL, a client application might need a UI processing component that could convert dropdown selections into FHIR API calls.</p>",
        "id": 153978547,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1532652062
    },
    {
        "content": "<p>only what to provide...</p>",
        "id": 153978556,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532653568
    },
    {
        "content": "<p>Constructing the ECL is the tricky part, but the current spec is pretty wide open as to how loose the match can be when <code>exact</code> is false.<br>\nI presume one always wants at least one property to be present?<br>\nThere's a bunch of interpretation still open as to what exact means in the presence of multi-valued properties.  eg if I ask for an exact match for site = appendix, and action = excision then I would expect all partial matches to have at least one of those values matching, but what about subtypes of appendix? or direct-site / indirect-site which are subtypes of site?<br>\nShould a client expect an \"exhaustive\" list of matches, or maybe just n of the \"best\" matches?</p>",
        "id": 153978561,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1532654020
    },
    {
        "content": "<p>right. that's why it's maturity level 0. I'm just pointing out that ECL is not a functional replacement, though it's semantically doing some very similar</p>",
        "id": 153978568,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532657170
    },
    {
        "content": "<p>Yep - my initial stab at trying to understand the semantics &amp; boundaries of this API was an attempt to translate it to ECL (assuming SCT).<br>\nI quickly ran into all these questions about how strict the matching should be.  Without knowledge of any use-cases to inform me of what might be practically useful I've been unable to make any progress.</p>",
        "id": 153978580,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1532659795
    },
    {
        "content": "<p>maybe we can talk about this a little next week when ftf</p>",
        "id": 153978581,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532660030
    },
    {
        "content": "<p><a href=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=17563\" target=\"_blank\" title=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=17563\">GF#17563 </a> request to correct remaining references to $compose operation in the $find-matches operation page.</p>",
        "id": 153978585,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1532661350
    },
    {
        "content": "<p>oops thanks</p>",
        "id": 153978586,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532661819
    }
]