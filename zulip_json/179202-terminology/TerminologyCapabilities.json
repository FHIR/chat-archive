[
    {
        "content": "<p>When responding metadata request, should a terminology server returns CapabilityStatement or TerminologyCapabilities or both?</p>",
        "id": 153955497,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1525294029
    },
    {
        "content": "<p>The CapabilityStatement.</p>",
        "id": 153955500,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1525294429
    },
    {
        "content": "<p>Then what is the usage of TerminologyCapabilities resource?<br>\nI though that is a replacement of CapabilityStatement.</p>",
        "id": 153955502,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1525294475
    },
    {
        "content": "<p>I thought the idea was both</p>",
        "id": 153955513,
        "sender_full_name": "Robert McClure",
        "timestamp": 1525294926
    },
    {
        "content": "<p>Every FHIR server is required to provide a CapabilityStatement in response to a metadata request.  The TerminologyCapabilities resource is intended to provide additional information specific to Terminology Servers - e.g. which properties are supported for individual Code Systems. Support for the TerminologyCapabilities resource, where applicable, is declared in the Capability Statement. Expecting a Terminology Server to include a TerminologyCapabilities resource in its response to the a metadata request would require a breaking change in the specification.</p>",
        "id": 153955517,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1525295354
    },
    {
        "content": "<p>So you are saying it is an additional request to get the TerminologyCapabilities? What would the request be?</p>",
        "id": 153955518,
        "sender_full_name": "Robert McClure",
        "timestamp": 1525295437
    },
    {
        "content": "<p>We've been discussing having an additional metadata endpoint specifically for the terminology service, but haven't made a decision on how to do that yet.</p>",
        "id": 153955519,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1525295456
    },
    {
        "content": "<p>Same as other resources - GET with optional search parameters. The following request will return the (trial) TerminologyCapabilities resource from my server...<br>\nGET <a href=\"http://its.patientsfirst.org.nz/RestService.svc/Terminz/TerminologyCapabilities\" target=\"_blank\" title=\"http://its.patientsfirst.org.nz/RestService.svc/Terminz/TerminologyCapabilities\">http://its.patientsfirst.org.nz/RestService.svc/Terminz/TerminologyCapabilities</a></p>",
        "id": 153955523,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1525295819
    },
    {
        "content": "<p>Yes, you can do that with CapabilityStatement (and, as you said, any other resource), too.  But 'metadata' is a designated endpoint for retrieving the single instance (in case there is more than one instance on the server) of <strong>the</strong> CapabilityStatement which declares the capabilities for this server (at that particular base endpoint).  I think we likely want a similar \"terminology metadata\" endpoint for the terminology service (particularly because some servers may provide both general server capabilities <strong>and</strong> also specific terminology services).</p>",
        "id": 153955526,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1525296425
    },
    {
        "content": "<p>here is a link to the prior discussion <a href=\"#narrow/stream/48-terminology/subject/Accessing.20the.20server.20terminology.20capability.20statement\" title=\"#narrow/stream/48-terminology/subject/Accessing.20the.20server.20terminology.20capability.20statement\">https://chat.fhir.org/#narrow/stream/48-terminology/subject/Accessing.20the.20server.20terminology.20capability.20statement</a>, and to further work to be done for <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14539\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14539\">GF#14539</a></p>",
        "id": 153955528,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1525296721
    },
    {
        "content": "<p>I guess there's a case for returning all the capabilities of a Terminology Server in a single request - and that would also need include all the OperationDefinition resources where a server doesn't support all the in/out parameters in the specification for a particular operation. On the other hand, given the large and unwieldy nature of what might be returned (particularly from an all-purpose server) there is also merit in continuing the approach where the ConformanceStatement provides references to additional capability and conformance related resources.</p>",
        "id": 153955529,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1525296957
    },
    {
        "content": "<p>It has to be possible to ask a server what it's own terminology capabilities are. It must also be possible for a server to host a list of terminology capability statements</p>",
        "id": 153956098,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1525495140
    },
    {
        "content": "<p>I lean towards adding an element or extension to the capability statement to refer to the the terminology capabilities rather than adding to the API</p>",
        "id": 153956099,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1525495181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191364\">@Peter Jordan</span> wouldn't <code>[base]/TerminologyCapabilities</code> return a <code>Bundle</code> containing all the <code>TerminologyCapabilities</code> stored on the server?</p>",
        "id": 153956110,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1525496111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I agree with <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> - it would be <em>very</em> preferable to be able to get to a server's own terminology capabilities statement in a single request rather than having to first get the <code>/metadata</code> (this is already very slow on some systems).</p>",
        "id": 153956115,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1525496650
    },
    {
        "content": "<p>well, we won't solve the slowness problem by making it bigger</p>",
        "id": 153956117,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1525497076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> You're right. Mine currently just sends a single resource, but I'll correct that to place it in a bundle in the next release of my server.</p>",
        "id": 153956119,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1525498149
    },
    {
        "content": "<p>No, I'd rather have a well-known endpoint like <code>/terminologymetadata</code> or <code>/metadata/terminology</code> or similar.<br>\nThe alternative (which would make it bigger and which I also dislike) would be to have the terminology capabilities be returned from <code>/metadata</code> as a contained resource</p>",
        "id": 153956120,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1525498931
    },
    {
        "content": "<p>I think it probably would be best to include a reference (not a contained resource) to the additional terminology (and any other applicable service) capabilities within CapabilityStatement and also provide known endpoint(s) where they are returned directly.</p>",
        "id": 153956137,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1525523574
    },
    {
        "content": "<p>why are there more than one TerminologyCapabilities instance on a server? Is that one for each coding system?</p>",
        "id": 153956261,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1525637615
    },
    {
        "content": "<p>Not sure, but TerminologyCapabilities.codeSystem is 0...* and (interestingly) each codeSystem has a canonical uri element.</p>",
        "id": 153956265,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1525641669
    },
    {
        "content": "<p>Can you assume that GET [server]/TerminologyCapabilities actually refers to the terminology capabilities of THAT server? It's not the case for CapabilityStatement...</p>",
        "id": 153956281,
        "sender_full_name": "David Hay",
        "timestamp": 1525661589
    },
    {
        "content": "<p>No, I don't think you can necessarily assume that.  If the server supports general REST interactions then the presence of a TerminologyCapabilities resource instance may not indicate that the server supports those capabilities (just as with CapabilityStatement).  So, as we've mentioned, I think an explicit endpoint is needed - via a specific dedicated endpoint for terminology capabilities or a reference from 'metadata' or both.</p>",
        "id": 153956282,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1525662027
    },
    {
        "content": "<p>a server that is a terminology server would generally only carry a single TerminologyCapabilities resource. But a server that has other purposes - a repository of systems, for instance, or a conformance server - might carry multiple terminology capabilities statements that describe other systems</p>",
        "id": 153956285,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1525664994
    },
    {
        "content": "<p>I don't think you can rely on that.  If you want to know for sure what terminology capabilities a system supports, there needs to be an extension that points from CapabilityStatement to the TerminlogyCapabilities.  (And I'm very much not sold on TerminologyCapabilities being a separate resource.)</p>",
        "id": 153956332,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525688803
    },
    {
        "content": "<p>I agree with an extension for  TerminologyCapabilities instance either as a reference or as an embedded resource.</p>",
        "id": 153956585,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1525709531
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> Support for the TerminologyCapabilities resource can already be declared in a CapabilityStatement. I don't believe that requiring clients to examine extensions in order to determine what a server can do is a particularly good strategy. Whether, not, the TerminologyCapabilities resource should be merged with CapabilityStatement is a moot point - but probably doesn't satisfy the use case whereby a server may contain multiple instances of the later. However, I believe there is a good argument for adding an operation that returns a bundle containing everything a particular terminology server supports, which would include OperationDefinitions for server-specific implementations of operations such as $expand.</p>",
        "id": 153956809,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1525728592
    },
    {
        "content": "<p>There are absolutely going to be situations where you'll need to look at extensions in CapabilityStatement - not everything a system can do can be part of core.  (We already have extensions on CapabilityStatement for somethings)</p>",
        "id": 153956816,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525728973
    },
    {
        "content": "<p>A server can have lots of instances of CapabilityStatement - but it only exposes one at the metadata endpoint, which is what matters here.</p>",
        "id": 153956817,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525728996
    },
    {
        "content": "<p>My remarks related to the single CapabilityStatement exposed by the metadata endpoint. IMHO, the TerminologyCapabilities resource is definitely an improvement on the previous use of extensions in the CapabilityStatement to declare support for external Code Systems. We need to make it as clear and simple as possible for clients to determine what a Terminology Server can do: I'm usually asked that question at least several times at each Connectathon and my reply in Cologne will be that 3 separate queries are required.</p>",
        "id": 153956827,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1525730272
    },
    {
        "content": "<p>I understand the desire to make things simple, but creating a new resource every time a new service comes along can't scale.</p>",
        "id": 153956829,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525731162
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191364\">@Peter Jordan</span> what are your three requests?<br>\n1. CapabilityStatement - /metadata<br>\n2. TerminologyCapabilities - /???<br>\n3. OperationDefinition???</p>",
        "id": 153956831,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1525731218
    },
    {
        "content": "<p>well <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>, a \"new service that comes along\" wouldn't meet the 80% rule, right?  How many service types are currently needing something like TerminologyCapabilities?  I could posit something for workflow, and something for events/CDS maybe, but otherwise?</p>",
        "id": 153956838,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1525732053
    },
    {
        "content": "<p>CapabilityStatement is at /metadata.  The CapabilityStatement points to relevant OperationDefinitions, StructureDefinitions, SearchParameters, etc.  It would need to point to TerminologyCapability too - presumably via an extension.  Merely hosting a TerminologyCapability says <em>nothing</em> about what the system can do.  (And the TerminologyCapability for a system might not even be hosted by that same system - just as the OperationDefinitions, StructureDefinitions and other resources pointed to by the \"metadata\" CapabilityStatement of a server don't have to be hosted by that server.</p>",
        "id": 153956842,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525732431
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span>  <br>\n2. GET [base]/TerminologyCapabilities/Terminz-Example  (will also work without the resource id)<br>\n3 GET [base]/OperationDefinition will return all the operation definitions on my Server, otherwise they can be requested individually using the URLs in the CapabilityStatement.</p>\n<p>Can confirm that the Tsunami of FHIR Services hasn't reached NZ either.  Flippancy aside, I do think that terminology services probably form a very distinct module within the FHIR spec, as evidenced by highly specific, product-based implementations.</p>",
        "id": 153956933,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1525785540
    },
    {
        "content": "<p>The vocab WG needs to make a formal proposal for TerminologyCapabilities resource</p>",
        "id": 154014330,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1541020049
    },
    {
        "content": "<p>note that the build depends on this resource now - I need to get information about the code systems from the <a href=\"http://tx.fhir.org\" target=\"_blank\" title=\"http://tx.fhir.org\">tx.fhir.org</a></p>",
        "id": 154014331,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1541020075
    },
    {
        "content": "<p>as does the IG publisher</p>",
        "id": 154014332,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1541020084
    },
    {
        "content": "<p>You mean retroactively submit the resource proposal?  Do you recall what the deadline would be for that?</p>",
        "id": 154014336,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1541020310
    },
    {
        "content": "<p>it hasn't been proposed, and needs to be. we probably have 2 weeks or so</p>",
        "id": 154014337,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1541020344
    },
    {
        "content": "<p>Right.  So we can approve it on the call next week, then?</p>",
        "id": 154014339,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1541020380
    },
    {
        "content": "<p>yes</p>",
        "id": 154014340,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1541020392
    },
    {
        "content": "<p>ok</p>",
        "id": 154014342,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1541020428
    }
]