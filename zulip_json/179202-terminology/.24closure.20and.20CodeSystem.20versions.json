[
    {
        "content": "<p>I am trying to understand how <code>$closure</code> should behave with respect to multiple CodeSystem versions?</p>\n<p>Starting from the primary use-case for <code>$closure</code>, i.e., <code>code:below</code> &amp; <code>code:above</code> searches, consider the scenario where <code>Condition</code> resources have been added to our server with <code>Condition.code</code> populated with all of <code>Coding.code</code>, <code>Coding.system</code>, <em>and</em> <code>Coding.version</code>.</p>\n<p>Furthermore, consider that, over time, different versions are specified for the same <code>CodeSystem</code>.</p>\n<p>Now, when the <code>Coding?code:below=http://mySystem.com|123</code> search arrives we duly collect the unique <code>Codings</code> from <code>Condition.code</code> and send them, along with <code>http://mySystem.com|123</code>, off to our <code>$closure</code> operation.</p>\n<p>1. What should it do with the mix of versions?<br>\n2. Does it make a difference if the <code>CodeSystem</code> does/does not support concept permanence (i.e., <code>CodeSystem.versionNeeded = true</code>)?</p>",
        "id": 168103062,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1560481525
    },
    {
        "content": "<p>hey there's a reason why we didn't specify this ;-)</p>",
        "id": 168172353,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560546972
    },
    {
        "content": "<p>but yes, it surely would make a difference</p>",
        "id": 168172365,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560546990
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> I know I'm not understanding this but it seem you asking if a version specific search should return concepts that are not in the specified version? Can you help me understand the issue?</p>",
        "id": 168685183,
        "sender_full_name": "Robert McClure",
        "timestamp": 1561126645
    },
    {
        "content": "<p>Not quite.  The search above: <code>Condition?code:below=http://mySystem.com|123</code> (there was a typo above) asks for all <code>Condition</code> resources where the <code>code</code> field is <code>123</code> or any of its descendants in the CodeSystem <code>http://mySystem.com</code>. There are no versions specified in the <em>query</em>.  However, there may be different versions specified in the <code>Condition.code</code> entries in the data.</p>",
        "id": 168728771,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1561164601
    },
    {
        "content": "<p>The challenge is that in one of these specified versions, <code>A</code>, the code <code>456</code> is not a descendant of <code>123</code> but in another (later) version <code>456</code> is a descendant of <code>123</code>.  So, should it match or not?  There are wide ranging implications for either choice, both semantic and technical.</p>",
        "id": 168728884,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1561164741
    },
    {
        "content": "<p>Yes, we really need to think through what we want the behavior to be for this.  However, in many cases it may not be as hard as it sounds.  For SNOMED CT, for example, I suspect that a likely approach will be to base the closure table on the latest version available on the server or the specific version being requested by the client (which should be consistent), regardless of what the version was when any particular instance of data was recorded.  What you have to decide, though, is if (and how) any historical relationships will be included in the subsumption.  If you don't account somehow for historical relationships then any instance data that was recorded with a code that is now inactive in the version being used in the closure table will be ignored.  In some cases that may be acceptable, but I suspect that it many cases it will not be.</p>",
        "id": 168729279,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1561165547
    },
    {
        "content": "<p>Agreed <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> .  However I am fairly disinclined to automagically use the historical relationships because this has the server deciding on things that are really only in the control of the client to know whether it is appropriate.</p>",
        "id": 168817087,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1561342030
    },
    {
        "content": "<p>For an example like this, the client could find all now-inactive codes in its data, apply the historical map, and then pass the mapped concepts to the $closure operation.  It would also need to update its client-side join operations to factor in the historical map relationships, if any.</p>",
        "id": 168817154,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1561342168
    },
    {
        "content": "<p>Yeah, that might be a reasonable approach to take on it.</p>",
        "id": 168817282,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1561342391
    },
    {
        "content": "<p>I'll include this in the whitepaper I'm putting together</p>",
        "id": 168817553,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1561342898
    },
    {
        "content": "<p>great</p>",
        "id": 168817605,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1561342957
    }
]