[
    {
        "content": "<p>I started <a href=\"#narrow/stream/215610-shorthand/topic/Codesystems.20and.20Valuesets\" title=\"#narrow/stream/215610-shorthand/topic/Codesystems.20and.20Valuesets\">this thread in the shorthand stream</a> about valuesets and codesystems that are often used in genomics.<br>\n<span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  commented:</p>\n<blockquote>\n<p>looking back at what Bob is doing...</p>\n<ul>\n<li>sounds like it should be discussed on the terminology track to see what should be done. Typically, these gene terminologies are very large, and you can't simply define them</li>\n<li>more likely, I'll need to do implementation work on <a href=\"http://tx.fhir.org\" title=\"http://tx.fhir.org\">tx.fhir.org</a> to support these kinds of terminologies</li>\n</ul>\n</blockquote>\n<p>In addition to gene terminologies defining <a href=\"http://www.genenames.org\" title=\"http://www.genenames.org\">gene names</a>, some of these systems are only grammars (<a href=\"https://varnomen.hgvs.org/\" title=\"https://varnomen.hgvs.org/\">HGVS</a> or <a href=\"http://glstring.org\" title=\"http://glstring.org\">GLStrings</a>) that we need to bind to.</p>\n<p>So, I'm bringing it up here in this track for to see what should be done.</p>",
        "id": 196201699,
        "sender_full_name": " Bob Milius",
        "timestamp": 1588608114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191345\">@Alejandro Metke</span> has done a bunch of work in the genomic terminologies space.<br>\nThere's also work out of Nebraska in the pathology space where I believe they've mostly used string-typed concrete domains to build SNOMED extensions where the HGVS string, for example, is referenced as a property of SNOMED code for a test.</p>",
        "id": 196251679,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1588634431
    },
    {
        "content": "<p>The main work we've done is around transforming OWL ontologies to FHIR code systems (it is an open source project available here: <a href=\"https://github.com/aehrc/fhir-owl\" title=\"https://github.com/aehrc/fhir-owl\">https://github.com/aehrc/fhir-owl</a>). I know the Clinical Genomics working group has been using this for some of the ontologies that are used in genomics because a few are available in OWL format. The only issue here is to standardise the systems' urls.</p>\n<p>I think the difficult part is dealing with grammar-like terminologies. FHIR already uses UCUM, which has similar characteristics, but I think it would be good to have more clarity around 1) if terminology servers should support this kind of terminology 2) if yes, what is the expected behaviour (which operations make sense). In my view the answer to 1) is yes and 2) some operations could be clearly supported, such as $validate-code, but some others are not as clear, for example, $expand.</p>",
        "id": 196252879,
        "sender_full_name": "Alejandro Metke",
        "timestamp": 1588635595
    },
    {
        "content": "<p>you could make a task if you think we should be clearer, but I thought we already were - a terminology server that implements a code system with a grammar should have the following behavior: </p>\n<ul>\n<li>it should be clear whether the grammar is supported or not (e.g. snomed). (terminology capabilities) </li>\n<li>we could say for some of them in their definition that it servers are required to implement the grammar (e.g. media type, language) but we don't. UCUM would be a candidate to for being required but I'm not sure</li>\n</ul>\n<p>For servers that  do support the grammar:</p>\n<ul>\n<li>$validate-code should understand the grammar correctly and validate the semantics of the grammar as completely as possible</li>\n<li>$expand is more complicated:<ul>\n<li>if the server is expanding an enumerated value set, it should only add valid expressions to the expansion</li>\n<li>for some code systems that have a grammar, we have a filter to exclude the grammar (pre-coordinated terms only). For others that's not appropriate</li>\n<li>servers should be able to do expansions without grammar if the filter says so</li>\n<li>servers can't expand a value set that allows for post-coordinated terms, but it may choose to return a subset (including post-coordinated terms or not) and mark it as indicative since the full expansion cannot be generated</li>\n</ul>\n</li>\n</ul>",
        "id": 196256002,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588638183
    },
    {
        "content": "<p>I'd love to have FHIR binding support something that is in essence a syntax check, ie: is the code defined one that is in the code system space based on conforming to syntax rules. This would be used for bindings where the code system is a grammar and the element intends to allow any valid code. This actually turns out to be very common for grammar code system bindings (UCUM, BCP47) and the alternative of creating some subset invariably results in a missed code that is valid and needed. <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span>  - thoughts?</p>",
        "id": 196256016,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588638201
    },
    {
        "content": "<p>that's what we already have</p>",
        "id": 196256086,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588638251
    },
    {
        "content": "<p>We don't have a binding that special for this. Are you saying you implement that way in your server?</p>",
        "id": 196256240,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588638388
    },
    {
        "content": "<p>that's what it means to support those code systems. There's nothing special about that</p>",
        "id": 196256256,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588638410
    },
    {
        "content": "<p><code>/CodeSystem/$validate-code</code> should check grammar (as Grahame said above)</p>",
        "id": 196256308,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1588638481
    },
    {
        "content": "<p>I'm not following what you mean by \"that is what it means to support those code systems.\" The resource for this code system can not look like a SCT resource</p>",
        "id": 196256358,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588638498
    },
    {
        "content": "<p>validate, yes. \"support\" no</p>",
        "id": 196256378,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588638532
    },
    {
        "content": "<p>if you mean, you cannot express any of this in a code system resource, then sure, you're right. If you mean something else, I don't know what you do</p>",
        "id": 196256392,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588638550
    },
    {
        "content": "<p>Seems you must be doing something special to treat the two different types of code systems \"the same\" with validation when the base resources I'd assume they operate on are completely different. Hence not easy or understandable for normal folks</p>",
        "id": 196256534,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588638671
    },
    {
        "content": "<p>I don't understand this response at all. What base resources do they operate on?</p>",
        "id": 196256569,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588638722
    },
    {
        "content": "<p>If a grammar were simple, for example characterised by a regex, then the CodeSystem could include this (in an extension element) and the terminology server would be able to provide some support generically.<br>\nChallenges arise when there's a normalisation step required (eg order of terms in a grammar is not important), or the grammar is complex, requiring ANTLR, ABNF, etc to express.</p>",
        "id": 196256637,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1588638791
    },
    {
        "content": "<p>right. we never tried to make the code system resource express any of those things. It only expresses simple non-grammar code systems</p>",
        "id": 196256668,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588638833
    },
    {
        "content": "<p>I'm sure I'm the one confused. Does BCP47 and UCUM have a code system resource with concepts in it? I'd assume not. Yet for all the other code system resources, they do. I'd have assumed you need a code system resource to do validation operations on the code system. Not true?</p>",
        "id": 196256672,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588638835
    },
    {
        "content": "<p>SO you are saying that validate-code is special sauce done independent of the code system resource</p>",
        "id": 196256761,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588638917
    },
    {
        "content": "<p>and seems is completely up to the TS creator to figure out?</p>",
        "id": 196256795,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588638942
    },
    {
        "content": "<p>that does not sound very easy for others to implement</p>",
        "id": 196256850,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588638970
    },
    {
        "content": "<p>Well, the idea is that complexity is offloaded to the TS implementer</p>",
        "id": 196256871,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1588639019
    },
    {
        "content": "<p>The expectation is that the number of code systems with grammars etc is small</p>",
        "id": 196256887,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1588639057
    },
    {
        "content": "<p>and the number of TS devs is also small</p>",
        "id": 196256941,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588639085
    },
    {
        "content": "<p>and will forever be small ;-)</p>",
        "id": 196256950,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588639105
    },
    {
        "content": "<p>given that UCUM, BCP47 are <em>everywhere</em></p>",
        "id": 196256966,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588639137
    },
    {
        "content": "<p>we have not tried to make a CodeSystem resource for BCP47, or UCUM etc. My server supports many code systems that I have not tried to make CodeSystem resources for.</p>\n<blockquote>\n<p>I'd have assumed you need a code system resource to do validation operations on the code system</p>\n</blockquote>\n<p>No. All the working terminology servers have some internal API that implements the code systems, and one internal implementation of the API takes a code system resource</p>\n<blockquote>\n<p>validate-code is special sauce done independent of the code system resource</p>\n</blockquote>\n<p>Not  dependent on having one, no</p>\n<blockquote>\n<p>that does not sound very easy for others to implement</p>\n</blockquote>\n<p>no, but the question isn't 'how can it be easy to support such terminologies' since there'll never be an easy way. The question was, 'what's the least worst way to do it'. And having worked with some of our early attempts to define a uber-grammar that supports all the things people want to do, and looking ahead at the genomics ones, I knew that I wasn't going to even try for an uber-grammer in FHIR. Instead what we did was simple: define the CodeSystem resource to make sure the long tail is easily supported, and ensure that the terminology service API can handle the requirements of the complicated grammars, and then let servers decide which of those they were going to support</p>",
        "id": 196257048,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588639221
    },
    {
        "content": "<p>the internal mini-terminology server in the validater/publisher looks to see if there's a CodeSystem resource. If there is, it uses it's internal implementation for $expand/$validate-code. Otherwise it hands it over to the terminology server</p>",
        "id": 196257098,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588639319
    },
    {
        "content": "<p>My point is, perhaps we make it easy to bind to a known implementation of a validator service, versus hope there is a accessible TS that does it for you. I get the long-tail piece and that is exactly my point. Allow the binding to find a validator versus hope there is one inside your system.</p>",
        "id": 196257135,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588639325
    },
    {
        "content": "<p>no I have no idea what you are talking about. What's the difference between a validator service and an accessible TS?</p>",
        "id": 196257149,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588639360
    },
    {
        "content": "<p>Perhaps the missing piece is TS federation?</p>",
        "id": 196257254,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1588639447
    },
    {
        "content": "<p>most implementations will use internal FHIR services. ON occasion they will need this sort of external help. How do they link to the TS when needed? - I may call you</p>",
        "id": 196257257,
        "sender_full_name": "Robert McClure",
        "timestamp": 1588639454
    },
    {
        "content": "<p>This is essentially what the idea of terminology services is all about.  The complexity is handled by the \"specialist software\", making it much easier for applications generally to make use of terminology and do that correctly.</p>",
        "id": 196257457,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1588639653
    },
    {
        "content": "<p>What <span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span> is looking for is to use <a href=\"http://hl7.org/fhir/StructureDefinition/valueset-trusted-expansion\" title=\"http://hl7.org/fhir/StructureDefinition/valueset-trusted-expansion\">http://hl7.org/fhir/StructureDefinition/valueset-trusted-expansion</a> on the binding, instead of just being allowed to do so on the value set. (we just talked). He's going to:</p>\n<ul>\n<li>make some test cases for the validator to get the ever-so tardy author of the validator to actually implement these things</li>\n<li>make a jira task to extend the extension to us on bindings as well as in value sets</li>\n</ul>",
        "id": 196258282,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588640524
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> the problem with federated terminology for me is that the engine (+ internal API) running <a href=\"http://tx.fhir.org\" title=\"http://tx.fhir.org\">tx.fhir.org</a> was never defined with federation in mind. The architecture assumes extremely low latency (e.g. direct code bindings) between the different code system providers. That's probably not a capability that we actually exercise, but I'd either have to  rewrite my internal API, or somehow turn the internal highly granular API back to something coarse. </p>\n<p>E.g. the internal expansion approach is something like </p>\n<ul>\n<li>'here's a filter - can you handle that?'</li>\n<li>ok set up to be able to filter with this code/op/value</li>\n<li>then a voting protocol for which filter is going to drive the iteration and which other ones are just going to veto the iteration steps (iterate on the smallest overall set)</li>\n<li>then iterating, letting each filter remove things that don't meet the filter</li>\n<li>then assemble the expansion, hierarchically if possible (the iteration keeps track of this)</li>\n</ul>\n<p>I can't federate that</p>",
        "id": 196258771,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588641122
    },
    {
        "content": "<p>I do have experience with federating tx services, because I already do - I maintain the mini-terminology server inside the validator. And I know just where it's broken, and the edge cases that no one else has found yet. One day I'll have to figure out how to resolve those edge cases</p>",
        "id": 196258817,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588641183
    },
    {
        "content": "<p>That seems pretty low level to want to federate?  Why not at the $expand / $validate-code level?<br>\nI'm thinking something like a fail-over approach (try internal and on \"unsupported\", try next federated server), and/or allow specified CS/VS to be routed directly to a federated TS</p>",
        "id": 196258991,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1588641413
    },
    {
        "content": "<p>well, the second is the trusted expansion source. The first... doesn't really federate Tx services - it just provides some fall back functionality</p>",
        "id": 196259092,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588641540
    },
    {
        "content": "<p>So, trusted-expansion points at a FHIR TS endpoint?  eg <a href=\"https://genomics.ontoserver.csiro.au/fhir\" title=\"https://genomics.ontoserver.csiro.au/fhir\">https://genomics.ontoserver.csiro.au/fhir</a> ?</p>",
        "id": 196262182,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1588645860
    },
    {
        "content": "<p>y</p>",
        "id": 196262657,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588646568
    },
    {
        "content": "<p><a href=\"http://jira.hl7.org/browse/FHIR-27028\" title=\"http://jira.hl7.org/browse/FHIR-27028\">FHIR#27028</a> ticket to clarify this in the spec</p>",
        "id": 196264355,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1588649281
    }
]