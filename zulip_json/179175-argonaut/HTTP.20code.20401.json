[
    {
        "content": "<p><a href=\"https://www.hl7.org/fhir/us/core/CapabilityStatement-us-core-server.html#behavior\" target=\"_blank\" title=\"https://www.hl7.org/fhir/us/core/CapabilityStatement-us-core-server.html#behavior\">US Core 7.1.1.1</a>. The first section says </p>\n<blockquote>\n<p>...Return the following response classes: ...(Status 401/4xx): unauthorized request.</p>\n</blockquote>\n<p>The following security says </p>\n<blockquote>\n<p>A server SHALL reject any unauthorized requests by returning an HTTP 401 unauthorized response code.</p>\n</blockquote>\n<p>So what does 4xx codes mean where it first mentioned? And second question, if server returns 4xx for unauthorized request, is it valid or not?<br>\n<span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> <span class=\"user-mention\" data-user-id=\"191410\">@Brett Marquard</span></p>",
        "id": 189256692,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1582837428
    },
    {
        "content": "<p>can you make a tracker.  should only be 401</p>",
        "id": 189257657,
        "sender_full_name": "Eric Haas",
        "timestamp": 1582837948
    },
    {
        "content": "<p>You should NOT force 401. See <a href=\"http://build.fhir.org/security.html#AccessDenied\" target=\"_blank\" title=\"http://build.fhir.org/security.html#AccessDenied\">http://build.fhir.org/security.html#AccessDenied</a></p>",
        "id": 189261894,
        "sender_full_name": "John Moehrke",
        "timestamp": 1582840846
    },
    {
        "content": "<p>by forcing 401 you enable an attacker to determine what exists vs what does not exist.  Servers should have the ability to implement policy on what they do with access control failures</p>",
        "id": 189261966,
        "sender_full_name": "John Moehrke",
        "timestamp": 1582840896
    },
    {
        "content": "<blockquote>\n<p>by forcing 401 you enable an attacker to determine what exists </p>\n</blockquote>\n<p>I'm not arguing we should specify any more than we already have -- but if we <em>did</em> require the use of <code>401</code> for requests that lacked an <code>Authorization</code> header this would <em>not</em> enable an attacker to determine what exists vs what does not exist. The <code>401</code> would be used for all paths if an access token was omitted (based on the request, not based on what data existed in a server).</p>",
        "id": 189265373,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1582843284
    },
    {
        "content": "<p>I didn't understand it was specific to that exchange only. as you can imagine I get many people going from one specific to a general rule too quickly without considering the ramifications.</p>",
        "id": 189265550,
        "sender_full_name": "John Moehrke",
        "timestamp": 1582843416
    },
    {
        "content": "<p>There are three scenarios: 1) the client sends request with valid token, 2) the client sends request with invalid token, 3) the client sends request without a token. Both case 2) and 3) shall end with Access Denied. My question is what is the correct response code for these two situation. I used to think 401 SHALL be the correct code for both 2) and 3) till I recently found some servers send 400.  So I started to look around but could not find any concrete answer.</p>",
        "id": 189270617,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1582847802
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> I looked at <a href=\"http://build.fhir.org/security.html#AccessDenied\" target=\"_blank\" title=\"http://build.fhir.org/security.html#AccessDenied\">http://build.fhir.org/security.html#AccessDenied</a>. My understanding for that section is that the code SHALL be 401 \"This communicates that user authentication was attempted and failed to be authenticated.\"<br>\nAnd what does this mean \"by forcing 401 you enable an attacker to determine what exists vs what does not exist\"?<br>\nThanks</p>",
        "id": 189270986,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1582848131
    },
    {
        "content": "<p>to explain that, let me ask what you would return if the request situation was the same, but there was no data that matched the query parameters? Most will answer that should either be 200 that is empty, or a 404 not found. Well now I can tell if there is data that exists (does match my query parameter) but for which I don't have access rights to.  I don't need access rights, I will just probe around with these query parameters until I can tell what the data is NOT, which tells me what the data is.</p>",
        "id": 189309542,
        "sender_full_name": "John Moehrke",
        "timestamp": 1582896872
    },
    {
        "content": "<p>so, the recommendation from many security professionals, we just quote them on the FHIR core security page, is that policy should choose what to return. When the data are very sensitive it can be best to return 200 with an empty bundle.</p>",
        "id": 189309634,
        "sender_full_name": "John Moehrke",
        "timestamp": 1582896935
    },
    {
        "content": "<p>There are cases, like what Josh indicated, where a specific error code is not going to lead to exposing data. Josh case is where a token is completely missing.</p>",
        "id": 189310702,
        "sender_full_name": "John Moehrke",
        "timestamp": 1582897690
    },
    {
        "content": "<p>I am not against having recommended codes for access control failure. What I am against is SHALL language. The reason I am against that is that it forbids a service from imposing policy. It can also lead a client to believe that that error code is the only failure-mode, and thus the client is fragile to servers imposing a different policy. -- so what I am asking for is to recognize that hackers are creative, and the data you are protecting is valuable.  Think about Security Considerations, not just happy path.</p>",
        "id": 189310942,
        "sender_full_name": "John Moehrke",
        "timestamp": 1582897844
    },
    {
        "content": "<p>The OAuth 2 specification actually defines a lot about the errors: <a href=\"https://tools.ietf.org/html/rfc6750#section-3.1\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc6750#section-3.1\">https://tools.ietf.org/html/rfc6750#section-3.1</a></p>",
        "id": 189339827,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1582916317
    },
    {
        "content": "<p>(this is the bearer token extension, which is the type of token SMART uses)</p>",
        "id": 189339849,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1582916335
    },
    {
        "content": "<p>So 400, 401, 403 specifically called out for different types of errors</p>",
        "id": 189340153,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1582916504
    },
    {
        "content": "<p>And if they're nice, hopefully the error code as well :)</p>",
        "id": 189340223,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1582916527
    },
    {
        "content": "<p>Yeah, we talked through these -- but looked like only the header details are defined at a \"SHALL\" (MUST) level, and specific response codes were \"SHOULD\"s.</p>",
        "id": 189531098,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583179781
    }
]