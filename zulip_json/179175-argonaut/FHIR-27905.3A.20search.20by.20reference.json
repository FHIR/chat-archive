[
    {
        "content": "<p>in  <a href=\"http://jira.hl7.org/browse/FHIR-27905\">J#27905</a> <span class=\"user-mention\" data-user-id=\"192576\">@Robert Scanlon</span>  asked to  Clarify search by reference conformance expectations</p>\n<p>What do implementers think is minimum needed?</p>\n<p>e.g. : add bullet in <a href=\"http://build.fhir.org/ig/HL7/US-Core/general-guidance.html#search-syntax\">Search Syntax</a> to say...( paraphasing )</p>\n<p>search by reference ... Patient/123 or just 123 or [base]/Patient/123</p>\n<p>more formally stated as :</p>\n<ul>\n<li>note for values of type <code>reference</code> (how to search by <a href=\"#.html\">reference</a>), the syntax {base}/{Type}/[id] means that the base url and Type values (where unambiguous*) are optional <em>for the client</em> to supply</li>\n</ul>\n<p>\"where unambiguous\"  means for a search parameter like <code>patient</code> the Type is assumed to be Patient.  For a search parameter of <code>subject</code> it cannot be assumed.</p>",
        "id": 214213554,
        "sender_full_name": "Eric Haas",
        "timestamp": 1603384707
    },
    {
        "content": "<p>How do people feel about stating that formally in terms of server requirements?  The server SHALL support search values of type reference of the form [base]/[Type]/[id] and [Type]/[id] in all cases.  The server SHALL support search values of type reference of the form [id] where Type is unambiguous.</p>",
        "id": 214246429,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603399862
    },
    {
        "content": "<p>I worry that people may interpret what 'optional for the client' means in terms of server requirements differently.  Unless somewhere it is stated that 'optional for client' means 'required for server' at all times... though that seems like a dangerous statement.</p>",
        "id": 214246968,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603400142
    },
    {
        "content": "<blockquote>\n<p>The server SHALL support search values of type reference of the form [base]/[Type]/[id] and [Type]/[id] in all cases. The server SHALL support search values of type reference of the form [id] where Type is unambiguous.</p>\n</blockquote>\n<p>Can you give examples of these (apparently) three different cases? I am not sure I follow...</p>",
        "id": 214248138,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1603400746
    },
    {
        "content": "<ol>\n<li><code>https://example.com/fhir/Procedure?patient=5</code></li>\n<li><code>https://example.com/fhir/Procedure?patient=Patient/5</code></li>\n<li><code>https://example.com/fhir/Procedure?patient=https://example.com/fhir/Patient/5</code></li>\n</ol>",
        "id": 214249075,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603401280
    },
    {
        "content": "<p>Thanks. Would the proposed rules apply to any and all references? Only the ones marked Must Support? Specific references only?</p>",
        "id": 214255391,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1603405488
    },
    {
        "content": "<p>only the searchparameters of type <code>reference</code> that are named in the guide:  eg: AllergyIntolerance <code>patient</code> parameter</p>",
        "id": 214255586,
        "sender_full_name": "Eric Haas",
        "timestamp": 1603405614
    },
    {
        "content": "<p>Do <strong>Patient/5</strong> and <strong>https://example.com/fhir/Patient/5</strong> and mean different things?  Or should the server treat them as if they were the same?  I.e. if the resource on the server is using a relative URL in the reference, should it only find results if the relative reference is provided?  Of should the server normalize the received search value and normalize the references in the resources and then do the search by comparing the normalized values?</p>\n<p>I'm not sure I like having a server attempt to normalize the value received in the search parameter.  Some references may be local to that logical FHIR server, but some might refer to an external FHIR server, so you'd then have to figure out when to normalize and when not to.  But if you don't normalize, then if some resources have a full URL, and some just have the relative part, you'll probably only get a subset of what you expect.</p>",
        "id": 214572408,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1603718800
    },
    {
        "content": "<p>We assume that the server knows its own base URL, and normalizes if and only if the URL matches that.</p>",
        "id": 214575616,
        "sender_full_name": "Paul Church",
        "timestamp": 1603720376
    },
    {
        "content": "<p>Knowing your own base URL is tricky when you have reverse proxies, load-balanced VIPs, API managers etc.  Especially if those are managed by a different entity than  the one that manages the FHIR server.   This has been a problem for us in other areas already.</p>",
        "id": 214580161,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1603722477
    },
    {
        "content": "<p>Yes, that has been a complete nuisance for us as well. We've done full URL rewriting in a proxy layer, but that's a layer we control.</p>",
        "id": 214581668,
        "sender_full_name": "Paul Church",
        "timestamp": 1603723125
    },
    {
        "content": "<p>Are you re-writing in your HTTP response bodies as well?  I get re-writing stuff in the URL and HTTP headers, but trying to re-write everything in the actual body sounds terrible.  And if/when we support signing FHIR resources, that would break signatures.</p>",
        "id": 214599275,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1603730310
    },
    {
        "content": "<p>Yes. This isn't actually a production solution yet, but it rewrites URLs in the response body. In a typical deployment, the actual full URL of the GCP FHIR store is an internal implementation detail that the customer will not want to expose outside of the proxy and may not remain stable over time anyway.</p>",
        "id": 214600410,
        "sender_full_name": "Paul Church",
        "timestamp": 1603730732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191764\">Cooper Thompson</span> <a href=\"#narrow/stream/179175-argonaut/topic/FHIR-27905.3A.20search.20by.20reference/near/214572408\">said</a>:</p>\n<blockquote>\n<p>Do <strong>Patient/5</strong> and <strong>https://example.com/fhir/Patient/5</strong> and mean different things?  Or should the server treat them as if they were the same?  I.e. if the resource on the server is using a relative URL in the reference, should it only find results if the relative reference is provided?  Of should the server normalize the received search value and normalize the references in the resources and then do the search by comparing the normalized values?</p>\n<p>I'm not sure I like having a server attempt to normalize the value received in the search parameter.  Some references may be local to that logical FHIR server, but some might refer to an external FHIR server, so you'd then have to figure out when to normalize and when not to.  But if you don't normalize, then if some resources have a full URL, and some just have the relative part, you'll probably only get a subset of what you expect.</p>\n</blockquote>\n<p>I would like your opinion on this,  This is to guide the client on allowed formats - so if the relative reference and absolute reference mean different things - The client needs to know this.</p>",
        "id": 214605973,
        "sender_full_name": "Eric Haas",
        "timestamp": 1603732997
    },
    {
        "content": "<p>We also do the symmetric thing, a full URL reference in a resource will match a search for Patient/5 if the URL begins with the server's base URL. I would recommend that app clients always search for Patient/5, which puts the burden on the other side (whoever is writing the resources) to get it right.</p>",
        "id": 214623713,
        "sender_full_name": "Paul Church",
        "timestamp": 1603741505
    },
    {
        "content": "<p>From our (Epic) perspective, right now we just support the raw ID (patient=5), and we always assume that the ID is relative to our logical server, and we don't address the subject issue.  Our logical server can be known by many different URLs, but we need to know all the URLs we are known as to generate fullUrl for search bundles anyway, so it isn't a hard problem to accept an absolute URL reference and chop off the URL part.  </p>\n<p>I personally think it would be nice if we could get rid of absolute URLs in the REST API, and to my knowledge fullUrl in the search bundle is the big annoying one.  However if we normalize reference searching to require the full URL format, then we're adding in another absolute URL requirement, and I'd rather we remove them.  </p>\n<p>I'm not bothered about Patient/5 vs. 5 for distinguishing the resource type of the subject you want, though it seems like a token-style syntax would be better there.  It seems like Reference.type (ResourceType) is really the qualifier we want, but because of the REST API URL structure, that is I think entirely redundant with the path components of the reference.</p>",
        "id": 214632492,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1603746056
    },
    {
        "content": "<p>Agree that a good base, and what I've seen in the wild, is the unqualified patient=X</p>",
        "id": 214655161,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603765356
    },
    {
        "content": "<p>I would definitely be interested in reasons why this might be hard on a client app</p>",
        "id": 214655169,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603765372
    },
    {
        "content": "<p>when FHIR supported the old subject param everywhere, we saw a lot of variation (and mistakes) in the way those parameters were used, but patient simplified this and removed a lot of the deviation we saw in applications.</p>",
        "id": 214655190,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603765413
    },
    {
        "content": "<p>I have no objection to patient=5. The only caveat is \"Servers SHOULD reject a search where the logical id refers to more than one matching resource across different types\"  but that isn't likely to come up often.</p>",
        "id": 214708949,
        "sender_full_name": "Paul Church",
        "timestamp": 1603809822
    },
    {
        "content": "<blockquote>\n<p>I would definitely be interested in reasons why this might be hard on a client app</p>\n</blockquote>\n<p>From a generic client library perspective, <code>reference_param=Type/id</code> should always work when searching by any reference, while <code>reference_param=id</code> may or may not work depending on if that parameter applies to multiple types.  So I can <strong>imagine</strong> some generic FHIR clients being explicit about the type always as a rule , and being surprised they have to understand that the parameter only applies to one type and therefore they can't prepend the type to the id always, automatically.</p>",
        "id": 214709192,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603809920
    },
    {
        "content": "<p>I stress <strong>imagine</strong> because the client library I've worked on does not do this, and I would be surprised if the popular java, .net, and javascript libraries do this today (though I haven't looked deeply at them in some time).</p>",
        "id": 214709348,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603809967
    },
    {
        "content": "<p>Also, the language in the <a href=\"https://www.hl7.org/fhir/search.html#reference\">search section</a> is a little loose on if <code>reference_param=Type/id</code> is always expected to work or only will work in cases where the type is ambiguous, so that may be another count against this imagined scenario.</p>",
        "id": 214709514,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603810041
    },
    {
        "content": "<p>I think the explicit type should always be allowed and the language clarified if necessary. There's no value in disallowing it for unambiguous types.</p>",
        "id": 214709923,
        "sender_full_name": "Paul Church",
        "timestamp": 1603810165
    },
    {
        "content": "<p>I would hope it is not much of a burden to accept both forms on unambiguous types to provide a little more leeway on the client side.  But I recognize it is more stuff to maintain if there aren't any cases where there are ambiguous types (in US Core, today).</p>",
        "id": 214710929,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603810535
    }
]