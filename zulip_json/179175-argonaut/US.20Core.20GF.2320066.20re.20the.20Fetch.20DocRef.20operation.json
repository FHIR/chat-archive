[
    {
        "content": "<p>See US Core <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20066\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20066\">GF#20066</a><br>\nThis tracker brings up a couple of issues making the case that  that this  $docref could be a search</p>\n<ul>\n<li>Who is using it?</li>\n<li>Based on the the definition of  <a href=\"http://hl7.org/fhir/operations.html#3.2.0\" target=\"_blank\" title=\"http://hl7.org/fhir/operations.html#3.2.0\">operation</a> it is clearly an operation.  The case is being made that this could be a search too since many times there aren't a bunch of FHIR resources being persisted ... so the first two bullets in the operation definition don't make a lot of sense since always creating \"new\" resources on the fly in the background in response to a search request</li>\n<li>what <em>should</em> it be? ( I am inclined to agree with John)</li>\n<li>do we ned to edit the operation definition? </li>\n</ul>\n<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  <span class=\"user-mention\" data-user-id=\"191357\">@Andrew Torres</span></p>",
        "id": 159094896,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550776064
    },
    {
        "content": "<p><a href=\"https://fhir.cerner.com/millennium/dstu2/infrastructure/document-reference/#operation-docref\" target=\"_blank\" title=\"https://fhir.cerner.com/millennium/dstu2/infrastructure/document-reference/#operation-docref\">https://fhir.cerner.com/millennium/dstu2/infrastructure/document-reference/#operation-docref</a></p>",
        "id": 159095169,
        "sender_full_name": "Drew Torres",
        "timestamp": 1550776271
    },
    {
        "content": "<p>We are using it to meet MU3.</p>",
        "id": 159095174,
        "sender_full_name": "Drew Torres",
        "timestamp": 1550776278
    },
    {
        "content": "<p>The operation was used because we are asking the API to take action to generate a document.</p>",
        "id": 159095200,
        "sender_full_name": "Drew Torres",
        "timestamp": 1550776307
    },
    {
        "content": "<p>Yes, same for us</p>",
        "id": 159095326,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550776408
    },
    {
        "content": "<p>We don't explicitly say anywhere that servers are prohibited from creating data on the fly in response to a query, however there's an implicit assumption that if I query the data today and I query the data tomorrow, all of yesterday's data will still be there unless it's been explicitly deleted.  With an operation, there's no expectation that information will be retained.</p>",
        "id": 159095611,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550776585
    },
    {
        "content": "<p>$docref supports <code>start</code> and <code>end</code> parameters - that do not make much sense for a search</p>",
        "id": 159096214,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550777044
    },
    {
        "content": "<p>My comment was specifically to express the difference between $docref and a query on DocumentReference. If the difference is indeed that there is an expectation that $docref will result in \"a\" DocumentReference that does not currently exist, and will not return all the other DocumentReference that do exist.. THEN I would be very happy. What I am worried about is that $docref does something similar but not exactly the same as a query on DocumentReference... I would still be concerned with this kind of OnDemand mechanism that seems to be different than doing a query on DocumentReference. This because, as Lloyd points out, it is very possible to create a DocumentReference during a query on DocumentReference. This is indeed what is described in IHE-MHD for support of OnDemand.   So I would be happy with a clarification of the behavior of $docref, and and note that DocumentReference query can achieve the same result...</p>",
        "id": 159099353,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550778983
    },
    {
        "content": "<p>DocumentReference query cannot achieve the same result <code>$docref?start=x&amp;end=y</code> creates and returns a document with all the data for that period, that is not something a search can do</p>",
        "id": 159099815,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550779285
    },
    {
        "content": "<p>why not?</p>",
        "id": 159100343,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550779672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span>   I think that would be the same as <code>DocumentReference?patient=[patient]&amp;period=[period]</code>  assuming the server would respond with a an \"on the fly' response to it as lloyd explains above</p>",
        "id": 159100437,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550779740
    },
    {
        "content": "<p>seems to be a simple use of the DocumentReference -period query parameter.</p>",
        "id": 159100439,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550779741
    },
    {
        "content": "<p>Search parameter that result in modifying the data inside one of the returned resources?</p>",
        "id": 159100463,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550779758
    },
    {
        "content": "<p>right. Yes there needs to be some way that a server can declare that it will respond that way... but it is fully possible</p>",
        "id": 159100478,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550779773
    },
    {
        "content": "<p>but that is simply a profile declaration in the CapabilityStatement...</p>",
        "id": 159100570,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550779828
    },
    {
        "content": "<p>however we do default to  'the latest the most recent or current document is in scope.' when no time period is given</p>",
        "id": 159100580,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550779842
    },
    {
        "content": "<p>I'd say that search parameters should modify the set of resources that is returned. not  what is inside the resources</p>",
        "id": 159100635,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550779902
    },
    {
        "content": "<p>@Michele  I don't understand 'result in modifying the data inside one of the returned resources'</p>",
        "id": 159100643,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550779911
    },
    {
        "content": "<p>Maybe the specs do not explicitly prohibit - but it seems to me that would be a very strange behavior indeed</p>",
        "id": 159100697,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550779931
    },
    {
        "content": "<p>It is not strange... when I use various RESTful api against classic internet providers, results are returned to me that clearly didn't exist prior to me asking. There is no way for a map API to have all possible responses.</p>",
        "id": 159100780,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550780034
    },
    {
        "content": "<p>FHIR is an API, not a persistence model. Else we couldn't be using FHIR as an API to an EHR database... :-)</p>",
        "id": 159100854,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550780080
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> calling <code>$docref?start=2019-01-01</code> and <code>$docref?start=2018-01-01&amp;end=2018-12-31</code> returns one document in both cases, but _different_ documents: the first has all the data for this year, the second all the data for last year</p>",
        "id": 159100867,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550780100
    },
    {
        "content": "<p>and why is that an issue?</p>",
        "id": 159100903,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550780136
    },
    {
        "content": "<p>again.. I am okay with $docref, as long as it is clear that is where one goes for ondemand documents, and as long as DocumentReference query is not forbidden from doing the same thing given the same query parameters.</p>",
        "id": 159100907,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550780141
    },
    {
        "content": "<p>because search parameters do searches? and searches returns different sets of things depending on the value of the search parameters - do not change the things</p>",
        "id": 159101004,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550780210
    },
    {
        "content": "<p>more specifically I think $docref needs to clearly NOT return non-ondemand document entries</p>",
        "id": 159101014,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550780222
    },
    {
        "content": "<p>The Client does not know whether the resources are persisted or created on the fly so I not sure that matters for them.  If the resources are persisted then it would matter for the server.</p>",
        "id": 159101153,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550780321
    },
    {
        "content": "<p>so back to <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  why can't one overload the operation with regular search?  what is the issue there?</p>",
        "id": 159101276,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550780424
    },
    {
        "content": "<p>a naming opportunity: calling it something like <code>$generate-ccda</code> would be a heck of a lot clearer.</p>",
        "id": 159102398,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1550781545
    },
    {
        "content": "<p>Agree with Josh :)</p>",
        "id": 159102421,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1550781587
    },
    {
        "content": "<p>Also, the doc for us is not persisted, and wouldn't come back in a general search</p>",
        "id": 159102488,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1550781629
    },
    {
        "content": "<p>if that <em>is</em> persisted, and changes the state of the server/resource, that would be unexpected behavior for a GET</p>",
        "id": 159102534,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1550781688
    },
    {
        "content": "<p>which is precisely why we went operation (all the above)</p>",
        "id": 159102536,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1550781698
    },
    {
        "content": "<p>If the operation can be defined in a non-US-centric manner, that would be better.  CCDA is US-specific.</p>",
        "id": 159103055,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550782185
    },
    {
        "content": "<p>Lloyd, the type of document is a parameter. so the client explicitly asks for C-CDA. it is not baked into the API</p>",
        "id": 159104232,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550783076
    },
    {
        "content": "<blockquote>\n<p>so back to <span class=\"user-mention silent\" data-user-id=\"191404\">@John Moehrke</span>  why can't one overload the operation with regular search?  what is the issue there?</p>\n</blockquote>\n<p>is this a question to me? Or is this a echoing my statement and asking others why not?   <br>\nBecause I am happy to keep the operation with a well defined behavior, but am also happy for it to go away and use query for that functionality.</p>",
        "id": 159104859,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550783599
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> I was pushing back against the proposal for $generate-ccda as a name.</p>",
        "id": 159105234,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550783934
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"191404\">@John Moehrke</span> I was pushing back against the proposal for $generate-ccda as a name.</p>\n</blockquote>\n<p>ah, right... $generate-doc</p>",
        "id": 159105649,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550784278
    },
    {
        "content": "<p>actually the current $docref does not have a parameter for the encoding of the document... it does expect C-CDA output...    <br>\nwhich is a good behavior problem... if a server can give a document for the given LOINC code in 5 different formats (mime-type + profile-conformance), does it return 5 different DocumentReference? Or does the server guess at the best response?</p>",
        "id": 159105890,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550784453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  it was a question for you.   As it stands it does overload with search which at the  time seemed like a good idea as a  convenience for the client.  They don't know how or care how the document is fetched.   So would like to know the specific issues when is truly a search  ( assume you would get the best match )</p>",
        "id": 159106233,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550784665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span>   the operation is not just for ccda</p>",
        "id": 159106277,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550784703
    },
    {
        "content": "<p>right. That is why IHE XDS just folded OnDemand into normal XDS query. Most clients don't know they should ask two questions when they simply want to know what documents are available.</p>",
        "id": 159106385,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550784776
    },
    {
        "content": "<p>so we went with a operation.   which is better?</p>",
        "id": 159106431,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550784827
    },
    {
        "content": "<blockquote>\n<p>the current $docref does not have a parameter for the encoding of the document..</p>\n</blockquote>\n<p>The server chooses what it want to serve</p>",
        "id": 159106548,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550784904
    },
    {
        "content": "<p>...implementation detail...  but should mention that in the spec</p>",
        "id": 159106647,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550784971
    },
    {
        "content": "<p>Re: naming, what's the common thread? <code>$generate-document</code>?</p>",
        "id": 159106648,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1550784972
    },
    {
        "content": "<p>Is it just about summary documents?</p>",
        "id": 159106662,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1550784994
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span>   like John and  I said its more a client get doc operation adn trying to <strong>mush both</strong>  onthefly and existing docrefs into single transaction.  so I think any name should reflect the client side  more like $return-docref</p>",
        "id": 159106993,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550785214
    },
    {
        "content": "<p>I'm still stumped then. What's the use case for an operation to return an existing doc?</p>",
        "id": 159107183,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1550785361
    },
    {
        "content": "<p>like John mentioned above</p>\n<blockquote>\n<p>Most clients don't know they should ask two questions when they simply want to know what documents are available.</p>\n</blockquote>",
        "id": 159107253,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550785429
    },
    {
        "content": "<p>Ideally <em>one</em> ask for a docref no matter whether is created anew or persisted somewheres</p>",
        "id": 159107369,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550785510
    },
    {
        "content": "<blockquote>\n<p>I'm still stumped then. What's the use case for an operation to return an existing doc?</p>\n</blockquote>\n<p>if we make it clear that the operation is to only return potential ondemand documents, and will NOT return existing documents; then the client can know that it doesn't have to have logic to look for redundant entries. One way or the other... I just want deterministic behavior.</p>",
        "id": 159107383,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550785529
    },
    {
        "content": "<p>And IHE went with a search that does it all.   And the intent was for $docref to do it all as well.   ( which is the focus of his tracker - although I could counter his tracker with a tracker on IHE and say the same ... :-))</p>",
        "id": 159107570,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550785656
    },
    {
        "content": "<p><code>$generate-or-retrieve-document</code></p>",
        "id": 159107687,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1550785773
    },
    {
        "content": "<p>Bottom I am OK either way do it all with search or do is all with an operation.  Just need the community to decide what we want to do and then we can address the name</p>",
        "id": 159107699,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550785784
    },
    {
        "content": "<p>It's the reference that throws me off, I think -- it's not expressing the intent of the caller.</p>",
        "id": 159107713,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1550785801
    },
    {
        "content": "<p>I see your point there</p>",
        "id": 159107773,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550785829
    },
    {
        "content": "<p><code>$get-documents</code>allows for the possibility of generation or retrieval and is shorter...</p>",
        "id": 159107819,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550785907
    },
    {
        "content": "<p>$get-doc ??</p>",
        "id": 159107872,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550785943
    },
    {
        "content": "<p>Maybe is not a good name, but it had been there a long time and it is deployed in production already - why break things?</p>",
        "id": 159107909,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550785999
    },
    {
        "content": "<p>Mostly I'm just trying to understand it; sometimes naming things helps :) It might not be worth renaming in real life.</p>",
        "id": 159108032,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1550786092
    },
    {
        "content": "<p>The way we implemented it is that we (1) generate the documents for the specified type(s) and period if we know how (2) fetch the existing document for the specified type and period (3) return the combination of (1) and (2)</p>",
        "id": 159108476,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550786487
    },
    {
        "content": "<p>what I am confused at is... a DocumentReference resource is a metadata resource, it does not return the document. The client needs to invoke the URL in DocumentReference.content.attachment.url to get the bytes. <br>\nWhat I expect is that DocumentReference.content.attachment.url will be equal to the $document operation. <br>\nSo, we have cascading operations... why?</p>",
        "id": 159111815,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550788849
    },
    {
        "content": "<p>We preferred it that way to not have to mix the generated document vs documents that live in the system. When you query DocumentReference?Patient=1234 we only return documents that exist in the system (not the generated ones). Your point is valid. In our implementation you can skip the DocoumentReference by doing: Binary/$autogen-ccd-if?patient=1316035, but support the operation on Documentreference lets the consumer get the metadata about the document without actually generating the document.</p>",
        "id": 159112992,
        "sender_full_name": "Drew Torres",
        "timestamp": 1550789981
    },
    {
        "content": "<p>(We actually stick the document inside attachment.data so there is no second GET needed)</p>",
        "id": 159120140,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550797927
    },
    {
        "content": "<p>Just finished reading this 65+ chain and I am little fuzzy on the conclusion:<br>\n A) Remove operation<br>\n B) Rename operation <code>$generate-or-retrieve-document</code><br>\n C) Be more clear about difference in expectations on search vs <code>$docref</code> operation</p>",
        "id": 159181647,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1550861879
    },
    {
        "content": "<p>I vote for C. Stuff is in production. Haven't had many complaints. Why rock the boat?</p>",
        "id": 159181738,
        "sender_full_name": "Drew Torres",
        "timestamp": 1550861929
    },
    {
        "content": "<p>C is not completely correct.  John correctly understood the fact that $docref was defined to return <strong>both</strong> on the fly and pre-exisiting docrefs.    IHE does this same thing using search.     As stated above  <em>the client doesn't give a hoot about the mechanics behind returning a docref</em> and should not be required to make two separate calls (i.e., a search and an operation ) each time.  So its seems the consensus is to keep $docref and therefore I think the choice should be:</p>\n<p>d) go <strong>all in</strong> on $docref  for all searching  (sorry John)  since having both search and operation both confusing  and onerous for the client.   this means making all search on docref optional and removing from docref.</p>",
        "id": 159203973,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550881599
    },
    {
        "content": "<p>If that  not acceptable then a) remove operation and supercharge the search as John suggests</p>",
        "id": 159204171,
        "sender_full_name": "Eric Haas",
        "timestamp": 1550881863
    },
    {
        "content": "<p>correct. I prefer ( a )... query is all that is needed. It will work against a basic FHIR server, where as forcing the operation means that everyone must add the operation... and there is no functional benefit to an operation.</p>",
        "id": 159284694,
        "sender_full_name": "John Moehrke",
        "timestamp": 1551030563
    },
    {
        "content": "<p>It is not a search - 'Search operations traverse through an _existing_ set of resources _filtering_ by parameters supplied to the search operation.'</p>",
        "id": 159336518,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1551101137
    },
    {
        "content": "<p>Besides that: it has been implemented, it works, implementers are OK with it - why change things?</p>",
        "id": 159336583,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1551101177
    },
    {
        "content": "<p>I am not forcing change, I am asking for clarity. I think you have expressed that in your case the operation will only return one ondemand document. That would be a fine clarification. In that case I can know that I will not get duplicates between the operation and a search. As long as I can understand this, I am good with the result. but I also don't think we should have an operation when one is not needed, as it forces clients to do two things.</p>",
        "id": 159343591,
        "sender_full_name": "John Moehrke",
        "timestamp": 1551107261
    },
    {
        "content": "<p>FYI - after long discussion Eric/I plan to propose deprecation of $docref on SD this Thursday</p>",
        "id": 160580690,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1552404932
    },
    {
        "content": "<p>In favor of IHE approach using search.  Deprecate means keep in for one more cycle before removing.</p>",
        "id": 160580825,
        "sender_full_name": "Eric Haas",
        "timestamp": 1552405015
    },
    {
        "content": "<p>You cannot use search to return document created on the fly: 'Search operations traverse through an _existing_ set of resources _filtering_ by parameters supplied to the search operation'</p>",
        "id": 160583781,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1552407067
    },
    {
        "content": "<p>We to distinguish something... the Query on DocumentReference can return DocumentReference items that indicate the ability to request that a document be created. If a client does a GET on the DocumentReference.content.attachment.url, that is when the document is created. Not at query time.  This is the model that has been in XDS/XCA/MHD for a long time.<br>\nI recognize the distinction that some see the $docref as returning the DocumentReference and also the Document that was created during that operation.</p>",
        "id": 160584692,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552407799
    },
    {
        "content": "<p>so, if we can clarify that distinction, then I will be happy.. Can we make clear that $docref is used to create an ondemand document, where the result is both the DocumentReference and the document ?   Specifically it would NOT return static entries, just the one requested to be created.</p>",
        "id": 160584893,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552407949
    },
    {
        "content": "<p>Implementers seems to be happy with how things are - once again, why do you want to change things? Especially things that are already in production?</p>",
        "id": 160585291,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1552408165
    },
    {
        "content": "<p>I submitted ballot comment against the IG aligning with FHIR R4... not DSTU2... many things changed between DSTU2 and R4.</p>",
        "id": 160585390,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552408212
    },
    {
        "content": "<p>That's not a reason to change even more things</p>",
        "id": 160585519,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1552408297
    },
    {
        "content": "<p>The comment points out that some servers are acting differently than other servers. I am just looking for everyone to implement the same behavior. Some return all results, some just one newly created document. Some return the document , some don't.. I am looking for deterministic behavior that a client app can rely on. I don't care what that behavior is. It just needs to be consistent, else we are not talking 'standards' we are talking custom code in client apps to deal with custom behavior by various servers.</p>",
        "id": 160585870,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552408511
    },
    {
        "content": "<p>We are concerned about having 2 ways to do the same thing between IHE MHD and US Core.   We feel that these are two broadly implemented specs and see an opportunity to align.   After other feedback, we are considering limiting the scope of docref to CCD as a compromise and adding in the  IHE like search.  </p>\n<p>Thinking aloud ....Or should we support both as an interim solution.   </p>\n<p>RE John;'s concerns  the operation is clearly defined to return DocRef.  So that is not an issue with the specification..</p>",
        "id": 160586119,
        "sender_full_name": "Eric Haas",
        "timestamp": 1552408668
    },
    {
        "content": "<p>Add more explanation / examples to the specs - do not change them<br>\n(and having said that - there will be always incompatible / wrong implementations - that's not something that can be solved just writing specs unfortunately)</p>",
        "id": 160586392,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1552408822
    },
    {
        "content": "<p>does $docref return only onDemand documents? or not?   It says SHOULD today, which is confusing. A client can't tell if it will get duplicate results or not. Can we make this a SHALL-NOT?</p>",
        "id": 160586674,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552408980
    },
    {
        "content": "<p>does $docref return the DocumentReference and the Binary of the document? Seems there is strongest support for YES, both.</p>",
        "id": 160586759,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552409038
    },
    {
        "content": "<p>does $docref return one entry, or a set of documents that meet the criteria? I think the strongest support is that the server determines THE best match, returning one entry that best matches, not all entries that are close.</p>",
        "id": 160586877,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552409092
    },
    {
        "content": "<p>No, not only on demand: 'The server SHOULD return at least all references for documents that it has made available in a document indexing system. This is the same as a simple query '</p>",
        "id": 160587265,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1552409325
    },
    {
        "content": "<p>so then you want it to say SHALL</p>",
        "id": 160587295,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552409346
    },
    {
        "content": "<p>That is clarity I can live with. I don't think it is right, but it is more clear.</p>",
        "id": 160587322,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552409372
    },
    {
        "content": "<p>'This is the same as a simple query' is crystal clear to me</p>",
        "id": 160587422,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1552409425
    },
    {
        "content": "<p>SHOULD is not the same as SHALL</p>",
        "id": 160587434,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552409436
    },
    {
        "content": "<p>SHOULD means to a client... you might get them, you might not.   You are looking at the spec from a server perspective. I am looking at the spec from a client.</p>",
        "id": 160587495,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552409492
    },
    {
        "content": "<p>make it a SHALL... but I suspect that is going to make other server vendors upset... as they return only the onDemand entry.</p>",
        "id": 160587585,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552409538
    },
    {
        "content": "<p>Again, they look clear to me - from both sides - and implementers seems to be ok</p>",
        "id": 160587621,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1552409568
    },
    {
        "content": "<p>Im an implementer... I am not ok with it... hence my ballot comment... the whole reason for standards governance</p>",
        "id": 160587663,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552409611
    },
    {
        "content": "<p>OK - clarify it if you want - but do not _change_ it please</p>",
        "id": 160587786,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1552409676
    },
    {
        "content": "<p>I presented three decisions.. what is your company position? We can then poll all the EHR vendors and see if there is a consensus.</p>",
        "id": 160587863,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552409732
    },
    {
        "content": "<p>The three options above? We'll do C) Be more clear about difference in expectations on search vs $docref operation</p>",
        "id": 160590880,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1552411850
    },
    {
        "content": "<p>reading through chain I am not crystal clear on 'option C)' Please re paste here</p>",
        "id": 160591113,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1552412030
    },
    {
        "content": "<p>Just finished reading this 65+ chain and I am little fuzzy on the conclusion:<br>\nA) Remove operation<br>\nB) Rename operation $generate-or-retrieve-document<br>\nC) Be more clear about difference in expectations on search vs $docref operation</p>",
        "id": 160591957,
        "sender_full_name": "Drew Torres",
        "timestamp": 1552412521
    },
    {
        "content": "<p>I like C too.</p>",
        "id": 160592007,
        "sender_full_name": "Drew Torres",
        "timestamp": 1552412525
    },
    {
        "content": "<p>I don't know about what C means... I pointed out three things that I think are not clear in the current specification. I am okay with keeping $docref if it has a well defined behavior.  Note that I think renaming is helpful to clarity, but clarity is more important first.<br>\n1. does $docref return only onDemand documents? or not? It says SHOULD today, which is confusing. A client can't tell if it will get duplicate results or not. Can we make this a SHALL-NOT?<br>\n2. does $docref return the DocumentReference and the Binary of the document? Seems there is strongest support for YES, both.<br>\n3. does $docref return one entry, or a set of documents that meet the criteria? I think the strongest support is that the server determines THE best match, returning one entry that best matches, not all entries that are close.</p>",
        "id": 160598526,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552416545
    },
    {
        "content": "<p>mmmm when I read it I don't interpret any of that...seems pretty clear to me</p>\n<blockquote>\n<p>1. does $docref return only onDemand documents? or not? It says SHOULD today, which is confusing. A client can't tell if it will get duplicate results or not. Can we make this a SHALL-NOT?</p>\n</blockquote>\n<p>it SHOULD return <strong>DocumentReferences</strong> for both pre-indexed ( I agree SHALL would be better) and on demand : \"a Bundle... containing resources conforming to the US Core DocumentReference Profile for the patient\"      I don't understand the duplicate comment.</p>\n<blockquote>\n<p>2. does $docref return the DocumentReference and the Binary of the document? Seems there is strongest support for YES, both. </p>\n</blockquote>\n<p>NO each DocRef has a URL pointing to a document.  This is a 2 step process get the docref and then the document.  \"The document itself can be subsequently retrieved using the link provided from the DocumentQuery search results. The link could,for example, be a FHIR endpoint to a Binary Resource or some other document repository.\"</p>\n<blockquote>\n<p>3. does $docref return one entry, or a set of documents that meet the criteria? I think the strongest support is that the server determines THE best match, returning one entry that best matches, not all entries that are close.</p>\n</blockquote>\n<p>\"The operation takes the input parameters:</p>\n<p>patient id<br>\nstart date<br>\nend date<br>\ndocument type<br>\nand returns a Bundle off type “searchset” containing resources conforming to the US Core DocumentReference Profile for the patient. \"<br>\n\" If neither a start date nor an end date is provided, the most recent or current document is in scope.\"<br>\n\" If no type is provided, the CCD document if available SHALL be in scope and all other document types MAY be in scope.\"</p>\n<p>Specific behavior by a implementation should be documented in its CapStatement.</p>",
        "id": 160601035,
        "sender_full_name": "Eric Haas",
        "timestamp": 1552418343
    },
    {
        "content": "<p>2 - <span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> you are asserting the exact opposite of what <span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> indicated earlier.</p>",
        "id": 160658681,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552480442
    },
    {
        "content": "<blockquote>\n<p>(We actually stick the document inside attachment.data so there is no second GET needed)</p>\n</blockquote>\n<p>see 2 inline</p>",
        "id": 160658718,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552480484
    },
    {
        "content": "<p>thus, the specification is not clear. on 2</p>",
        "id": 160658735,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552480508
    },
    {
        "content": "<blockquote>\n<p>DocumentReference query cannot achieve the same result <code>$docref?start=x&amp;end=y</code> creates and returns a document with all the data for that period, that is not something a search can do</p>\n</blockquote>\n<p>note this is the strongest argument for keeping $docref, and having it do different things than a query. Totally agree with <span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> . This is why I am NOT trying to eliminate, but rather to make clear THIS is the behavior.</p>",
        "id": 160658966,
        "sender_full_name": "John Moehrke",
        "timestamp": 1552480785
    },
    {
        "content": "<p>here my proposed edits:  <a href=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20066&amp;start=0\" target=\"_blank\" title=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20066&amp;start=0\">https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20066&amp;start=0</a></p>",
        "id": 161184380,
        "sender_full_name": "Eric Haas",
        "timestamp": 1553025247
    },
    {
        "content": "<p>I think I understand your edit proposal, and it seems to address my concerns. I understand that $docref shall return all static results that match the paramaters of $docref while also returning dynamicly created entries for onDemand.  Thanks</p>",
        "id": 161344050,
        "sender_full_name": "John Moehrke",
        "timestamp": 1553174398
    }
]