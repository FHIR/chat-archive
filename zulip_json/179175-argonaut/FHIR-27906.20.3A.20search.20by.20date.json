[
    {
        "content": "<p>in <a href=\"http://jira.hl7.org/browse/FHIR-27906\">J#27906</a> <span class=\"user-mention\" data-user-id=\"192576\">@Robert Scanlon</span>  asked to clarify search by date precision conformance expectations.  </p>\n<p>What do implementers think is a low enough bar.  by day ???</p>\n<p>e.g. :  add bullet in <a href=\"http://build.fhir.org/ig/HL7/US-Core/general-guidance.html#search-syntax\">Search Syntax</a> to say...</p>\n<ul>\n<li>Servers SHALL support search by date to <em>at least</em> day precision</li>\n</ul>\n<p>(but obviously implied is MAY support to even more precise datetime searches )</p>",
        "id": 214211956,
        "sender_full_name": "Eric Haas",
        "timestamp": 1603384022
    },
    {
        "content": "<p>When searching by _lastUpdated you need much more than that - at least second</p>",
        "id": 214218578,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1603387011
    },
    {
        "content": "<p>For everything else I'd say day is fine</p>",
        "id": 214218620,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1603387032
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span>  There is a statement in the specification that there \"may be dragons\" when you search without a time</p>",
        "id": 214221155,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603388211
    },
    {
        "content": "<p>I would prefer not requiring this complexity/support of day precision only if the underlying field always includes time+zone</p>",
        "id": 214221213,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603388239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span>  can you clarify?  Are you proposing no guidance on precision for search by date?</p>",
        "id": 214221606,
        "sender_full_name": "Eric Haas",
        "timestamp": 1603388417
    },
    {
        "content": "<p>I'm proposing to not require servers to support the timeless precision if their underlying server/field is always a date with a timezone, given that there are issues with searching with imprecise dates as called out in the specification</p>",
        "id": 214222001,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603388586
    },
    {
        "content": "<p>This implies a server may need a way to declare the precision supported :)</p>",
        "id": 214222035,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603388605
    },
    {
        "content": "<p><a href=\"http://hl7.org/fhir/search.html#date\">http://hl7.org/fhir/search.html#date</a></p>",
        "id": 214222200,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603388677
    },
    {
        "content": "<p>IE: it makes sense to search a patient by birth date with year, year/m/d, because the field is typically timeless</p>",
        "id": 214222339,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603388739
    },
    {
        "content": "<p>But if searching an observation's date, if the system only ever has a fully qualified date set for that field, you're going to run into \"dragons\" if you don't search with the time + zone</p>",
        "id": 214222514,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603388795
    },
    {
        "content": "<p>What I would like to establish is a <em>minimum</em> expectatation ... if there is one.   <span class=\"user-mention\" data-user-id=\"192576\">@Robert Scanlon</span> ?</p>",
        "id": 214223261,
        "sender_full_name": "Eric Haas",
        "timestamp": 1603389075
    },
    {
        "content": "<p>is this a element by element decision?</p>",
        "id": 214223334,
        "sender_full_name": "Eric Haas",
        "timestamp": 1603389110
    },
    {
        "content": "<p>Minimum may be to support the full timezone search</p>",
        "id": 214223444,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603389146
    },
    {
        "content": "<p>Do we know of servers that <em>don't</em> support that?</p>",
        "id": 214223597,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603389221
    },
    {
        "content": "<p>It's the \"safest\" or \"most well understood\" I think</p>",
        "id": 214223685,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603389253
    },
    {
        "content": "<p>but for Patient.birthDate that seems burdensome for client?</p>",
        "id": 214224173,
        "sender_full_name": "Eric Haas",
        "timestamp": 1603389469
    },
    {
        "content": "<p>(waiting for <span class=\"user-mention\" data-user-id=\"192576\">@Robert Scanlon</span>  to chime in....)</p>",
        "id": 214224404,
        "sender_full_name": "Eric Haas",
        "timestamp": 1603389568
    },
    {
        "content": "<p>That field is unique in that it is defined specifically as a Date and not a DateTime. Maybe it's as easy as looking at the field definition?</p>",
        "id": 214228916,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603391450
    },
    {
        "content": "<p>I think that's pretty rare in the spec</p>",
        "id": 214228941,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1603391461
    },
    {
        "content": "<p>Sorry for the slow response <span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> , I was offline for a bit.  My primary concern is that I think there needs to be some well defined rules so a client can know which precisions a server can handle that doesn't involve trial-and-error.  Those rules could be 'every precision must be supported for every element'.  Or 'this single precision must always be supported'.  Or 'do this precision for this element and this other precision for this other element'.   Or 'check the capabilitystatement for an extensionthat tells you which precision the servers supports'.</p>",
        "id": 214231982,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603392850
    },
    {
        "content": "<blockquote>\n<p>When searching by _lastUpdated you need much more than that - at least second</p>\n</blockquote>\n<p>Search by <code>_lastUpdated</code> isn't required in US Core is it?</p>",
        "id": 214234761,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603394044
    },
    {
        "content": "<p>You're right, it is not. It is the _only_ search by date our client uses though (if the server implements it).</p>",
        "id": 214236551,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1603394852
    },
    {
        "content": "<p>Yeah that's too bad,  it would be very useful to clients that want to synchronize their copy of the data.  Is it widely implemented?</p>",
        "id": 214239336,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603396187
    },
    {
        "content": "<blockquote>\n<p>That field is unique in that it is defined specifically as a Date and not a DateTime. Maybe it's as easy as looking at the field definition?</p>\n</blockquote>\n<p>I took a look at the types associated with all date searches.  All <strong>except two</strong> parameters search elements of type period, dateTime or instant:  Goal has a search of target-date that points to Goal.target.dueDate of type <code>date</code>, though it is not part of a required search.    Patient has a search of birthdate that points to Patient.birthDate of type <code>date</code>, and is part of a required search.</p>",
        "id": 214244288,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603398702
    },
    {
        "content": "<table>\n<thead>\n<tr>\n<th>Resource</th>\n<th>Search Parameter</th>\n<th>Required?</th>\n<th>Fields</th>\n<th>Types</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CarePlan</td>\n<td>date</td>\n<td></td>\n<td>CarePlan.period</td>\n<td>period</td>\n</tr>\n<tr>\n<td>Condition</td>\n<td>onset-date</td>\n<td></td>\n<td>Condition.onset[x]</td>\n<td>dateTime, period</td>\n</tr>\n<tr>\n<td>DiagnosticReport</td>\n<td>date</td>\n<td>x</td>\n<td>DiagnosticReport.effective[x]</td>\n<td>dateTime, period</td>\n</tr>\n<tr>\n<td>DocumentReference</td>\n<td>date</td>\n<td>x</td>\n<td>DocumentReference.date\\</td>\n<td>instant</td>\n</tr>\n<tr>\n<td>DocumentReference</td>\n<td>period</td>\n<td></td>\n<td>DocumentReference.context.period</td>\n<td>period</td>\n</tr>\n<tr>\n<td>Encounter</td>\n<td>date</td>\n<td>x</td>\n<td>Encounter.period</td>\n<td>period</td>\n</tr>\n<tr>\n<td>Goal</td>\n<td>target-date</td>\n<td></td>\n<td>Goal.target.due[x]</td>\n<td>date</td>\n</tr>\n<tr>\n<td>Immunization</td>\n<td>date</td>\n<td></td>\n<td>Immunization.occurrence[x]</td>\n<td>dateTime</td>\n</tr>\n<tr>\n<td>MedicationRequest</td>\n<td>authoredon</td>\n<td></td>\n<td>MedicationRequest.authoredOn</td>\n<td>dateTime</td>\n</tr>\n<tr>\n<td>Observation</td>\n<td>date</td>\n<td>x</td>\n<td>Observation.effective[x]</td>\n<td>dateTime, period</td>\n</tr>\n<tr>\n<td>Patient</td>\n<td>birthdate</td>\n<td>x</td>\n<td>Patient.birthDate</td>\n<td>date</td>\n</tr>\n<tr>\n<td>Procedure</td>\n<td>date</td>\n<td>x</td>\n<td>Procedure.performed[x]</td>\n<td>dateTime, period</td>\n</tr>\n</tbody>\n</table>",
        "id": 214244575,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1603398849
    },
    {
        "content": "<blockquote>\n<p>Is it widely implemented?</p>\n</blockquote>\n<p>No, just a couple of places I believe. In other cases we have to get everything and then filter client-side</p>",
        "id": 214245824,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1603399529
    },
    {
        "content": "<p><a href=\"http://hl7.org/fhir/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.searchParam.documentation\">CapabilityStatement.rest.resource.searchParam.documentation</a>  can used to document the server and client behaviour.  on a resource+sp basis.   So the \"how \" is not the big issue to me is the \"what\"  level of precision. What  I have heard so far is to the day for type <code>date</code> and the  \"the full timezone search\" otherwise</p>",
        "id": 214249258,
        "sender_full_name": "Eric Haas",
        "timestamp": 1603401411
    },
    {
        "content": "<p>trying to document  \"full timezone search\"  and what that means</p>\n<blockquote>\n<p>a precision to the <em>time + timezone</em> ?</p>\n</blockquote>\n<p>so hour is good as a minimum precision?</p>\n<p>and what if I want all the hbac1 since Feb.</p>\n<p><code>GET [base]/Observation?patient=06e1f0dd-5fbe-4480-9bb4-6b54ec02d31b&amp;code=4548-4&amp;date=gt2020-01-01</code></p>\n<p>I think the time is unnecessary here.    so I think <em>with modifiers</em>  gt,lt,ge,le to the day is good</p>",
        "id": 215797468,
        "sender_full_name": "Eric Haas",
        "timestamp": 1604627174
    },
    {
        "content": "<p>If you have a time at all, FHIR requires it to be precise to offset so you couldn't just send hour</p>",
        "id": 215864011,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1604677778
    },
    {
        "content": "<p>following the recommendations above, Observation's field being searched is defined as a dateTime, and to avoid the \"dragons\" in the spec, that would require the fully supplied dt/tm</p>",
        "id": 215864111,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1604677807
    },
    {
        "content": "<p>b/c you may say after january 1, but behind the scenes, that's jan 1 in the <em>server</em> current offset... which can really result in unexpected results</p>",
        "id": 215864226,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1604677867
    },
    {
        "content": "<p>(again, minimum bar of support - a server could decide to support more)</p>",
        "id": 215864452,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1604677969
    },
    {
        "content": "<p>but my query is \"since February?  how is a time zone relevant?  The ask is imprecise so why should the client have to tack on an hour and timezone?</p>",
        "id": 215864507,
        "sender_full_name": "Eric Haas",
        "timestamp": 1604678000
    },
    {
        "content": "<p>I don't see the difficulty here from the client perspective. The client can easily construct a timestamp that means \"since February\".</p>",
        "id": 215864934,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1604678169
    },
    {
        "content": "<p>this is a client expectation btw</p>\n<p>the server's expectation is also unclear to me as I try to document it. ..</p>\n<p>SHALL servers support all the way to fraction seconds,  seconds?  + time zone.  ( I have not checked what the base spec says so may be premature to discuss here)</p>",
        "id": 215864962,
        "sender_full_name": "Eric Haas",
        "timestamp": 1604678181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191315\">Josh Mandel</span> <a href=\"#narrow/stream/179175-argonaut/topic/FHIR-27906.20.3A.20search.20by.20date/near/215864934\">said</a>:</p>\n<blockquote>\n<p>I don't see the difficulty here from the client perspective. The client can easily construct a timestamp that means \"since February\".</p>\n</blockquote>\n<p>that is Ok but I just want to be clear about the client 'burden'</p>",
        "id": 215865123,
        "sender_full_name": "Eric Haas",
        "timestamp": 1604678254
    },
    {
        "content": "<p>All the example in the guide and other guides have been pretty lax with re to precision...so I expect this will require a lot of updates.</p>",
        "id": 215865394,
        "sender_full_name": "Eric Haas",
        "timestamp": 1604678357
    },
    {
        "content": "<p>Would this imply that the above query would/could/should fail?   My assumption was it would but it is not that clear to me.</p>",
        "id": 215865567,
        "sender_full_name": "Eric Haas",
        "timestamp": 1604678419
    },
    {
        "content": "<p>We don't have anyone I'm aware of that uses our (most popular of our APIs) Observation API without an offset</p>",
        "id": 215866466,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1604678755
    },
    {
        "content": "<p>And yes, we would fail that when it doesn't have the offset today. For us, it's especially hard to get something that would meet what an app would \"expect\" there as our data sources are multi-time zone</p>",
        "id": 215866660,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1604678840
    },
    {
        "content": "<p>so even using the current server offset to query behind the scenes gets weird</p>",
        "id": 215866686,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1604678855
    },
    {
        "content": "<p>OK that is helpful to know.</p>",
        "id": 215866794,
        "sender_full_name": "Eric Haas",
        "timestamp": 1604678892
    },
    {
        "content": "<p>I'm fixing my language to be more precise.. we pass in offsets which aren't zones...</p>",
        "id": 215866821,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1604678906
    }
]