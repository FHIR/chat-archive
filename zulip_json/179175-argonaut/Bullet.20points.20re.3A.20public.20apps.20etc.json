[
    {
        "content": "<ol>\n<li>Refresh tokens are important for providing a seamless consumer experience.  If an app is ineligible for refresh tokens, the developer is likely to seek other means of achieving this (e.g., saving a user's password and simulating login; or moving to a cloud-based architecture even though there's no use case for managing data off-device).</li>\n</ol>",
        "id": 237199647,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620063862
    },
    {
        "content": "<ol start=\"2\">\n<li>Client architectures that put data in the cloud (e.g., confidential apps) are open to certain attacks that purely-on-device apps are not subject to (e.g., cloud server becomes compromised and tokens/secrets leak). A breach in this context can be <em>widespread</em>, across many users.</li>\n</ol>",
        "id": 237200049,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620064031
    },
    {
        "content": "<ol start=\"3\">\n<li>Public clients (including, e.g., most native apps today, where an app is only registered once with a given EHR) are open to certain attacks that confidential clients can avoid (e.g., a malicious app on your device might steal tokens from a valid app, or might impersonate a valid app). A breach in this context is more likely to be <em>isolated to a given user or device</em>.</li>\n</ol>",
        "id": 237200243,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620064099
    },
    {
        "content": "<p>--&gt; The choice of app architecture should be based based on context. Apps that already need to manage data in the cloud should consider a confidential client architecture; apps that don't should consider a purely-on-device architecture.</p>",
        "id": 237200372,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620064156
    },
    {
        "content": "<p>But this decision only works if refresh tokns are available in either case; otherwise, app developers will switch architectures <em>just to be able to maintain persistent access</em>, even if the overall security posture is dimnished.</p>\n<p>^^ Is this assessment worth capturing in a \"best practices / considerations\" page?</p>",
        "id": 237200531,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620064206
    },
    {
        "content": "<p>Don't worry, you didn't miss a meeting....Josh + I + Dan had a call to prepare for Friday call and thought why not post some thoughts to help generate discussion.</p>",
        "id": 237200614,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1620064236
    },
    {
        "content": "<p>What options exist that let an auth server verify that a client can secure a refresh token?  Dynamic Client Registration I think is one option.  Are there any others?</p>",
        "id": 237206547,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1620066474
    },
    {
        "content": "<p>Other than a simple self-attestation.</p>",
        "id": 237206844,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1620066581
    },
    {
        "content": "<blockquote>\n<p>What options exist that let an auth server verify that a client can secure a refresh token? Dynamic Client Registration I think is one option. Are there any others?</p>\n</blockquote>\n<p>I don't think dynamic client registration itself does this, right? If this is per-device, then the refresh token and the per-device client_secret can leak through the same channels.</p>",
        "id": 237206967,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620066611
    },
    {
        "content": "<p>I think attestation is a good practice from the \"make sure everyone is thinking about this\" perspective -- but it breaks down if apps that \"admit\" the truth aren't eligible for the access they need.</p>\n<p>So: attestation <em>with the right incentives</em> seems like a good pattern.</p>",
        "id": 237207110,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620066656
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 237892808,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1620422963
    },
    {
        "content": "<p>OAuth 2.1 provides mechanisms for public clients to protect refresh tokens.  See [1] for details, but in summary cryptographic token binding is one mechanism, rotation of detection and replay of refresh tokens is another.</p>\n<p>[1]: <a href=\"https://tools.ietf.org/html/draft-ietf-oauth-v2-1-02#section-6.1\">https://tools.ietf.org/html/draft-ietf-oauth-v2-1-02#section-6.1</a></p>",
        "id": 237893781,
        "sender_full_name": "Matt Randall",
        "timestamp": 1620423486
    },
    {
        "content": "<p>In particular, DPOP should be a readily-accessible method for most applications to perform such cryptographic binding.  See <a href=\"https://tools.ietf.org/html/draft-ietf-oauth-dpop-02\">https://tools.ietf.org/html/draft-ietf-oauth-dpop-02</a></p>",
        "id": 237893866,
        "sender_full_name": "Matt Randall",
        "timestamp": 1620423548
    },
    {
        "content": "<p>And the recommendations for refresh token rotation are something servers can do in a way that's totally transparent for (non-malicious) clients.</p>",
        "id": 237895414,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620424342
    },
    {
        "content": "<p>The DPOP spec is really nice, but early. <span class=\"user-mention\" data-user-id=\"191609\">@Matt Randall</span> do you think this will move ahead?</p>\n<blockquote>\n<p>DPoP does not ensure the integrity of the payload or headers of requests.  The DPoP proof only contains claims for the HTTP URI and  method, but not, for example, the message body or general request headers.</p>\n</blockquote>\n<blockquote>\n<p>This is an intentional design decision intended to keep DPoP simple to use,</p>\n</blockquote>\n<p>That's a really good call. Still, this is a fair amount of new surface area.</p>",
        "id": 237897157,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620425196
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span>  DPOP seems to have some weight behind it, I hadn't even realized I had linked to a previous version - draft 3 apparently was released last month, so it's definitely under active development.</p>\n<p>Refresh token rotation seems fairly achievable without adding a 2nd draft spec into the mix, but has the negative side effect that if something goes awry in managing the state of that token on either side (client or authorization server), it could result in the user having to go back through the authorization flow. </p>\n<p>DPOP on the other hand seems fairly robust and relatively straightforward for both client and server to implement, with the only drawback I see is that the crypto used to bind the refresh token initially won't last forever (after many years, whatever algorithm or key strength that was used would be considered defunct, likely requiring a revocation).</p>",
        "id": 237902044,
        "sender_full_name": "Matt Randall",
        "timestamp": 1620428222
    },
    {
        "content": "<p>To add my opinion, refresh rotation seems favorable initially, given that refresh rotation as a possibility is already covered in 2.0 [1].  </p>\n<p>[1] <a href=\"https://tools.ietf.org/html/rfc6749#section-10.4\">https://tools.ietf.org/html/rfc6749#section-10.4</a></p>",
        "id": 237902281,
        "sender_full_name": "Matt Randall",
        "timestamp": 1620428391
    },
    {
        "content": "<p>I like that DPOP provides an answer to \"how to mitigate the risk of tokens leaving a device\". (We had discussed the idea of dynamic registration + asymmetric keys for otherwise public apps, which can also help in this situation; it's functionally pretty close, if you constrain the scope of \"dynamic registration\" to be \"registering a local device instance associated with all the metadata about some already registered client\")</p>",
        "id": 237902376,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620428431
    }
]