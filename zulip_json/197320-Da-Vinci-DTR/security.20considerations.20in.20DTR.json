[
    {
        "content": "<p>hi <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> , I think as a group we never focussed much on the security portion for any of the Da Vinci IGs in detail at any point. Hence during an overall security sweep, the issue that was brought up during this morning's call can be addressed. We at Mettle, in our workflow already implemented the feature of saving and retrieval of Questionnaires. Since there was no standard, we were implementing it in our own way and will change our implementation based on the standards that will be addressed. <br>\nRegarding security, we currently implement three layers of security. Again this is not the standard way of implementation but had to put in some sort of mechanism to get the appropriate ISO information security certifications. I am presenting the methodology that we use but will be happy to change it once we get a standard way defined by Da Vinci.</p>\n<ol>\n<li>To prevent man-in-the-middle attack, we use the standard TLS encryption for any data that is transmitted between two parties in any direction for all the IGs.</li>\n<li>To identify the application which invoked an FHIR request (get/post/put) we use the client credentials flow. </li>\n<li>In addition to the above two, for communication between providers and payers through an external SMART application, we also include an access token with the appropriate scope from the EHR. The payer/intermediary endpoint which receives the FHIR request will verify the access token with the EHR to confirm the authenticity of the incoming request. For FHIR requests which don't create new resources on the FHIR endpoint, we also make sure that the scope available for the access token supplied is same as the scope allowed for the access token that created the resource. This may or may not be the standard way of doing things, but it covers the security requirements for getting an ISO 27001 Certification for information security. so we implemented this mechanism. </li>\n</ol>\n<p>The payer/intermediary which stores the information has a list of predefined EHR verification systems against which that can verify the access token along with the scopes that it carries.  This list can be updated periodically as needed.  </p>\n<p>We would love to get your feedback on this and will change our process to meet the standard. However, the bottom line here is that we can find some way to establish the authenticity of the incoming requests at the payers end which stores the data.</p>",
        "id": 257471891,
        "sender_full_name": "Sreekanth Puram",
        "timestamp": 1634180341
    },
    {
        "content": "<p>For step 2, are you talking about requests to the EHR or requests to the payer?  What we're introducing is the latter.  If you're referring to app-to-payer, can you expand on what \"client credentials flow\" is?</p>\n<p>The challenge that we have is:</p>\n<ul>\n<li>the app could be any SMART app that implements DTR (though we could enforce that the payer must 'trust' the app and there could possibly be a shared secret)</li>\n<li>shared secret isn't super robust though.  If anyone gets hold of the code for the SMART app, they could learn that secret and impersonate the app</li>\n<li>payer isn't part of the SMART Oauth process and won't be known to the auth server.</li>\n</ul>",
        "id": 257472605,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634180982
    },
    {
        "content": "<p>I am talking about the app to the payer. The client credentials flow would require that we use a client id and client secret to authenticate a client which is accessing a FHIR endpoint. Instead of using a clear text client secret, we can use a signed key (a JWT) as a client secret. The signed key will be obtained dynamically from the app vendor's endpoint after checking the authenticity of the EHR under which the app is being invoked. </p>\n<p>As mentioned in step 3: If the payer does not trust the app vendor alone, they should be able to  verify the authenticity of the EHR/Hospital system which invoked the smart app in addition to verifying the mart app.</p>",
        "id": 257473669,
        "sender_full_name": "Sreekanth Puram",
        "timestamp": 1634181898
    },
    {
        "content": "<p>I'm not understanding the flow.  We're talking about securing the connection from SMART app to payer.  How is the EHR involved at all?  And how is the vendor involved?  Do you have a flow diagram?</p>",
        "id": 257474657,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634182761
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> please find the image for  the provider side auth workflow below<br>\n<a href=\"/user_uploads/10155/GcUy7jF2o8dBexd9bNxxrmr1/provider_side.jpg\">provider_side.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/GcUy7jF2o8dBexd9bNxxrmr1/provider_side.jpg\" title=\"provider_side.jpg\"><img src=\"/user_uploads/10155/GcUy7jF2o8dBexd9bNxxrmr1/provider_side.jpg\"></a></div>",
        "id": 257480770,
        "sender_full_name": "Sreekanth Puram",
        "timestamp": 1634188332
    },
    {
        "content": "<p>And the payer side workflow below <a href=\"/user_uploads/10155/3NqEoPscvWnjBi7FnqwTbX6s/payer_side.jpg\">payer_side.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/3NqEoPscvWnjBi7FnqwTbX6s/payer_side.jpg\" title=\"payer_side.jpg\"><img src=\"/user_uploads/10155/3NqEoPscvWnjBi7FnqwTbX6s/payer_side.jpg\"></a></div>",
        "id": 257480888,
        "sender_full_name": "Sreekanth Puram",
        "timestamp": 1634188457
    },
    {
        "content": "<p>Ok, so you're passing the access token given to the SMART app to access the EHR along to the payer to govern what the app is allowed to access.  That may be sufficient.  Even if the credentials the app uses to sign its JWT are compromised, an app can't do anything unless it's launched by an EHR (which means you can't just stand up your own app and start hitting payer) and the app can only access the data for the specific patient the app was launched for).  If the app is launched without patient context, then it won't have permission to access any of the stored DocumentReferences.</p>",
        "id": 257526605,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634214922
    },
    {
        "content": "<p>That's correct. There may be few other methodologies that we may come up with if we do a security sweep of all the Implementation guides.</p>",
        "id": 257535576,
        "sender_full_name": "Sreekanth Puram",
        "timestamp": 1634218469
    },
    {
        "content": "<p>I think your approach is proper and what I would recommend. the shared secret is what is supported today, UDAP will bring in better approaches. I would recommend DaVinci always defer to the security IGs, and the security checklist in the core spec.</p>",
        "id": 257560918,
        "sender_full_name": "John Moehrke",
        "timestamp": 1634227632
    },
    {
        "content": "<p>The security checklist doesn't nail down the validation mechanisms.  Certainly we need to point to it as a starting point and to cover generic stuff, but we need to constrain and be tighter to ensure interoperability and raise the bar in certain places.  UDAP presumes application registries, which I don't think we're going to have...</p>",
        "id": 257562662,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634228312
    },
    {
        "content": "<p>agreed. glad to get improvement requests for the FHIR core security pages.</p>",
        "id": 257581030,
        "sender_full_name": "John Moehrke",
        "timestamp": 1634235522
    },
    {
        "content": "<p>What is the benefit of the Payer receiving the Access Token issued by the EHR for the App? <br>\nCan then payer somehow tell which patient's/user's etc. scope the access token has? <br>\nOr is the payer required to validate that the given access token can be used to read the specific patient from the EHR before returning a response?</p>",
        "id": 257581910,
        "sender_full_name": "Matt Varghese",
        "timestamp": 1634235885
    },
    {
        "content": "<p>In addition to checking whether the request came from a valid app, the payer also needs to make sure that the app is not invoked outside the EHR from which it was launched when it created the DocumentReference. The patient/user context can be retrieved from the access token. Again this is one way of solving the problem of client secret getting misused. There may be other mechanisms.</p>",
        "id": 257583855,
        "sender_full_name": "Sreekanth Puram",
        "timestamp": 1634236658
    },
    {
        "content": "<p>minimally it is useful to record in the audit log the triggering user and purpose. Often the user is not used in an access permit/deny decision.</p>",
        "id": 257584035,
        "sender_full_name": "John Moehrke",
        "timestamp": 1634236724
    },
    {
        "content": "<p>Yes - the payer would absolutely be needing to enforce the same patient scope.  Best way to do that is probably to have the DocumentReferences on the payer be absolute references to the EHR's Patient (rather than the payer's member).  Then there's should be no need for the payer to query the EHR to check the token or try to resolve patient's resource id to payer's member id.</p>",
        "id": 257589619,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634238985
    },
    {
        "content": "<p>In our case, we'd absolutely want to use it in permit/deny - so a malicious app can't query any other patient's data than the specific one the user of the SMART app is trying to access.</p>",
        "id": 257589745,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634239037
    },
    {
        "content": "<blockquote>\n<p>Then there's should be no need for the payer to query the EHR to check the token or try to resolve patient's resource id to payer's member id.</p>\n</blockquote>\n<p>Are you saying then that the DTR App cannot do a DocumentReference Search; only a DocumentReference read? I can't see how that would work, since the DTR App will not have the  ID of the DocumentReference.<br>\nAnd if Search is available, most implementations don't allow scoping for search on only some search params, and not other search params. </p>\n<p>So as long as the DTR App needs to be able to do a DocumentReference search, it would not be safe until the payer validates the token, and verifies that the patient is the same patient in the EHR scope?</p>",
        "id": 257616925,
        "sender_full_name": "Matt Varghese",
        "timestamp": 1634250979
    },
    {
        "content": "<p>It can do a search, but it needs to be limited to only searching for the DocumentReferences for the current patient.</p>",
        "id": 257617000,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634251028
    },
    {
        "content": "<p>There is no \"current patient\" on the payer side. Only the EHR side has a \"current patient\"?</p>",
        "id": 257617044,
        "sender_full_name": "Matt Varghese",
        "timestamp": 1634251054
    },
    {
        "content": "<p>The 'current patient' is identified in the token from the EHR.  We will need to find a way to pass that same token to the payer - possibly in a new header.  (It's not a 'regular' auth token as it's not for the payer's system.)</p>",
        "id": 257617263,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634251171
    },
    {
        "content": "<p>Would that do anything, unless the <strong>payer validates with the EHR</strong> that the current patient it was passed is indeed the patient the EHR has open?</p>",
        "id": 257631191,
        "sender_full_name": "Matt Varghese",
        "timestamp": 1634260180
    },
    {
        "content": "<p>The token from EHR to smart app has a limited time-span and would have had to have been in the app's \"hands\" to query with in order for it to re-use later, so it can't really access anything it wouldn't have already had access to in that scenario.</p>",
        "id": 257633531,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634262131
    },
    {
        "content": "<p>That is the case when the app is a real app. </p>\n<p>But if the app is a malicious app, it can just pull out a token and a current patient ID from thin air, and then do a DocumentReference search for perhaps something like all DocumentReferences Authored by XYZ Clinic. </p>\n<p>If the payer doesn't validate the token, and the patient and find that the token and patient are not real, this is not doing any good?</p>",
        "id": 257635015,
        "sender_full_name": "Matt Varghese",
        "timestamp": 1634263441
    },
    {
        "content": "<p>The payer will need to validate the token.  I don't understand why it would also need to validate the patient.  If the token was valid, why would the patient not be?</p>",
        "id": 257636941,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634265184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/197320-Da-Vinci.20DTR/topic/security.20considerations.20in.20DTR/near/257636941\">said</a>:</p>\n<blockquote>\n<p>The payer will need to validate the token.  I don't understand why it would also need to validate the patient.  If the token was valid, why would the patient not be?</p>\n</blockquote>\n<p>The payer needs to validate the token and should be able to extract information about the logged-in user, patient, etc. <br>\n For non-popular EHRs or practice management systems, the payer should also have a list of other third-party authentication tools like Auth0, AWS Cognito, etc that they trust.</p>\n<p>The other option is for the EHR to provide a digitally signed key with timestamp on demand for the apps which run within its scope. That way, the payer can always verify if the call comes from a EHR invoked app or a malicious app.</p>",
        "id": 257642691,
        "sender_full_name": "Sreekanth Puram",
        "timestamp": 1634270468
    },
    {
        "content": "<p>Apps can change, so what's not malicious today might become ill-behaved.  Our mechanism needs to ensure that the payer can limit the app to only seeing stored information relevant to the patient the EHR feels is in context.</p>",
        "id": 257643219,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634270936
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> I am just thinking out loud. Can we use the same mechanism to handle the problem of Alert fatigue where the payer stores  the app context and other metadata for every CRD requestby default? So in case, the provider misses the alert arising out of the response to CDS hooks, the provider or the back-office staff can launch a SMART app and start the DTR process at a later stage also.</p>",
        "id": 257726338,
        "sender_full_name": "Sreekanth Puram",
        "timestamp": 1634315497
    },
    {
        "content": "<p>I don't think storing the information addresses alert fatigue.  Alert fatigue is addressed by ensuring that the card is only passed back when there is DTR information to fill out that a) should be filled out now; and b) should be filled out by the current user.  However, in those cases where the provider opts not to launch DTR right now (e.g. they're too busy), then yes, we could cause it to be automatically stored.</p>",
        "id": 257729396,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1634316793
    }
]