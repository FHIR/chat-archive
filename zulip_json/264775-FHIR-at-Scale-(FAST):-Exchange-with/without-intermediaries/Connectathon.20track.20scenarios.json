[
    {
        "content": "<p>Draft test scenarios to discuss at tomorrow's Hybrid / Intermediary Exchange call. (1:00 ET, <a href=\"https://global.gotomeeting.com/join/262996117\">https://global.gotomeeting.com/join/262996117</a>)</p>\n<p><a href=\"/user_uploads/10155/3EZcbwakfdHUKHhaKIOgP2Rh/FAST-Exchange-Connectathon-Scenarios-draft-20211220.docx\">FAST-Exchange-Connectathon-Scenarios-draft-20211220.docx</a></p>",
        "id": 265631829,
        "sender_full_name": "Frank McKinney",
        "timestamp": 1640045799
    },
    {
        "content": "<p>FYI - I was able to get async working on the eHx Hub POC, using our POC HAPI FHIR server as the target responder, application path routing, and I disabled URL rewriting.  Tested multiple times today and it looks good.  So we should be good to go for testing the (new) async workflow next week.</p>",
        "id": 266993338,
        "sender_full_name": "Mike Yackanich",
        "timestamp": 1641418012
    },
    {
        "content": "<p>I reconfigured the eHx POC Intermediary to use hostname-based routing (versus AppPath) - and I recreated all of the Postman request tests.  I'll share the new Postman with <span class=\"user-mention\" data-user-id=\"238597\">@Frank McKinney</span>  and <span class=\"user-mention\" data-user-id=\"196338\">@Patrick Murta</span>  via email.  Note that all of these tests use the public HAPI server at <a href=\"http://hapi.fhir.org\">hapi.fhir.org</a> as the target responder.</p>",
        "id": 267635074,
        "sender_full_name": "Mike Yackanich",
        "timestamp": 1641930478
    },
    {
        "content": "<p>Is there a scenario where the destination uses two intermediaries in parallel?</p>",
        "id": 267638246,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1641931894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192685\">@Vassil Peytchev</span>  - not that I know of, so I defer to Frank and Patrick.  The current multi-hop scenario with 2 intermediaries is sequential.  Not sure I understand a multi-intermediary, parallel scenario.  Would this represent a fan-out of sorts by the intermediaries?</p>",
        "id": 267643406,
        "sender_full_name": "Mike Yackanich",
        "timestamp": 1641934489
    },
    {
        "content": "<p>I am imagining different intermediaries providing a different entry points - for example, one for claims/billing type queries, another for clinical data queries. Or is the current assumption that a destination can only get queries from a single intermediary?</p>",
        "id": 267644916,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1641935191
    },
    {
        "content": "<p>TEFCA has one intermediary for all requests for one client</p>",
        "id": 267645007,
        "sender_full_name": "David Pyke",
        "timestamp": 1641935229
    },
    {
        "content": "<p>Not client, destination. Or did you mean from the destination's point of view, a client can only reach it via only one intermediary? If that is the case, I am thinking multiple clients, some use int1 (and always int1) and others use int2 (and always int2). destination needs to respond to both int1 and int2.</p>",
        "id": 267645524,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1641935469
    },
    {
        "content": "<p>YEs, both.  A client -&gt; int1 -&gt; int 2 -&gt; destination.  There may be more than 2 intermediaries involved</p>",
        "id": 267647054,
        "sender_full_name": "David Pyke",
        "timestamp": 1641936252
    },
    {
        "content": "<p>more than one client may use int1, more than one destination may use int2</p>",
        "id": 267647112,
        "sender_full_name": "David Pyke",
        "timestamp": 1641936278
    },
    {
        "content": "<p>but a destination will only be connected to one QHIN/intermediary</p>",
        "id": 267647164,
        "sender_full_name": "David Pyke",
        "timestamp": 1641936311
    },
    {
        "content": "<p>So it may be client2 -&gt; int3 -&gt; int2 -&gt; destination</p>",
        "id": 267647223,
        "sender_full_name": "David Pyke",
        "timestamp": 1641936344
    },
    {
        "content": "<p>But client 1 will only connect though int1</p>",
        "id": 267647334,
        "sender_full_name": "David Pyke",
        "timestamp": 1641936384
    },
    {
        "content": "<p>That example will work. My concern is that in the above example from Dave, the existence of int1 and int3 has not been considered by the IG. It requires that the destination is aware of the existence of int1 and int3, and which one was the entry point for the query that is coming from int2.</p>",
        "id": 267650902,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1641937981
    },
    {
        "content": "<p>This solution needs to be flexible enough for there to be a ring of 10+ intermediaries that may need to connect via int2 to destination</p>",
        "id": 267651390,
        "sender_full_name": "David Pyke",
        "timestamp": 1641938177
    },
    {
        "content": "<p>int2 would be one of the intermediaries in the ring</p>",
        "id": 267651715,
        "sender_full_name": "David Pyke",
        "timestamp": 1641938352
    },
    {
        "content": "<p>Exactly, and the way to do this is not by making the destination magically slap a different FHIR base on any full URLs it has depending on which of  the 10+ intermediaries the initial request comes from, but by accepting the inevitability that any FHIR intermediary must handle URL re-writes (and re-sign and re-encrypt content if necessary).</p>",
        "id": 267652697,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1641938792
    },
    {
        "content": "<p>Yeah, although I'm not a fan of re-sign/re-encrypt as that would have issues with provenance</p>",
        "id": 267652959,
        "sender_full_name": "David Pyke",
        "timestamp": 1641938921
    },
    {
        "content": "<p>In fairness, I assume that production intermediaries will need to support re-sign/re-encrypt anyway, since that needs to happen if the MIME type changes...  :-/<br>\n(note: I do <em>not</em> like this story, just reading it as I see it written)</p>",
        "id": 267748229,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1642004744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194452\">@Bas van den Heuvel</span>  - the multi-hop requests are now flowing to your intermediary successfully.  I had to restart my service.  The following example actually routes through 3 intermediaries (2 of mine, and then yours), and then arrives at the target destination of <a href=\"http://hapi.fhir.org\">hapi.fhir.org</a>.  Note that public.hapi.fhir.org.multihop must resolve to 52.10.37.229.</p>\n<p>wget --no-check-certificate --quiet \\<br>\n  --method GET \\<br>\n  --timeout=0 \\<br>\n  --header '' \\<br>\n   '<a href=\"http://public.hapi.fhir.org.multihop:52774/fhirproxy/fast/r4/Patient?_id=2696380\">http://public.hapi.fhir.org.multihop:52774/fhirproxy/fast/r4/Patient?_id=2696380</a>'  -SO-</p>",
        "id": 267757634,
        "sender_full_name": "Mike Yackanich",
        "timestamp": 1642008420
    },
    {
        "content": "<p>It also worked from my PC - good work.</p>",
        "id": 267759081,
        "sender_full_name": "Bas van den Heuvel",
        "timestamp": 1642009023
    }
]