[
    {
        "content": "<p>We currently have a number of places where we have a particularly unwieldy definition link this:</p>",
        "id": 179379451,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572386776
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/4dD-sDji4RBCefh_RO3gk3ji/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/4dD-sDji4RBCefh_RO3gk3ji/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/4dD-sDji4RBCefh_RO3gk3ji/pasted_image.png\"></a></div>",
        "id": 179379506,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572386819
    },
    {
        "content": "<p>or, as an alternative:</p>",
        "id": 179379527,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572386829
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/XufqNOY9fsO3qdpW5VXL9roj/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/XufqNOY9fsO3qdpW5VXL9roj/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/XufqNOY9fsO3qdpW5VXL9roj/pasted_image.png\"></a></div>",
        "id": 179379869,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572387007
    },
    {
        "content": "<p>Neither of these patterns are particularly rewarding, and I'd like it if we could come up with a better approach such that the structure definition could just say:</p>\n<p><code>Instantiates[x] : Canonical(Definition) | uri  0..*</code></p>",
        "id": 179379962,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572387074
    },
    {
        "content": "<p>This thread is discussing options to get to that point.</p>",
        "id": 179379988,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572387091
    },
    {
        "content": "<p>note that the fundamental underlying problem is how these things are represented in json, as an array with no type</p>",
        "id": 179380008,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572387114
    },
    {
        "content": "<p>Note that making any changes in this space will likely involve breaking reference implementations, parsers and serializers and involves changing 'normative' content, so it's something that would need to meet with near universal acceptance by implementers if we were going to fix it.</p>",
        "id": 179396748,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572401614
    },
    {
        "content": "<p>right. It's not clear that this would count as a 'breaking change' since past content would (must) continue to be valid. but it's still a significant change</p>",
        "id": 179399149,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572405397
    },
    {
        "content": "<p>The most obvious thing to do is the simplest, rather than the nicest. To say that if the array is polymorphic, then all entries are Tuples with value and type properties:</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"s2\">&quot;instantiates&quot;</span> <span class=\"err\">:</span> <span class=\"p\">[{</span>\n    <span class=\"nt\">&quot;value&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;http://someuri&quot;</span><span class=\"p\">,</span>\n    <span class=\"nt\">&quot;type&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;uri&quot;</span>\n  <span class=\"p\">},{</span>\n    <span class=\"nt\">&quot;value&quot;</span> <span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"nt\">&quot;reference&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;http://someuri&quot;</span> <span class=\"p\">},</span>\n    <span class=\"nt\">&quot;type&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;Reference&quot;</span>\n  <span class=\"p\">}]</span>\n</pre></div>",
        "id": 182014040,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574858042
    },
    {
        "content": "<p>the XML would be:</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"nt\">&lt;instantiatesUri</span> <span class=\"na\">value=</span><span class=\"s\">&quot;http://someuri&quot;</span><span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;instantiatesReference&gt;</span>\n     <span class=\"nt\">&lt;reference</span> <span class=\"na\">value=</span><span class=\"s\">&quot;http://someuri&quot;</span><span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;/instantiatesReference&gt;</span>\n</pre></div>",
        "id": 182014214,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574858177
    },
    {
        "content": "<p>Not sure how that can be a non-breaking change?</p>",
        "id": 182072866,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1574902434
    },
    {
        "content": "<p>it doesn't change anything that is already exchanged</p>",
        "id": 182075991,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574906655
    },
    {
        "content": "<p>The key question is whether the choice of which to use is mostly/always at run-time, or whether the intention is that one of these options will always be profiled out to leave the one that is thought to be required in some particular operational situation.</p>",
        "id": 182091001,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574930346
    },
    {
        "content": "<p>I think it's a 50:50 mix of those things</p>",
        "id": 182096949,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574936297
    },
    {
        "content": "<p>If in any Resource, it is not knowable, I.e has to be assumed to be runtime, you can use  a wrapper class/type that contains the variant ways of representing the reference, and at the point of reference you don't have any 'multiple' problem at all.</p>",
        "id": 182102336,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574941771
    },
    {
        "content": "<p>That seems like an implementation strategy, but it's not clear how it adds value to the specification (and equally viable implementation strategy is just to point to Object or equivalent and have logic that checks whether the Object is one of the allowed types.</p>",
        "id": 182119714,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1574957027
    },
    {
        "content": "<p>A key thing is that our choices aren't generally driven by shared attributes, but rather by shared capabilities.  It's totally fine to have two classes as part of a choice that have no overlapping attributes at all.</p>",
        "id": 182119769,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1574957074
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I guess we lucked out that OO decided 'instantiates' wasn't core for Observation.  However, it would still break the serialization of instantiates[x] everywhere it does appear and the serialization was supposed to be normative.  Howe can we say that's allowed?</p>",
        "id": 182119906,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1574957191
    },
    {
        "content": "<blockquote>\n<p>it would still break the serialization of instantiates[x] everywhere it does appear</p>\n</blockquote>\n<p>How do you figure that?</p>",
        "id": 182119923,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574957216
    },
    {
        "content": "<p>Instead of showing up as \"instantiatesUri\" as the JSON propery it'll show up as \"instantiates\"</p>",
        "id": 182120462,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1574957750
    },
    {
        "content": "<p>only it it's cardinality is 0..*, and nothing like that exists right now</p>",
        "id": 182120519,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574957773
    },
    {
        "content": "<p>So this would only change the names if the element repeated, but not if maxOccurs=1?  The creates a different kind of pain...</p>",
        "id": 182120593,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1574957860
    },
    {
        "content": "<p>yes that's what I proposed.</p>",
        "id": 182120649,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574957891
    },
    {
        "content": "<p>because I don't see a way not to have that pain in the json format.</p>",
        "id": 182120686,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574957934
    },
    {
        "content": "<blockquote>\n<p>That seems like an implementation strategy, but it's not clear how it adds value to the specification (and equally viable implementation strategy is just to point to Object or equivalent and have logic that checks whether the Object is one of the allowed types.</p>\n</blockquote>\n<p>Well it's a modelling strategy - it simplifies the Resource definitions. The variant reference / inline attributes are now in some class/definition that can contain various kinds of references and/or values. Secondly, it seems unwieldy having two data items for instantiatesUri and instantiatesCanonical - presumably only one of them will ever be set at any time, and they are both in fact URIs. As far as I can see, the construct canonical(T) indicates that the target of the URI must be a Resource of type T, but does that turn into anything concrete? Anyway, is there any reason a reference to a protocol (where this kind of thing appears in <a href=\"http://hl7.org/fhir/servicerequest.html\" target=\"_blank\" title=\"http://hl7.org/fhir/servicerequest.html\">http://hl7.org/fhir/servicerequest.html</a>) can't easily change from something that might happen to be FHIR Resource-represented or representable to something else? That would be another reason to get rid of the pattern instantiatesUri / instantiatesCanonical.</p>",
        "id": 182129530,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574966960
    },
    {
        "content": "<blockquote>\n<p>is there any reason a reference to a protocol (where this kind of thing appears in <a href=\"http://hl7.org/fhir/servicerequest.html\" target=\"_blank\" title=\"http://hl7.org/fhir/servicerequest.html\">http://hl7.org/fhir/servicerequest.html</a>) can't easily change from something that might happen to be FHIR Resource-represented or representable to something else</p>\n</blockquote>\n<p>I'm not quite sure what you mean there. The principle is that it might refer to a formally defined protocol - using a PlanDefinition - but it might just refer to some published paper or something published elsewhere. but when profiling, people may want to make a rule that it has to be one or the other. Though they might not either. </p>\n<p>It is very unwieldy - I don't like where we are at all here. Hence the discussion.</p>",
        "id": 182129728,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574967145
    },
    {
        "content": "<p>It is possible to have more than one.  A single action could follow more than one protocol or be part of more than one order set.  And they might be any combination of resource or web page/PDF.  </p>\n<p>I don't understand how introducing wrapper classes would simplify.  Providing a list of candidate types seems simpler than having a class containing multiple properties restricting to only one.</p>",
        "id": 182131214,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1574968903
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>is there any reason a reference to a protocol (where this kind of thing appears in <a href=\"http://hl7.org/fhir/servicerequest.html\" target=\"_blank\" title=\"http://hl7.org/fhir/servicerequest.html\">http://hl7.org/fhir/servicerequest.html</a>) can't easily change from something that might happen to be FHIR Resource-represented or representable to something else</p>\n</blockquote>\n<p>I'm not quite sure what you mean there. The principle is that it might refer to a formally defined protocol - using a PlanDefinition - but it might just refer to some published paper or something published elsewhere. but when profiling, people may want to make a rule that it has to be one or the other. Though they might not either. </p>\n<p>It is very unwieldy - I don't like where we are at all here. Hence the discussion.</p>\n</blockquote>\n<p>Right - today it points to an NCI PDF, next month (perhaps due to a new research paper in the BMJ) some places decide to move over to some better <a href=\"http://NICE.org.uk\" target=\"_blank\" title=\"http://NICE.org.uk\">NICE.org.uk</a> protocol, for which, let's just say, the Interopen people here happen to have built a PlanDefinition profile, and suddenly those data refs inside various FHIR resources being generated days after that now have a null in the instantiatesUri field, and a new, different URI in the instantiatesCanonical field. Now let's imagine that a year later, everyone moves on yet again to another protocol, say developed by U Waterloo and the refs are now all pointing to HTML pages on their site. You get the idea.</p>\n<p>So I think that patterns such as these need to reflect better the very fluid states of affairs in the real world, and thus to assume less, and perhaps unexpectedly, the models actually can be made cleaner, even though the reality they represent is messier than one might like.</p>",
        "id": 182134423,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574973145
    },
    {
        "content": "<p>I think you are saying that because it's a URI in either case, the differentiation of what the URI refers to shouldn't be explicit in the instance.</p>",
        "id": 182134970,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574973967
    },
    {
        "content": "<p>I think the whole grounds for the pattern in the first place is because some group of implementers very much wanted it to be explicit in the instance</p>",
        "id": 182135314,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574974446
    },
    {
        "content": "<p>Firstly, how are you going to make the type (e.g. ActivityDefinition) explicit in the URI? Secondly, why are there 2 URI fields when they are (slightly) alternative representations for one actual reference. This is from ServiceRequest, but I think the same argument applies to the other instances of this. You don't use 2 fields to carry one thing at runtime, especially when in all cases it is a URI.</p>\n<p>Anyway, do you know what the implementers  /designers were really thinking when they created this? Maybe they don't know much about modelling techniques and thought that was the way to capture a single data item that can have different format URIs? Maybe they know all about modelling and had something more esoteric in mind. It is not clear from the definition. Maybe worth finding out about.</p>",
        "id": 182137852,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574978142
    },
    {
        "content": "<blockquote>\n<p>Anyway, do you know what the implementers /designers were really thinking when they created this?</p>\n</blockquote>\n<p>Yes because I asked as soon as I saw the pattern</p>",
        "id": 182138255,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574978815
    },
    {
        "content": "<p>And... are you saying it's the right pattern for the design intention?</p>",
        "id": 182138285,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574978869
    },
    {
        "content": "<p>no. I question both the design intention and the instantiation</p>",
        "id": 182138336,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574978918
    },
    {
        "content": "<p>Right. So, wouldn't you agree that we need to get more rigorous about this kind of thing? Because at the moment, things like this are getting cemented into the foundations and are starting to become unchangeable legacy way too soon...</p>",
        "id": 182138414,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574979042
    },
    {
        "content": "<p>I agree we should question the design yes</p>",
        "id": 182138431,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574979078
    },
    {
        "content": "<p>but it always helps to understand the requirements. For instance, why did the designers want to make a statement about the target explicit in the source ?</p>",
        "id": 182138480,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574979157
    },
    {
        "content": "<p>Not the target, the type of target. We have the same thing in openEHR, when you want to constrain a URI to point to a type of thing, it's actually not that easy.</p>",
        "id": 182138934,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574979865
    },
    {
        "content": "<p>how is it done in openEHR?</p>",
        "id": 182138950,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574979884
    },
    {
        "content": "<p>Well we don't have any pretty method right now, but the right way to do it would be to store the constraint in the relevant archetype node. It means having to have a specific archetype node type for references. The type constraint, unlike nearly every other archetype constraint, isn't a constraint on the runtime value of anything; instead, it just retains the fact that the designers want the URI pointing to a type XYZ thing at runtime. Now, in openEHR at least, when data are being created, you have the archetypes (or bits thereof, within templates) live in memory, in a data-constructor context. So the data builder can find out what that type info was for a URI field, and assuming it has some way to determine the dynamic type of the attached data object, it can do the usual check: does this data satisfy the archetype constraint.</p>",
        "id": 182139104,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980126
    },
    {
        "content": "<p>So most if not all of this logic could be replicated in FHIR-land, but it probably needs some special node type in StructureDefinition or somewhere.</p>",
        "id": 182139121,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980163
    },
    {
        "content": "<p>I have FHIR DSTU4 in the ADL workbench, I could show how this works in archetypes at some future date.</p>",
        "id": 182139133,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980199
    },
    {
        "content": "<p>well, in fact, we have the field- targetProfile. We just have a set of methodology rules built in that mean that you can't have a type that <em>might</em> have a targetProfile.</p>",
        "id": 182139275,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574980346
    },
    {
        "content": "<p>either it does or doesn't. And so you end up where we are</p>",
        "id": 182139352,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574980503
    },
    {
        "content": "<p>so a different approach to this problem is to either define a new type that <em>may</em> have a target profile. (or adapt either uri or canonical so that it may have a targetProfile or not)</p>\n<p>or Define a special value for targetProfile that means, not a resource</p>",
        "id": 182139436,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574980661
    },
    {
        "content": "<p>that reminds me, though, of one of the differences here - the resolution path for a canonical is different to the resolution path for a uri, which is one reason to make them separate</p>",
        "id": 182139497,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574980706
    },
    {
        "content": "<p>Right, so you have to have a wrapper type, that carries a URI reference, and some other optional constraint info, e.g. the target canonical type if there is one. Then the Resource definition can just have one field 'protocol' or whatever, with the type constraints, but now understood as: if this URI points to a Resource at runtime, it should be of one of these types...</p>",
        "id": 182139503,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980724
    },
    {
        "content": "<p>Well, all the more reason to hide that detail in a small type...</p>",
        "id": 182139529,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980777
    },
    {
        "content": "<p>hah- you've ended up exactly where we'd be, if not that the JSON foramt doesn't support that construct. Which is why we disallow it. I'm proposing a solution...</p>",
        "id": 182139530,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574980779
    },
    {
        "content": "<p>Well that's the tail wagging the dog, but anyway, why doesn't it work? I can think of a JSON structure to do the openEHR equivalent...</p>",
        "id": 182139588,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980834
    },
    {
        "content": "<p>isn't the problem in the StructureDefinition meta-type on which the JSON is based?</p>",
        "id": 182139601,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980866
    },
    {
        "content": "<p>(i.e. you need a new meta-type)</p>",
        "id": 182139603,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980874
    },
    {
        "content": "<p>because json isn't inherently polymorphic. And we didn't define the structure to do that - much argument about pros and cons back then.</p>",
        "id": 182139605,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574980880
    },
    {
        "content": "<p>you need to use _type in JSON. If you don't, you're dead.</p>",
        "id": 182139612,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980901
    },
    {
        "content": "<p>Seriously...</p>",
        "id": 182139615,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980917
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>{\n    &quot;message&quot;: &quot;Error message&quot;,\n    &quot;code&quot;: 90000,\n    &quot;errors&quot;: [\n        {\n            &quot;_type&quot;: &quot;DV_CODED_TEXT&quot;,\n            &quot;value&quot;: &quot;Error message&quot;,\n            &quot;defining_code&quot;: {\n                &quot;terminology_id&quot;: {\n                    &quot;value&quot;: &quot;local&quot;\n                },\n                &quot;code_string&quot;: &quot;9000&quot;\n            }\n        },\n        {\n            &quot;_type&quot;: &quot;DV_CODED_TEXT&quot;,\n            &quot;value&quot;: &quot;Secondary error message&quot;,\n            &quot;defining_code&quot;: {\n                &quot;terminology_id&quot;: {\n                    &quot;value&quot;: &quot;local&quot;\n                },\n                &quot;code_string&quot;: &quot;8000&quot;\n            }\n        }\n    ]\n}\n</pre></div>",
        "id": 182139681,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574980996
    },
    {
        "content": "<p>I'll take that as an endorsement of my proposal then, since that is what my proposal was</p>",
        "id": 182139688,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574981007
    },
    {
        "content": "<p>that's just some openEHR EHR data, but you get the idea - those fields starting with '_type' are polymorphic fields.</p>",
        "id": 182139746,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574981052
    },
    {
        "content": "<p>I would strongly recommend using that generally, it's crippling not having it.</p>",
        "id": 182139756,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574981092
    },
    {
        "content": "<p>(we do the same in JSON archetype serialisation, I just don't  have one to hand right now)</p>",
        "id": 182139777,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1574981137
    },
    {
        "content": "<p>Makes json de-serialization totally custom doesn't it?<br>\nAnd would need to switch on that property before trying to understand the other fields.</p>",
        "id": 184830694,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1578193687
    },
    {
        "content": "<p>yes, like we do already with resourceType</p>",
        "id": 184836533,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1578206388
    },
    {
        "content": "<p>Well you can use normal JSON deserialsation, but then you have to post-process the resulting data tree. That implies using an intermediate class model that represents a generic data tree that can be further traversed to generate the 'real' class instances. There are other strategies. JSON just ins't semantically very strong.</p>",
        "id": 185217085,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1578580790
    }
]