[
    {
        "content": "<p>Creating this thread to continue discussion on this subject: <a href=\"#narrow/stream/179166-implementers/topic/Proposal.20for.20a.20new.20type.20ConceptReference\" title=\"#narrow/stream/179166-implementers/topic/Proposal.20for.20a.20new.20type.20ConceptReference\">https://chat.fhir.org/#narrow/stream/179166-implementers/topic/Proposal.20for.20a.20new.20type.20ConceptReference</a></p>",
        "id": 179379313,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572386714
    },
    {
        "content": "<p>as originally proposed here: <a href=\"https://wiki.hl7.org/Proposal_for_ConceptReference\" target=\"_blank\" title=\"https://wiki.hl7.org/Proposal_for_ConceptReference\">https://wiki.hl7.org/Proposal_for_ConceptReference</a></p>",
        "id": 179379342,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572386732
    },
    {
        "content": "<p>ping here</p>",
        "id": 179986827,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572994474
    },
    {
        "content": "<p>Decision on MnM call: Draft a new data type</p>\n<p>CodeableReference  : Reference {<br>\n     coding : Coding [0..1] // a reference to a code system or ontology that describes the essential properties of what is/might be referenced<br>\n   }</p>\n<p>This can have a binding. Update the specification accordingly, and let people look at it. Use it in MedicationRequest so we can see what it looks like</p>",
        "id": 179987204,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572994831
    },
    {
        "content": "<p>If we like it, ask Pharmacy to endorse the change</p>",
        "id": 179987222,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572994844
    },
    {
        "content": "<p>I still think that the name CodeableReference isn't very clear (and is potentially misleading) as to what this actually is.  Clunky (which it certainly is) or not, ReferenceOrConcept is much clearer in regard to the nature and intent.</p>",
        "id": 180483536,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1573536614
    },
    {
        "content": "<p>The  way I see it, this is a data structure that we use to refer to a something (a concept). <br>\nThat reference, sometimes, happens to be coded.</p>",
        "id": 180493244,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1573547604
    },
    {
        "content": "<p>I understand your reasoning, <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span>  but I think ReferenceOrConcept sounds slightly misleading to me. <br>\nThis is a designation of a concept. So if I were to do it clunky for sake of accuracy, I would go for \"ReferenceOrCodedConcept\" or \"ReferencedConceptOrCodedConcept\" (this is just to see if we mean the same). This is why I think CodeableReference would be good.</p>",
        "id": 180493548,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1573547954
    },
    {
        "content": "<p>The challenge is that is's not necessarily an 'or'.  You could have a reference to both the drug code <em>and</em> a pointer to the Medication instance, for example.</p>",
        "id": 180518395,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1573567338
    },
    {
        "content": "<p>Agree, <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>.  And <span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span>.  CodeableReference does sound better and probably isn't really as unclear or potentially misleading as I originally thought.  I'm coming around to it.</p>",
        "id": 180527588,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1573572433
    },
    {
        "content": "<p>Defining this data type... I do not find anywhere that we say that the types specified in the content models are final - that is, just because we define CodeableReference as a specialization of Reference, you cannot use it anywhere Reference is used</p>",
        "id": 182198926,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575055036
    },
    {
        "content": "<p>and, in fact, strictly from that point of view, it's not a specialization of Reference. So I'm going to define it as a sibling, though we already have the specialization issue around Quantity</p>",
        "id": 182199013,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575055089
    },
    {
        "content": "<p>I can't define it as a specialization of Reference - there's an invariant in must be to violate.</p>",
        "id": 182200347,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575056670
    },
    {
        "content": "<p>I don't recall, from the discussion, is whether we intended to allow both coding and reference</p>",
        "id": 182200384,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575056735
    },
    {
        "content": "<p>I can see situations where it might be helpful to provide both.  You might have one profile that requires one and another that requires the other.</p>",
        "id": 182200544,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575056894
    },
    {
        "content": "<p>did we discuss that?</p>",
        "id": 182200574,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575056955
    },
    {
        "content": "<p>I think I'd asserted that it could be useful to have both, but I don't recall much discussion.</p>",
        "id": 182200673,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575057068
    },
    {
        "content": "<p>I've run into a deeper problem - this type cannot be indexed and searched. The search syntax is ambiguous. I really think that the type will have to be </p>\n<p><code>CodeableReference:\n   coded: CodeableConcept 0.1\n   reference: Reference 0..1</code></p>",
        "id": 182200739,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575057146
    },
    {
        "content": "<p>but I'll see how I go</p>",
        "id": 182200829,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575057251
    },
    {
        "content": "<blockquote>\n<p>I've run into a deeper problem - this type cannot be indexed and searched. The search syntax is ambiguous. I really think that the type will have to be </p>\n<p><code>CodeableReference:\n   coded: CodeableConcept 0.1\n   reference: Reference 0..1</code></p>\n</blockquote>\n<p>Incidentally, that's what I proposed on this blog post: <a href=\"https://wolandscat.net/2019/05/08/a-fhir-experience-the-formalism/\" target=\"_blank\" title=\"https://wolandscat.net/2019/05/08/a-fhir-experience-the-formalism/\">https://wolandscat.net/2019/05/08/a-fhir-experience-the-formalism/</a> </p>\n<div class=\"codehilite\"><pre><span></span>class TypedReference\n    type: CodeableConcept [0..1];\n    reference: Reference &lt;Any&gt;[0..1];\n\n    Invariants:\n        type /= null or reference /= null\nend\n</pre></div>",
        "id": 182292846,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575220910
    },
    {
        "content": "<p>well, I think that's the right thing to define.</p>",
        "id": 182295437,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575225524
    },
    {
        "content": "<p>If you use that universally, another bunch of confusing elements will evaporate, and the software implementations can be a bit smarter.</p>",
        "id": 182298959,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575231677
    },
    {
        "content": "<p>I'm glad you think so</p>",
        "id": 182299033,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575231811
    },
    {
        "content": "<p>Unfortunately, that's only a small fix. The 'choice' types are a much bigger problem...</p>",
        "id": 182299536,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575232663
    },
    {
        "content": "<p>so you keep saying, but also you keep misunderstanding</p>",
        "id": 182299584,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575232709
    },
    {
        "content": "<p>Anytime you want to post the formal justification of that feature so I can understand... :)</p>",
        "id": 182300626,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575234558
    },
    {
        "content": "<p>The formal justification is \"we need multiple types - and they don't necessarily have an inheritance structure\".  E.g. deceasedBoolean vs. deceasedDate.  No common inheritance, but we don't need it to.  And it's not terribly clear how that creates problems for implementers.</p>",
        "id": 182301222,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575235648
    },
    {
        "content": "<p>Yep, everyone has that need. And everyone uses inheritance. And then constraints where more is needed. After checking that the modelling is correct (often it is not). The basic problem, as has already been described over a decade ago is that the choice pattern a) subverts typing and b) doesn't map to normal programming languages (so yes it is am implementation problem as well). There is a reason no-one and no formalism (other than XML schema) uses this construct. But we have been over this at length, and I guess I am not going to convince anyone there. It's a pity because it is going to cause  (is causing) real trouble.</p>",
        "id": 182301551,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575236280
    },
    {
        "content": "<p>\"everyone uses inheritance\" is not true.  And we have a thousands of FHIR implementations and haven't had complaints about the current approach. <br>\n (And those implementations certainly are mapped to normal programming languages.)  You say that it's causing \"real problems\"?  Can you be specific as to how?  Implementation in Java, C#, Swift and several other languages don't seem to have a problem.</p>\n<p>Sure, we could say that the type for \"deceased\" is \"anyType\" and put an invariant on it that says that it must be a boolean or date.  A choice <em>is</em> intrinsically a constraint.  If you prefer to think of it as an abstract type with a constraint, you're free to do so.  But just listing \"here's the allowed types\" is much more straightforward than throwing the list of allowed types in amongst all of the other constraints we have.</p>",
        "id": 182302379,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575237747
    },
    {
        "content": "<p>my view is that if you're looking for an OO model, then you do have a challenge. The reference implementations have reverse engineered and implied reference model, and that's what Tom is looking for. We agree to make some parts of it more explicit. But I don't see how we can practically make more of it for the choice attributes other than what we have already done... they have type Type. I've searched for common inheritance patterns but there aren't any</p>",
        "id": 182302727,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575238397
    },
    {
        "content": "<p>It's not to do with what I am looking for. It's just how the rest of the world works. The choice construct is a constraint mixed into a typed formalism, but with no underlying type to constrain (other than an assumed 'Any' type, which is useless). I'm not sure why you don't want to take account of what the rest of the industry does.</p>",
        "id": 182304461,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575241684
    },
    {
        "content": "<p>When you put a list of types as the type of something, it means you don't know what the type is, or what minimal characteristics are required there - so it means that no-one can know what things might or might not be allowed there. This is very basic.</p>",
        "id": 182304530,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575241806
    },
    {
        "content": "<p>There are no \"minimal characteristics\" - you have a date or a boolean.  And if you reference a Device or a Patient, you're not interested in minimum 'data' characteristics.  When you make a choice of \"should this resource be allowed as a target\", the decision isn't at all based on what elements are present in those resources - it's based on what meaning the resources represent.</p>",
        "id": 182307796,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575247771
    },
    {
        "content": "<p>We've had choice formalisms in HL7 for 30+ years - they were part of v2 (segment choices) and were a key part of v3.  There were lots of things implementers complained about with v3 (for good reason), but choices was never one of them.  Behind the scenes they were represented as an abstract class with specializations, but the choices were almost never driven by what elements were present</p>",
        "id": 182307866,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575247896
    },
    {
        "content": "<p>Right - the date / boolean thing. That is indeed a true constraint need; we see that all the time in health, as you do. So I'm not arguing that you don't need a way of writing 'Date|Boolean' - somewhere. But it is not true that you don't have a conceptual supertype in that slot - you do, it is called something like DataValue. So if you think about all the leaf domain data items across the resources, often you know it can only be Coded or Quantity or Date etc. Those cases are easy. But then you hit these cases like your example, and other common ones - {Quantity | Interval&lt;Quantity&gt; | String} and so on. So for those, the most specific type you can put is DataValue. One non-breaking solution for dealing with this problem is here: <a href=\"https://wolandscat.net/2019/09/12/fhir-fixes-the-observation-value-problem/\" target=\"_blank\" title=\"https://wolandscat.net/2019/09/12/fhir-fixes-the-observation-value-problem/\">https://wolandscat.net/2019/09/12/fhir-fixes-the-observation-value-problem/</a></p>",
        "id": 182352309,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575298437
    },
    {
        "content": "<p>There are more systemic ways to solve it better in the type system, but that solution won't break anything you have now. With that typing, you can then remove the type choices to Profiles. So here's a key point: the actual choices you want to allow will not be universal across all uses of the slot in question. Only in some places will you want {Boolean | Date}. IN other places it will be known to be Boolean, and in others, Date. Somewhere else it will be later discovered to be String. Now, if you want to be super-smart, you can go one better and create a normative profile on the Resource element that limits the types that could ever be possibly used to e.g. {Boolean | Date | String}, and force all downstream Profiles to come from that one. Some software might then trust those normative profiles and use their assumptions. In any case, all software can assume that nothing other than descendants of DataValue can appear in that spot, and can process accordingly.  Today, it can only assume 'Type', which is no use at all.</p>",
        "id": 182352813,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575298731
    },
    {
        "content": "<p>However ... the main cases where getting rid of 'choice' are more the Admin resources, also places where various kinds of Thing can occur (Substance etc), also various kinds of Event, types for the BasedOn field and so on.</p>",
        "id": 182353013,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575298838
    },
    {
        "content": "<p>I get that HL7 has had some kind of choice forever. So has XSD. Proponents of the latter probably have not seen the problem either, but I'd guess it is because they have not realised what things you can't do when you have that kind of approach to typing. No other typed formalism does this, and as I've said many times, there are many good reasons, all with a formal basis.</p>\n<p>Hopefully you accept that I'm being critical of the approach on a formal basis, and with the idea in mind of avoiding both model development and maintenance problems (you have them right now) and downstream consequences. None of my comments should be taken to be about anyone's work etc.</p>",
        "id": 182353433,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575299065
    },
    {
        "content": "<p>We don't <em>want</em> to move the type choices to profiles - the type choice of date|}boolean for deceased[x] is something that has to be enforced by the base standard - it's not something that can vary from implementation to implementation.  Creating both a resource and a normative profile on the resource doesn't make a whole lot of sense?  What's the value in having the split?  What are the things we can't do by having a choice?  I don't understand how what you're proposing is going to make either development or maintenance effort.  </p>\n<p>Fully understand you're not being critical of any individual - I'm just genuinely not understanding what the benefit of the change is.  At the moment, I see more complexity without any additional benefit.  So one of us (or both of us) are missing something :)</p>",
        "id": 182358028,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575301558
    },
    {
        "content": "<p>Well at the moment, the formal type of the deceased element you are talking about is 'Type'. That's not much help to software. But actually I had missed the fact that you were talking about deceased. For that element, I would argue {date | boolean} is wrong modelling anyway, because they convey different semantics. This is one of those annoying patterns that occurs when the data might a) contain a DOD only, or b) a 'deceased' flag only or maybe even c) both (terrible data design in the source system, but very common. So sometimes you could get a deceased Boolean as data; other times you can only get the Date, and the flag has to be inferred. This is a bit like the concept type / reference problem.</p>",
        "id": 182361215,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575303352
    },
    {
        "content": "<p>The kind of solution you want is a small type  that encapsulated the semantics in the following way:</p>\n<div class=\"codehilite\"><pre><span></span>class EventDate {\n    date: Date [0..1];                                //  date event occurred\n    occurredFlag: Boolean [0..1];      // flag indicating even occurred\n    occurred (): Boolean {\n        if (occurredFlag)\n            return True;\n        else\n            return date != null;\n    }\n\n    invariant\n        date != null or occurredFlag\n}\n</pre></div>\n\n\n<p>You can be a bit more correct by using a tri-state for occurredFlag, but the logical result is the same. The version of that in FHIR would just be the data part of it plus the invariant. </p>\n<p>If you had this, it would replace a few pairs of data points across the Resources by a single element of this type. Obviously rename as you prefer but you get the idea. The type could potentially be considered a General-purpose data type in FHIR. Like the concept reference type, if you decide to do that, this just converts an annoyance to a semantic type that properly models the situation.</p>",
        "id": 182362127,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575303894
    },
    {
        "content": "<p>We're defining the interface, not the implementation.  And we don't want any system to ever send <em>both</em> deceasedDate and deceasedBoolean because a) it would be redundant; and b) it raises the possibility of inconsistency.  We don't care what the class looks like - we care what the instance over the wire looks like and the instance needs to guarantee that you'll only ever have one or the other, not both.</p>",
        "id": 182363043,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575304464
    },
    {
        "content": "<p>And of course, it's possible to have neither.</p>",
        "id": 182363062,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575304481
    },
    {
        "content": "<p>By the way, the analysis of the problem of mixing constraints with a typed system is here: <a href=\"https://wolandscat.net/on-additive-and-subtractive-formalisms/\" target=\"_blank\" title=\"https://wolandscat.net/on-additive-and-subtractive-formalisms/\">https://wolandscat.net/on-additive-and-subtractive-formalisms/</a><br>\nThere are /were a lot more papers on this last time I researched it some years ago, from IBM, the Relax NG authors etc. I have yet to put those refs in.</p>",
        "id": 182363201,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575304587
    },
    {
        "content": "<p>Right, so the definition of the kind of instance you want is:</p>\n<div class=\"codehilite\"><pre><span></span>class EventDate {\n    date: Date [0..1];                                //  date event occurred\n    occurredFlag: Tristate [0..1];       // flag indicating event occurred\n\n    invariant\n        date != null xor occurredFlag\n}\n</pre></div>",
        "id": 182363247,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575304650
    },
    {
        "content": "<p>I don't see how that ensures that I can't have both date and occurredFlag in an instance?</p>",
        "id": 182363373,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575304723
    },
    {
        "content": "<p>Sorry hit return too fast. Refresh.</p>",
        "id": 182363453,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575304774
    },
    {
        "content": "<p>Where I put Tristate, you can just have a Boolean, as long as you consider that the field can be null or set, and then if so, you can simplify to this:</p>\n<div class=\"codehilite\"><pre><span></span>class EventDate {\n    date: Date [0..1];                                //  date event occurred\n    occurredFlag: Boolean [0..1];      // flag indicating event occurred\n\n    invariant\n        date != null xor occurredFlag != null\n}\n</pre></div>",
        "id": 182363598,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575304853
    },
    {
        "content": "<p>(I normally work in programming language terms, where primitive types are not nullable things, but always inline values, at least in many languages. Since you are working off the serial representation, anything can be null, even an int or bool field).</p>",
        "id": 182363775,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575304943
    },
    {
        "content": "<p>Also I meant to put an 'xor' in that invariant.</p>",
        "id": 182363802,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575304970
    },
    {
        "content": "<p>This is a data model of a concept you can think of as 'Event occurrence'. That would be a better name for the class in fact.</p>",
        "id": 182363956,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575305065
    },
    {
        "content": "<p>Ok - so you've created an anonymous class that essentially duplicates what the existing choice structure does.  To me, that seems more complex, and it's not terribly clear what it buys.  I read through the document you referenced above.  It warns that combining additive and subtractive approaches will create problems, but I can't see any explicit examples of what sort of problems.  What is the benefit of separating out the constraints from the additive hierarchy?  The implementation must adhere to both in practice - it can't ignore one or the other.  Behind the interface, it doesn't matter how they code/store the data, all that matters is what get's shared over the wire.  If they want to separate constraints from additive model in their internal implementation, nothing stops them.</p>",
        "id": 182365086,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575305732
    },
    {
        "content": "<p>Well the typed model is about data <em>possibilities</em>, in all circumstances. That what you can build reliable software on. Such models function on the basis of <em>meaningful</em> types. Every property in every class has a type a la UML.  Now when you state the type of a property to be one of an ad hoc list of types, you are subverting the normal typing. Now, you might argue that the real type of that property is just Any or similar. If so, then that's really what it is. But that's not helpful.</p>\n<p>For example, I assume you would agree at least in the abstract, that numerous Resource elements could notionally have the type Party, i.e. some supertype whose descendants are all, Roles, Actors, Persons, Practitioners and so on. Let's pretend for a moment that we agreed on that. Then you would type those elements as Party. Now, in a typed system, the meaning of assigning a type to a property (or method, or argument etc) is: the entity attached to this reference at runtime must conform to this type, and this type expresses the minimal set of characteristics required by the semantics of this model, for that element to have. That is what allows software to be written with polymorphism etc. If we know Party has at least identity and photo (let's just say), then the software can do things with that, without having to know the dynamic type of the attached thing. But if the type is Any, it can't do anything interesting.</p>\n<p>At a modelling level, the whole conversation is different. Instead of trying to work out which other types could be added to the current disjoint ad hoc type list in a choice field, it would instead be oriented to determining the minimum semantics required by that field - 'must at least be a person' or so. Once this conversation is had, it is clear how to use that part of the model.</p>\n<p>In summary, the software assumes what the model typing says. If you want to then apply constraints (= projections) for specific situations, then it should be done in another layer - one that allows different instantiations / usages of the model to have different type projections. Now, occasionally there are annoying cases like the example above. These are not however different - they are just (we believe) more or less universally applicable. If we really got our analysis right, then in such a case, some conjunction of normally disjoint types becomes a type in its own right, with the semantics understood from the analysis, and it can join the type system. Hence, a special type, addressing a universal special case (= a general case ;)</p>",
        "id": 182366659,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575306636
    },
    {
        "content": "<p>so reading this:</p>",
        "id": 182369774,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575308464
    },
    {
        "content": "<blockquote>\n<p>you can then remove the type choices to Profiles. </p>\n<p>create a normative profile on the Resource element that limits the types that could ever be possibly used to e.g. {Boolean | Date | String}, and force all downstream Profiles to come from that one</p>\n</blockquote>\n<p>Yes. that's exactly what we did. and then we put the base Profile in the type definition itself, so it was in the same place.</p>\n<p>You have made 3 fundamental claims:</p>\n<ul>\n<li>moving the choice into a specialised type instead of inlining it would be better. But why? </li>\n<li>defining a DataValue would be better than just using Type - but it has no additional properties. So why better?</li>\n<li>splitting the constraints into a separate model that people can't ignore would be better than having them inline in the one model. Again, why?</li>\n</ul>\n<p>I think that what you really don't like is the inlining....</p>",
        "id": 182370077,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575308647
    },
    {
        "content": "<p>The typed model does define the possibilities.  The possibilities are boolean and date.  Address, Telecom, string, etc. may be specializations of 'DataValue', but they are <em>not</em> possibilities in the model.</p>\n<p>I'd prefer to ignore the participants discussion for right now and focus on boolean/date.  (Though I think the same argument applies - we don't care about any commonality across attributes for the participants any more than we care about commonality of attributes for boolean|date)</p>",
        "id": 182370398,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575308902
    },
    {
        "content": "<blockquote>\n<p>we don't care about any commonality across attributes for the participants</p>\n</blockquote>\n<p>I just want to put on record that I don't agree with that</p>",
        "id": 182370469,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575308954
    },
    {
        "content": "<p>Let me rephrase.  The driver for whether we include something in the choice isn't driven by commonality of elements.  When we say \"yes, a device could author that\", it's not driven by what data elements we've asserted that a device might have (or what constraints are in place or might be in place in the future).  It's driven only by the fact that the scope of Device includes real-world entities that could be an author.  Whether the device gets represented by a name, an identifier, a URL and/or a description (and how those attributes compare to what might be on Patient or Organization or Practitioner) doesn't come into play in the discussion.</p>",
        "id": 182373661,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575310917
    },
    {
        "content": "<p>but it must be something more than random, right? There's some underlying principles in play? </p>\n<p>I'm still waiting for <span class=\"user-mention\" data-user-id=\"191388\">@Thomas Beale</span> to come up with a BFO sourced framework on this...</p>",
        "id": 182376740,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575312733
    },
    {
        "content": "<p>Certainly not random, but as discussed previously, it's based on capability of the business entity, not what data elements we use to describe the business entity.</p>",
        "id": 182377219,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575313013
    },
    {
        "content": "<p>there's really no link between those things?</p>",
        "id": 182380610,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575315166
    },
    {
        "content": "<p>There might be, but it's not a given.  The attributes of interest (as reflected in existing systems) and the capacities of interest have a loose correlation at best.  I might choose, at the edge, to represent a device by type + URL and provider by name + optional license number.  The decision when a new resource comes along about whether to add it to an existing choice structure is not \"do the attributes look the same?\" but \"does it have the right capacity?\".  The attributes of Person are very similar to those of Patient, Practitioner and RelatedPerson.  But we don't include it in any of the same choice structures because we've made a very firm decision that Person doesn't have <em>any</em> capacities other than linking instances.  On the other hand, we <em>do</em> include Device and HealthCareService in several of those choices, despite the minimal overlap of attributes - because they share the relevant capacities.</p>",
        "id": 182399231,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575328002
    },
    {
        "content": "<p>I do think we should ask, though, what the relevant attributes, and should they have them, or not? I note that in practice we have Role.class / Role.code either present or fixed for the resources, right?</p>",
        "id": 182400977,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575329647
    },
    {
        "content": "<p>From a RIM mapping perspective, yes.  So one of the capacities is certainly whether something is a Role or an Act.  Another is the category of Act.mood.  RIM doesn't have a useful hierarchy for things like \"can take responsibility\" or \"can receive communications\" unfortunately.</p>",
        "id": 182401849,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575330449
    },
    {
        "content": "<p>BFO... <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 182405580,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575334133
    },
    {
        "content": "<p>Firstly BFO itself won't help that much here - it is an upper ontology, and distinguishes only among categories of real-world things, primarily continuants (things that can be said to exist over time, including dependent continuants, e.g. qualities, roles, functions that depend on an independent continuant 'bearer' for existence) and occurrents - parts of processual entities. For our purposes, it mainly gives an understanding of how a  'role' should be understood. But for most other Qs I need to dig into Information Artefact Ontolog (IAO) and Ontology for Biomedical Investigations (OBI). These are more fluid and larger. I'll aim to do this this week.</p>",
        "id": 182428254,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575364454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> </p>\n<blockquote>\n<p>You have made 3 fundamental claims:</p>\n<ul>\n<li>moving the choice into a specialised type instead of inlining it would be better. But why? </li>\n<li>defining a DataValue would be better than just using Type - but it has no additional properties. So why better?</li>\n<li>splitting the constraints into a separate model that people can't ignore would be better than having them inline in the one model. Again, why?<br>\nI think that what you really don't like is the inlining....</li>\n</ul>\n</blockquote>\n<ol>\n<li>and 3. are the same. So the real question is: what is your type declaration of (sticking with deceased) the data element?</li>\n</ol>\n<p>Is it:<br>\na) {Date | Boolean} i.e. the disjoint set of 2 types <em>or</em><br>\nb) something else that is hidden behind these two, like Any, or Type?<br>\nNow a) is not a 'type', it's a conjunction of types. This does not create a type, and is not a type in a typed system. When you put something like this as the type, you still don't know what the type is. That's why zero programming languages, UML or anything else (apart from XSD and maybe some other serialisation languages) do this.</p>",
        "id": 182428552,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575364746
    },
    {
        "content": "<p>I don't know how many times I will have to say this: it's a <code>Type</code>, per the UML, with a constraint (in OCL in the UML diagram) that it's one of a few types</p>",
        "id": 182429191,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575365358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> </p>\n<blockquote>\n<p>There might be, but it's not a given.  The attributes of interest (as reflected in existing systems) and the capacities of interest have a loose correlation at best.  I might choose, at the edge, to represent a device by type + URL and provider by name + optional license number.  The decision when a new resource comes along about whether to add it to an existing choice structure is not \"do the attributes look the same?\" but \"does it have the right capacity?\".  The attributes of Person are very similar to those of Patient, Practitioner and RelatedPerson.  But we don't include it in any of the same choice structures because we've made a very firm decision that Person doesn't have <em>any</em> capacities other than linking instances.  On the other hand, we <em>do</em> include Device and HealthCareService in several of those choices, despite the minimal overlap of attributes - because they share the relevant capacities.</p>\n</blockquote>\n<p>This is the core of the issue. What Lloyd is saying here that any named entity type in the model, such as Device, isn't defined to be what the model says it is (i.e. attributes, invariants, anything else formally stated in the model - it could be pure interface if you want), but is instead the meaning of that word in the real world. Principle #0 of all modelling is this: the meaning of a type T, for any computational use of the model, and also human uses, is just what the model says it is. Indeed, this is why we write models.</p>\n<p>If we were to take the line that types names like Device, Patient etc are merely proxies for things going by those names (according to whom?) in the real world, we are dead from the outset. Then they become like a UN declaration, having its own meaning in every country it is taken back to. Modelling cannot function like that.</p>\n<p>The way it does function is: you state the type of some attribute (property, argument, function, etc) and that is the <em>contract</em> in terms of typing of that feature. So if you put author:Party, it means author must at least be a Party (however we defined Party), and may be any formal descendant as well. Now, at some point someone comes a long and starts talking about how it really should only be someone who has accountability (let's just say), and you work through that, and decide, really it is author: Role, since Party also has Actor descendants that have no accountability. And so on.</p>",
        "id": 182429280,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575365411
    },
    {
        "content": "<p>If a community can't trust the meaning of the entities in the model to be what the model says they are... then the enterprise is over.</p>",
        "id": 182429339,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575365492
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> </p>\n<blockquote>\n<p>I don't know how many times I will have to say this: it's a <code>Type</code>, per the UML, with a constraint (in OCL in the UML diagram) that it's one of a few types</p>\n</blockquote>\n<p>Ok, so all instances of <code>Reference(A | B | C)</code> and <code>choice[x]</code> should be understood as inlined constraints hiding the real type, which is always Type (which is something pretty close to Any)?</p>",
        "id": 182429480,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575365640
    },
    {
        "content": "<p>That's true for choice[x].</p>\n<p>Reference is something else - it's always Reference. The variance is in what it points to, which is not a direct property; it's a constraint on the type returned when you retrieve whatever the link points to</p>",
        "id": 182429597,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575365754
    },
    {
        "content": "<p>See the problem here? You are trying to state that in such locations, we would like the concrete types to include A, B, C etc, without having done the modelling to determine what abstract definition makes A, B, C valid, but not other types. So the formal type in most places is just Type.</p>",
        "id": 182429669,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575365812
    },
    {
        "content": "<p>'done the modelling' means... what?</p>",
        "id": 182429797,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575365929
    },
    {
        "content": "<p>Ok, so let's leave Reference() for now. There are two problems here:</p>\n<ol>\n<li>you are saying that type names mean whatever people think they mean in the real world (guaranteed to be very variable)</li>\n<li>you haven't provided computationally useful types in all the choice[x] locations, only Type.</li>\n</ol>",
        "id": 182429842,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575365991
    },
    {
        "content": "<p>'done the modelling' means that there is a missing discussion(s) to establish the commonality for the disjoint set of types, which can be used to define an abstract type that you formally need, and will act as the criterion for things that can go in that slot.</p>\n<p>Actually all of this applies to Reference() as well.</p>",
        "id": 182429988,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575366092
    },
    {
        "content": "<p>I certainly don't agree to #1. I tried to follow your argument there but failed. I think you're making a false strawman. </p>\n<p>With regard to #2... I don't think you've proposed anything different, or done anything different in openEHR</p>",
        "id": 182430069,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575366140
    },
    {
        "content": "<p>No 1. is what Lloyd just said.</p>",
        "id": 182430455,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575366442
    },
    {
        "content": "<p>No 2. is what you just said.</p>",
        "id": 182430466,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575366453
    },
    {
        "content": "<p>w.r.t. No 2, we have abstract types all over the place. That's why openEHR software can do useful things.</p>",
        "id": 182430556,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575366503
    },
    {
        "content": "<p>I don't agree with how you characterised what Lloyd said. So let's leave #1. Lloyd can take that up</p>",
        "id": 182430564,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575366510
    },
    {
        "content": "<p>Well, either you agree that the meaning of some type T is what the model says or not; above I read that you don't, it's a variable thing, and can keep changing. So which is it?</p>",
        "id": 182430610,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575366556
    },
    {
        "content": "<p>I'm open to argument about what additional abstract types we should define</p>",
        "id": 182430620,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575366566
    },
    {
        "content": "<p>Ok so, very simple question: I see choice[x] or Reference(A|B|C) somewhere, how can I know what the formal type behind those actually is?</p>",
        "id": 182430711,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575366620
    },
    {
        "content": "<p>i.e. the type that would tell me what other concrete types could possibly be allowed to be added to the conjunction type constraint, or even if those already on the list were valid?</p>",
        "id": 182430747,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575366663
    },
    {
        "content": "<p>do you want to talk about Reference or choice[x]? because the answers are different. I'd rather talk about choice[x] for now</p>",
        "id": 182430981,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575366822
    },
    {
        "content": "<p>I don't think they should be. But let's stick with choice[x] for now.</p>",
        "id": 182432567,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575368014
    },
    {
        "content": "<p>Choice is mainly a data types question, as is obvious from this page - <a href=\"http://hl7.org/fhir/R4/choice-elements.json\" target=\"_blank\" title=\"http://hl7.org/fhir/R4/choice-elements.json\">http://hl7.org/fhir/R4/choice-elements.json</a></p>",
        "id": 182432694,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575368107
    },
    {
        "content": "<p>So a single missing type - DataValue or similar, that is the common parent of all the various types mentioned there would give you the formal type in most of those locations.</p>",
        "id": 182432760,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575368167
    },
    {
        "content": "<p>And you can go better, if you agree on a single type to solve the CodeableConcept/Reference question, and a similar approach as discussed above on Boolean/Date.</p>",
        "id": 182432787,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575368202
    },
    {
        "content": "<p>The point to do this is that there is currently nothing saying that <code>\"ActivityDefinition.subject[x]\": [\"CodeableConcept\", \"Reference\"]</code> is the same as <code>\"CarePlan.activity.detail.product[x]\": [\"CodeableConcept\", \"Reference\"]</code> etc. They're just lists. How do we know that someone won't come and change one of them? If they really have some semantics, then it should be defined in a type.</p>",
        "id": 182432963,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575368326
    },
    {
        "content": "<p>umm. so how does DataValue differ from Type?</p>",
        "id": 182432984,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575368343
    },
    {
        "content": "<p>That argument can be applied in a lot of places. E.g. </p>\n<div class=\"codehilite\"><pre><span></span>&quot;Condition.onset[x]&quot;: [&quot;dateTime&quot;, &quot;Age&quot;, &quot;Period&quot;, &quot;Range&quot;, &quot;string&quot;],\n&quot;Condition.abatement[x]&quot;: [&quot;dateTime&quot;, &quot;Age&quot;, &quot;Period&quot;, &quot;Range&quot;, &quot;string&quot;],\n</pre></div>\n\n\n<p>There is presumably a reason why this particular set of types recurs.</p>",
        "id": 182433025,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575368378
    },
    {
        "content": "<p>presumably you would think that not much was achieved if everything that currently specialises Type changes to specialise DataValue</p>",
        "id": 182433117,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575368413
    },
    {
        "content": "<p>Well the allowable descendants of DataValue will just be data types. Your Type type is more or less Any isn't it? Meaning the valid runtime substitutions are pretty well any Resource.</p>",
        "id": 182433156,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575368453
    },
    {
        "content": "<p>when we started discussing this, I made a list of all the choices[x] to look for patterns. I din't pick up any ones strong enough to handle as a type</p>",
        "id": 182433177,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575368482
    },
    {
        "content": "<p>Resources are not specializations of Type</p>",
        "id": 182433191,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575368498
    },
    {
        "content": "<p>nor are Elements of resources</p>",
        "id": 182433212,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575368518
    },
    {
        "content": "<p>Ok, what's the formal definition of Type?</p>",
        "id": 182433255,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575368525
    },
    {
        "content": "<p>It doesn't have one. We agreed to add it and formalise all this - one outcome of this discussion - but it's going to something along the lines of 'a reusable type definition that can be assigned as the type of an element'.  I'm not sure that there's much more we can say</p>",
        "id": 182433629,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575368781
    },
    {
        "content": "<p>Well, where does it fit in the type conformance hierarchy? What does my Java etc type structure look like?</p>",
        "id": 182433715,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575368836
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/eavv-AAQW3FDT32JnK3F3Xec/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/eavv-AAQW3FDT32JnK3F3Xec/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/eavv-AAQW3FDT32JnK3F3Xec/pasted_image.png\"></a></div>",
        "id": 182433889,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575368948
    },
    {
        "content": "<p>all the general purpose types inherit from Type or maybe one of the specialisations</p>",
        "id": 182433940,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575368988
    },
    {
        "content": "<p>Ok so Type is another Element subtype. I'm not seeing its utility. Also, what is PrimitiveType?</p>",
        "id": 182434047,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575369058
    },
    {
        "content": "<p>Type has pretty much the utility you associate with DataValue</p>",
        "id": 182434120,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575369118
    },
    {
        "content": "<p>PrimitiveType is any of the primitives like string, integer etc. We don't ever use it in the resources, but it gets a lot of work out in the reference implementations</p>",
        "id": 182434196,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575369157
    },
    {
        "content": "<p>Ok, so that means that the descendants of Type are just the data values, i.e. Primitive Data Types and General Purpose Data Types?</p>",
        "id": 182434574,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575369380
    },
    {
        "content": "<p>Are the inheritance hierarchies shown at <a href=\"http://hl7.org/implement/standards/fhir/datatypes.html\" target=\"_blank\" title=\"http://hl7.org/implement/standards/fhir/datatypes.html\">http://hl7.org/implement/standards/fhir/datatypes.html</a> going to be changed to do that?</p>",
        "id": 182434644,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575369455
    },
    {
        "content": "<p>Then in cases like Observation.value, I don't know why there is any constraint (the one that is there is wrong...).</p>",
        "id": 182434780,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575369532
    },
    {
        "content": "<p>Also, why not call Type 'DataValue' or 'DataType' or similar?</p>",
        "id": 182434801,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575369554
    },
    {
        "content": "<p>I'm actually working on changing the diagrams right now.</p>",
        "id": 182434948,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575369654
    },
    {
        "content": "<p>We still have not addressed:</p>\n<ul>\n<li>the many occurrences of the same type constraints on <a href=\"http://hl7.org/fhir/R4/choice-elements.json\" target=\"_blank\" title=\"http://hl7.org/fhir/R4/choice-elements.json\">http://hl7.org/fhir/R4/choice-elements.json</a></li>\n<li>Reference().</li>\n</ul>",
        "id": 182434955,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575369657
    },
    {
        "content": "<p>I could be comfortable calling it DataType instead of Type</p>",
        "id": 182434992,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575369686
    },
    {
        "content": "<blockquote>\n<p>the many occurrences of the same type constraints on <a href=\"http://hl7.org/fhir/R4/choice-elements.json\" target=\"_blank\" title=\"http://hl7.org/fhir/R4/choice-elements.json\">http://hl7.org/fhir/R4/choice-elements.json</a></p>\n</blockquote>\n<p>That's a new subject to me. What do you see?</p>",
        "id": 182435074,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575369725
    },
    {
        "content": "<p>Here's a simple question. Why do we have :<code>[\"positiveInt\", \"string\"]</code> and many other things of the same form - a type and String? I can guess but interested in the FHIR answer.</p>",
        "id": 182435109,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575369756
    },
    {
        "content": "<p>Well we already looked at [\"CodeableConcept\", \"Reference\"] - there's a specific semantic, and it would be better modelled as a single type the formally specifies that semantic.</p>",
        "id": 182435165,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575369817
    },
    {
        "content": "<p>that specific type will be in the current build as soon as I can get a successful build (I've got a validation unit test oscillating between pass and fail for no reason I can see)</p>",
        "id": 182435269,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575369883
    },
    {
        "content": "<p>I assume all the ones with String as an option are meant to cope with the situation where there could a native Int / Date / whatever, OR just a String field with a serial form of such a type. But think about it: for all those cases, what that pattern is doing is loading onto 10,000 app developers the annoyance of working out the conversion, when the 100 system / vendor owners a) should know what the right conversion is and b) could convert it at source.</p>",
        "id": 182435338,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575369944
    },
    {
        "content": "<p>the positiveInt / String .. I've been discussing that with PHER who defined that type.. what are they trying to achieve there.. They have may protocols where the immunization series are sequential numbers, but others have named sequences</p>",
        "id": 182435414,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575369988
    },
    {
        "content": "<p>bzzt. you assume wrong.</p>",
        "id": 182435429,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575370002
    },
    {
        "content": "<p>it's generally for where you have an unparseable human description of the value, probably vague</p>",
        "id": 182435517,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575370077
    },
    {
        "content": "<p>ok, that's why I was asking</p>",
        "id": 182435926,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575370367
    },
    {
        "content": "<p>but you are saying that those values are actually Identifiers?</p>",
        "id": 182435955,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575370383
    },
    {
        "content": "<p>They should probably just be strings...</p>",
        "id": 182435963,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575370394
    },
    {
        "content": "<p>But I assume I assume right for these ones:</p>\n<div class=\"codehilite\"><pre><span></span>&quot;Immunization.occurrence[x]&quot;: [&quot;dateTime&quot;, &quot;string&quot;],\n    &quot;Immunization.protocolApplied.doseNumber[x]&quot;: [&quot;positiveInt&quot;, &quot;string&quot;],\n    &quot;Immunization.protocolApplied.seriesDoses[x]&quot;: [&quot;positiveInt&quot;, &quot;string&quot;],\n    &quot;ImmunizationEvaluation.doseNumber[x]&quot;: [&quot;positiveInt&quot;, &quot;string&quot;],\n    &quot;ImmunizationEvaluation.seriesDoses[x]&quot;: [&quot;positiveInt&quot;, &quot;string&quot;],\n    &quot;ImmunizationRecommendation.recommendation.doseNumber[x]&quot;: [&quot;positiveInt&quot;, &quot;string&quot;],\n    &quot;ImmunizationRecommendation.recommendation.seriesDoses[x]&quot;: [&quot;positiveInt&quot;, &quot;string&quot;],\n</pre></div>",
        "id": 182435998,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575370436
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/ZPRSKerwsGVyagwKHceuR1-c/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/ZPRSKerwsGVyagwKHceuR1-c/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/ZPRSKerwsGVyagwKHceuR1-c/pasted_image.png\"></a></div>",
        "id": 182436107,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575370507
    },
    {
        "content": "<p>or maybe you are saying its the same story for all of those. In which case they are all ids, not computable numbers.</p>",
        "id": 182436891,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575371188
    },
    {
        "content": "<p>And the documentation is wrong for xx.seriesDoses...</p>",
        "id": 182437003,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575371283
    },
    {
        "content": "<p>Immunization.occurrence[x] of string would be something like \"When they were 2 or 3\" or \"sometime in highschool\" - because that's all you've got.  The others are described in the documentation \"A string should only be used in cases where an integer is not available (such as when documenting a recurring booster dose).\"  I.e. the notion of \"sequence number\" doesn't really make sense when you're talking about something like tetanus.  You don't say this is tetanus shot 7 or 8.  You just say \"10-year booster\" or something like that.  Or, more specifically, that's what existing systems do - and the FHIR spec needs to support how existing systems capture their data.</p>",
        "id": 182470474,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575392377
    },
    {
        "content": "<p>Going back to your earlier reply to my statement, elements in the model are defined by their definitions and scopes, not by their elements.  The elements represent the properties that can be used to describe the resource, but they don't <em>define</em> the resource.  I.e. An element in my database isn't a Patient because it has name, gender, date of birth, etc.  It's a Patient because it meets the semantics of \"Demographics and other administrative information about an individual or animal receiving care or other health-related services.\" and as further refined in the Scope and Usage section of the resource.  The meaning isn't defined by any arbitrary implementer's interpretation of the word \"Patient\", it comes from the specific definition that HL7 has.  For many systems, the \"contract\" for Practitioner and Patient will be identical - they'll capture name, identifier and not much else.  But the fact that the contract is the same does <em>not</em> mean that the resources are interchangeable or that you can use Practitioner everywhere that you use Patient or vice versa.</p>",
        "id": 182472683,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575393676
    },
    {
        "content": "<p>Well, in any computing system, the only meaning (for computation) is the formal definition. If your model says that Patient has these N things, then that really is what 'patient' is in your system. It's what your software thinks it is; it's what your data says it is. It's what your analytics treats as 'patients' or not. It's no different in ontology-land, or SNOMED CT. The 'meaning' of any concept in SNOMED is only: its formally defined properties and relations with other concepts - that is how it is computed. I don't of course dispute the idea of some more nuanced / human-oriented idea of classes or Resources in the model - but at the end of the day, software doesn't read any of that.</p>",
        "id": 182480244,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575397905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> </p>\n<blockquote>\n<p>For many systems, the \"contract\" for Practitioner and Patient will be identical - they'll capture name, identifier and not much else. But the fact that the contract is the same does not mean that the resources are interchangeable or that you can use Practitioner everywhere that you use Patient or vice vice versa</p>\n</blockquote>\n<p>Well, the Patient and Practitioner resources <em>are</em> interchangeable for an in-memory reference (i.e. some variable in software) of static type Party (assume that it's a parent of both). That's what polymorphism is. Of course, that part of the software can only refer to properties defined on Party.</p>",
        "id": 182480586,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575398114
    },
    {
        "content": "<p>It doesn't mean they are generally semantically interchangeable of course - they are distinct types, so they can't be, except for a reference statically typed to any common parent.</p>",
        "id": 182481376,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575398527
    },
    {
        "content": "<p>Anyway, in the page  <a href=\"http://hl7.org/fhir/R4/choice-elements.json\" target=\"_blank\" title=\"http://hl7.org/fhir/R4/choice-elements.json\">http://hl7.org/fhir/R4/choice-elements.json</a> I think nearly every item is replaceable by a type, it's just a question of analysing why you have these combinations. Mostly it is to do with either:</p>\n<ul>\n<li>there is a real reference to an X OR an X inline AND/OR a code indicating the type of X</li>\n<li>ideally there is a structured / formal data item, but sometimes there is only a string</li>\n<li>variations on ways of representing the time of some event, e.g. a Date, Duration (how long ago), String (a description) etc</li>\n<li>variations on a single point item and a range/interval of that type<br>\nI think you have already agreed on a proper type to replace the very common <code>[\"CodeableConcept\", \"Reference\"]</code> combination.</li>\n</ul>\n<p>I would look at <code>[\"dateTime\", \"Age\", \"Period\", \"Range\", \"string\"]</code> - it is pretty clear what that pattern is about. Create a class to encapsulate the semantics, and it will make devs much happier than having to write painful code trawling through various type-matching attempts. </p>\n<p>Another one to look at: <code>[\"CodeableConcept\", \"Address\", \"Reference\"]</code>.</p>\n<p>I think analysing these out properly and constructing types, or modifications to the data type will simplify the Resources. I think you could get rid of all choice[x] doing this, which would remove a lot of programmer complexity, and significantly reduce the maintenance work for the Resources themselves.</p>",
        "id": 182482208,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575399031
    },
    {
        "content": "<p>If I have two database tables (e.g. \"ACTIVE_PATIENTS\" and \"PAST_PATIENTS\") that happen to contain the same number of columns with the same  names and types, that does <em>not</em> mean that the meaning of rows from both tables is the same.  The meaning of computational systems absolutely comes from the names of the elements and the meaning that the designer of the system ascribes to those elements.</p>\n<p>Sure, we could create specialized classes for each combination of data types that happen to prove useful somewhere.  But what's the point?  It adds complexity, but doesn't add value - at least to most implementers.  We could create a class called \"TimeyThing\" that encapsulates the dateTime|Age|Period|Range|string choice.  But all that means is that there's a layer of indirection in the spec and that implementers need to drill down to realize what types are allowed to be expressed within TimeyThing.  It also creates complexity when there's a need to constrain.  One system might constrain to dateTime|string, another to dateTime|age|Range, another to dateTime|Period|string, etc.  Do those constraints now get buried too?  Do we need named types for all of the sub-combinations that implementers must support and create a poly-hierarchy to reflect what can be constrained to what?</p>\n<p>Even creating a common type for CodeableConcept or Reference is introducing complexity.  And what's actually happening is that we're creating a merger rather than a true choice - i.e. you can have both the CodeableConcept <em>and</em> the Reference.</p>",
        "id": 182483571,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575399862
    },
    {
        "content": "<p>Well you don't create a new type for every accidental (i.e. contingent) conjunction of properties, only for sets of defining properties. This is how both ontology-building and modelling are (should be) done. It's an Aristotelian method, by which each type B is defined as an A that b's, e.g. a mammal is a vertebrate that produces milk to nourish young. That's a defining quality; but you would not define a class of 'stripy mammals', since fur / skin patterns are contingent, variable qualities</p>",
        "id": 182484174,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575400260
    },
    {
        "content": "<p>All those choices on that page are a measure of what kind of complexity you are dealing with - the complexity of 'dirty data'. But most of them are combinations that correspond to specific situations that recur all the time. E.g. a Date or a Period and so on. All, or nearly all of those combinations do have specific semantics and it helps a great deal to define them once and for all. That greatly reduces the pain for client programmers. For example, if you agree that there is a common situation where a Date or a Period could be returned to indicate when some past even occurred, the obvious response is to formalise what is going on there. It's nothing complicated, but a little class that puts those two things together takes away a certain number of decisions, errors and time-wasting from client programmers. E.g.:</p>\n<div class=\"codehilite\"><pre><span></span>class EventTime {\n    absolute: DateTime[0..1];\n    relative: Duration[0..1];\n\n    invariant\n        absolute != null xor relative != null\n}\n</pre></div>\n\n\n<p>Now a software version of that class can include a useful bit of logic e.g. :</p>\n<div class=\"codehilite\"><pre><span></span>class EventTime {\n    absolute: DateTime[0..1];\n    relative: Duration[0..1];\n    absolute_moment (): DateTime {\n        if (absolute != null)\n            return absolute;\n        else\n            return today() - relative;\n    }\n\n    invariant\n        absolute != null xor relative != null\n}\n</pre></div>\n\n\n<p>that's a bit rough, and the names could be different / better, but you get the idea. Let's imagine the core group did this analysis, and agreed on a type like the above. Now you have formal semantics for that situation, a single type instead of a choice, and another bunch of choice[x] evaporates.</p>\n<p>It looks to me like nearly every other occurrence of choice - certainly the ones that occur multiple times - can be analysed and modelled this way.</p>",
        "id": 182485256,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575400961
    },
    {
        "content": "<p>CodeableReference is added to the spec: <a href=\"http://build.fhir.org/references.html#codeablereference\" target=\"_blank\" title=\"http://build.fhir.org/references.html#codeablereference\">http://build.fhir.org/references.html#codeablereference</a><br>\nit's used in MedicationRequest: <a href=\"http://build.fhir.org/medicationrequest-definitions.html#MedicationRequest.reason\" target=\"_blank\" title=\"http://build.fhir.org/medicationrequest-definitions.html#MedicationRequest.reason\">http://build.fhir.org/medicationrequest-definitions.html#MedicationRequest.reason</a></p>\n<p>It's added as MnM agreed to add it, except that it's flat not inheriting from CodeableConcept or Reference (there were technical reasons why that wasn't possible). But this structure is wrong for a few reasons, and it should be </p>\n<div class=\"codehilite\"><pre><span></span>class CodeableReference\n    coded: CodeableConcept [0..1];\n    reference: Reference &lt;Any&gt;[0..1];\nend\n</pre></div>",
        "id": 182486712,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575401859
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> How would we constrain CodeableReference to be just a Reference or just a CodeableConcept?</p>",
        "id": 182486804,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575401912
    },
    {
        "content": "<p>looking at this list, I feel like we should analyse it by committee... </p>\n<p>I don't know, why, for instance, these are different:</p>\n<div class=\"codehilite\"><pre><span></span>   &quot;Claim.accident.location[x]&quot;: [&quot;Address&quot;, &quot;Reference&quot;],\n    &quot;Claim.item.location[x]&quot;: [&quot;CodeableConcept&quot;, &quot;Address&quot;, &quot;Reference&quot;],\n</pre></div>",
        "id": 182486831,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575401938
    },
    {
        "content": "<p>But <span class=\"user-mention\" data-user-id=\"191388\">@Thomas Beale</span> is right that <code>dateTime | Period | Duration</code> is a very common combination that does have some particular semantic challenges that might make it worth defining a reusable choice structure.</p>\n<p>Though there's also <code>date | Period</code> which is giving me some pause. Does that imply that the Period should also be whole day periods? The resource doesn't say. Here's a committee where Tom's criticisms are totally valid.</p>",
        "id": 182487182,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575402162
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191388\">@Thomas Beale</span> The challenge is that we need arbitrary combinations even in the main spec.  The \"arbitrary\" bit comes from what's commonly needed/used.  In principle, any time can be expressed as a fixed point (with varying constraints on precision), an uncertain range (possibly with unknown upper or lower bounds), a relative point (e.g. age), an uncertain relative range, or as free text.  But in practice, not all of those options are relevant in the places where we capture timing information.  Systems capturing Condition onsets may well capture \"age at onset\", but few lab systems capture \"age at specimen collection\".  That's not because the notion couldn't still be meaningful, it's just not what business practice does.  And the core specification needs to align with what business practice does - not with what's theoretically possible.  As soon as you expand every element to the theoretically possible, the complexity becomes unmanageable and implementers (rightfully) refuse the spec.</p>",
        "id": 182487222,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575402198
    },
    {
        "content": "<p>The semantics of date | Period actually vary.  Sometimes the period indicates \"this thing occurred with a duration\".  Sometimes it means \"this thing occurred sometime between this start and this end\".  The difference is communicated in the definition of the element, not in the type.  (We argued about whether distinct types were appropriate in the early days of FHIR and decided that from an implementer perspective, the distinction wasn't helpful/comprehensible.)</p>",
        "id": 182487343,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575402302
    },
    {
        "content": "<p>(dateTime | Period), (date | Period), (dateTime | Period | Duration), (dateTime | Period | Age | Range | string), (dateTime | Period | string) are all combinations that appear.  And the more complex combinations might be constrained to simpler combinations in downstream profiles.  I don't see how introducing types and complex type hierarchies makes implementer lives easier here.  It keeps being asserted that it does/will, but where are the programmers asking for it?  Where are the examples of code that would be made simpler?  I'm just not getting it...</p>",
        "id": 182487724,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575402533
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> for:</p>",
        "id": 182487824,
        "sender_full_name": "Andy Stechishin",
        "timestamp": 1575402594
    },
    {
        "content": "<p>For CodeableReference, the benefit of the type is the ability to convey both so that downstream systems that prefer one approach or the other can see the data as they wish.  And even there, I don't think the current proposed type meets the bar because constraint in downstream profiles just became hard.</p>",
        "id": 182487834,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575402600
    },
    {
        "content": "<p>\"Claim.accident.location[x]\": [\"Address\", \"Reference\"],<br>\n    \"Claim.item.location[x]\": [\"CodeableConcept\", \"Address\", \"Reference\"],<br>\nThe reason for the difference</p>",
        "id": 182487941,
        "sender_full_name": "Andy Stechishin",
        "timestamp": 1575402640
    },
    {
        "content": "<p>is that accidents by definition are accidental and as such seldom have a code to describe where they occurred. Whereas the Claim.item which can be a service will often occur somewhere in an institution that may be identified simply by a coded value. The code was explicitly asked to be added to the Claim.item by the community but it was felt by the same community that accident location did not require this change. I believe there may be description of this in the comments.</p>",
        "id": 182488252,
        "sender_full_name": "Andy Stechishin",
        "timestamp": 1575402826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> </p>\n<blockquote>\n<p>That's not because the notion couldn't still be meaningful, it's just not what business practice does. And the core specification needs to align with what business practice does - not with what's theoretically possible. As soon as you expand every element to the theoretically possible, the complexity becomes unmanageable and implementers (rightfully) refuse the spec.</p>\n</blockquote>\n<p>I'm not saying you need to stop using plain Duration or Date - sure use them where they are correct. But in places where everyone agrees (as apparently has happened, quite a few times) that this Date | Duration situation (or maybe Date | Duration | Period is the general case) can happen, now you have a type for it. No discussions needed, no need to waste hours on that, since it is already solved.</p>",
        "id": 182489091,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575403178
    },
    {
        "content": "<p>But it's not solved - the discussion needs to happen for every single element about what combination is reasonable - and commonly supported for <em>that</em> element.  The fact that there's a FunkyTimeA type that has a particular combination doesn't mean that combination is appropriate when a new attribute comes along.  Maybe it's identical to FunkyTimeA with one less or one more type.  If the requirement genuinely is distinct, then we don't want to use a type that allows something or prohibits something inappropriately.  The problem we <em>do</em> want to move away from is where types get excluded because they weren't thought about, or types get included inappropriately because the modeler didn't realize that a use was inappropriate.  (e.g. having 'string' in a choice with CodeableConcept)</p>",
        "id": 182489452,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575403379
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191369\">@Andy Stechishin</span> I looked again at the notes and still didn't see anything</p>",
        "id": 182489596,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575403457
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> that new type shouldn't inherit from CodeableConcept. It could in theory inherit from Reference&lt;T&gt;, Although a more thorough analysis would probably lead to something more like a type CodedDataType&lt;DataType&gt;, i.e. a type that effective wraps some other type and adds a code to it. This takes care of cases like {Address | CodeableConcept} and probably others. But that's possibly a step too far.</p>",
        "id": 182489599,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575403458
    },
    {
        "content": "<p>I was thinking about that... I think it is a step too far.</p>",
        "id": 182489637,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575403485
    },
    {
        "content": "<p>for our analytical pleasure, here's the list of choice types grouped by the type set, and sorted by frequency:</p>",
        "id": 182489675,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575403514
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>[CodeableConcept, Reference]: (41) [DataRequirement.subject[x], ActivityDefinition.subject[x], ActivityDefinition.product[x], CarePlan.activity.detail.product[x], ChargeItem.product[x], Claim.diagnosis.diagnosis[x], Claim.procedure.procedure[x], Contract.topic[x], Contract.term.topic[x], Contract.term.asset.valuedItem.entity[x], CoverageEligibilityRequest.item.diagnosis.diagnosis[x], DeviceRequest.code[x], EventDefinition.subject[x], ExplanationOfBenefit.diagnosis.diagnosis[x], ExplanationOfBenefit.procedure.procedure[x], Invoice.lineItem.chargeItem[x], Library.subject[x], Measure.subject[x], Medication.ingredient.item[x], MedicationAdministration.medication[x], MedicationDispense.statusReason[x], MedicationDispense.medication[x], MedicationKnowledge.ingredient.item[x], MedicationKnowledge.administrationGuidelines.indication[x], MedicationRequest.medication[x], MedicationStatement.medication[x], MedicinalProduct.specialDesignation.indication[x], MedicinalProductContraindication.otherTherapy.medication[x], MedicinalProductIndication.otherTherapy.medication[x], MedicinalProductInteraction.interactant.item[x], PlanDefinition.subject[x], PlanDefinition.action.subject[x], ResearchDefinition.subject[x], ResearchElementDefinition.subject[x], Specimen.container.additive[x], SpecimenDefinition.typeTested.container.additive.additive[x], Substance.ingredient.substance[x], SubstanceSpecification.property.definingSubstance[x], SubstanceSpecification.relationship.substance[x], SupplyDelivery.suppliedItem.item[x], SupplyRequest.item[x]]\n[Period, dateTime]: (15) [BiologicallyDerivedProduct.collection.collected[x], BiologicallyDerivedProduct.processing.time[x], BiologicallyDerivedProduct.manipulation.time[x], ClinicalImpression.effective[x], CommunicationRequest.occurrence[x], DetectedIssue.identified[x], DiagnosticReport.effective[x], Media.created[x], MedicationAdministration.effective[x], MedicationStatement.effective[x], MedicinalProductAuthorization.procedure.date[x], Provenance.occurred[x], RiskAssessment.occurrence[x], Specimen.collection.collected[x], Specimen.processing.time[x]]\n[Period, date]: (8) [Claim.supportingInfo.timing[x], Claim.item.serviced[x], ClaimResponse.addItem.serviced[x], CoverageEligibilityRequest.serviced[x], CoverageEligibilityResponse.serviced[x], ExplanationOfBenefit.supportingInfo.timing[x], ExplanationOfBenefit.item.serviced[x], ExplanationOfBenefit.addItem.serviced[x]]\n[Period, Timing, dateTime]: (7) [ChargeItem.occurrence[x], Contract.term.action.occurrence[x], DeviceRequest.occurrence[x], DeviceUseStatement.timing[x], ServiceRequest.occurrence[x], SupplyDelivery.occurrence[x], SupplyRequest.occurrence[x]]\n[positiveInt, string]: (6) [Immunization.protocolApplied.doseNumber[x], Immunization.protocolApplied.seriesDoses[x], ImmunizationEvaluation.doseNumber[x], ImmunizationEvaluation.seriesDoses[x], ImmunizationRecommendation.recommendation.doseNumber[x], ImmunizationRecommendation.recommendation.seriesDoses[x]]\n[Attachment, Reference]: (5) [Consent.source[x], Contract.friendly.content[x], Contract.legal.content[x], Contract.rule.content[x], Contract.legallyBinding[x]]\n[Age, Period, Range, dateTime, string]: (4) [AllergyIntolerance.onset[x], Condition.onset[x], Condition.abatement[x], Procedure.performed[x]]\n[Address, CodeableConcept, Reference]: (4) [Claim.item.location[x], ClaimResponse.addItem.location[x], ExplanationOfBenefit.item.location[x], ExplanationOfBenefit.addItem.location[x]]\n[canonical, uri]: (3) [ConceptMap.source[x], ConceptMap.target[x], PlanDefinition.action.definition[x]]\n[Money, string, unsignedInt]: (3) [CoverageEligibilityResponse.insurance.item.benefit.allowed[x], CoverageEligibilityResponse.insurance.item.benefit.used[x], ExplanationOfBenefit.benefitBalance.financial.allowed[x]]\n[Duration, Period, Timing, dateTime]: (3) [EvidenceVariable.characteristic.participantEffective[x], ResearchElementDefinition.characteristic.studyEffective[x], ResearchElementDefinition.characteristic.participantEffective[x]]\n[CodeableConcept, boolean]: (3) [Dosage.asNeeded[x], MedicationRequest.substitution.allowed[x], ServiceRequest.asNeeded[x]]\n[Attachment, Coding, Quantity, Reference, boolean, date, dateTime, decimal, integer, string, time, uri]: (3) [Contract.term.offer.answer.value[x], Questionnaire.item.initial.value[x], QuestionnaireResponse.item.answer.value[x]]\n[Age, Duration, Period, Range, Timing, dateTime]: (3) [ActivityDefinition.timing[x], PlanDefinition.action.timing[x], RequestGroup.action.timing[x]]\n[*]: (3) [StructureMap.group.rule.source.defaultValue[x], Task.input.value[x], Task.output.value[x]]\n[boolean, canonical]: (2) [ImplementationGuide.definition.resource.example[x], ImplementationGuide.manifest.resource.example[x]]\n[Reference, string]: (2) [Annotation.author[x], DeviceDefinition.manufacturer[x]]\n[Ratio, SimpleQuantity]: (2) [MedicationAdministration.dosage.rate[x], NutritionOrder.enteralFormula.administration.rate[x]]\n[Quantity, string]: (2) [SubstanceSpecification.moiety.amount[x], SubstanceSpecification.property.amount[x]]\n[Quantity, Range, string]: (2) [SubstanceAmount.amount[x], SubstanceReferenceInformation.target.amount[x]]\n[Duration, Range]: (2) [PlanDefinition.action.relatedAction.offset[x], RequestGroup.action.relatedAction.offset[x]]\n[Coding, uri]: (2) [MessageDefinition.event[x], MessageHeader.event[x]]\n[CodeableConcept, Quantity, Range, boolean]: (2) [DeviceRequest.parameter.value[x], SupplyRequest.parameter.value[x]]\n[CodeableConcept, Period, Quantity, Range, Ratio, SampledData, boolean, dateTime, integer, string, time]: (2) [Observation.value[x], Observation.component.value[x]]\n[Attachment, Reference, string]: (2) [Communication.payload.content[x], CommunicationRequest.payload.content[x]]\n[Attachment, Quantity, Reference, boolean, string]: (2) [Claim.supportingInfo.value[x], ExplanationOfBenefit.supportingInfo.value[x]]\n[Address, Reference]: (2) [Claim.accident.location[x], ExplanationOfBenefit.accident.location[x]]\n[dateTime, string]: (1) [Immunization.occurrence[x]]\n[boolean, integer]: (1) [Patient.multipleBirth[x]]\n[boolean, decimal, id, integer, string]: (1) [StructureMap.group.rule.target.parameter.value[x]]\n[boolean, dateTime]: (1) [Patient.deceased[x]]\n[boolean, code, dateTime, decimal, integer, string, uri]: (1) [ValueSet.expansion.parameter.value[x]]\n[base64Binary, string]: (1) [AuditEvent.entity.detail.value[x]]\n[SimpleQuantity, string]: (1) [SpecimenDefinition.typeTested.container.minimumVolume[x]]\n[Reference, url]: (1) [ImplementationGuide.definition.page.name[x]]\n[Reference, boolean]: (1) [MedicationRequest.reported[x]]\n[Reference, Timing, date, dateTime]: (1) [TriggerDefinition.timing[x]]\n[Range, decimal]: (1) [RiskAssessment.prediction.probability[x]]\n[Range, SimpleQuantity]: (1) [Dosage.doseAndRate.dose[x]]\n[Range, Ratio, SimpleQuantity]: (1) [Dosage.doseAndRate.rate[x]]\n[Quantity, Range, Ratio]: (1) [ServiceRequest.quantity[x]]\n[Quantity, Range, Ratio, string]: (1) [SubstanceSpecification.relationship.amount[x]]\n[Period, date, string]: (1) [FamilyMemberHistory.born[x]]\n[Period, Timing, string]: (1) [CarePlan.activity.detail.scheduled[x]]\n[Period, Timing, dateTime, instant]: (1) [Observation.effective[x]]\n[Period, Range]: (1) [RiskAssessment.prediction.when[x]]\n[Money, unsignedInt]: (1) [ExplanationOfBenefit.benefitBalance.financial.used[x]]\n[Money, SimpleQuantity]: (1) [Coverage.costToBeneficiary.value[x]]\n[Identifier, Reference]: (1) [Composition.relatesTo.target[x]]\n[Duration, date]: (1) [Goal.target.due[x]]\n[Duration, Period, dateTime]: (1) [DataRequirement.dateFilter.value[x]]\n[Duration, Period, Range]: (1) [Timing.repeat.bounds[x]]\n[Coding, boolean, code, dateTime, decimal, integer, string]: (1) [CodeSystem.concept.property.value[x]]\n[Coding, Reference, date, integer, string, time]: (1) [Questionnaire.item.answerOption.value[x]]\n[Coding, Quantity, Reference, boolean, date, dateTime, decimal, integer, string, time]: (1) [Questionnaire.item.enableWhen.answer[x]]\n[CodeableConcept, date]: (1) [Goal.start[x]]\n[CodeableConcept, canonical, uri]: (1) [GuidanceResponse.module[x]]\n[CodeableConcept, SimpleQuantity]: (1) [MedicationKnowledge.administrationGuidelines.patientCharacteristics.characteristic[x]]\n[CodeableConcept, SimpleQuantity, base64Binary, string]: (1) [MedicationKnowledge.drugCharacteristic.value[x]]\n[CodeableConcept, Range]: (1) [Population.age[x]]\n[CodeableConcept, Quantity, Range]: (1) [PlanDefinition.goal.target.detail[x]]\n[CodeableConcept, Quantity, Range, Reference]: (1) [UsageContext.value[x]]\n[CodeableConcept, Quantity, Range, Reference, boolean]: (1) [Group.characteristic.value[x]]\n[CodeableConcept, Quantity, Range, Ratio, boolean, integer, string]: (1) [Goal.target.detail[x]]\n[CodeableConcept, Duration]: (1) [Specimen.collection.fastingStatus[x]]\n[CodeableConcept, DataRequirement, Expression, canonical]: (1) [ResearchElementDefinition.characteristic.definition[x]]\n[CodeableConcept, DataRequirement, Expression, Reference, TriggerDefinition, canonical]: (1) [EvidenceVariable.characteristic.definition[x]]\n[Age, Range, string]: (1) [FamilyMemberHistory.age[x]]\n[Age, Range, boolean, date, string]: (1) [FamilyMemberHistory.deceased[x]]\n[Age, Period, Range, string]: (1) [FamilyMemberHistory.condition.onset[x]]\n</pre></div>",
        "id": 182489679,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575403518
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> I think you are not looking at this in the right way. I would be looking for common situations, not assuming that every time some combination like {Date | Duration} pops up, it is an entirely de novo situation. There are reasons these combinations pop up; usually it is the same reason every time some particular combination pops up. So look for that, analyse it, and build a type for it so that it is no longer an ad hoc analysis every time. If on the n+1st time of seeing {Date | Duration}  the group looks at the handy EventTime type, and decides, no, that doesn't correspond to our situation, ok, they can avoid it. But 95% of the time, it will correspond.</p>",
        "id": 182489959,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575403712
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> you saved me the trouble, I was going to build exactly that list</p>",
        "id": 182489988,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575403734
    },
    {
        "content": "<p>Any chance you can do it with one entry on a line?</p>",
        "id": 182490012,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575403756
    },
    {
        "content": "<p>one entry what?</p>",
        "id": 182490032,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575403775
    },
    {
        "content": "<p>on the right side?</p>",
        "id": 182490056,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575403789
    },
    {
        "content": "<p>I just did it, a bit more readable.</p>",
        "id": 182490306,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575403949
    },
    {
        "content": "<p>sorry my bad - I just realised it is a 2-col list</p>",
        "id": 182490312,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575403955
    },
    {
        "content": "<p>Ok so I am prepared to bet that a lot of that long tail of (2) and (1) are just lesser versions of say  combinations with (3) or more occurrences, but the relevant group hasn't thought it through (their minds being on more interesting questions no doubt).</p>",
        "id": 182490543,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575404143
    },
    {
        "content": "<p>No matter what I look at, there are reasons and semantics. E.g. <code>[boolean, integer]</code> - this is a repeat of the situation of 'presence and/or quantity' which is an analogue of 'occurred and/or when'.</p>",
        "id": 182490751,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575404257
    },
    {
        "content": "<p>There are explanations for all of these. Despite some undoubted missing types, and possibly some wrong extra types, you will find that when you interrogate everyone who created these things that in each case, they were trying to solve the same problem as some other group that created (nearly) the same pattern.</p>",
        "id": 182490867,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575404322
    },
    {
        "content": "<p>ok. my comments: </p>\n<ul>\n<li>[CodeableConcept, Reference]: (41) - already going away</li>\n<li>[Period, dateTime]: (15) + [Period, date]: (8) - deserves it's own type to deal with the semantics. Probably with a profile. </li>\n<li>[Period, Timing, dateTime]: (7) - maybe part of the previous type? Timing is always difficult</li>\n<li>[positiveInt, string]: (6) - not a type. Not a pattern I like either. Discussion with committee (though on these cases the tooling should make the type PrimitiveType not Type)</li>\n<li>[Attachment, Reference]: (5) - make Reference a property of Attachment - this is a current topic in the implementers channel</li>\n<li>[Age, Period, Range, dateTime, string]: (4) - don't know. these are few and slippery things anyway</li>\n<li>[Address, CodeableConcept, Reference] - this pattern should not exist; these are all Location things. Why inline things out of Location ? </li>\n<li>[canonical, uri]: (3) - this pattern should not exists - part of the discussion about instantiate[x]</li>\n</ul>",
        "id": 182490872,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575404331
    },
    {
        "content": "<p>Grahame, your list looks good.</p>",
        "id": 182491016,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575404429
    },
    {
        "content": "<p>So I propose the creation of a new DataType, called AbsoutelyHorribleTimeThingy, with dateTime, Period, Duration, and Timing in it</p>",
        "id": 182491068,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575404468
    },
    {
        "content": "<p>as mutually exclusive choices</p>",
        "id": 182491089,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575404488
    },
    {
        "content": "<p>We have it on out TODO list in openEHR to solve this annoying timing question i.e. the 5 (or is it 23) ways of specifying time in various situations. I will try to accelerate that bit of modelling and share it. Might not quite do what you need, but could at least give you some ideas.</p>",
        "id": 182491109,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575404502
    },
    {
        "content": "<p>What does it mean to have Period, dateTime as its own type?  Can I still constrain it to just Period or just dateTime in my profile?  Is there overhead in the instance due to having a distinct type?</p>",
        "id": 182491116,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575404506
    },
    {
        "content": "<p>yes and yes</p>",
        "id": 182491178,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575404530
    },
    {
        "content": "<p>Is the overhead in the instance worth it?  What's the added value?</p>",
        "id": 182491205,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575404560
    },
    {
        "content": "<p>Nah, programmers will thank you for it, and will think of it as FantasticSavedMe3HoursOfPointlessArgumentTimingThingy...</p>",
        "id": 182491216,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575404570
    },
    {
        "content": "<p>with regard to the overhead - it's a tradeoff. Tom's reasonable point is that there's trade off somewhere. Reusable semantics requires some structure to set up reusability</p>",
        "id": 182491220,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575404577
    },
    {
        "content": "<p>My working name for that kind of type is just TimeSpecifier...</p>",
        "id": 182491232,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575404585
    },
    {
        "content": "<p>but I don't think it's as obvious a tradeoff as Tom thinks.</p>",
        "id": 182491239,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575404597
    },
    {
        "content": "<p>It's the tricky input / display / transform semantics that make it worth making re-usable</p>",
        "id": 182491259,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575404616
    },
    {
        "content": "<p>Maybe I'm driving you guys up the wall here, but my point is: think of all the client programmers... every single unnecessary choice they have to make, is a a loss of time, and also a possible source of error. Make things a bit harder for the server-side, there will be 100x less of them. And big companies... ;)</p>",
        "id": 182491354,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575404685
    },
    {
        "content": "<p>we do. and we get their input all the time. Both here and privately and face to face. And their feedback is nowhere unanimous along the lines you think</p>",
        "id": 182491408,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575404738
    },
    {
        "content": "<p>I've heard lots of assertions about what developers will want.  I haven't heard <em>developers</em> asking for these things yet, just a few modeler types.  (And we're not trying to satisfy the needs of modeler types).  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> can you explain more concretely what having the new types will make easier for our standard 'simple' developers that will offset the cost of more named things to understand, more opacity around what data can be present and more complex instances?  (Remembering as well that our objective is to keep things as simple as possible for the 'simple' developers, even if it means foisting more work on the more sophisticated developers.)</p>",
        "id": 182491417,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575404750
    },
    {
        "content": "<p>[Reference, url] - surely same as your last list item</p>",
        "id": 182491423,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575404755
    },
    {
        "content": "<p>maybe</p>",
        "id": 182491476,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575404773
    },
    {
        "content": "<p>similar principle</p>",
        "id": 182491487,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575404783
    },
    {
        "content": "<p>(Note - when I say 'modeler type', I consider myself one of those.  I try to guard, not always successfully, at pushing modeling ideals into the spec that conflict with what developers actually do/want.)</p>",
        "id": 182491593,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575404855
    },
    {
        "content": "<p>Nearly every time there is a boolean, it is represents 'presence' or 'occurred' - and it is with some other data type, which is the appropriate type for the thing being reported quantitatively - integer, decimal, dateTime etc. So there is a very common pattern there which is not instantly obvious in Grahame's table.</p>",
        "id": 182491679,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575404893
    },
    {
        "content": "<p>Also, <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, how do we constrain the new CodeableReference to just Reference or just CodeableConcept if that's what a profile needs?  I don't see how that's possible?</p>",
        "id": 182491725,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575404927
    },
    {
        "content": "<p>Ha. 90% of developers want less crap to wade through and less decisions to make. And we are all sometimes in that mode. Quite often reading a spec we realise we wrote. When I see something that makes me write out a 5-way if/then/else type testing statement, I think - really, they didn't sort this out? Then I see it's something we wrote, and I think... ok, we need to sort this out. Anytime people have to write ad hoc type-testing code, something is wrong (or at least not done).</p>",
        "id": 182491970,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575405084
    },
    {
        "content": "<p>so at present, we have a set of elements that have a set of related patterns -around date(Time) | Period | Duration | Timing. If I'm going to deal with those, I'm going to have to do some variation of the following tasks:</p>\n<ul>\n<li>write User interface for input and also display</li>\n<li>move content in from / out to other formats</li>\n<li>figure out what it means for some actual code that interprets the meaning</li>\n</ul>\n<p>In most of those cases, I'm pretty much going to have to write separate code for the different possible types. And I'm going to get a fair degree of re-use of that code across different elements. </p>\n<p>But I will have to introduce case / switch statement for each element to deal with the choices. Moving the choice to a specific type means that I can centralise the case/switch statement and have cleaner easier to maintain visitor pattern type code etc, and it's wroth more in investing robustness around the type.</p>\n<p>But it's a bit of moving deck  chairs around the titanic. The complexity exists; I don't think we're fundamentally adding to it. It's just a question of where the cost of re-use is least painful</p>",
        "id": 182492081,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405151
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> don't you just want to force one of them to be 1..1? That should be easy.</p>",
        "id": 182492093,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575405161
    },
    {
        "content": "<p>yes, the way I'd rather do it would make that simpler, but it's not special otherwise</p>",
        "id": 182492127,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405190
    },
    {
        "content": "<blockquote>\n<p>means that I can centralise the case/switch statement and have cleaner easier to maintain visitor pattern type code etc, and it's wroth more in investing robustness around the type.</p>\n</blockquote>\n<p>what that guy said...</p>",
        "id": 182492197,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575405238
    },
    {
        "content": "<p>also centralising the definition of the choice allows us to have more to say about the play off between the choices and invest in profiling etc to make sense of things like date | Period</p>",
        "id": 182492416,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405379
    },
    {
        "content": "<p>for me, that's the swaying factor on the date related elements. Clearly we should be saying more about this stuff than we are .</p>",
        "id": 182492460,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405410
    },
    {
        "content": "<p>For fun... search 'onset' in the table:</p>\n<div class=\"codehilite\"><pre><span></span>[Age, Period, Range, dateTime, string]    // 2 hits\n[Age, Period, Range,          string]    // 1 hit\n</pre></div>",
        "id": 182492477,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575405422
    },
    {
        "content": "<p>Actually, I think that makes sense</p>",
        "id": 182492530,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405464
    },
    {
        "content": "<p>Though I'm not sure the sensibleness is that important as opposed to consistency</p>",
        "id": 182492592,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405489
    },
    {
        "content": "<p>'timing':</p>\n<div class=\"codehilite\"><pre><span></span>[Period, date]    // 2 hits\n[Period, Timing, dateTime]   // 1 hit\n[Age, Duration, Period, Range, Timing, dateTime]    // 3 hits\n[Reference, Timing, date, dateTime]             // 1 hit\n</pre></div>",
        "id": 182492812,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575405646
    },
    {
        "content": "<p>date | dateTime is not a sensible combination</p>",
        "id": 182492866,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405683
    },
    {
        "content": "<p>'occurrence':</p>\n<div class=\"codehilite\"><pre><span></span>[Period, dateTime]    // 1 hit\n[Period, Timing, dateTime]    // 6 hits; #7 is called &#39;timing&#39;...\n[dateTime, string]         // 1 hit\n</pre></div>",
        "id": 182493004,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575405754
    },
    {
        "content": "<p>ouch. there's some bug in my analysis</p>",
        "id": 182493078,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405827
    },
    {
        "content": "<p>no it's in your reformat, <span class=\"user-mention\" data-user-id=\"191388\">@Thomas Beale</span></p>",
        "id": 182493153,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405866
    },
    {
        "content": "<p>no whoops, I was just reading it wrong</p>",
        "id": 182493180,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405899
    },
    {
        "content": "<p>What reformat?</p>",
        "id": 182493181,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575405900
    },
    {
        "content": "<p>no just ignore that. I had a problem between the chair and the keyboard</p>",
        "id": 182493240,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> does Timing | Reference(Schedule)   make any sense?</p>",
        "id": 182493301,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405964
    },
    {
        "content": "<p>There are 5 rows in <a href=\"http://hl7.org/fhir/R4/choice-elements.json\" target=\"_blank\" title=\"http://hl7.org/fhir/R4/choice-elements.json\">http://hl7.org/fhir/R4/choice-elements.json</a> with \"date\", \"dateTime\" (among other types)</p>",
        "id": 182493332,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575405986
    },
    {
        "content": "<p>it looks incoherent to me</p>",
        "id": 182493339,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575405988
    },
    {
        "content": "<p>2 of the 5 are the genuine Type ancestors</p>",
        "id": 182493409,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575406046
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> I can't make sense of a a choice between Timing | Reference(Schedule) in TriggerDefinition. It looks like an error to me</p>",
        "id": 182493733,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575406238
    },
    {
        "content": "<p>I don't understand how intermediary types = less crap to wade through and less decisions to make.  The number of decisions are identical.  If I have a choice of dateTime|Period|Age|Range|string, whether that's expressed as a type or as a choice, I still need to figure out: a) which of those types does my system support; b) how do I map my existing data structures into the FHIR format.</p>\n<p>Remember - implementers aren't implementing FHIR.  They aren't generally adding any new capabilities to their systems or changing their internal data models <em>at all</em>.  They're just mapping what they've got into the FHIR structures.</p>\n<p>In terms of crap to wade through, we've just added one more named thing, one more set of descriptions, one more click in the spec to see what's actually available and one more node to navigate through when defining path structures or creating instances.</p>",
        "id": 182493972,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575406414
    },
    {
        "content": "<p>yes there's a cost.</p>",
        "id": 182494061,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575406449
    },
    {
        "content": "<blockquote>\n<p>- implementers aren't implementing FHIR. They aren't generally adding any new capabilities to their systems or changing their internal data models at all.</p>\n</blockquote>\n<p>That's not true for many implementers. There are some who are not changing things at all. but as many are changing some things.and others are building from scratch. particularly clients are generally building from scratch. And in case you hadn't noticed, that is getting more common</p>",
        "id": 182494152,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575406513
    },
    {
        "content": "<p>so we are seeking for the least net pain. I'm not at all persuaded that we should get rid of choice elements generally, but I am persuaded that for 3 to 4 of the common patterns, it's worth it to define specific types to enable re-use and investment</p>",
        "id": 182494299,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575406600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> thanks for that explanation.  My impression of your explanation is that the types are a useful <em>implementation</em> artifact, but not necessarily a useful <em>exchange</em> artifact.  It seems to me that expressing them in the standard leads to a more complex spec and more complex instances, with no real benefit in \"specification\" space.  However, there is savings and re-use on the implementation side.  Would it make sense to push this stuff into the reference implementations rather than the specifications?  I.e. If the reference implementation sees a certain combination, it could treat that as a class and re-use certain code?</p>",
        "id": 182494492,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575406731
    },
    {
        "content": "<p>Where is Timing|Reference(schedule) appearing?  Can't see it in the list you provided</p>",
        "id": 182494524,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575406751
    },
    {
        "content": "<p>My point is more that, with FHIR, we try very hard not to <em>depend</em> on implementers changing what they do - we try to make it so they can simply expose their data \"as is\" in the FHIR standard, though obviously mapping/transformation is necessary.  The driver for changing behavior is supposed to be implementation guides, not the core specification itself.</p>",
        "id": 182494740,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575406852
    },
    {
        "content": "<p>TriggerDefinition</p>",
        "id": 182494745,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575406853
    },
    {
        "content": "<p>that point seems unrelated to this dsicussion</p>",
        "id": 182494790,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575406880
    },
    {
        "content": "<p>I think that we should define them where they are useful definition artifact. Which I think is the case for CodeableReference and this HorribleDatePattern</p>",
        "id": 182494900,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575406930
    },
    {
        "content": "<p>For TriggerDefinition, it <em>could</em> make sense, but more documentation is needed.  Does it mean that the trigger fires once for each Slot in the Schedule?</p>",
        "id": 182495184,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575407067
    },
    {
        "content": "<p>as it actually happens? or as it is used up? Weird...</p>",
        "id": 182495321,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575407140
    },
    {
        "content": "<p>No clue as to the use-case.  I can see it as a theoretical possibility, but definitely couldn't implement it as currently specified and don't know when I'd actually want to use it.</p>",
        "id": 182495495,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575407194
    },
    {
        "content": "<p>My concerns are:<br>\n- adding complexity obfuscation to the specification<br>\n- adding layers to the instances<br>\n- making it harder to declare constraints<br>\n- making work groups feel that they can't use arbitrary collections that reflect the reality because their needs don't fit one of the \"standard patterns\"</p>\n<p>Is exposing this stuff in the reference implementations but not the interface a possibility?</p>",
        "id": 182495599,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575407252
    },
    {
        "content": "<p>Yes, I think the reference to Schedule in the trigger there is a mistake.</p>",
        "id": 182496046,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1575407451
    },
    {
        "content": "<p>When I defined it I was thinking \"Schedule\" more broadly than what it is actually representing.</p>",
        "id": 182496082,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1575407470
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> you'll write up the change request?</p>",
        "id": 182496529,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575407703
    },
    {
        "content": "<p>Yes, doing that now</p>",
        "id": 182497506,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1575408192
    },
    {
        "content": "<p><a href=\"https://jira.hl7.org/browse/FHIR-25269\" target=\"_blank\" title=\"https://jira.hl7.org/browse/FHIR-25269\">https://jira.hl7.org/browse/FHIR-25269</a></p>",
        "id": 182498605,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1575408755
    },
    {
        "content": "<p>ok. MnM decisions:<br>\n- we'll announce that we are intending to migrate all CodeableConcept | Reference to the new type<br>\n- we'll announce that we're working on the new date/timing related type and create a new thread to do that here  on the <a class=\"stream\" data-stream-id=\"211987\" href=\"/#narrow/stream/211987-methodology\">#methodology</a> stream. If we can get consensus, then we'll put something in the spec and seek further comment</p>",
        "id": 182503084,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575411650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191388\">@Thomas Beale</span> do you want to create a change proposal for the seriesDoses thing? I have presume that's 3 of 6 kind of thing - don't know how that could not be a positiveInt</p>",
        "id": 182520572,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575428754
    },
    {
        "content": "<p>The reason for it not being a positive int is when it's not actually part of a series.  E.g. a Tetanus booster.  (What's not clear is why they're sticking that in sequence as opposed to putting it somewhere else...)</p>",
        "id": 182520903,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575429177
    },
    {
        "content": "<p>you described doseNumber[x]. seriesDoses[x] - that doesn't appear to make sense at all</p>",
        "id": 182526675,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575436922
    },
    {
        "content": "<p>I'm just echoing the explanation given in the usage notes for the element.  <span class=\"user-mention\" data-user-id=\"192758\">@Craig Newman</span>, can you provide a better explanation of the choice of posInt|string?</p>",
        "id": 182526902,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575437279
    },
    {
        "content": "<blockquote>\n<p>doseNumber[x] = Nominal position in a series. The use of an integer is preferred if known. A string should only be used in cases where an integer is not available (such as when documenting a recurring booster dose).</p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p>seriesDoses[x] = The recommended number of doses to achieve immunity.</p>\n</blockquote>\n<p>I can only presume this pair is so you can say '2 of 4'. Under what circumstances is it meaningful for the second part ('of 4') o be non-numerical? ('Tetanus booster of However many boosters appropriate') ?</p>",
        "id": 182527047,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575437440
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> that was my understanding reading the documentation as well. seriesDoses has to be numerical, or else its documentation, as well as the overall concept make no sense. So something is wrong here.</p>",
        "id": 182532478,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575445228
    },
    {
        "content": "<p>right. do you want to make a task for them to fix it?</p>",
        "id": 182540700,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575453479
    },
    {
        "content": "<p>Well I don't think it is my business to make comments about the models of that group. I think (as I have said previously) that there is a methodology review function that is somewhat missing generally, given the number of questionable choices / errors we are seeing. I'm not saying that casually, what I mean is that the people working on these models don't have sufficient initial guidance on what they should / should not do (even if they are serious modelling experts - it's mainly a question of FHIR modelling norms etc), and also, there isn't a 'model QA' filter occurring before any committee changes are committed, or if there is, it's not working as intended.</p>\n<p>So yes, I assume someone should raise a CR to fix that particular problem, but the fact is there are lots of these - if we comb through your table, we'll discover another dozen for sure. This is why we should make the effort to sort out these special Data types that deal with common situations of getting a Date | Duration, item | boolean, Ref | value and so on.</p>",
        "id": 182553395,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575464850
    },
    {
        "content": "<p>\"booster\" or something like \"annual\" for flu shots is the use case for a string doseNumber. Most immunizations are administered as part of a primary series with a recommended number of doses (2 doses of MMR, 3 doses of Hepatitis A, etc) which is the \"seriesDose\". However when there are boosters recommended (a meningococcal vaccine every 10 years after the completion of the primary series) there is no known upper limit because you don't know how long the patient will ultimately live (or how many doses they actually get (they could wait 20 years for their first booster).</p>",
        "id": 182556820,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575467525
    },
    {
        "content": "<p>Why is that being captured in 'sequence'?  Wouldn't sequence just be non-applicable and you'd capture the purpose of the dose in a different element entirely?</p>",
        "id": 182556880,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575467580
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"192758\">@Craig Newman</span>)</p>",
        "id": 182556901,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575467599
    },
    {
        "content": "<p>That's one way to do it. I think in the immunization world, it's all one concept, it's just that \"booster\" isn't a number.</p>",
        "id": 182557037,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575467689
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192758\">@Craig Newman</span>  So, within most immunization databases, they'd have a single field that would capture either \"1\", \"2\", \"3\" or \"booster\"?  Is there a constrained set of values that could exist other than the numbers?  Could this be a code rather than string?</p>",
        "id": 182561780,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575470946
    },
    {
        "content": "<p>An alternative would be to just make it a string. That would still allow a number to be sent if it's part of the primary series. I wouldn't necessarily expect that anyone will need even the primary series doses to be numbers (as opposed to a string like \"first\" or \"second\"). I think we just kept positiveInt because that was how the element was defined in STU3 and earlier versions</p>",
        "id": 182561902,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575471003
    },
    {
        "content": "<p>I don't think EHRs or IIS (immunization registry systems) really even store data like this. The \"2 out 3\" really is more part of an on the fly evaluation of the patient's history against a set of recommendations (which are often expressed by the experts in non-computable forms). A patient may have a history of 2 doses of MMR but if the first one was given too early (prior to 12 months of age), then they may only have one valid dose and the recommendation would be for the second valid dose in a 2 dose series even though it would technically be the third dose given to the patient. </p>\n<p><span class=\"user-mention\" data-user-id=\"193813\">@Nathan Bunker</span> might have input too.</p>",
        "id": 182562298,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575471214
    },
    {
        "content": "<p>If you're not doing math or comparisons, then making it an 'int' may be unnecessary.  However, still wondering whether 'code' might be a better choice for interoperability purposes?</p>",
        "id": 182562330,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575471239
    },
    {
        "content": "<p>Presumably the number of relevant integers would be relatively small?  What's the maximum int would could ever expect to see?  Are there non-int values other than 'booster'?</p>",
        "id": 182562460,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575471279
    },
    {
        "content": "<p>I'm not sure we could come up with a set of codes. The largest number of doses is probably in the 7-10 range for tetanus, diphtheria and pertussis (although many folks will separate those vaccines into separate childhood and adolescent series). \"annual\" for flu is the the only other non-number concept that comes to my mind and even that one isn't quite as common as boosters.</p>",
        "id": 182562678,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575471406
    },
    {
        "content": "<p>I feel like these concepts are more for humans than computers as the CDS engines will likely do their own evaluations and come up with their own numbers.</p>",
        "id": 182562765,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575471460
    },
    {
        "content": "<p>I would agree with Craig. The concept of \"dose number\" is not something that would ever be computable. For immunization purposes the ideal solution for these fields would be that they were strings. We don't want systems making computations off of them, but rather just display this to an end user. Saying they are due for TD #10 doesn't make sense to an end provider. But saying they are due for TD Booster does.</p>",
        "id": 182562987,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575471593
    },
    {
        "content": "<p>In other areas the concept of dose number might be more computable, such as when you are giving a very defined series of medications in a week. But for immunizations the next dose number is really just a milepost for the clinician to help them understand where they are in the series. The actual dose number really doesn't matter, and doesn't affect clinical care. The rest of the recommendation contains the details of which vaccination to give and when and these are the ones that need to be computable. </p>\n<p>As for making the concepts codeable, I'm not sure this would be a useful exercise. We don't know of any business rules that would be triggered that would require a standardized set of codes. For our business purposes simply having a human-understandable string works very well.</p>",
        "id": 182563345,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575471785
    },
    {
        "content": "<p>So I guess the question then is what the reason is for introducing positiveInt?</p>",
        "id": 182563672,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575471977
    },
    {
        "content": "<p>Good question. I don't know the history on this resource. But often the value is a positive number and often it is clinically thought about in this way. So then it often gets modeled as such. This is probably an over-simplification during modeling.</p>",
        "id": 182564451,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575472357
    },
    {
        "content": "<blockquote>\n<p>The concept of \"dose number\" is not something that would ever be computable.</p>\n</blockquote>\n<p>Aren't there cases where it is computable? If you have guideline that says \"Children after 1 y.o. need vaccine X administered in 3 doses\", don't you want to record that an administration is dose 1 or 2 or 3?</p>",
        "id": 182564878,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1575472566
    },
    {
        "content": "<p>In practice we don't look at the dose number when computing which doses are due next. Instead we look at the entire history and determine the next dose needed. Even if a clinician said \"I gave dose 2\" we would not then recommend dose 3. Instead we look at the entire history and determine what is needed next. Sometimes we know about additional doses the clinician didn't know about, so the dose she gave was actually dose 3, not dose 2. Or too much time has passed and while that was dose 2 administered the patient is too old to get dose 3. So we are now moving on to the booster dose. So in practice if our systems get the dose number reported we completely ignore it. It's actually useless to know what dose the clinician thought they were giving, all we care about it which vaccines were given when.</p>",
        "id": 182565508,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575472973
    },
    {
        "content": "<p>The only place we use dose number is when telling a clinician to give a vaccination. They understand the significance of the dose numbers and where they are in a vaccination series. So if we say the patient is due for dose 4 of 5. This makes sense to them and helps them understand what we are recommending. This is important because there actually may be 5 doses already on the record, but maybe third dose listed wasn't a valid dose, because it was given too soon. So then the clinician can see that and realize that while the patient did get the 5 required doses, one of them didn't count. Then they will accept the clinical decision support and do an extra dose.</p>",
        "id": 182565737,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575473122
    },
    {
        "content": "<p>But at no time would this dose \"number\" be computed. And it is not needed to store on the vaccination record.</p>",
        "id": 182565834,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575473177
    },
    {
        "content": "<p>This seems to be assuming that \"the vaccination record\" only exists on one centralized location. If you have multiple vaccination records, wouldn't you want the information stored?</p>",
        "id": 182566674,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1575473683
    },
    {
        "content": "<p>Also keep in mind that it's all relative to the set of recommendations being compared to. And those are fluid to some extent. Not only do recommendations change, but even within a single static set of recommendations, the number of doses can change as the the patient ages and doses are or are not given. What may start out as a 4 dose series may change to a 3 dose series if the first dose isn't given on time. Or if you compare to a different schedule, the evaluation may be different.</p>",
        "id": 182567854,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575474468
    },
    {
        "content": "<p>The only way you can give an accurate evaluation/forecast is if you have access to the compete history which may be spread over multiple system (but hopefully that is less and less the case as more providers contribute to and query IIS). If the system is spread out over multiple systems, the dose number becomes less and less reliable. If Doctor Jones gives the patient the first dose and Doctor Smith gives the patient the second dose and each record the doses in their respective (non-interoperable) systems, each one may flag their dose as \"dose 1 of x\" but clearly that's wrong.</p>",
        "id": 182568093,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575474613
    },
    {
        "content": "<p>Just to echo what Craig said the dose number is a very fluid concept and changes with time. I did make a comment that implied a central location. Vaccinations are always given with the idea that the clinician has complete knowledge of the entire vaccination history. In the past this was done with a paper immunization \"shot card\" that recorded the basic information needed for the clinician to determine the proper next dose to give. Today this is done in a central immunization systems and/or EHR record. Wherever this happens the goal is the same, to get a complete history. The dose number is just an output of the recommendation engine at the point in time when recommendations are requested. It helps orientate the clinician to the results. But there is nothing that can be computed from the dose number and no decisions can be automated.</p>",
        "id": 182568645,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575474993
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>The concept of \"dose number\" is not something that would ever be computable.</p>\n</blockquote>\n<p>Aren't there cases where it is computable? If you have guideline that says \"Children after 1 y.o. need vaccine X administered in 3 doses\", don't you want to record that an administration is dose 1 or 2 or 3?</p>\n</blockquote>\n<p>in openEHR we wouldn't rely on any '1 of 3' data, we'd query the EHR and find out how many previous admins had been recorded (and probably the docs would double check with parents etc).</p>",
        "id": 182569834,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575475667
    },
    {
        "content": "<p>They might not all be reflected in the EHR.</p>",
        "id": 182570103,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575475809
    },
    {
        "content": "<p>That's what I'm worried about. You shouldn't query the EHR and count doses, because you won't know which vaccinations really count. Both because there are different types of combinations that count or don't count and also because which doses count depends on the age of the patient and what other vaccinations were given when. There might be 3 perfectly good doses on the EHR record but the second one might be given too close to another vaccination so it doesn't count and has to be repeated. You need a CDS engine to evaluate the history and come up with a recommendation. Then tell the user that \"today the patient is due for dose 2 of 3\". </p>\n<p>Ideally we would just be reporting back a string that was human readable but not computable.</p>",
        "id": 182572862,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575477369
    },
    {
        "content": "<p>Indeed you can't trust that everything that happens in the real world turns up in the EHR. For that very reason, you will hardly see any data of the form '1st of 3' in any computable form, precisely for the reason that the patient might have moved, the system might have changed, all the usual reasons. But, if (say) 2 doses have been actually recorded and all the relevant details are there, you certainly know that those two shots have been done. So any data or person saying they are not sure, or that it was only one is probably wrong. You should always query the EHR; it's just a question of how you treat the results.</p>",
        "id": 182577160,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575479801
    },
    {
        "content": "<p>having read the discussion, especially the 'this is not computable' comments, there's no reason for Immunization.protocolApplied.doseNumber to be anything but a string. </p>\n<p>OTOH, The discussion never even came close to justififying the existence of Immunization.protocolApplied.seriesDoses at all, let alone that it is a choice of positiveInt | String</p>",
        "id": 182577811,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575480199
    },
    {
        "content": "<p>From previous discussions with you, I thought that Immunization.protocolApplied.seriesDoses (and honestly Immunization.protocolApplied.doseNumber too) existed so that the provider could record their intent (at the time of administration they gave the vaccine because (one way or another) they had determined that the second dose of a four dose series was needed). These two concepts exist on all 3 immunization related resources although how they get populated are different:<br>\n-Immunization is the provider intent or understanding at the time of administration<br>\n-ImmunizationEvaluation is the CDS engine determination after comparing the patient history with a set of guidelines<br>\n-ImmunizationRecommendation is also the product of CDS engine evaluation and forecast against a set of guidelines<br>\nThe values of the elements in the Immunization resource should not impact the evaluation and forecasting process of the CDS engine producing the ImmunizationEvaluation and ImmunizationRecommendation.</p>",
        "id": 182579543,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575481235
    },
    {
        "content": "<p>For the US, I'm not aware of any use case for Immunization.protocolApplied.seriesDose, except perhaps for trying to translate between HL7 v2 where the base standard does have this concept. (Although we constrained out this usage for US immunization reporting use.) It's possible that in some situations it might be useful to know what dose the clinician intended this administration to be. My guess is that this is a concept in FHIR as it was also a required concept in HL7 v2 and presumably is being used in other situations. </p>\n<p>As for the other two Craig mentions on ImmunizationEvaluation and ImmunizationRecommendation: Being able to communicate the dose number is very helpful in providing context and orientation to the clinician. The decision making model is supposed to be joint so the CDS engine needs a way of communicating which dose it is recommending and the clinician needs to review this. But this information would not be used to plan out a series of events. You only give one dose in a series during an encounter and then the CDS process should be re-run for future encounters. The clinician might be told to give dose 2 of 4 today, and then in six months that the patient is now complete (because they are too old to get the dose 4). The only way to know if this is the case is to generate a CDS evaluation every time you look at the record and update the dose number recommendation.</p>\n<p>So ideally these fields would just be strings so that downstream systems don't try to do anything computable with them.</p>",
        "id": 182580847,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575482045
    },
    {
        "content": "<p>I commonly run into doseNumber in national registries. I don't recall whether seriesDoses was implied in the national program's approaches to me or not.</p>",
        "id": 182580900,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575482096
    },
    {
        "content": "<p>You can often assume the seriesDoses because most vaccines have a standard series. But the schedules are getting more complicated and some formulations allow for completing series faster (3 doses instead of 4 doses). So for completeness it's best to mention both the dose number and how many doses are in the series, that way the receiver isn't making the assumption.</p>",
        "id": 182581071,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575482213
    },
    {
        "content": "<p>In HL7 v2 we could receive a dose number, but in the US we have consistently ignored it when collecting for a registry. This is because we have to merge the records together and the clinicians often don't have the complete record. So what they call dose 2 might actually be 3. </p>\n<p>And then it gets even worse. If the registry stores the dose number, is this the number of the dose for only the valid shots that count towards the series or all the ones given? Also, how to handle combination vaccinations where a component might count or not count towards the series completion? Registries solve this problem by not assigning a permanent dose number, but rather by assigning it in real-time when displaying or returning data.</p>",
        "id": 182581397,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575482438
    },
    {
        "content": "<p>I think that this proviso should documented in the spec. I don't know how national registries resolve this, but they strongly think that the clinicians intent needs to be recorded</p>",
        "id": 182581656,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575482587
    },
    {
        "content": "<p>It sounds like we are closing in on an agreement that for all 3 immunization related resources the doseNumber and seriesDoses elements should be string only (remove the option for positiveInt) and clarify the source/intent of the elements in each resource (that is, in Immunization, it's the intent of the provider in administering the vaccine and in the other two, its the outcome of the CDS engine evaluation of patient history against the specific set of recommendations it uses). If we can agree on this, I'll go ahead and create a Jira ticket.</p>",
        "id": 182581923,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575482729
    },
    {
        "content": "<p>yes please do</p>",
        "id": 182582657,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575483153
    },
    {
        "content": "<p>Craig, that sounds good. I can agree with changing them to string only.</p>",
        "id": 182592387,
        "sender_full_name": "Nathan Bunker",
        "timestamp": 1575489194
    },
    {
        "content": "<p>I created and triaged Jira ticket 25277. I'll get this on a Public Health WG call and let folks know when it will be discussed. </p>\n<p><a href=\"https://jira.hl7.org/browse/FHIR-25277\" target=\"_blank\" title=\"https://jira.hl7.org/browse/FHIR-25277\">https://jira.hl7.org/browse/FHIR-25277</a></p>",
        "id": 182689908,
        "sender_full_name": "Craig Newman",
        "timestamp": 1575571668
    },
    {
        "content": "<p>So... there's a whole lot of other strange combinations of choice[x] that I think need to be looked at. E.g. this one from Group: <a href=\"/user_uploads/10155/ky_mRBvRgOsSOG_VxsWeoYs0/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/ky_mRBvRgOsSOG_VxsWeoYs0/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/ky_mRBvRgOsSOG_VxsWeoYs0/pasted_image.png\"></a></div>",
        "id": 182970404,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575907465
    },
    {
        "content": "<p>That's a generic value, like Observation.value - another place that should just have DataType. I can't think of any reason why the choice there doesn't have Duration, String, or most other possible data types.</p>",
        "id": 182970606,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575907576
    },
    {
        "content": "<p>Another one from Dosage. How do the 'rate'  choice types make sense? <a href=\"/user_uploads/10155/8IO7d5rxf1iZ81dYXMUuwmvc/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/8IO7d5rxf1iZ81dYXMUuwmvc/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/8IO7d5rxf1iZ81dYXMUuwmvc/pasted_image.png\"></a></div>",
        "id": 182971809,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575908259
    },
    {
        "content": "<p>For Group, string isn't useful for computation.  Duration wouldn't be meaningful without an anchor.  In short, the types that are listed are the ones for which we have use-cases.</p>\n<p>Rate can be 30ml/5min, or 3ml/min-4ml/min or just 3ml/min</p>",
        "id": 182973273,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575909093
    },
    {
        "content": "<p>In Group, aren't these any characteristics that act as criteria for inclusion? Are you saying that the only possible use cases have those particular data types? Duration comes to mind as a number of years of experience, for example.</p>",
        "id": 182975296,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575910321
    },
    {
        "content": "<p>It's hard to imagine that all the use cases are known, so it's pretty close to certain that that list of types is deficient.</p>",
        "id": 182975372,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575910354
    },
    {
        "content": "<p>No argument with those rates - they are all Ratios. So how do Range and SimpleQuantity work? Where is the denominator?</p>",
        "id": 182975434,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575910395
    },
    {
        "content": "<p>Group is for subjects - typically veterinary, public health and research scenarios.  \"Years of experience\" isn't something that's been identified as a criteria there.  The set of data types we use is driven by \"what are the types typically used by systems capturing inclusion/exclusion criteria for research for for public health outreach.  (Veterinary use tends to be enumerated and thus doesn't much rely on criteria.)</p>",
        "id": 182978106,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575912088
    },
    {
        "content": "<p>Right - I was forgetting that. But nevertheless, I would be very surprised to learn that just the set of data types defined now for characteristics is the definitive set. Why not just leave it open, and allow implementers to use whatever data type that represents what they find in their system? (There is a different discussion to be had about what a 'Group' really is anyway, but I'll leave that for the moment).</p>",
        "id": 182989380,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575919049
    },
    {
        "content": "<p>When we leave it open, that imposes a cost on developers.  It's saying to them \"most implementers support this, you should to\" - when that's not true.  We prefer to define the choices we have evidence are used and allow extensions and future evolution of the specification to handle new stuff/edge requirements.</p>",
        "id": 182989832,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575919341
    },
    {
        "content": "<blockquote>\n<p>Why not just leave it open, and allow implementers to use whatever data type</p>\n</blockquote>\n<p>Obviously that would be convenient for anyone writing content, or closed systems. But less convenient for someone writing parsing/processing code in an open environment, since they don't get to choose which data types to implement.</p>",
        "id": 182989847,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575919356
    },
    {
        "content": "<p>But with a standard set of Data type libraries, there's nothing special for any developer to do, as far as I can see. Just bring back the data.</p>",
        "id": 182994026,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575921894
    },
    {
        "content": "<p>sure, if you're only fetching the data, and doing nothing with it. But, you know, mostly, people expect systems to actually do something</p>",
        "id": 182995017,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575922555
    },
    {
        "content": "<p>I.e. user interfaces, database tables, appropriate indexing, conversion to and from other interfaces, etc.</p>",
        "id": 182999805,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575925466
    },
    {
        "content": "<p>I don't expect a FHIR interface to do anything for me. I expect it to get back some data to my requesting system, where the computation will be done. No-one's expecting the message layer to do anything semantic; they have analytics, reporting and applications to do all the work.</p>",
        "id": 183017589,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575939408
    },
    {
        "content": "<blockquote>\n<p>No-one's expecting the message layer to do anything semantic;</p>\n</blockquote>\n<p>You're wrong there. There are plenty of people who do. But you're just moving the deckchairs around anyway: if you get the data, you have to process it somewhere, and if you have to process it, you have to deal with what you got, somewhere, in some way</p>",
        "id": 183017686,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575939531
    },
    {
        "content": "<p>Sure, that's the business of the receiver system. But that's nothing to do with FHIR.</p>",
        "id": 183018066,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575939926
    },
    {
        "content": "<p>You're forgetting a basic fact - the receiver system / application has its own type system. FHIR is just a transport. If you wanted it to be something else, it would need a genuinely different type system (and modelling methodology).</p>",
        "id": 183045049,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575972156
    },
    {
        "content": "<p>I'd rather it focussed on just getting the messages and interactions right... and I think we have some way to go there.</p>",
        "id": 183045089,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575972188
    },
    {
        "content": "<p>For example, I think it is worth examining further your inverted list of choice[x] choices, and making more progress on special data types adapted to dealing with common combinations of alternate representations of things, as we have discussed. Just leaving those as open lists of types in my view is a case of moving deck-chairs around. Let's stack 'em up neatly instead and minimise the ad hoc approach to this whole thing. My theory is choice[x] can be gotten rid of completely.</p>",
        "id": 183049508,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575975919
    },
    {
        "content": "<p>You don't agree, but we can obtain very useful improvements in trying to at least minimise it.</p>",
        "id": 183049529,
        "sender_full_name": "Thomas Beale",
        "timestamp": 1575975948
    }
]