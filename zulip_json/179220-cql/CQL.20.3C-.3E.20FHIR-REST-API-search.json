[
    {
        "content": "<p>Hello, as there are not yet many existing CQL-engines it would be an interesting (imho) approach to translate CQL to FHIR-REST-API-searches and vice versa. Although the FHIR-search is much less expressive, a subset of all possible queries would be translatable. Has this idea already been tried somewhere ? Or what would the experts in the field of CQL and FHIR-search think of that idea ?</p>",
        "id": 154026318,
        "sender_full_name": "Georg Fette",
        "timestamp": 1545220917
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"196537\">@Georg Fette</span> , the java-based CQL engine translates retrieves to FHIR API calls, which is effectively conjunctive queries with sorting.</p>",
        "id": 154026485,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1545265004
    },
    {
        "content": "<p>The translation is pretty rough right now, there are a lot of areas that should be more driven by the profiles (rather than the hard-coded translation that happens now), but the core is there.</p>",
        "id": 154026486,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1545265073
    },
    {
        "content": "<p>And the CQL-to-ELM translator does some minimal optimization to push filters into retrieves. More could definitely be done in that area as well (like translating related retrieves into includes).</p>",
        "id": 154026487,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1545265109
    },
    {
        "content": "<p>Hi, <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span>, do you refer to the JavaScript- or the Java-engine ? In which of the code projects of the cqlframework repository is this translation located ? Or do you mean that the actual execution of CQL in the engine is performed by successive FHIR API calls, which can be seen as a translation to FHIR API calls ?</p>",
        "id": 154026610,
        "sender_full_name": "Georg Fette",
        "timestamp": 1545299965
    },
    {
        "content": "<p>In the <a href=\"https://github.com/dbcg/cql_engine\" target=\"_blank\" title=\"https://github.com/dbcg/cql_engine\">Java engine</a>, <a href=\"https://github.com/DBCG/cql_engine/tree/master/cql-engine-fhir\" target=\"_blank\" title=\"https://github.com/DBCG/cql_engine/tree/master/cql-engine-fhir\">FHIR provider</a>, but yes, it is the latter, that the actual execution of CQL in the engine is performed by FHIR API calls. To do that, it needs to translate the retrieves to FHIR API calls. To use it as a translator independent of the engine would take some refactoring, but it's a place to start.</p>",
        "id": 154026700,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1545320788
    },
    {
        "content": "<p>For the CQL Services prototype we built (which uses the coffeescript execution engine) we do a <em>very simple</em> analysis of the ELM to extract the retrieve statements and build FHIR DSTU2 queries for them (which we use to publish prefetch clauses for arbitrary CQL-backed CDS Hooks services).</p>\n<p>The result is a set of very broad queries (e.g., <code>Condition?patient={{context.patientId}}</code>).  We don't try to narrow based on value sets, time ranges, or other logic in the CQL query, although that would certainly be a nice capability to add.</p>\n<p>See: <a href=\"https://github.com/AHRQ-CDS/AHRQ-CDS-Connect-CQL-SERVICES/blob/master/lib/local-hooks.js#L73-L180\" target=\"_blank\" title=\"https://github.com/AHRQ-CDS/AHRQ-CDS-Connect-CQL-SERVICES/blob/master/lib/local-hooks.js#L73-L180\">https://github.com/AHRQ-CDS/AHRQ-CDS-Connect-CQL-SERVICES/blob/master/lib/local-hooks.js#L73-L180</a></p>",
        "id": 154026726,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1545330025
    },
    {
        "content": "<p>ah, interesting. Thank you.</p>",
        "id": 154026886,
        "sender_full_name": "Georg Fette",
        "timestamp": 1545382675
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> and <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span>  - I just read this thread from last year while trying to work develop knowledge artifacts for drug-drug interaction CDS using a CDS service, CQL, and CDS Hooks. </p>\n<p>I was wondering  the current status on the recommendations for specifying prefetch as written in <a href=\"http://hl7.org/fhir/2018May/clinicalreasoning-cds-on-fhir.html\" target=\"_blank\" title=\"http://hl7.org/fhir/2018May/clinicalreasoning-cds-on-fhir.html\">http://hl7.org/fhir/2018May/clinicalreasoning-cds-on-fhir.html</a> ? </p>\n<p>I dug through the code of the most recent releases of cqf-ruler and played with adding lists of DataRequirement to  both the PlanDefinition and Library for our CDS artifacts.  In neither case does it affect the prefetch template of the service.  Is this something that just wasn't implemented?  </p>\n<p>I did not try the AHRQ engine but from the thread, it looked like it would not do that either.</p>",
        "id": 174128158,
        "sender_full_name": "Rich Boyce",
        "timestamp": 1566813246
    },
    {
        "content": "<p>I can't speak for cqf-ruler, but regarding AHRQ CQL Services, we have not yet implemented any more sophisticated approaches to generating prefetch queries.  I'm not sure if/when we will do that.  It's not an immediate priority.</p>",
        "id": 174139684,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1566825220
    },
    {
        "content": "<p>I'm surprised by the fact that data requirements aren't surfaced for you, that is something the CQF-Ruler is doing; I believe it takes it directly from the CQL though: <a href=\"http://cds-sandbox.alphora.com/cqf-ruler/cds-services\" target=\"_blank\" title=\"http://cds-sandbox.alphora.com/cqf-ruler/cds-services\">http://cds-sandbox.alphora.com/cqf-ruler/cds-services</a></p>",
        "id": 174182136,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1566859905
    },
    {
        "content": "<p>Not from the DataRequirements in the Library (though those should be consistent).</p>",
        "id": 174182145,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1566859918
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> and <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span>  Thanks for the replies.  <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span>  A bit of clarification - I <em>do</em> see data requirements surfacing from CQL but how that happen is not what I expected. In reading <a href=\"https://cql.hl7.org/05-languagesemantics.html\" target=\"_blank\" title=\"https://cql.hl7.org/05-languagesemantics.html\">https://cql.hl7.org/05-languagesemantics.html</a> it looks like  a difficult problem was solved in determining data requirements from CQL. However, when I am writing a knowledge artifact that uses CQL + CDS Hooks,  I am finding that the design might make it harder to be explicit about the prefetch templates I want the CDS client to receive when subscribing to a hook. What I end up with is a number of pre-fetch templates that look like a combination of all of the data queries present in CQL rather than the handfull of things that we want to suggest the CDS client send in the hook. That is why I wondered if  I could explicitly specify the data requirement using the related Library or Plan Definition and maybe have that override the output of Request analysis when converted to prefetch? I am not very experienced so will be glad to be directed another direction if I am missing something. Please let me know your thoughts. Thanks!</p>",
        "id": 174495394,
        "sender_full_name": "Rich Boyce",
        "timestamp": 1567115038
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"196276\">@Rich Boyce</span> -- I'd love to solve this problem too and have thought along the same lines.  Let me suggest an example to ensure we're on the same page.  Let's say that you have CQL including something like this:</p>\n<div class=\"codehilite\"><pre><span></span>define RecentDrugTest: [Observation: &quot;Urine Drug Test&quot;] UDT\n  where UDT.issued on or after (Today() - 1 year)\n</pre></div>\n\n\n<p>(Forgive any syntax errors; I did not try to compile it).</p>\n<p>Ideally, the prefetch would be a FHIR query that filters on the code (to be a urine drug test) and the issued date (to be in the last year).  Instead, the prefetch query gets generated as a wide-open query for all the patient's Observations (and the CQL engine does the filtering afterward).  Is that about right?  (That's how the AHRQ CQL Services works anyway).</p>\n<p>Aside from the challenge of correctly translating arbitrary <code>where</code> clauses into a query, we also have the challenge that valueset-based queries on FHIR are unlikely to be supported.  You could construct a query that enumerates all the codes in the value set, but for a large value set, this might also be problematic -- as you can end up with a looooong URL.  So... the reason we haven't done it yet?  It's hard.</p>\n<p>I have also thought, however, that given this, perhaps the most feasible solution is to allow the calculated prefetch statements to be overridden via configuration.  Although there is the danger that someone will write the queries wrong, there is some good upside if someone smart (like you) writes the queries right!  In the AHRQ CQL Servics, we'd likely support this sort of thing through the CQL Hooks config file.  In Bryn's Java based implementation, I'm not sure what the best approach would be.</p>",
        "id": 174497621,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1567117254
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> - I apologize for the slow reply. I think your example is correct but I can show you a specific example that illustrates the issue. The CQL Library and PlanDefinition from here (<a href=\"https://git.rwth-aachen.de/binhphi109/pddi-cds/tree/connectathon-21-pddi/examples/pddi-cds/warfarin-nsaids-order-sign\" target=\"_blank\" title=\"https://git.rwth-aachen.de/binhphi109/pddi-cds/tree/connectathon-21-pddi/examples/pddi-cds/warfarin-nsaids-order-sign\">https://git.rwth-aachen.de/binhphi109/pddi-cds/tree/connectathon-21-pddi/examples/pddi-cds/warfarin-nsaids-order-sign</a>) are loaded into the v0.1.2-PDDI-CDS branch of cqf-ruler  (<a href=\"https://github.com/DBCG/cqf-ruler.git\" target=\"_blank\" title=\"https://github.com/DBCG/cqf-ruler.git\">https://github.com/DBCG/cqf-ruler.git</a>). Also, the vocabulary  bundle. I mention these so that you can see the resources specifically, especially the CQL (<a href=\"https://git.rwth-aachen.de/binhphi109/pddi-cds/blob/connectathon-21-pddi/examples/pddi-cds/warfarin-nsaids-order-sign/warfarin-nsaids-cds-sign-logic.cql\" target=\"_blank\" title=\"https://git.rwth-aachen.de/binhphi109/pddi-cds/blob/connectathon-21-pddi/examples/pddi-cds/warfarin-nsaids-order-sign/warfarin-nsaids-cds-sign-logic.cql\">https://git.rwth-aachen.de/binhphi109/pddi-cds/blob/connectathon-21-pddi/examples/pddi-cds/warfarin-nsaids-order-sign/warfarin-nsaids-cds-sign-logic.cql</a>). As a note, I removed all test resources provided by the cqf-ruler team so there should be no other terminology or CDS resources besides the ones for my PDDI use case. So, running a GET request for cds-services (<a href=\"http://localhost:2020/cds-services\" target=\"_blank\" title=\"http://localhost:2020/cds-services\">http://localhost:2020/cds-services</a>) returns the response in this attached JSON  <a href=\"/user_uploads/10155/v24BGNEn3BVFtT8zKMbNk8mu/cqf-ruler-response.json\" target=\"_blank\" title=\"cqf-ruler-response.json\">cqf-ruler-response.json</a> which has a  large number of non-relevant components in the prefetch template. The listing below shows what I would like and would be willing toto specify explicitly, perhaps using the PlanDefinition: </p>\n<div class=\"codehilite\"><pre><span></span>{\n  &quot;services&quot;: [\n    {\n      &quot;hook&quot;: &quot;order-sign&quot;,\n      &quot;name&quot;: &quot;PlanDefinition - Warfarin NSAIDs Recommendation Workflow&quot;,\n      &quot;title&quot;: &quot;Warfarin NSAIDs Recommendation&quot;,\n      &quot;id&quot;: &quot;warfarin-nsaids-cds-sign&quot;,\n      &quot;prefetch&quot;: {\n        &quot;item1&quot;: &quot;Patient?_id={{context.patientId}}&quot;,\n        &quot;item2&quot;: &quot;MedicationRequest?patient={{context.patientId}}&amp;authoredon=ge2019-05-27&quot;,\n        &quot;item3&quot;: &quot;MedicationAdministration?patient={{context.patientId}}&amp;effective-time=ge2019-05-27&quot;,\n        &quot;item4&quot;: &quot;MedicationDispense?patient={{context.patientId}}&amp;whenhandedover=ge2019-05-27&quot;,\n        &quot;item5&quot;: &quot;MedicationStatement?patient={{context.patientId}}&amp;effective=ge2019-05-27&quot;,\n        &quot;item6&quot;: &quot;Condition?patient={{context.patientId}}&quot;\n      }\n    },\n    {\n      &quot;hook&quot;: &quot;order-select&quot;,\n      &quot;name&quot;: &quot;PlanDefinition - Warfarin NSAIDs Recommendation Workflow&quot;,\n      &quot;title&quot;: &quot;Warfarin NSAIDs Recommendation&quot;,\n      &quot;id&quot;: &quot;warfarin-nsaids-cds-select&quot;,\n      &quot;prefetch&quot;: {\n        &quot;item1&quot;: &quot;Patient?_id={{context.patientId}}&quot;,\n        &quot;item2&quot;: &quot;MedicationRequest?patient={{context.patientId}}&amp;authoredon=ge2019-05-27&quot;,\n        &quot;item3&quot;: &quot;MedicationAdministration?patient={{context.patientId}}&amp;effective-time=ge2019-05-27&quot;,\n        &quot;item4&quot;: &quot;MedicationDispense?patient={{context.patientId}}&amp;whenhandedover=ge2019-05-27&quot;,\n        &quot;item5&quot;: &quot;MedicationStatement?patient={{context.patientId}}&amp;effective=ge2019-05-27&quot;,\n        &quot;item6&quot;: &quot;Condition?patient={{context.patientId}}&quot;\n      }\n    }\n  ]\n}\n</pre></div>",
        "id": 174905723,
        "sender_full_name": "Rich Boyce",
        "timestamp": 1567619851
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> , the idea of specifying the prefetch explicitly as a configuration is definitely a possibility, and I do think it is a shortcoming of the current data requirements approach that there is no way to distinguish between something you want to fetch initially, versus something you're okay with retrieving after the fact. If we knew the initial query, we could limit the prefetch to only the data requirements involved in that. For example, the Inclusion Criteria.</p>",
        "id": 175033141,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1567741072
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"196276\">@Rich Boyce</span> , that looks like a bug in the requirements gathering code. We'll take a look and make sure that's functional on the latest branch in the ruler.</p>",
        "id": 175033189,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1567741115
    }
]