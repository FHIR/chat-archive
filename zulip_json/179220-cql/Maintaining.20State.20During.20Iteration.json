[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span>, or anyone, is there any good way to maintain state during iteration? In my case, I'm trying to calculate a running total over a list of non-unique values. So, I want to turn something that looks kind of like:</p>\n<div class=\"codehilite\"><pre><span></span><code>L = { 1, 2, 2, 3, 4, 5 }\n</code></pre></div>\n<p>Into something that looks like:</p>\n<div class=\"codehilite\"><pre><span></span><code>T = { 1, 3, 5, 8, 12, 17 }\n</code></pre></div>\n<p>My elements are actually <code>Tuple</code>s with a date and a value, but the above example illustrates the problem.</p>\n<p>At first I tried recursion, but it seems like that isn't supported. Then I thought I could use <code>IndexOf</code>, <code>Take</code>, and <code>Sum</code>, but my elements are not unique. Is there a way to do this that I'm not thinking of? I'm using <code>cql-to-elm</code> to generate my ELM, and <code>cql-execution</code> to run it.</p>",
        "id": 234543296,
        "sender_full_name": "Pascal Brandt",
        "timestamp": 1618422294
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"193402\">@Pascal Brandt</span>!  Are you able to use the soon-to-be-published CQL 1.5 version?  If so, you might want to take a look at <a href=\"http://build.fhir.org/ig/HL7/cql/03-developersguide.html#aggregate-queries\">Aggregate Queries</a>.  If I understand what you're trying to do correctly, I think this would provide a pretty straight-forward approach.</p>\n<p>The CQL-to-ELM 1.5.2 translator supports it already and we've also added support in <code>cql-execution</code> (thanks to <span class=\"user-mention\" data-user-id=\"214452\">@Rob Dingwell</span>) -- but note that it is not yet <em>released</em> in <code>cql-execution</code>.  We can probably cut a new release of <code>cql-execution</code> soon if you think this will be helpful.</p>",
        "id": 234546128,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1618423254
    },
    {
        "content": "<p>I'm using all kinds of custom builds, so I don't think pulling in new features is going to be a problem. I'm already on <code>1.5.2</code> of <code>cql-to-elm</code>. I'm using the CQL Testing Framework for execution, but I'm on a custom build of that as well, so let me update <code>cql-execution</code> there. Any gitsha you can recommend?</p>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span>!</p>",
        "id": 234547190,
        "sender_full_name": "Pascal Brandt",
        "timestamp": 1618423638
    },
    {
        "content": "<p>I haven't tried loading the <code>cql-execution</code> package using a reference to it on GH.  Hopefully that works OK.  You can use the HEAD of master right now, which is sha <code>160b69e29a2d88e0891276986a551661772df4b5</code>.</p>",
        "id": 234553176,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1618426051
    },
    {
        "content": "<p>Just as a follow-up, everything seems to be working as expected. Here are the steps I followed in case anyone wants to do the same.</p>\n<p>First I added a <a href=\"https://classic.yarnpkg.com/en/docs/selective-version-resolutions/\">resolution</a> in my <code>package.json</code> to grab the gitsha I wanted:</p>\n<div class=\"codehilite\"><pre><span></span><code>&quot;resolutions&quot;: {\n  &quot;cql-execution&quot;: &quot;cqframework/cql-execution#160b69e&quot;\n}\n</code></pre></div>\n<p>Then, I had to add a <code>postinstall</code> script to build the (required) <code>lib</code> directory:</p>\n<div class=\"codehilite\"><pre><span></span><code>&quot;scripts&quot;: {\n  &quot;postinstall&quot;: &quot;yarn --cwd ./node_modules/cql-execution install&quot;\n}\n</code></pre></div>",
        "id": 234565836,
        "sender_full_name": "Pascal Brandt",
        "timestamp": 1618430673
    },
    {
        "content": "<p>Ah, yes.  It was that <code>postinstall</code> step that had me concerned.  Thanks for sharing.  And... let us know how the aggregate query approach works for you!</p>",
        "id": 234567534,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1618431379
    },
    {
        "content": "<p>It worked perfectly! Here's my expression:</p>\n<div class=\"codehilite\"><pre><span></span><code>define &quot;Sorted Dates With Totals&quot;:\n    (Tail(&quot;Sorted Dates With Counts&quot;)) DC\n        aggregate all DT starting ({\n            Tuple {\n                date: First(&quot;Sorted Dates With Counts&quot;).date,\n                total: First(&quot;Sorted Dates With Counts&quot;).count\n            }\n        }): flatten {\n            DT,\n            Tuple {\n                date: DC.date,\n                total: Last(DT).total + DC.count\n            }\n        }\n</code></pre></div>\n<p><code>\"Sorted Dates With Totals\"</code> is of type <code>List&lt;Tuple { date System.DateTime, count Integer }&gt;</code>. The only thing that tripped me up initially is the default to set semantics. Adding <code>all</code> made sure duplicates weren't ignored.</p>",
        "id": 234583770,
        "sender_full_name": "Pascal Brandt",
        "timestamp": 1618437741
    }
]