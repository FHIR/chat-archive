[
    {
        "content": "<p>I have a question about how type checking should be implemented in CQL.</p>\n<p>Defines and functions can appear in any order. But since they can depend on each other, I'm not sure what order they should be type checked in. For example:</p>\n<div class=\"codehilite\"><pre><span></span>define function isSmall(n Integer): lessThanOne(n)\ndefine function lessThanOne(n Integer): n &lt; 1\n</pre></div>\n\n\n<p>It seems to me that it's important to type check <code>lessThanOne</code> _first_, to figure out that it returns a boolean. (Since the return type isn't written in the program.) And then when type checking <code>isSmall</code>, you can see that <code>lessThanOne(n)</code> will return a boolean.</p>\n<p>How can you determine what order to type check functions in?</p>\n<p>And if they're recursive, like if <code>f</code> calls <code>g</code>, and <code>g</code> calls <code>f</code>, how do you deal with that? Because when functions are recursive, it seems to me that there's no good order that works.</p>",
        "id": 179942211,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1572967527
    },
    {
        "content": "<p>Is this question in the context of processing/compiling the CQL syntax directly?  If you're using the open source CQL-to-ELM translator, there is a flag you can set to have the outputted ELM include the return type for each expression.  Of course, you could also look at the CQL-to-ELM translator to see how it approaches type checking.  I think <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> implemented most of the type checking there, so he may be able to provide a high-level overview of the approach.</p>",
        "id": 179948749,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1572971199
    },
    {
        "content": "<p>It's in the context of implementing a new CQL-to-ELM translator.</p>",
        "id": 179949036,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1572971373
    },
    {
        "content": "<p>Oh, I missed this part of the spec! \"Functions can be defined that reference other functions anywhere within any library and to any degree of nesting, so long as the reference does not result in a circular reference.\" So recursion simply isn't allowed. That answers my question.</p>",
        "id": 179979427,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1572989115
    },
    {
        "content": "<p>I would think that there's valid uses for recursion in the CQL space. Certainly FHIR resources have a few structures where recursion is a natural fit...</p>",
        "id": 179979524,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572989185
    },
    {
        "content": "<p>It would make type checking difficult. In most statically typed languages, function return types are required for exactly this reason.</p>\n<p>In Haskell they're not required. But to support this, it uses type inference and unification, and you can end up with a function's return type being an ununified type variable. Adding type variables would be a pretty big addition to CQL's type system.</p>\n<p>I don't know of any easy (and sound) way to support type-checking recursive functions when their return types can be omitted.</p>",
        "id": 179980890,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1572990202
    },
    {
        "content": "<p>run time resolution....? (javascript?)</p>",
        "id": 179982240,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1572991061
    },
    {
        "content": "<p>There are valid uses for recursion, but it is currently explicitly disallowed. One approach would be to allow it generally (and require the explicit declaration of return types where recursion was used in a function declaration that prevented inference of the type). Another approach would be to introduce a recursive construct (like CTEs in T-SQL).</p>",
        "id": 180064144,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1573066031
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> That makes sense.</p>",
        "id": 180083675,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1573079793
    }
]