[
    {
        "content": "<p>Hello I am comparing the properties of CQL and Neo4J's query language Cypher and have a question related to CQL's aggregation operators:<br>\nAn aggregation operator has to be given a \"scope\" or a \"grouping key\" on which the operator performs the aggregation. In Cypher the scope is defined by all identifiers mentioned before the aggregation operator. Thus, \"MATCH (A:Person) RETURN count(A.gender)\" returns the amount of Person-instances with a given gender property, whereas \"MATCH (A:Person) RETURN A, count(A.gender)\" returns all Person-instances and in a second colunn the amount of gender properties that each Person-instance contains. Is such a aggregation grouping definition as well specified in CQL ? What should \"[Person] A return Count(A.given)\" and \"[Person] A return A, Count(A.given)\" return ?</p>",
        "id": 181630774,
        "sender_full_name": "Georg Fette",
        "timestamp": 1574423632
    },
    {
        "content": "<p>The first expression <code>[Person] A return Count(A.given)</code> would return a List of <code>Integer</code>s, with each item in the returned List corresponding to each person's number of reported given names.</p>\n<p>I don't think the second expression is valid as-is.  A return statement has to return a single item -- so you'd need to return it either as a Tuple or a List.  Here is what it might look like as a Tuple:</p>\n<div class=\"codehilite\"><pre><span></span>[Person] A return { person: A, givenCount: Count(A.given) }\n</pre></div>\n\n\n<p>The above would return a List of <code>Tuple { person Person, givenCount Integer }</code> with each Tuple corresponding to an input Patient.</p>",
        "id": 181636486,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1574428860
    },
    {
        "content": "<p>Note, however, that if we're talking about <code>FHIR</code>, then <code>A.given</code> isn't valid at all since <code>given</code> is actually on <code>Patient.name</code> (which is an array itself).  So if you want a working FHIR example, those queries would have to change a bit.</p>",
        "id": 181636721,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1574429046
    },
    {
        "content": "<p>Oh, yeah, your right. I should have written \"A.gender\" instead of \"A.given\".<br>\nBut why is \"[Person] A return Count(A.given)\" returning a list of numbers ? This assumes that the grouping is performed on each Person.<br>\nWhat does \"[Person] A return Count(A)\" return ? A list of ones ?<br>\nIs there a section in the documentation that states how to group within the aggregate operators ?</p>",
        "id": 181683886,
        "sender_full_name": "Georg Fette",
        "timestamp": 1574462133
    },
    {
        "content": "<p>ah, chapter 5.3. Query Evaluation gives me the explanation, okay.</p>",
        "id": 181684381,
        "sender_full_name": "Georg Fette",
        "timestamp": 1574462571
    },
    {
        "content": "<p>so for getting the amount of Persons the count operator has to be wrapped around the retrieve to do the trick (\"Count([Person])\") ?</p>",
        "id": 181685765,
        "sender_full_name": "Georg Fette",
        "timestamp": 1574463807
    },
    {
        "content": "<p>Yes, that's correct, the aggregate operators in CQL take a list of values; CQL doesn't have a group by shorthand like SQL does, the aggregates are \"primitive\".</p>",
        "id": 181686409,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1574464502
    }
]