[
    {
        "content": "<p>Hello,<br>\nI have some questions related to the 'return' operand in CQL:<br>\n- Is another structure other than 'Tuple' allowed to form results ? If arbitrary structures are allowed to be constructed in the return part how does the syntax of the 'constructors' of those structures look like ? On page 46 of the CQL documentation there is an example of a 'Concept' literal. But it is not clear to me how the values in the winged brackets are assigned to the members of the concept in the example. How would it look like if the returned results would be e.g. ad hoc constructed patient resources that are created by values retrieved by the query statment ?<br>\n- If 'Tuple' is used as return type, how does it look like when elements with different cardinality are used as the elements of the tuple ? Like in<br>\n [Encounter] E return Tuple { id: E.identifier, diagnosis: E.diagnosis }<br>\nDoes in this case each tuple contain a list as its second element ?<br>\n- If 'Tuple' is used as return type, is it allowed to create the tuple of elements of differnt types mentioned in the query statement ? Something like:<br>\n[Encounter] E with [Condition] C return Tuple { id: E.identifier, c: C.identifier }<br>\nDoes the list of returned tuple represent the cartesian product of all encounters and conditions that are found ? I have thought of the cartesian product because every valid encounter would have to be combined with every valid condition. It would look a bit like an unconstrained join in SQL which would as well return a cartesian product.<br>\nGreetings<br>\nGeorg</p>",
        "id": 154010162,
        "sender_full_name": "Georg Fette",
        "timestamp": 1539849788
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"196537\">@Georg Fette</span>, the short answer is yes to all of the above. CQL supports a tuple selector <code>{ id: 1, name: 'Joe' }</code> (the <code>Tuple</code> keyword is optional), but CQL also supports instance selectors using the same syntax, but with the name of the type as a prefix. So something like  <code>Encounter { id: 1, period: ... }</code>.</p>",
        "id": 154011253,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1540253223
    },
    {
        "content": "<p>And yes, the unfiltered result of a multi-source query is the Cartesian product of all the input sources.</p>",
        "id": 154011254,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1540253255
    },
    {
        "content": "<p>Exactly like an unconstrained join in SQL.</p>",
        "id": 154011255,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1540253269
    }
]