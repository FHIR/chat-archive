[
    {
        "content": "<p>Is there a way to specify an the path of an included library?  </p>\n<p>EX: I have several different measures in subdirectories and have a common library <code>MySharedStuff</code></p>\n<ul>\n<li>/Measure1/Measure1.cql</li>\n<li>/Measure2/Measure2.cql</li>\n<li>/Shared/MySharedStuff.cql</li>\n</ul>\n<p>What I want to do is have those individual measures be able to include the MySharedStuff library .</p>\n<p>The examples I've seen for includes seem to assume that all of the files are in the same directory as there's no reference to a path.</p>\n<p>Do I need to copy all shared files into each measure subdirectory or is there a way to refer to the library's path?</p>\n<p>EX: <code>include \"../Shared/MyShredStuff\" version '1' called MySharedStuff</code></p>\n<p>Any direction very much appreciated</p>",
        "id": 191781872,
        "sender_full_name": "Eric Whitley",
        "timestamp": 1585156959
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"245789\">@Eric Whitley</span> -- the CQL spec only allows for libraries to be included by their name and identifier.  It assumes that these are unique and that the implementing system has a mechanism for resolving them.  How they get resolved is considered an implementation detail not covered by the spec.  The spec itself doesn't say much about this, but there is a little blurb in the <a href=\"https://cql.hl7.org/07-physicalrepresentation.html#library-references\" title=\"https://cql.hl7.org/07-physicalrepresentation.html#library-references\">Physical Representation</a> section of the doc:</p>\n<blockquote>\n<p>The implementation environment must provide a mechanism for library references to be resolved based on their names and versions.</p>\n</blockquote>",
        "id": 191803177,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1585166305
    },
    {
        "content": "<p>The reference implementation CQL-to-ELM translator, however, does have a specific approach to library resolution -- and if I recall, that approach requires all libraries to (a) have a a file name matching the library name, and (b) be in the same folder.  <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> can confirm or deny that one, however, as he's the primary maintainer of that code.</p>",
        "id": 191803470,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1585166411
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> I really appreciate you taking the time to answer my question. That makes sense. I was trying to wrap my head around how that would be handled based on the docs. As I think about that now it actually makes way more sense. I was coming at it from the perspective of \"script A is here and script B is here\" and the resolution is in the script, but it seems like it's more like \"library A is used\" and then whatever tooling you're using is responsible for resolving where that version of the code is stored. Thanks again - I appreciate you explaining that.</p>",
        "id": 191805778,
        "sender_full_name": "Eric Whitley",
        "timestamp": 1585167581
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245789\">@Eric Whitley</span> , yes Chris is right, the translator has a default implementation that assumes current directory, but it defines a LibrarySourceProvider interface that environments are expected to provide an implementation for. In the Atom plugin, we're just using the default resolver, so we typically organize around a single CQL directory. For example, in the connectathon repository: <a href=\"https://github.com/DBCG/connectathon/tree/master/fhir3/input/pagecontent/cql\" title=\"https://github.com/DBCG/connectathon/tree/master/fhir3/input/pagecontent/cql\">https://github.com/DBCG/connectathon/tree/master/fhir3/input/pagecontent/cql</a></p>",
        "id": 191808895,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1585169286
    },
    {
        "content": "<p>Within an environment like a FHIR server plugin, we have a resolver that actually references the Library resources available in the server to resolve libraries, and that happens by the canonical URL of the library (which is constructed from the name of the library).</p>",
        "id": 191808963,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1585169335
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span>  and <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> . This is incredibly helpful. I really appreciate your responses on this. Helps me better understand how to approach thinking about this.</p>",
        "id": 191810851,
        "sender_full_name": "Eric Whitley",
        "timestamp": 1585170262
    },
    {
        "content": "<p>Is filtering in CQL hash based or loop based? In terms of the Patient Context.</p>",
        "id": 194943589,
        "sender_full_name": "Mohammad Afaq Khan",
        "timestamp": 1587567393
    },
    {
        "content": "<p>The CQL specification itself doesn't prescribe how filtering is implemented, that's up to the implementation and depends on a lot of different factors. In the Java-based engine, the patient context filtering is passed to the data access layer, either using the subject parameter of a FhIR URL, or the equivalent subject parameter in the JPA layer of a HAPI FHIR server if it's running in process.</p>",
        "id": 194970267,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1587579037
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> !</p>",
        "id": 194983584,
        "sender_full_name": "Mohammad Afaq Khan",
        "timestamp": 1587585487
    },
    {
        "content": "<p>In the CoffeeScript/JavaScript cql-execution project, filtering is loop-based.  For example, <code>[Condition: \"Diabetes\"] C where C.status.value = 'active'</code> will loop through all Conditions in the passed in bundle, checking for conditions whose code is in the \"Diabetes\" VS and whose status is active.  It's not a very efficient approach, but it does allow CQL to be executed without a database backend.</p>",
        "id": 194992248,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1587590082
    },
    {
        "content": "<p>O ok, I was curious because someone I work with was concerned about Big O. Thanks <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> !</p>",
        "id": 195005834,
        "sender_full_name": "Mohammad Afaq Khan",
        "timestamp": 1587600272
    },
    {
        "content": "<p>CHEF BRYN lol put us on a diet jk. #Chefâ€™sGotTheFHIR</p>",
        "id": 195113074,
        "sender_full_name": "Mohammad Afaq Khan",
        "timestamp": 1587672522
    }
]