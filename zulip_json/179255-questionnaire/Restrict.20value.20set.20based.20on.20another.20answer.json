[
    {
        "content": "<p>I have a questionnaire that includes questions for country and state/province.   Is there a way to restrict the listed state/provinces based on which country is selected? </p>\n<p>For country, the question is a choice from the ISO 3166-1-2 valueset (2 character country codes). For state/province, the question is a choice from the ISO 3166-2 valueset (three letter province codes prefixed by the appropriate two letter country code). This should make it easy to figure out which province codes belong to which country (all province codes XX-YYY belong to country code XX), but I can't see any way to filter a valueset in the questionnaire.</p>",
        "id": 214534927,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1603690563
    },
    {
        "content": "<p>The first question is whether the code system actually exposes the associated country code for the state code as a property.  If it does, <em>and</em> your terminology service supports is, then you can get the property to come along in your value set expansion and have access to it and use answerExpression to adaptably define your answer set based on the answer to the country question.  I don't know that our FHIR copy of 3166-2 does that though.  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> ?</p>",
        "id": 214537316,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1603693586
    },
    {
        "content": "<p>I think it should. Much better than having people resort to code syntax hacking</p>",
        "id": 214640206,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1603750578
    },
    {
        "content": "<p>I'm not sure 3166-2 does have these properties in ISO's definition. And I doubt the FHIR ValueSet does either. Using a terminology service and properties sounds like a very \"elegant\" way of solving the problem (read overly-complex), but it seems to me that simply being able to say give me codes from the specified value set that have the prefix of \"code from of previous question\" should be straight forward.</p>",
        "id": 214643393,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1603753161
    },
    {
        "content": "<p>I don't know if FHIRPath could do that, but presumably CQL could in answerExpression</p>",
        "id": 214643717,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1603753377
    },
    {
        "content": "<p>That would be excellent. Time to brush up on CQL.</p>",
        "id": 214643894,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1603753524
    },
    {
        "content": "<p>If you get it working, feel free to contribute it as an example to the SDC spec :)</p>",
        "id": 214647482,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1603756858
    },
    {
        "content": "<p>I'll take a look too. That's roughly what I was trying at the connectathon.</p>",
        "id": 214668912,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1603785046
    },
    {
        "content": "<p>Well, I'm stumped. Likely I'm just not seeing it because of my unfamiliarity with either FHIRPath or CQL, but I don't see anyway to manipulate the contents of a ValueSet/CodeSystem.</p>",
        "id": 214918394,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1603936373
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> <span class=\"user-mention\" data-user-id=\"195344\">@Paul Lynch</span></p>",
        "id": 214923517,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1603943177
    },
    {
        "content": "<p>Do you have the expansion for the ValueSet?  Then you could write an answerExpression like:<br>\n<code>%valuesetExp.expansion.contains.where(code.startsWith(%stateCode))</code><br>\nWhether that will work depends in part on how picky your form rendering engine is, because it will return \"contains\" structures rather than Codings, which is what (strictly speaking) is required by the type.  But, the essential field names in the two structures are the same (plus some extra stuff), so it might not care (as in the case of our JavaScript-based <a href=\"http://lhncbc.github.io/lforms/\">LHC-Forms</a> renderer).</p>\n<p>For future plans for a more proper way of transforming \"contains\" to \"Coding\", see <a href=\"http://jira.hl7.org/browse/FHIR-29324\">J#29324</a>.</p>",
        "id": 214958258,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1603973929
    }
]