[
    {
        "content": "<p>Pondering whether/if the <code>Q.questionnaire</code> (url)  should be on <code>item</code> so can mash multiple Qs in one QR.   The use case is Adaptive Forms where each Q is a single item(question) could still be 1:1 , but would there be any advantage to 'many' Q : 1 QR</p>",
        "id": 153974918,
        "sender_full_name": "Eric Haas",
        "timestamp": 1531402835
    },
    {
        "content": "<p>The whole definition of QuestionnaireResponse is that it's a response to a Questionnaire.  If you have a dynamic form, you still have a single \"logical\" Questionnaire that defines the scope and pattern for what questions were being asked.   There's also a form-specific Questionnaire that reflects exactly what questions were asked in what order.  The meaning for each question would come from the item.definition, not from pointing to multiple Questionnaires.  The piece we may need to add is the ability to share a Questionnaire that doesn't actually include its questions so that we can expose the metadata for a globaly dynamic form definition.  We might also need an ability to point to both the answer-specific questionnaire and to the global form.</p>",
        "id": 153974934,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1531405642
    },
    {
        "content": "<p>Right now I think a groupIdentifier like extension would work.  I not sure the client would need to be aware of the form, since all they see is series of questions.  What you end up with is essentially a flat form.  All the magic is happening behind the curtain.  If the Adaptive Q Server wants to share the form-specific questionnaire that is an implementation specific decision.</p>",
        "id": 153974953,
        "sender_full_name": "Eric Haas",
        "timestamp": 1531410277
    },
    {
        "content": "<p>A system consuming the QuestionnaireResponse would need the Questionnaire reference in order to be able to make sense of the data.  You'd also need it to query for the QuestionnnaireResponses stored on a server</p>",
        "id": 153974957,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1531410552
    },
    {
        "content": "<ul>\n<li>So Client initiates ---&gt;  Server Sends a Q1  = Intro page (item :group|display intro text|boolean to start)</li>\n<li>Client  q1:a1 = True ----&gt; Server Sends Q2 =  item:q2</li>\n<li>Client  q2:a2 = True ----&gt; Server Sends Q8 =  item:q8</li>\n<li>Client  q8:a3 = True ----&gt; Server Sends 'done: here is your score = âˆž'</li>\n</ul>\n<p>Q1..Q19  all belong to same group each with question.</p>",
        "id": 153974959,
        "sender_full_name": "Eric Haas",
        "timestamp": 1531410857
    },
    {
        "content": "<p>I agree with this <br>\n\"A system consuming the QuestionnaireResponse would need the Questionnaire reference in order to be able to make sense of the data. You'd also need it to query for the QuestionnnaireResponses stored on a server\"</p>",
        "id": 153974960,
        "sender_full_name": "Eric Haas",
        "timestamp": 1531411028
    },
    {
        "content": "<p>but if the magic is done by the server does it have to be represented in the questionnaire?  ( what if its proprietary logic)</p>",
        "id": 153974961,
        "sender_full_name": "Eric Haas",
        "timestamp": 1531411140
    },
    {
        "content": "<p>so things like enableWhen etc.  back to flatter is better  :-)  Just flatten the list to the actual questions?</p>",
        "id": 153974962,
        "sender_full_name": "Eric Haas",
        "timestamp": 1531411232
    },
    {
        "content": "<p>mmmm  I'm thinking the client will need to construct on the fly a new QR with a new contained Q.....</p>",
        "id": 153974963,
        "sender_full_name": "Eric Haas",
        "timestamp": 1531411322
    },
    {
        "content": "<p>... thats the ticket for now...!</p>",
        "id": 153974964,
        "sender_full_name": "Eric Haas",
        "timestamp": 1531411351
    },
    {
        "content": "<p>Agree with the contained Q approach.  The trick is how you query to find the QRs that all have \"custom\" embedded Qs that are all based on a shared \"non-exposed\" Q.  The shared Q wouldn't necessarily expose the questions or the logic, but would be relevant for search purposes.  The \"custom\" Qs would have the link to the data elements that provide the semantics and would show what answer choices the user was actually given</p>",
        "id": 153974965,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1531412042
    }
]