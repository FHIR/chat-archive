[
    {
        "content": "<p><a href=\"http://build.fhir.org/ig/HL7/sdc\" target=\"_blank\" title=\"http://build.fhir.org/ig/HL7/sdc\">http://build.fhir.org/ig/HL7/sdc</a> gives me an odd directory listing, and other links are 404s.</p>",
        "id": 185144007,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1578509446
    },
    {
        "content": "<p>The CI build is unhappy right now.  Hopefully fixed tomorrow once Grahame is back in action</p>",
        "id": 185145765,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1578510475
    },
    {
        "content": "<p>Ideally, if the build breaks, it would not deploy to the public version of the site that people are using.</p>",
        "id": 185145876,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1578510550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> Is that something that's possible to do?  Retain the old copy if the CI build fails?</p>",
        "id": 185146010,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1578510628
    },
    {
        "content": "<p>Sure -- though I'd definitely appreciate help making that change (it's not trivial, because the service receiving build content doesn't currently <em>understand</em> the content, and the service generating build content doesn't have access to previous build results).</p>",
        "id": 185152985,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1578515044
    },
    {
        "content": "<p>In general the preferred workflow would be to make changes in branches and merge them when they're not broken.</p>",
        "id": 185153021,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1578515069
    },
    {
        "content": "<p>In other words, keeping <code>master</code> healthy prevents broken CI content.</p>",
        "id": 185153046,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1578515091
    },
    {
        "content": "<p>that's not so useful when the problem is that the infrastructure collapges</p>",
        "id": 185559804,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1578969143
    },
    {
        "content": "<p>Hmm, like if the infrastructure breaks between testing changes in a branch and merging them into master?</p>",
        "id": 185563980,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1578975212
    },
    {
        "content": "<p>Anyway, maybe we can have a canonical place where the filed build logs go, like a subdirectory of the successful build output?</p>",
        "id": 185564022,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1578975276
    },
    {
        "content": "<p>which logs?</p>",
        "id": 185564097,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1578975442
    },
    {
        "content": "<p>Build error log, and any of other output that you'd want to post in the case of a failure</p>",
        "id": 185599216,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1579011348
    },
    {
        "content": "<p>so if the build fails completely, put some kind of error log in place instead?</p>",
        "id": 185628365,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1579028796
    },
    {
        "content": "<p>so if the build fails completely, put some kind of error log in place instead?</p>",
        "id": 185628379,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1579028815
    },
    {
        "content": "<p>so if the build fails completely, put some kind of error log in place instead?</p>",
        "id": 185628424,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1579028852
    },
    {
        "content": "<p>Why not reverse the merge commit on master if the build fails, to get back to the previous working version?</p>",
        "id": 185628615,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1579028981
    },
    {
        "content": "<p>Do you mean automatically? This could cause some troubling / unstable behavior, and it's probably not desirable if it's a build infrastructure problem (rather than a content problem) that caused the failure -- because in that case, rolling back the commit wouldn't actually fix the build.</p>",
        "id": 185628821,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1579029092
    },
    {
        "content": "<p>If the build fails (completely or otherwise), the question is: what's the desired behavior. Right now we upload the complete (failed) build context, including output, logs, and source materials -- and replace any published content with this. I was thinking a better step might be to take this whole package and upload it to a <em>subdirectory</em> of any previous successful build (if there is any). Basically this would mean:</p>\n<ul>\n<li>At any time at most one successful build output would be published (for a given branch)</li>\n<li>Any any time, at most one failed build output would be published</li>\n<li>At any given time, there could be a (most recent) success output <em>and</em> a (most recent) failure output, both published</li>\n</ul>",
        "id": 185629098,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1579029244
    },
    {
        "content": "<p>If this sounds like the right outcome, we can work towards that. It's not entirely trivial, but should be doable. I'd love help if anybody is interested in rolling up their sleeves on the build infrastructure.</p>",
        "id": 185629164,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1579029295
    },
    {
        "content": "<p>what should happen if there's never been a successful build? that's an important case because it's the onramp step</p>",
        "id": 185629584,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1579029530
    },
    {
        "content": "<p>The other thing to say is that pretty much all I could aim to do in case of a total failure is to get the console log output dumped, but the host that runs the IG Publisher is in a better place to do that already</p>",
        "id": 185629685,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1579029601
    },
    {
        "content": "<p>Why upload anything if the build fails?  Is there no place to see the errors other than the public website?  (As you can tell, I am not familiar with the build infrastructure.)  I would think the process would look like:</p>\n<p>1) Generate the new version of the web pages on a staging server<br>\n2) Confirm that the new version is good (no build failure; selected pages look okay)<br>\n3) Copy the pages from staging to production<br>\n4) Move the old version on production to a \".bak\" directory<br>\n5) Move the new version into place</p>\n<p>But, I am sure there other considerations of which I am not aware.</p>",
        "id": 185630808,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1579030159
    },
    {
        "content": "<p>this is a most useful page: <a href=\"https://fhir.github.io/auto-ig-builder/builds.html\" target=\"_blank\" title=\"https://fhir.github.io/auto-ig-builder/builds.html\">https://fhir.github.io/auto-ig-builder/builds.html</a></p>",
        "id": 185631181,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1579030354
    },
    {
        "content": "<p>If there has never been a successful build, then there's zero successful build hosted, and zero or one failure.</p>",
        "id": 185632297,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1579031016
    },
    {
        "content": "<p>I'm thinking that in terms of file layout on our web server we'd have something like</p>\n<div class=\"codehilite\"><pre><span></span>example-ig/\n├── failure\n│   ├── errors.log\n│   ├── ig.json\n│   └── output\n│   └── other-source-files\n├── index.html\n├── success-file-1\n└── success-file-2\n</pre></div>",
        "id": 185632470,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1579031108
    },
    {
        "content": "<p>So if you just navigate to the URL for the IG, you'd see the successful build; if you navigate to <code>/failure</code>, you'd get failure details (if any).</p>",
        "id": 185632514,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1579031135
    },
    {
        "content": "<p>The \"only publish good builds\" approach you described in step (2) above <span class=\"user-mention\" data-user-id=\"195344\">@Paul Lynch</span> doesn't explain how failure logs get published.</p>",
        "id": 185632617,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1579031183
    },
    {
        "content": "<p>I was thinking that the failure logs would be viewable on the \"staging server\".  But, I was also thinking that everything was published at once, which I see by Grahame's link that that is not the case, so things are more complex than I was thinking.</p>",
        "id": 185632933,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1579031368
    }
]