[
    {
        "content": "<p>So I'm tracking what maybe a bug inside of SearchNarrowingInterceptor. Correct me if I'm wrong or have overlooked something.</p>\n<p>As behavior goes, a call to a @Search endpoint hits SearchNarrowingInterceptor before the AuthorizationInterceptor. There, an AuthorizedList is assembled of compartments. Like... </p>\n<div class=\"codehilite\"><pre><span></span><code>            for (IdType patientId : patientIds) {\n                cascadingList.addCompartment(patientId.getValue());\n            }\n</code></pre></div>\n\n\n<p>This appends a fresh parameter onto the request, like <a href=\"http://X/fhir/ExplanationOfBenefit\">http://X/fhir/ExplanationOfBenefit</a> would suddenly become <a href=\"http://X/fhir/ExplanationOfBenefit?patient=Patient/998,Patient/999\">http://X/fhir/ExplanationOfBenefit?patient=Patient/998,Patient/999</a>, just as the documentation says.</p>\n<p>Thereafter, the thread visits AuthorizationInterceptor. There I couldn't get...</p>\n<div class=\"codehilite\"><pre><span></span><code>           .allow().read().resourcesOfType(ExplanationOfBenefits.class).inCompartment(&quot;Patient&quot;, patientIds);\n</code></pre></div>\n\n\n<p>...to work. Basically, the request was stopped before the search was executed. Based on input from <span class=\"user-mention\" data-user-id=\"191427\">@Jens Villadsen</span>, I've set up my own IAuthRuleTester.matchesOutput() to use a custom IAuthRuleTester to verify post-search compartmental values of the outgoing resources. </p>\n<div class=\"codehilite\"><pre><span></span><code>           .allow().read().resourcesOfType(ExplanationOfBenefit.class).withAnyId().withTester(myTester);\n</code></pre></div>\n\n\n<p>That approach works great but this struck me as weird, and I did further digging. All along, I've been sending multiple compartmental parameters as a list, either in my manual request or from what the SearchNarrowingInterceptor provides, ie patient=Patient/998,Patient/999. When I tried the approach with just a <em>single</em> value, it works just fine using the \".inCompartment\" approach. So it seems something about giving a list of compartment values to SearchNarrowingInterceptor doesn't get past the \".inCompartment\" rule?</p>\n<p>P.S., the Provider endpoint is setup to accept multiple values for the compartmental value:</p>\n<div class=\"codehilite\"><pre><span></span><code>    @Search\n    public Bundle searchExplanationOfBenefitBySearchParameters(\n        @OptionalParam(name=ExplanationOfBenefit.SP_PATIENT) StringAndListParam patientParam,\n</code></pre></div>",
        "id": 212242635,
        "sender_full_name": "James Fadeley",
        "timestamp": 1601847048
    },
    {
        "content": "<p>After some discussion and reading with colleagues, it maybe a situation where HAPI can return multiple patients but that's against FHIR specifications?</p>",
        "id": 212331812,
        "sender_full_name": "James Fadeley",
        "timestamp": 1601919334
    },
    {
        "content": "<p>Nop - that is entirely legal</p>",
        "id": 212333319,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1601920100
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"348029\">@James Fadeley</span> I would suspect that you should build up the chain with allow() .... inCompartment(\"Patient\", patientId).andThen() for each patientID in the list</p>",
        "id": 212418486,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1601986632
    },
    {
        "content": "<p>There's nothing in the spec that stops you from returning multiple patients AFAIK</p>",
        "id": 212418525,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1601986660
    },
    {
        "content": "<p>There's nothing against that from a pure FHIR perspective. You may wish to apply some access control rules to filter the result set, but what filters to apply, and when to apply them, depends on a specific context.</p>",
        "id": 212425871,
        "sender_full_name": "René Spronk",
        "timestamp": 1601990361
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191427\">Jens Villadsen</span> <a href=\"#narrow/stream/179167-hapi/topic/Unusual.20SearchNarrowingInterceptor.20behavior.2E/near/212418486\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"348029\">James Fadeley</span> I would suspect that you should build up the chain with allow() .... inCompartment(\"Patient\", patientId).andThen() for each patientID in the list</p>\n</blockquote>\n<p>Hmmm. I was trying to use the collection method with<br>\n<code>Collection &lt;IdType&gt; patientIds = new ArrayList&lt;IdType&gt;();</code><br>\n...and then spooling through, adding each IdType and giving that to the inCompartment chain. It didn't seem to allow the search through when I thought it should. I could try individuals, but shouldn't the Collection approach work?</p>",
        "id": 212429416,
        "sender_full_name": "James Fadeley",
        "timestamp": 1601991948
    },
    {
        "content": "<p>I ask because the length of the IdTypes list will vary. So either adding a collection or looping through the list is what I'll need.</p>",
        "id": 212432027,
        "sender_full_name": "James Fadeley",
        "timestamp": 1601993082
    },
    {
        "content": "<p>hmmm ... had forgotten that inCompartnent can take a list - so both approaches should be valid</p>",
        "id": 212435112,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1601994336
    },
    {
        "content": "<p>maybe <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> can weigh in on this</p>",
        "id": 212435160,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1601994362
    },
    {
        "content": "<p>Any updates on this?</p>",
        "id": 214632594,
        "sender_full_name": "James Fadeley",
        "timestamp": 1603746101
    },
    {
        "content": "<p>To explain a TL;DR, I think the Search Narrowing providing a list of Patient ids, (id patient=Patient/100,Patient/101) is getting stopped by InCompartment in Authorization Interceptor because it thinks there's no match.</p>",
        "id": 214635344,
        "sender_full_name": "James Fadeley",
        "timestamp": 1603747585
    },
    {
        "content": "<p>Ummm, any news? Luck?</p>",
        "id": 222341701,
        "sender_full_name": "James Fadeley",
        "timestamp": 1610391641
    },
    {
        "content": "<p>I have implemented the SearchNarrowingInterceptor,  AuthorizationInterceptor &amp; ConsentInterceptor in my project as per the limited documentation available.</p>\n<p>In the SearchNarrowingInterceptor, I am creating an AuthorizedList with one compartment for the patient that is sending the request to limit his access to records related to his patient Id only. So when I search for any other patient ID he gets an access denied message.</p>\n<p>In the scenario when I am logged in as Patient 0987654321 and try to search for a Patient 1234567890 using the below URL:</p>\n<p><a href=\"http://baseurl/Patient?_id=1234567890\">http://baseurl/Patient?_id=1234567890</a></p>\n<p>the SearchNarrowingInterceptor in the background is adding both patient IDs to the values Array of the _id param and since this is not acceptable I am getting the below error message </p>\n<p>HTTP 400 Bad Request</p>\n<p>Response Body</p>\n<p>{</p>\n<p>\"resourceType\": \"OperationOutcome\",</p>\n<p>\"issue\": [ {</p>\n<p>\"severity\": \"error\",</p>\n<p>\"code\": \"processing\",</p>\n<p>\"diagnostics\": \"Multiple values detected for non-repeatable parameter '_id'. This server is not configured to allow multiple (AND/OR) values for this param.\"</p>\n<p>} ]</p>\n<p>}</p>\n<p>How can I restrict the _id values to the one in the search request only, or is this a bug?</p>",
        "id": 250719222,
        "sender_full_name": "Victor Saad",
        "timestamp": 1629951928
    }
]