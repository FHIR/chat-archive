[
    {
        "content": "<p>(Related question to my previous one) If I'm writing a resource provider, is it possible to set an ETag on the response I'm providing to a search? Or an operation? And if so, how do I do that?</p>",
        "id": 153870957,
        "sender_full_name": "Jim Steel",
        "timestamp": 1486694448
    },
    {
        "content": "<p>The server should automatically set the ETag based on the resource version being returned from a read/vread, but I believe it doesn't set it otherwise.</p>",
        "id": 153871101,
        "sender_full_name": "James Agnew",
        "timestamp": 1486847055
    },
    {
        "content": "<p>Yeah, I'm implementing a server and hoping to set my own ETags (so I can then respect them if they come back in If-None-Match), to support caching</p>",
        "id": 153871158,
        "sender_full_name": "Jim Steel",
        "timestamp": 1486941411
    },
    {
        "content": "<p>not the difference between weak and strong etags. FHIR Etags are *nearly* strong etags, but not actually strong. W3C might have redefined strong etags based on our comments, but it's too late now</p>",
        "id": 153871166,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1486961215
    },
    {
        "content": "<p>Hmm, interesting..</p>\n<p>I'd assume you could achieve this by having your RP methods include parameters of type <code>HttpServletRequest</code> and <code>HttpServletResponse</code>. If you wanted to return a 304 on an arbitrary method, you could create a new exception that extends <code>BaseServerResponseException</code> with a code of 304 and throw that.</p>\n<p>I believe this should all work, although I have admittedly not tried it.</p>",
        "id": 153871268,
        "sender_full_name": "James Agnew",
        "timestamp": 1487019679
    },
    {
        "content": "<p>304 on an arbitrary operation is easy. I just throw a ca.uhn.fhir.rest.server.exceptions.NotModifiedException</p>",
        "id": 153871481,
        "sender_full_name": "Jim Steel",
        "timestamp": 1487115696
    },
    {
        "content": "<p>Ah right, I forgot that already existed. :)</p>\n<p>So although I haven't seen anyone do it before, what you're doing certainly sounds sensible.. and seems like it should be possible without needing changes to the library.</p>",
        "id": 153871497,
        "sender_full_name": "James Agnew",
        "timestamp": 1487123197
    },
    {
        "content": "<p>Yeah, I seem to be getting what I need by including request/response as parameters in my RP methods. I'm not sure if the ETags generated for non-reads are things we want to include in the spec. They vary between simple (e.g. for $lookup I'm just using versions of resources, like reads), and not so simple (e.g. $expand or $validate-code)</p>",
        "id": 153871508,
        "sender_full_name": "Jim Steel",
        "timestamp": 1487125598
    },
    {
        "content": "<p>There is a requirement on 304 responses, though, that it should return all the cache-related headers (ETag, Content-Location, Expires, Cache-Control, Vary), that a non-304 response would have returned. I have a vague suspicion that some of these may not be coming through, but when I get to that, if I find any issues I'll flag them on GitHub.</p>",
        "id": 153871513,
        "sender_full_name": "Jim Steel",
        "timestamp": 1487125811
    }
]