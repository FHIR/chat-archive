[
    {
        "content": "<p>I'm writing a tool that takes mappings I put in the the mapping column for a profile, and turns the resulting profile into a transformer that generates a FHIR Resource from the mapped source material.  One of the challenges I'm having is all the vagaries of how the RI works.</p>",
        "id": 153832266,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465533430
    },
    {
        "content": "<p>When a field is polymorphic in the RI, it has a setFieldname() signature.  When a field is typed, there is a setFieldnameType() signature.  I would expect for polymorphic fields to see setFieldname(Type x) to work as specified, and setFieldnameSpecifictype(SpecificType x) to also exist.  It's frustrating that it doesn't because it means I have to put conditions in to check for polymorphism IN the base class, which model I really didn't want to have to read if I could skip it.</p>",
        "id": 153832267,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465533624
    },
    {
        "content": "<p>Oh, I'm working with DSTU2 BTW, not DSTU3.</p>",
        "id": 153832268,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465533657
    },
    {
        "content": "<p>Another challenge is dealing with the enumeration types when the base type is code.  I understand why this was done, but the problem is that I have no consistent way to figure out whether the enumeration is defined WITHIN the resource or separately (e.g., compare AdministrativeGender with ObservationStatus, nor when I have to be sure that the enumeration is used rather than the codeType.  What I really want is a setXElement(CodeType t) method for these fields that is permitted to thrown an exception is CodeType is not a legal value.</p>",
        "id": 153832269,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465534443
    },
    {
        "content": "<p>there's no need to clutter up the interface with setFooType methods, since they all do the same thing</p>",
        "id": 153832270,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465537379
    },
    {
        "content": "<p>and clutter is the relevant word</p>",
        "id": 153832271,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465537387
    },
    {
        "content": "<p>you can easily check the polymorphism by looking at the base path</p>",
        "id": 153832272,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465537416
    },
    {
        "content": "<p>I know that's not as easy as ignoring it, but it shouldn't be hard</p>",
        "id": 153832273,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465537427
    },
    {
        "content": "<p>I could live with that one by simply extending the types and adding the polymorphic methods myself too, so I can live with that either way.</p>",
        "id": 153832274,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465537660
    },
    {
        "content": "<p>However, the problem with code is truly challenging.  How in the heck do I figure out where the enumeration is defined or if it is even used.  The RI apparently has some rules about when those are used and when they are not, but I cannot figure them out.  </p>",
        "id": 153832275,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465537737
    },
    {
        "content": "<p>well, if the code has a required value set binding, then it will get an enumeration </p>",
        "id": 153832276,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465537811
    },
    {
        "content": "<p>Nope.</p>",
        "id": 153832277,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465537819
    },
    {
        "content": "<p>if the required value set binding is shared across more than one place, it will be in Enumerations, else it will be in the resource</p>",
        "id": 153832278,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465537842
    },
    {
        "content": "<p>I thought that was the case, but apparently it is not as far as I can tell.</p>",
        "id": 153832279,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465537848
    },
    {
        "content": "<p>it should be the case</p>",
        "id": 153832280,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465537863
    },
    {
        "content": "<p>I'll dig up my example for that one.</p>",
        "id": 153832281,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465537864
    },
    {
        "content": "<p>On the Enumerations case, the information about whether the value-set is used in more than one place is NOT included in the structure definition for the value set.  I have to read the whole freakin FHIR model to figure that out.</p>",
        "id": 153832282,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465537914
    },
    {
        "content": "<p>yes, that's not very friendly. I'm thinking about that</p>",
        "id": 153832283,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465537948
    },
    {
        "content": "<p>I could maybe parse the HTML page but that's a hack.  I might have to resort to it.</p>",
        "id": 153832284,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465537954
    },
    {
        "content": "<p>in other languages, I can alias these things, but it's not so easy in java</p>",
        "id": 153832285,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465537967
    },
    {
        "content": "<p>parse html? why do that? </p>",
        "id": 153832286,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465537979
    },
    {
        "content": "<p>To get to the \"is it used in more than one place\" data.</p>",
        "id": 153832287,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538102
    },
    {
        "content": "<p>Only place I see it in the output.</p>",
        "id": 153832288,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538113
    },
    {
        "content": "<p>Althought arguably, the build could add that data to the .json and .xml defs as an extension.</p>",
        "id": 153832289,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538143
    },
    {
        "content": "<p>I could. no one has asked for it before </p>",
        "id": 153832290,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465538162
    },
    {
        "content": "<p>it sounds more like something that belongs in the java space though, since it's specific to the Java RI</p>",
        "id": 153832291,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465538221
    },
    {
        "content": "<p>On the aliasing, you COULD provide Patient.AdministrativeGender class that supported the fromCode() method.</p>",
        "id": 153832292,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538232
    },
    {
        "content": "<p>Not really.  </p>",
        "id": 153832293,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538237
    },
    {
        "content": "<p>if I provide a Patient.AdministrativeGender, I'd break lots of code because I'm not providing a common class for the common usages </p>",
        "id": 153832294,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465538306
    },
    {
        "content": "<p>I'm reading the .json to generate Java code.  I DON'T want to have to read the Java RI model.  I want some simple rules to go from the structureDef's to the Java.  Or I want the rules that do exist to be documented somewhere.</p>",
        "id": 153832295,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538316
    },
    {
        "content": "<p>Huh?</p>",
        "id": 153832296,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538324
    },
    {
        "content": "<p>that doesn't change the fact that this is specific to the Java RI</p>",
        "id": 153832297,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465538357
    },
    {
        "content": "<p>there is a solution, actually, which is to generate getFooCode / setFooCode for enumerations, as well as the 2 existing pairs of accessors </p>",
        "id": 153832298,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465538384
    },
    {
        "content": "<p>Yes, which was what I asked for above, but called it setFooElement instead.  That would work.</p>",
        "id": 153832299,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538483
    },
    {
        "content": "<p>but that already exists</p>",
        "id": 153832300,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465538544
    },
    {
        "content": "<p>ah but not with the type you want </p>",
        "id": 153832301,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465538553
    },
    {
        "content": "<p>Right.</p>",
        "id": 153832302,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538583
    },
    {
        "content": "<p>I'd be fine with setFooCode, because the name difference also deals with the behavioral difference.  One throws an exception, the other does not.</p>",
        "id": 153832303,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538628
    },
    {
        "content": "<p>Do other RI's locally define the enumeration unless it is shared?</p>",
        "id": 153832304,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465538695
    },
    {
        "content": "<p>I'll start by putting it in the DSTU3 version for non-repeating enumerations. </p>",
        "id": 153832305,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465538724
    },
    {
        "content": "<p>other RIs work very differently depending on the language</p>",
        "id": 153832306,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465538742
    },
    {
        "content": "<p>The dotnet client implementation also generates the enumerations using the same rules.<br>\nAnd yes, I do parse the entire XML (profile-datatypes and profile-resource) to determine if it is used elsehwere (simple XSLT usage) to work out where to put the enumeration class.</p>",
        "id": 153832307,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1465538843
    },
    {
        "content": "<p>Immunization.setStatus(String), Immunization.setStatusElement(CodeType)</p>",
        "id": 153832308,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465539043
    },
    {
        "content": "<p>doesn't follow the \"required\" rule.</p>",
        "id": 153832309,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465539059
    },
    {
        "content": "<p>Brian, I'm parsing 2-3 files now.  I don't really want to have to parse everything.  It's already taking me an hour just to build my profiles.  If I had to read everything to understand the RI model, it would be a lot more complicated.</p>",
        "id": 153832310,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465539174
    },
    {
        "content": "<p>Brian is referring to building the RI</p>",
        "id": 153832311,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465539213
    },
    {
        "content": "<p>Given that valueset-*.html has the data about where a value set is used, it's pretty clear that valueset-*.json could have an extension that said \"used in multiple places\".</p>",
        "id": 153832312,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465539347
    },
    {
        "content": "<p>(yes, for the dotnet RI)</p>",
        "id": 153832313,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1465539356
    },
    {
        "content": "<p>FYI, the dotnet RI is completely generated from 4 files (profiles-resources.xml, profiles-types.xml, search-parameters.xml and expansions.xml)</p>",
        "id": 153832315,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1465539490
    },
    {
        "content": "<p>but you don't need that if I generate the setFooCoode methods...?</p>",
        "id": 153832316,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465539546
    },
    {
        "content": "<p>I'm not getting how these <code>getFooCode()</code> methods would help. The existing methods follow the same pattern as all the other primitive fields:</p>\n<ul>\n<li><code>getFoo()</code> returns the native type (an Enum, a Date, a String, etc..)</li>\n<li><code>getFooElement()</code> returns the FHIR type (Enumeration, DateType, etc)</li>\n</ul>\n<p>On the DSTU2 structures there is the matter of the signatures being a bit less predictable with when they throw exceptions, as Kieth points out, but that's already resolved in the DSTU3 ones. Is this just a DSTU2 issue?</p>",
        "id": 153832351,
        "sender_full_name": "James Agnew",
        "timestamp": 1465553591
    },
    {
        "content": "<p>Of course I'm using <code>Patient.gender</code> as my reference point. Is there another field where the problem is more apparent?</p>",
        "id": 153832352,
        "sender_full_name": "James Agnew",
        "timestamp": 1465553633
    },
    {
        "content": "<p>the AsCode() methods always return a string. The existing native codes return either a code or an enumeration, and the namespece of the enumeration is uncertain. </p>",
        "id": 153832353,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465553706
    },
    {
        "content": "<p>exposing the string code directly makes sense to me</p>",
        "id": 153832354,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465553720
    },
    {
        "content": "<p>So the issue is wanting a predictable way of getting the string value of the code?</p>\n<p>Wouldn't <code>getFooElement().getValueAsString()</code> accomplish this?</p>",
        "id": 153832355,
        "sender_full_name": "James Agnew",
        "timestamp": 1465553789
    },
    {
        "content": "<p>what does it return if there's no foo? </p>",
        "id": 153832356,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465553827
    },
    {
        "content": "<p>null</p>",
        "id": 153832357,
        "sender_full_name": "James Agnew",
        "timestamp": 1465553839
    },
    {
        "content": "<p>(Not a NPE though, just returns null)</p>",
        "id": 153832358,
        "sender_full_name": "James Agnew",
        "timestamp": 1465553856
    },
    {
        "content": "<p>and how does the set work? set null to make foo go away? </p>",
        "id": 153832359,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465553870
    },
    {
        "content": "<p><code>getFooElement().setValueAsString(null);</code> would accomplish that</p>",
        "id": 153832360,
        "sender_full_name": "James Agnew",
        "timestamp": 1465553890
    },
    {
        "content": "<p>so........ I think that works for Keith. I should have thought of that</p>",
        "id": 153832361,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1465553923
    },
    {
        "content": "<p>Right, but that's only going to work for DSTU3... and I have DSTU2 to consider as well.</p>",
        "id": 153832398,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465585754
    },
    {
        "content": "<p>Hunh, that looks look it might work.</p>",
        "id": 153832399,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465586119
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> Thanks!  That solved it for me.</p>",
        "id": 153832412,
        "sender_full_name": "Keith Boone",
        "timestamp": 1465591694
    }
]