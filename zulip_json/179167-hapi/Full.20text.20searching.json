[
    {
        "content": "<p>Has anyone had experience using HAPI for lucene full text searching? I've got an autocomplete I'm using to look up Medication resources using a 'prefix, any order' approach. We're using fhir-jpa-server-base:3.2.0 with Hibernate Search, backed by MySQL. Achieving 'prefix, any order' was a bit of a challenge and very ugly. I'm just wondering whether there's a better way.</p>\n<p><strong>Request:</strong> <code>http://localhost:8080/my-app/Medication?_content=blister%20onda&amp;_profile=https://www.healthterminologies.gov.au/StructureDefinition/MyMedication</code></p>\n<p><strong>Problem:</strong><br>\nTrying to do a full text search, using _content, used the \"myContentText\" field, within the index, and not \"myContentTextEdgeNgram\". I did note that it looks as if the author originally intended to search this field as it is commented out on line 86 of FulltextSearchSvcImpl.java. As a result the search would only return matches on whole words, not prefix.</p>\n<p>Additionally, the search results did not appear to be in relevance order. For my autocomplete I just wanted to show the first page of results and not bother with paging through the remaining. However, since relevance ordering is not honored I'd never get back the results I'd expect. The cause of this is that IFulltextSearchSvc.search() returns the set of matching resource ids, in relevance order... but the SearchBuilder.java then uses that set in an IN SQL query, which does not honor the order of provided ids.</p>\n<p><strong>Solution 1 - Prefix searching:</strong><br>\nTo achieve this I created my own implementation of IFulltextSearchSvc.java which extends FulltextSearchSvcImpl.java and then just override FulltextSearchSvcImpl.search() and FulltextSearchSvcImpl.addTextSearch(). To configure my new implementation I included the following in my application configuration:</p>\n<div class=\"codehilite\"><pre><span></span>@Configuration\n@EnableTransactionManagement()\npublic class MyServerConfig extends BaseJavaConfigDstu3 {\n    @Bean(autowire = Autowire.BY_TYPE)\n    public IFulltextSearchSvc searchDaoDstu3() {\n        return new MyFulltextSearchSvc();\n    }\n}\n</pre></div>\n\n\n<p>I then attempted to simply uncomment the field definition for \"myContentTextEdgeNgram\". This did make lucene query the desired field. However, the query was too complex and overboosting the first term in the provided search text. To achieve a reasonable result I rewrote the query with just lucene, and not the hibernate querybuilder. The resulting lucene query is below (for the search text \"blister onda\").</p>\n<p><em>Hibernate search query builder (ranked my expected result of 'ZOFRAN ondansetron ... blister pack' wayyyyyy down the result set):</em><br>\n<code>+(myContentText:\"blister onda\"~2^4.0 ((myContentTextEdgeNGram:bli myContentTextEdgeNGram:blis myContentTextEdgeNGram:blist myContentTextEdgeNGram:bliste myContentTextEdgeNGram:blister myContentTextEdgeNGram:blister  myContentTextEdgeNGram:blister o myContentTextEdgeNGram:blister on myContentTextEdgeNGram:blister ond myContentTextEdgeNGram:blister onda)^2.0)) +myResourceType:medication</code></p>\n<p><em>Lucene query (ranked my expected result of 'ZOFRAN ondansetron ... blister pack' at the top of the result set):</em><br>\n<code>+(myContentTextEdgeNGram:blister myContentTextEdgeNGram:onda) +myResourceType:medication</code></p>\n<p><strong>BEFORE:</strong></p>\n<div class=\"codehilite\"><pre><span></span>    private void addTextSearch(QueryBuilder theQueryBuilder, BooleanJunction&lt;?&gt; theBoolean, List&lt;List&lt;? extends IQueryParameterType&gt;&gt; theTerms, String theFieldName, String theFieldNameEdgeNGram, String theFieldNameNGram) {\n        if (theTerms == null) {\n            return;\n        }\n        for (List&lt;? extends IQueryParameterType&gt; nextAnd : theTerms) {\n            Set&lt;String&gt; terms = new HashSet&lt;String&gt;();\n            for (IQueryParameterType nextOr : nextAnd) {\n                StringParam nextOrString = (StringParam) nextOr;\n                String nextValueTrimmed = StringUtils.defaultString(nextOrString.getValue()).trim();\n                if (isNotBlank(nextValueTrimmed)) {\n                    terms.add(nextValueTrimmed);\n                }\n            }\n            if (terms.isEmpty() == false) {\n                if (terms.size() == 1) {\n                    //@formatter:off\n                    Query textQuery = theQueryBuilder\n                        .phrase()\n                        .withSlop(2)\n                        .onField(theFieldName).boostedTo(4.0f)\n//                      .andField(theFieldNameEdgeNGram).boostedTo(2.0f)\n//                      .andField(theFieldNameNGram).boostedTo(1.0f)\n                        .sentence(terms.iterator().next().toLowerCase()).createQuery();\n                    //@formatter:on\n\n                    theBoolean.must(textQuery);\n                } else {\n                    String joinedTerms = StringUtils.join(terms, &#39; &#39;);\n                    theBoolean.must(theQueryBuilder.keyword().onField(theFieldName).matching(joinedTerms).createQuery());\n                }\n            }\n        }\n    }\n</pre></div>\n\n\n<p><strong>AFTER:</strong></p>\n<div class=\"codehilite\"><pre><span></span>    private void addTextSearch(QueryBuilder theQueryBuilder, BooleanJunction&lt;?&gt; theBoolean, List&lt;List&lt;? extends IQueryParameterType&gt;&gt; theTerms, String theFieldName, String theFieldNameEdgeNGram, String theFieldNameNGram) {\n        if (theTerms == null) {\n            return;\n        }\n        for (List&lt;? extends IQueryParameterType&gt; nextAnd : theTerms) {\n            Set&lt;String&gt; terms = new HashSet&lt;String&gt;();\n            for (IQueryParameterType nextOr : nextAnd) {\n                StringParam nextOrString = (StringParam) nextOr;\n                String nextValueTrimmed = StringUtils.defaultString(nextOrString.getValue()).trim();\n                if (isNotBlank(nextValueTrimmed)) {\n                    terms.add(nextValueTrimmed);\n                }\n            }\n            if (terms.isEmpty() == false) {\n                if (terms.size() &gt; 1) {\n                    String termsAsString = StringUtils.join(terms, &#39; &#39;);\n                    terms = new HashSet&lt;&gt;(1);\n                    terms.add(termsAsString);\n                }\n                List&lt;TermQuery&gt; queries = Arrays.asList(terms.iterator().next().toLowerCase().split(&quot; &quot;)).stream()\n                        .map(x -&gt; new TermQuery(new Term(theFieldNameEdgeNGram, x)))\n                        .collect(Collectors.toList());\n                BooleanQuery.Builder booleanQuery = new BooleanQuery.Builder();\n                for (TermQuery termQuery : queries) {\n                    booleanQuery.add(termQuery, BooleanClause.Occur.SHOULD);\n                }\n                theBoolean.must(booleanQuery.build());\n            }\n        }\n    }\n</pre></div>\n\n\n<p><strong>Solution 2 - Relevance Ordering:</strong><br>\nFirstly, I should point out that this solution is specific to MySQL although there are similar variations for most other common databases. Additionally, injecting my implementation is VERY ugly and far from desired. Since there was no way of configuring an alternate SearchBuilder, the only way (without forking HAPI) I could apply a fix was to replace the SearchBuilder.java with a copy contained within our own source code, keeping the same packaging to trick the classloader.... I did say it was ugly. Depending on any responses I may just create a branch of HAPI and a pull request.</p>\n<p>Anyway, given that IFulltextSearchSvc.search() returned the relevance ordered set of resource ids, I then added an order by condition to the subsequent SearchBuilder query that fetched the corresponding set of resources. The result seems legit. The top results returned in my autocomplete are now the most relevant.</p>\n<p><strong>BEFORE (around line 1370):</strong></p>\n<div class=\"codehilite\"><pre><span></span>         /*\n         * Fulltext search\n         */\n        if (myParams.containsKey(Constants.PARAM_CONTENT) || myParams.containsKey(Constants.PARAM_TEXT)) {\n            if (myFulltextSearchSvc == null) {\n                if (myParams.containsKey(Constants.PARAM_TEXT)) {\n                    throw new InvalidRequestException(&quot;Fulltext search is not enabled on this service, can not process parameter: &quot; + Constants.PARAM_TEXT);\n                } else if (myParams.containsKey(Constants.PARAM_CONTENT)) {\n                    throw new InvalidRequestException(&quot;Fulltext search is not enabled on this service, can not process parameter: &quot; + Constants.PARAM_CONTENT);\n                }\n            }\n\n            List&lt;Long&gt; pids;\n            if (myParams.getEverythingMode() != null) {\n                pids = myFulltextSearchSvc.everything(myResourceName, myParams);\n            } else {\n                pids = myFulltextSearchSvc.search(myResourceName, myParams);\n            }\n            if (pids.isEmpty()) {\n                // Will never match\n                pids = Collections.singletonList(-1L);\n            }\n\n            myPredicates.add(myResourceTableRoot.get(&quot;myId&quot;).as(Long.class).in(pids));\n        }\n</pre></div>\n\n\n<p><strong>AFTER (around line 1370):</strong></p>\n<div class=\"codehilite\"><pre><span></span>         /*\n         * Fulltext search\n         */\n        if (myParams.containsKey(Constants.PARAM_CONTENT) || myParams.containsKey(Constants.PARAM_TEXT)) {\n            if (myFulltextSearchSvc == null) {\n                if (myParams.containsKey(Constants.PARAM_TEXT)) {\n                    throw new InvalidRequestException(&quot;Fulltext search is not enabled on this service, can not process parameter: &quot; + Constants.PARAM_TEXT);\n                } else if (myParams.containsKey(Constants.PARAM_CONTENT)) {\n                    throw new InvalidRequestException(&quot;Fulltext search is not enabled on this service, can not process parameter: &quot; + Constants.PARAM_CONTENT);\n                }\n            }\n\n            List&lt;Long&gt; pids;\n            if (myParams.getEverythingMode() != null) {\n                pids = myFulltextSearchSvc.everything(myResourceName, myParams);\n            } else {\n                pids = myFulltextSearchSvc.search(myResourceName, myParams);\n                // The MySQL specific order by fix... to honour pid ordering\n                outerQuery.orderBy(myBuilder.asc(myBuilder.function(&quot;FIND_IN_SET&quot;, Integer.class,\n                        myResourceTableRoot.get(&quot;myId&quot;), myBuilder.literal(StringUtils.join(pids, &quot;,&quot;)))));\n            }\n            if (pids.isEmpty()) {\n                // Will never match\n                pids = Collections.singletonList(-1L);\n            }\n            myPredicates.add(myResourceTableRoot.get(&quot;myId&quot;).as(Long.class).in(pids));\n        }\n</pre></div>\n\n\n<p>Sooo... the above changes have resulted in a much more useful full text search, for my implementation, but is a bit ugly (particularly the SearchBuilder hack). Please let me know if there is a much simpler way of achieving the same or if I've fallen into any traps and missed any important considerations. At the very least, maybe my hack might prove useful to others.</p>",
        "id": 153960757,
        "sender_full_name": "Luke Swindale",
        "timestamp": 1526342683
    }
]