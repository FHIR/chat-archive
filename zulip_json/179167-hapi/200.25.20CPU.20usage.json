[
    {
        "content": "<p>We are using HAPI 3.1.0 JPA server in docker.  Without any queries running we saw more than 200% CPU usage on a 8-core server. There are two lines of message in the log file that look suspicious:</p>\n<p>2018-03-01 18:50:53.351 [scheduledExecutorService-3] INFO  ca.uhn.fhir.jpa.dao.SearchBuilder [SearchBuilder.java:2201] Query found 0 matches in 141937ms for query 29762bdf-b4d0-4e4c-a9f8-8b6ee336d2fb<br>\n2018-03-01 18:50:53.359 [scheduledExecutorService-5] INFO  ca.uhn.fhir.jpa.dao.SearchBuilder [SearchBuilder.java:2196] Initial query result returned in 141944ms for query 3c80150d-1ca1-4c6f-a4f1-568b03c6c974</p>\n<p>We emptied the data and still saw same message and similar CPU usage numbers.</p>\n<p>I wonder if anyone experience similar problems. If it is a normal behavior for HAPI, is there a recommended configuration to improve the performance? Thanks.</p>\n<p>Ye</p>",
        "id": 153941565,
        "sender_full_name": "Ye Wang",
        "timestamp": 1519930773
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"193152\">@Ye Wang</span> that is definitely not normal behaviour.</p>\n<p>Could  you grab a thread dump while it's in that state?</p>",
        "id": 153942006,
        "sender_full_name": "James Agnew",
        "timestamp": 1520129557
    },
    {
        "content": "<p>BTW- It might be worth upgrading to 3.2.0. There are no bugs I know of in 3.1.0 that would cause this but it never hurts to be on the latest release.</p>",
        "id": 153942007,
        "sender_full_name": "James Agnew",
        "timestamp": 1520129592
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> We haven't got a chance to upgrade to 3.2.0 yet. Attached is the thread dump file.<a href=\"/user_uploads/10155/P7m8J79fgzSplSEdTWT42nVa/hapi-fhir-500patients-threaddump.log\" target=\"_blank\" title=\"hapi-fhir-500patients-threaddump.log\">hapi-fhir-500patients-threaddump.log</a></p>",
        "id": 153942525,
        "sender_full_name": "Ye Wang",
        "timestamp": 1520280811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> What we are trying to do here is to dump 10 thousands patients data with about 26 million Observation resources in total. The loading rate is about a few resources per second. From my understanding it is probably the validations that slow the process down. So far we got 1 million Observations in. At current rate it would take weeks to get all the data in. Do you have suggestions on how to speed things up? The query on this 1 million resources is also kind of slow. It takes 200 ms to return the first 10 resources. In another similar server with the 77k sample Observation data, it only takes 50 ms. Then we discovered the usually high cup usage that lead to this post. Thanks for your help!</p>",
        "id": 153942531,
        "sender_full_name": "Ye Wang",
        "timestamp": 1520281464
    },
    {
        "content": "<p>There has been at least one previous case where, after careful analysis, a JPA-related CPU utilization problem in HAPI was resolved by replacing &lt;dao&gt;.saveAndFlush() with &lt;dao&gt;.save().<br>\n(see also:  <a href=\"https://github.com/jamesagnew/hapi-fhir/pull/575/files\" target=\"_blank\" title=\"https://github.com/jamesagnew/hapi-fhir/pull/575/files\">https://github.com/jamesagnew/hapi-fhir/pull/575/files</a>)<br>\nIf the JPA cache contains a large number of objects, repeated calls to &lt;dao&gt;.saveAndFlush() can be very CPU intensive.</p>",
        "id": 153942569,
        "sender_full_name": "Joel Schneider",
        "timestamp": 1520318646
    },
    {
        "content": "<p>Hi, sorry, one thing I did not realize from your initial message is that you are using Derby. If you want to store multiple millions of records, you should definitely replace Derby with something more scalable (i.e. postgres).</p>\n<p>Derby gets really flaky over a certain size, and that's probably what's happening here.</p>",
        "id": 153942892,
        "sender_full_name": "James Agnew",
        "timestamp": 1520461464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191926\">@Joel Schneider</span> <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> Thanks! We will take a look and report back if we make any progresses.</p>",
        "id": 153942902,
        "sender_full_name": "Ye Wang",
        "timestamp": 1520465251
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span>, I'm on the same team with <span class=\"user-mention\" data-user-id=\"193152\">@Ye Wang</span>. We switched to postgres (also switched to tomcat from jetty, just a matter of personal preference), here are some preliminary observations (and questions):<br>\n(1) The problem of 200% cpu usage (equivalence of fully using 2 cpus/cores) when idle, is gone, I'm not sure if it's due to the postgres switch or the servlet container switch, or both, or neither. The old instances using derby/jetty are still doing that, though.<br>\n(2) On the \"load\" (indexing) side, we are not observing significant differences in performance (yet)<br>\n(3) On the search side, when called using \"curl\", the postgres version does appear to be faster (question to follow below)<br>\n(4) When pointing the browser (chrome) at the server, clicking/switching between the resource types on the left nav, it's takes 2-3 seconds at least, and the postgres process consumes significant amount of cpu time during that whole period (2-3 seconds).<br>\nQuestions:<br>\n(1) On the load side, we ran two tests:<br>\nGenerated sample dataset, roughly 70 bundles totalling 30MB and 12,000 resources, took 10 minutes, which translates to 3MB/min, or 1,200 resources/min <br>\nReal (more or less) dataset (subset): 1.2GB or 2.5M resources, roughly 200 resources per bundle/file, took 12 hours, which translates into 1.6MB/min or 3,500 resources/min. Roughly one or two references (to another resource) per resource.<br>\nThese (performance) numbers aren't bad for an experimental product, but my question is, do these numbers reasonably reflect the capacity of the product? That 1.2G data are from 455 patients, we have much more data and it would take a week or more to load, if it can get there at all.<br>\n(2) On the search side, is search fully supported by Lucene or does the database have an role there, too? Any reason why it's so slow to click on the main page navigating between resources - the interface is helpful in exploring the data but it's just painfully slow, even for &lt;500 patients?<br>\n(3) Limited profiling shows most of the time (loading) were spent on the hibernate layer, which isn't that surprising. Do you agree with that observation, and if so, do you think it's reasonably simple (for us) to remove that layer - will lose the beauty of the JPA layer, of course.<br>\n(4) Do you see any (easy) way to improve the performance in significant ways, by \"significant\" I mean by a factor of X if not an order of magnitude? Along those lines, do you have any info on using elasticsearch (as the persistence layer)? <br>\nThanks! Xiaocheng</p>",
        "id": 153943529,
        "sender_full_name": "Xiaocheng Luan",
        "timestamp": 1520620683
    },
    {
        "content": "<p>Hi Xiaocheng,</p>\n<p>A few points:</p>\n<p>1. The default configuration of the FHIR server includes many many search parameters and therefore lots of indexes, so writing is naturally not going to be lightning fast. The JPA server isn't a \"big data\" solution intended to ingest massive amounts of data lightning fast, the optimization is definitely towards making that data easily usable and discoverable once it has been ingested. There are all kinds of things you can do to speed up ingestion depending on your use cases, including changing the indexes/search parameters, multithreading the ingestion, and even potentially using ETL tools.</p>\n<p>2. Lucene is used for terminology and fulltext searching. All other searching purely uses the DB.</p>\n<p>3. If you don't use the JPA layer, you're using HAPI FHIR as a \"plain server\". HAPI was originally designed with this use case actually, and lots of people use it this way. You need to supply your own storage logic of course in this case, but for many use cases this is a good option.</p>",
        "id": 153943591,
        "sender_full_name": "James Agnew",
        "timestamp": 1520683402
    },
    {
        "content": "<p>Thanks for the response, <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> . Those are in line with my thoughts, or guesses, more accurately. I just started playing around with FHIR and/or HAPI. We may have more questions for you down the road. Thanks again.</p>",
        "id": 153943903,
        "sender_full_name": "Xiaocheng Luan",
        "timestamp": 1520880215
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> , a separate question - does the HAPI search API support _revInclude, that is, search/get \"Patient\" but also want to (reverse) include the observations that refer to this patient? I tried but wasn't able to get any results. Also, the \"capabilities list\" as returned by the service does not list any _revInclude entries. The _include seems to work fine, I was able to include Patient in the Observations results. Thanks!</p>",
        "id": 153943999,
        "sender_full_name": "Xiaocheng Luan",
        "timestamp": 1520893919
    },
    {
        "content": "<p>Yup, _revinclude is fully supported. Can you post a sample query you're using against the public server that isn't working the way you expect?</p>",
        "id": 153944473,
        "sender_full_name": "James Agnew",
        "timestamp": 1520972320
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> ! Just double checked my request spelling and reverse inc does work! Funny enough, there were only a couple of misspellings in the HL7 docs (revInclude vs. revinclude, that is, camel case vs. all lower) and I happened to have copy/pasted the wrong one!</p>",
        "id": 153944769,
        "sender_full_name": "Xiaocheng Luan",
        "timestamp": 1521041117
    },
    {
        "content": "<p>Good catch, I've submitted a change request to fix 2 instances with a capital \"I\" in the Search documentation.</p>",
        "id": 153944787,
        "sender_full_name": "Igor Sirkovich",
        "timestamp": 1521043486
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"191393\">@Igor Sirkovich</span></p>",
        "id": 153948049,
        "sender_full_name": "Xiaocheng Luan",
        "timestamp": 1522077842
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span>, in the documentation for version 3.2.0, under \"JPA Server\", there is an \"Important Note\" that says: \"with a single table being used to hold resource bodies (which are stored as CLOBs, optionally GZipped to save space)\". While looking inside the postgres database used by HAPI server 3.2.0, I'm not seeing such a table that contains the resource bodies, could you please help clarify, thanks!</p>",
        "id": 153948053,
        "sender_full_name": "Xiaocheng Luan",
        "timestamp": 1522078218
    }
]