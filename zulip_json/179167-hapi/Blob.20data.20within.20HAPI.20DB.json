[
    {
        "content": "<p>I can see records in my HAPI database in HFJ_RESOURCE, with I think the actual data itself in HFJ_RES_VER.RES_TEXT. This is a \"LONGBLOB\" field. Is that the right place to extract this via SQL and how is it possible to convert the blob back to text?</p>",
        "id": 164014233,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1556042921
    },
    {
        "content": "<p>I'm not sure how you would (or if you can) do that in Derby<br>\nas Kevin suggested, moving to Mysql or Postgresql probably is something you will want to consider (if you haven't)<br>\nPostgresql works well for me</p>",
        "id": 164024169,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1556049315
    },
    {
        "content": "<p>Hi Rob, sorry, should have pointed out  - this is HAPI on MySQL in fact. I can see all the tables in a GUI viewer, but just cannot extract the actual resource data as text. It's encoded somehow. What can you see in HFJ_RES_VER.RES_TEXT?</p>",
        "id": 164024511,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1556049566
    },
    {
        "content": "<p>I've now tried Postgres. This shows the same field as a oid datatype. Which I assume is a link to the actual blob of data.  But again I cannot find a way to access the actual resource data via SQL.</p>",
        "id": 164040851,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1556064232
    },
    {
        "content": "<p>I don't know the answer offhand, but maybe I can take a look and see if I can find something on it</p>",
        "id": 164052056,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1556079199
    },
    {
        "content": "<p>if it helps, the java code is:</p>\n<p>public static String decodeResource(byte[] theResourceBytes, ResourceEncodingEnum theResourceEncoding) {<br>\n        String resourceText = null;<br>\n        switch (theResourceEncoding) {<br>\n            case JSON:<br>\n                resourceText = new String(theResourceBytes, Charsets.UTF_8);<br>\n                break;<br>\n            case JSONC:<br>\n                resourceText = GZipUtil.decompress(theResourceBytes);<br>\n                break;<br>\n            case DEL:<br>\n                break;<br>\n        }<br>\n        return resourceText;<br>\n    }</p>",
        "id": 164061697,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1556092937
    },
    {
        "content": "<p>On SQL Server 2017 if the encoding is JSONC. The following should work:</p>\n<p>SELECT TOP 1000 [PID]   <br>\n      ,Convert(varchar(max),DECOMPRESS(RES_TEXT))<br>\n  FROM [dbo].[HFJ_RES_VER]</p>",
        "id": 164062229,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1556093513
    },
    {
        "content": "<p>thanks Kevin. What I am looking for is a Postgres way to do that SQL statement. I have tried lots of variations of decode, case and lo_get functions but have not yet managed to get a plain text version of the resource. But now I know it might be gzip and not just base64 or something, that may help my searching.</p>",
        "id": 164068871,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1556101292
    },
    {
        "content": "<p>I thing the format in Postgres might be \"bytea\" but I don't know how to convert that to plain text.</p>",
        "id": 164068979,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1556101409
    },
    {
        "content": "<p>Rik, the decoding is done here: <a href=\"https://github.com/jamesagnew/hapi-fhir/blob/706af5d5794e117159b635614c72bcb8799df492/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirDao.java#L1142\" target=\"_blank\" title=\"https://github.com/jamesagnew/hapi-fhir/blob/706af5d5794e117159b635614c72bcb8799df492/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirDao.java#L1142\">https://github.com/jamesagnew/hapi-fhir/blob/706af5d5794e117159b635614c72bcb8799df492/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirDao.java#L1142</a></p>",
        "id": 164071329,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1556104270
    },
    {
        "content": "<p>The loading from the DB (via JPA) here: <a href=\"https://github.com/jamesagnew/hapi-fhir/blob/c8f2e4bbc94538c582400f002d536d85f81ca011/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirResourceDao.java#L898\" target=\"_blank\" title=\"https://github.com/jamesagnew/hapi-fhir/blob/c8f2e4bbc94538c582400f002d536d85f81ca011/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirResourceDao.java#L898\">https://github.com/jamesagnew/hapi-fhir/blob/c8f2e4bbc94538c582400f002d536d85f81ca011/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirResourceDao.java#L898</a></p>",
        "id": 164071334,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1556104285
    },
    {
        "content": "<p>Thanks Patrick, I will have a look at that. Looks like beautiful code! I am really looking for a non-code based way to do this, via SQL, but this may help work that out. Use case is an SQL enabled but  non-FHIR enabled system needs to read data.</p>",
        "id": 164073971,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1556107203
    },
    {
        "content": "<p>Most of the out the box FHIR servers store data in a similar way. When I was at NHS Digital we went a more traditional SQL focused route but that meant we had less coverage of FHIR.  <a href=\"https://github.com/nhsconnect/careconnect-reference-implementation\" target=\"_blank\" title=\"https://github.com/nhsconnect/careconnect-reference-implementation\">https://github.com/nhsconnect/careconnect-reference-implementation</a>  Its not that hard to extend but it has to be coded.</p>",
        "id": 164077234,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1556110112
    },
    {
        "content": "<p>If there is no easy SQL to get the data directly we will probably implement a workaround shim that gets the data via REST and feeds it into the SQL based product some other way. Or perhaps using that JPA routine from the source.</p>",
        "id": 164077909,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1556110761
    },
    {
        "content": "<p>Coming back to an old thread. HAPI appears to allow the data to be stored in RES_TEXT field as JSON or JSONC (which is gzip encoded). At least the decodeResource function (shown above) can retrieve those two formats. Is there a server config option to store data in unencoded json?</p>",
        "id": 176688236,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1569525387
    },
    {
        "content": "<p>There isn't currently, although I do think there should be.</p>",
        "id": 176694610,
        "sender_full_name": "James Agnew",
        "timestamp": 1569529840
    }
]