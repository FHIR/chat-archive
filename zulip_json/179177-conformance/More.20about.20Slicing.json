[
    {
        "content": "<p>See this thread: <a href=\"#narrow/stream/179239-tooling/topic/IG.20Publisher.20-.20Inconsistency.20in.20displaying.20snapshot\" title=\"#narrow/stream/179239-tooling/topic/IG.20Publisher.20-.20Inconsistency.20in.20displaying.20snapshot\">https://chat.fhir.org/#narrow/stream/179239-tooling/topic/IG.20Publisher.20-.20Inconsistency.20in.20displaying.20snapshot</a></p>",
        "id": 171996449,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564448305
    },
    {
        "content": "<ul>\n<li>the base profile slices an element (open, disciminated by a sub-element)</li>\n<li>it defines some constraints on all slices </li>\n<li>it defines one slice with a constraint on the sub-element</li>\n</ul>",
        "id": 171996468,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564448354
    },
    {
        "content": "<ul>\n<li>the derived profile imposes a must-support on the element</li>\n</ul>",
        "id": 171996472,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564448377
    },
    {
        "content": "<p>it doesn't say anything about slicing. It presumably means that the must-support applies to the element, and therefore to all the slices defined on the element. I'm not sure we've discussed this particular scenario?</p>",
        "id": 171996535,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564448445
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Just wondering should it be a candidate for GForge?</p>",
        "id": 171997598,
        "sender_full_name": "Uday Chandrupatla",
        "timestamp": 1564449970
    },
    {
        "content": "<p>not at the moment. Don't know what the issue is</p>",
        "id": 171997622,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564450075
    },
    {
        "content": "<p>there's a really thorny thing here - the implication is that a given element has 2 ancestors, and I don't know how to make that work</p>",
        "id": 171997663,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564450099
    },
    {
        "content": "<p>Trying to understand the scenario. Is this about how to compute/validate the set of constraints on the named slice in the (snapshot of) the derived profile?</p>",
        "id": 172017071,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564475792
    },
    {
        "content": "<p>No it’s about how to generate the snapshot in this case</p>",
        "id": 172022109,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564480364
    },
    {
        "content": "<p>FYI, the .NET SnapshotGenerator does NOT try to merge constraints on slice introduction with constraints on named slices. If a resource element matches a named slice, then I assume that the validator verifies the element against the constraints for the matching named slice, and also against any common constraints specified by the slice introduction element.</p>",
        "id": 172023353,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564481315
    },
    {
        "content": "<p>I remember that we have discussed merging common constraints specified by a slice group onto all named child slices, however I never got around to actually implementing this behavior in the .NET SnapshotGenerator. This is very hard to support in Forge, as the application would need to harmonize live changes to slice groups to all child slices. Theoretically possible, but quite hard in practice, especially gracefully dealing with all kinds of boundary conditions (i.e. report/merge conflicting constraints?).</p>",
        "id": 172023502,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564481444
    },
    {
        "content": "<p>I think it’s really complex. Imagine that the child profile profiles the unsliced element, and it also profiles the slice. The slice now inherits properties from 3 different elements - in what order? Nuts....</p>",
        "id": 172023982,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564481885
    },
    {
        "content": "<p>From a tooling point, we should say that if the base slices, then the derived profiles have to constrain the slices as well as the unsliced</p>",
        "id": 172024001,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564481914
    },
    {
        "content": "<p>Indeed. By not merging slice group constraints onto named slices, the .NET SnapshotGenerator completely ducks the multiple-inheritance issue - instead, leaving it up to the validator.  This shifts more work to validator implementations, but also allows validators to report on potentially conflicts between constraints from different origins (slice group vs. named slice).</p>",
        "id": 172024244,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564482182
    },
    {
        "content": "<p>SnapshotGenerator implementations always need to merge constraints in a specific, well-defined order. However validators can verify an element against any number of constraint sets, in any order and simply report all violations.</p>",
        "id": 172024383,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564482316
    },
    {
        "content": "<p>hah. the validator doesn't handle must-support, which is the question here.</p>",
        "id": 172028791,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564486600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192202\">@Uday Chandrupatla</span> - what you're trying to isn't going to be supported - you have to put must-support on the slice too</p>",
        "id": 172028815,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564486624
    },
    {
        "content": "<p>If your snapshot builder doesn't handle multiple parents, how do you handle the multiple type.profile constraints?  Yes, absolutely there are multiple \"parents\" for an element:</p>\n<ul>\n<li>the \"local\" parent - the slice parent in this profile</li>\n<li>the \"base\" parent - the same slice in the base profile</li>\n<li>the \"type\" parent(s) - the element in any attached type profiles</li>\n</ul>\n<p>The \"path\" of snapshot aggregation will weave it's way thru these.</p>",
        "id": 172037791,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1564493567
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> ^^</p>",
        "id": 172037899,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1564493646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span>, the .NET SnapshotGenerator aggregates element constraints from:<br>\n1) associated element in the base profile (if any)<br>\n2) external type profile, specified by the element itself or inherited from base element<br>\n3) any other constraints specified by the element itself<br>\nIn the specified order, from lowest to highest priority.<br>\nAs I mentioned before, the .NET SnapshotGenerator (and Forge) does NOT aggregate common constraints specified on a sliced element onto the associated concrete named slices. Assumption is that validators will verify slice elements in a resource instance against both sets of constraints; (1) common constraints specified by the slice intro and (2) specific constraints specified by a matching named slice.</p>",
        "id": 172039493,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564494939
    },
    {
        "content": "<p>What about sub-slices (reslices)?</p>",
        "id": 172040080,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1564495322
    },
    {
        "content": "<p>And multiple type profiles?</p>",
        "id": 172040397,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1564495498
    },
    {
        "content": "<p>According to the spec about <code>.type.profile</code> and <code>.type.targetProfile</code>, \"one must apply\":<br>\n<a href=\"http://hl7.org/fhir/elementdefinition.html#definition\" target=\"_blank\" title=\"http://hl7.org/fhir/elementdefinition.html#definition\">http://hl7.org/fhir/elementdefinition.html#definition</a><br>\nAlso:<br>\n<a href=\"http://hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.type.profile\" target=\"_blank\" title=\"http://hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.type.profile\">http://hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.type.profile</a><br>\n\"If any profiles are specified, then the content must conform to at least one of them.\"<br>\nThe .NET SnapshotGenerator only aggregates constraints from a <em>single</em> type profile, not if an element specifies multiple type profiles.</p>",
        "id": 172041889,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564496360
    },
    {
        "content": "<p>Re-slices aggregate constraints similarly:<br>\n1) associated (re)slice element in base profile<br>\n2) external type profile<br>\n3) other constraints specified by the reslice element itself</p>",
        "id": 172042068,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564496470
    },
    {
        "content": "<p>(FYI if I recall correctly, implementing support for reslicing did not require a lot of custom logic. Mainly to find the correct matching base element. However constraint aggregation is similar/equal.)</p>",
        "id": 172042335,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564496633
    },
    {
        "content": "<p>I think that's ok for validation constraints, but I think it's broken for the descriptive elements.</p>",
        "id": 172042347,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1564496638
    },
    {
        "content": "<p>Might be... Must confess that I have yet to find a real-life end user scenario that requires complex, deeply nested aggregation/concatenation of descriptive constraints. Many profiles we see in the wild do not specify any user-readable content at all :/</p>",
        "id": 172042760,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564496843
    },
    {
        "content": "<p>You haven't had me as a client very long yet! ;)</p>",
        "id": 172045806,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1564498639
    }
]