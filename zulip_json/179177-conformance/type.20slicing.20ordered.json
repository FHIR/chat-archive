[
    {
        "content": "<p>The Java Validator throws an error if you have a ordered type slicing (slicing like this doesn't make a lot of sense in the first place). The .net validator (Simplifier) accepts ordered type slicing.<br>\nI think it could make sense to add a constraint on discriminator to raise at least a warning if you want to do ordered type slicing.</p>",
        "id": 195400232,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1587984552
    },
    {
        "content": "<p>it's actually the snapshot generator, though that doesn't really matter</p>",
        "id": 195402158,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1587986013
    },
    {
        "content": "<p>I declined to support because I have no idea what it means to claim that they are ordered</p>",
        "id": 195402195,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1587986042
    },
    {
        "content": "<p>There could only be meaning if polymorphic types could be repeating - and they can't.  So I think asserting ordered type slicing as an error is reasonable.</p>",
        "id": 195428751,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1587999214
    },
    {
        "content": "<p>Actually, let me re-think that.  If the profile reaches through a repeating path, it could make sense.  E.g. entry.resource.  In that case, you'd be asserting that some resources needed to appear before other resources.  (Though whether that's a legal thing to do is unclear.  It's certainly a questionable practice...  In fact, using ordered slicing on any element where order doesn't have defined meaning is pretty questionable.)</p>",
        "id": 195429014,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1587999330
    },
    {
        "content": "<p>doesn't apply to entry resource, since that's not a choice of types</p>",
        "id": 195471343,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588019504
    },
    {
        "content": "<p>do we need an invariant for this? <span class=\"user-mention\" data-user-id=\"203235\">@Ward Weistra</span></p>",
        "id": 195545586,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588070640
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191451\">@Patrick Werner</span> Sounds fair to me, though not an expert. Can you suggest it on <a href=\"https://github.com/FirelyTeam/fhir-net-api/\" title=\"https://github.com/FirelyTeam/fhir-net-api/\">https://github.com/FirelyTeam/fhir-net-api/</a> so our API team can consider?</p>",
        "id": 195575958,
        "sender_full_name": "Ward Weistra",
        "timestamp": 1588085759
    },
    {
        "content": "<p>Sure. To be safe in the future i think we should add this as an error invariant.</p>",
        "id": 195576120,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588085812
    },
    {
        "content": "<p>Ok. Gave it some more thought. Some (German) Implementers love the ordered slicing on type. They use it to express stuff like: \"First Practitioner is sending the patient, second Practitioner is receiving the patient\". They use it to give semantical meaning on Resources they can't distinguish by a code or other criteria.</p>",
        "id": 195667808,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588143626
    },
    {
        "content": "<p>I can follow that thought, it looks good in Simplifier to have a defined order if you have no other criteria to slice on.</p>",
        "id": 195667869,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588143686
    },
    {
        "content": "<p>But validating such ordered type slicings is impossible. That's why <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> is not supporting it. Right?</p>",
        "id": 195668005,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588143749
    },
    {
        "content": "<p>Open Question: Should ordered slicing on type be prohibited by an error invariant, so StrucDefs using it won't validate? Or should this be 'legal' and the Validator throws a warning when validating an instance saying: i can't validate this ? Or even just ignores it.</p>",
        "id": 195668181,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588143865
    },
    {
        "content": "<p>As Simplifier doesn't raise an error on this i'm interested on <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> s opinion on this.</p>",
        "id": 195668216,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588143902
    },
    {
        "content": "<p>I think being able to do something in the .Net stack and getting Exceptions for the same in the Java stack is not good for FHIR and interoperability.</p>",
        "id": 195669341,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588144716
    },
    {
        "content": "<blockquote>\n<p>They use it to express stuff like: \"First Practitioner is sending the patient, second Practitioner is receiving the patient\"</p>\n</blockquote>\n<p>This is not slicing on type</p>",
        "id": 195672628,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588146826
    },
    {
        "content": "<p>I'm not sure what you are implying. Here is an example: <a href=\"https://simplifier.net/patrickssandbox/myobservation\" title=\"https://simplifier.net/patrickssandbox/myobservation\">https://simplifier.net/patrickssandbox/myobservation</a><br>\nclosed type based ordered slicing on derivedFrom()</p>",
        "id": 195675471,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588148612
    },
    {
        "content": "<p>But those are both normal Observations. If you get an observation, how do you distinguish whether it's obs1 or obs2?</p>",
        "id": 195675623,
        "sender_full_name": "Mareike Przysucha",
        "timestamp": 1588148715
    },
    {
        "content": "<p>first one is obs1, second obs2. Sliced by type, defined order. Not saying that i like this, or this is good practice. Just pointing to the fact that some people are using it that way.</p>",
        "id": 195676882,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588149612
    },
    {
        "content": "<p>Yes proper validation isn't possible, as you never know if someone changed the order. So a computer can't validate this, but extensible is also not validateable by a computer.</p>",
        "id": 195676948,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588149670
    },
    {
        "content": "<p>sorry, I did not see the cardinalities.</p>",
        "id": 195676953,
        "sender_full_name": "Mareike Przysucha",
        "timestamp": 1588149675
    },
    {
        "content": "<p>My goal is consistency between .net, (Simplifier/Forge) and the Java Stack</p>",
        "id": 195677008,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588149715
    },
    {
        "content": "<p>so <code>derivedFrom</code> is a Reference with cardinality 0..* This is <em>not type slicing</em></p>",
        "id": 195683754,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588153482
    },
    {
        "content": "<p><span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span> i'm confused now.</p>",
        "id": 195686076,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588154544
    },
    {
        "content": "<p>type slicing is when you have something like <code>Observation.value[x]</code> and you have a slice for <code>string</code> and a slice for <code>CodeableConcept</code></p>",
        "id": 195686824,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588154928
    },
    {
        "content": "<p>cardinality is 0..1, and so there's no repeats and you can't talk about order.</p>",
        "id": 195686851,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588154953
    },
    {
        "content": "<p>Observation.derivedFrom, of course you need to be able to talk about order</p>",
        "id": 195686858,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588154965
    },
    {
        "content": "<p>ohhh. Just learned something. Thanks.</p>",
        "id": 195686947,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588155012
    },
    {
        "content": "<p>i'm totally confused now. Sorry. Looking at: <a href=\"https://www.hl7.org/fhir/profiling.html#discriminator\" title=\"https://www.hl7.org/fhir/profiling.html#discriminator\">https://www.hl7.org/fhir/profiling.html#discriminator</a><br>\nI see:</p>\n<blockquote>\n<p>Used to match slices based on the type of the item. While it can be used with polymorphic elements such as Observation.value[x], mostly it is used with Resource types on references, to apply different profiles based on the different resource type. Typical example: slice on the type of List.item.resolve() for the types Patient, RelatedPerson.</p>\n</blockquote>",
        "id": 195701043,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588163695
    },
    {
        "content": "<p>Which says i can use this for reference types. (Doesn't say anything about 'can only be used on references with max card. =1 )</p>",
        "id": 195701273,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588163831
    },
    {
        "content": "<p>I also couldn't find another possibility to slice references based on the target reference type (not profile, just core type)</p>",
        "id": 195701342,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588163874
    },
    {
        "content": "<p>The Germans shouldn't assign meaning to the order when the core spec doesn't define order to have meaning - doing so is non-conformant.  If there's a different semantic between repetitions, then expose it in the instance and continue to allow the data to be sent in arbitrary order.  Imposing order (and meaning on order) where the spec says there isn't any is contrary to interoperability and sometimes dangerous</p>",
        "id": 195712399,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1588168605
    },
    {
        "content": "<p>I agree. Thats why i think there should be an invariant or a warning from the Validator itself on this to give explicit guidance. The non-conformancy isn't stated explicitly on the slicing page.</p>\n<p>On the other hand, Grahame said:</p>\n<blockquote>\n<p>Observation.derivedFrom, of course you need to be able to talk about order</p>\n</blockquote>\n<p>Which i interpret as its ok to talk about order in a list.</p>\n<p>What's your opinion on slicing on a target type?</p>",
        "id": 195713106,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588168844
    },
    {
        "content": "<p>yes you need to slice in target type. I can see that the language here is confusing - by \"type based slicing\" I meant, slicing an element that has a choice of types, not using a \"type\" discriminator</p>",
        "id": 195759316,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588188780
    },
    {
        "content": "<p><span aria-label=\"relieved\" class=\"emoji emoji-1f60c\" role=\"img\" title=\"relieved\">:relieved:</span> ok. Thats a relief.</p>",
        "id": 195802317,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1588228230
    }
]