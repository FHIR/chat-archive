[
    {
        "content": "<p>Is there a way to say must support at least type a and type b and may support type c when profiling a element of type reference 1..1 ?</p>",
        "id": 179675655,
        "sender_full_name": "Eric Haas",
        "timestamp": 1572653096
    },
    {
        "content": "<p>Not formally.  You could do it with text or define an extension</p>",
        "id": 179675858,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572653427
    },
    {
        "content": "<p>Or multiple profiles like a min max profile and then declare profile in cap statements</p>",
        "id": 179712279,
        "sender_full_name": "Eric Haas",
        "timestamp": 1572717816
    },
    {
        "content": "<p>Not sure how capability statement would help - you get one profile per resource to declare what you support</p>",
        "id": 179726285,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572743712
    },
    {
        "content": "<p>Min and max requires an ordering. How would this work?</p>",
        "id": 179816809,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1572859330
    },
    {
        "content": "<p>This isn't ordered.  It's setting mustSupport expectations</p>",
        "id": 179836884,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572877119
    },
    {
        "content": "<p>I agree the min max profile is not really a solution since they are mutually exclusive since min would be 'foo' type Reference(A|B)   and max would be 'foo' type Reference(A|B|C)  so a server that supports the max could not say is conformant to min....since it would not invalidate 'foo' <br>\n = Reference(C)</p>",
        "id": 179855703,
        "sender_full_name": "Eric Haas",
        "timestamp": 1572889204
    },
    {
        "content": "<p>it seems like an extension on ElementDefinition.type to me</p>",
        "id": 180100296,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1573098911
    },
    {
        "content": "<p><a href=\"http://build.fhir.org/elementdefinition-definitions.html#ElementDefinition.mustSupport\" target=\"_blank\" title=\"http://build.fhir.org/elementdefinition-definitions.html#ElementDefinition.mustSupport\">mustSupport</a> says that you define the meaning somewhere else in the profile. As I see it, testing of mustSupport conditions is outside the scope of the FHIR validator.</p>",
        "id": 180101633,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1573101066
    },
    {
        "content": "<p>The complex meaning <span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span>  proposes would go in text where ever you describe the meaning of must support.</p>",
        "id": 180101652,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1573101114
    },
    {
        "content": "<p>so use <a href=\"http://hl7.org/fhir/StructureDefinition/capabilitystatement-expectation\" target=\"_blank\" title=\"http://hl7.org/fhir/StructureDefinition/capabilitystatement-expectation\">http://hl7.org/fhir/StructureDefinition/capabilitystatement-expectation</a> in this context for <code>ElementDefinition.type.profile</code> or <code>ElementDefinition.type. targetProfile</code> ?   Although it would be in this case a modifier I guess.  So I'd need to define a new one.</p>\n<p>So what would it would mean is an implementer could support only the SHALLS +/- more types.  But I am not sure how profile validators would handle this level of variability.</p>",
        "id": 180106333,
        "sender_full_name": "Eric Haas",
        "timestamp": 1573108480
    },
    {
        "content": "<p>how is it relevant to profile validators?</p>",
        "id": 180107049,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1573109496
    },
    {
        "content": "<p>Validators couldn't do anything about the 'min', only check the max.</p>",
        "id": 180140538,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1573139167
    }
]