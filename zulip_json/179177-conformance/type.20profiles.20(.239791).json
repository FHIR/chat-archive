[
    {
        "content": "<p>Stream to discuss <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=9791\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=9791\">GF#9791</a>.</p>",
        "id": 153831901,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1465309875
    },
    {
        "content": "<p>To recap the FHIR-I call:<br>\nWhen applying a type profile to an element (setting elementdefinition.type.profile), one of these scenarios applies:<br>\n1. New @profile discriminated slicing - Effectively defining a new element specialization.<br>\n2. New slice discriminated by other elements (not @profile) and constrained by @profile.<br>\n3. Type profile added to existing slice.<br>\n4. Type profile added to un-sliced element.</p>\n<p>In all scenarios, for element definition elements that aggregate (constraint, mapping, alias), both the element base and the type profile must be represented, and de-duplication should be applied (since mappings on the base types will be inherited from both the element and type profile lineages).</p>\n<p>For elements with only 1 value that are calculable (min, max, maxLength, minValue[x], etc), both must be considered.</p>\n<p>For elements with only 1 value that cannot be programmatically merged (label, short, comments, etc), which lineage should be used?</p>\n<p>For 1, it was unanimous that all elementdefinition (ED) elements should be based on the type profile.<br>\nFor 2, general sentiment was that the type profile should be used.  Common use cases here are extensions since they are discriminated by url and constrained by type profile.  However, since the type profile is not the defining aspect of the slice (it's not the discriminator), there is some question.<br>\nFor 3, I think this would be treated like 4 since it's not defining anything new but rather constraining something existing.<br>\nFor 4, the base element would be used since the type is not re-defining, only constraining.</p>",
        "id": 153831902,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1465310678
    },
    {
        "content": "<p>Agree on all counts</p>",
        "id": 153831958,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1465354098
    },
    {
        "content": "<p>Very interesting discussion! As it happens, I was just looking at how to merge mappings on (unsliced) elements with a profiled type. Then Ewout informed me about the current discussion. If the community can reach concensus on these advanced merging rules, then I can try and implement them piece by piece in Forge, to determine if/how it works.</p>",
        "id": 153831996,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1465376405
    },
    {
        "content": "<p>For example, The Observation resource profile also defines element mappings on Observation.identifier, e.g. a v2 mapping to \"OBX.21\". The Identifier datatype profile also defines element mappings on the \"identifier\" root element, e.g. v2 mapping to \"CX / El\". So does the Observation.identifier element definition (implicitly) inherit these additional mappings from the Identifier profile? In other words, when expanding the snapshot, do I need to merge the mappings from the element definition in the Observation resource profile with the mappings from the element definition in the Identifier datatype profile?</p>",
        "id": 153831997,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1465376702
    },
    {
        "content": "<p>Yes?</p>",
        "id": 153832017,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1465393417
    },
    {
        "content": "<p>OK, thx ;p</p>",
        "id": 153832019,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1465393599
    },
    {
        "content": "<p>A mapping (or alias, or constraint) on a base type gets propagated *all over*. </p>",
        "id": 153832021,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1465393670
    },
    {
        "content": "<p>I'm not sure that the implications of annotating one of the types or Element or Resource was always fully appreciated.  Or maybe it was and that was always intended.</p>",
        "id": 153832022,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1465393717
    },
    {
        "content": "<p>The rim n/a mapping is going to be on lots and lots of elements.</p>",
        "id": 153832023,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1465393739
    },
    {
        "content": "<p>I was just wondering if it makes any sense to have different mappings on an element for the same system, as in the Observation.identifier example I mentioned, which would aggregate two different v2 mappings to both \"OBX.21\" and also to \"CX / El\". I can image how multiple mappings express information on a different abstraction/specialization level, but since I am no mapping expert I can't really tell. Thanks for the feedback.</p>",
        "id": 153832024,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1465394074
    },
    {
        "content": "<p>Also I guess, since profile and element mappings always are implicitly inherited (from multiple levels...), that it makes no sense for Forge to let the user edit any of the inherited mapping components. The rules state that the profile inherits all the original mappings anyway. So maybe Forge should render inherited profile mapping components in the UI as read-only? i.e. the user can only extend the collection, but not edit any of the implicitly inherited collection items.</p>",
        "id": 153832025,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1465394270
    },
    {
        "content": "<p>Yes, for any of the \"aggregable\" elements (mapping, constraint, alias) you can only add.</p>",
        "id": 153832026,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1465394325
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span>  That makes sense. I'll try to implement the correct behavior in Forge. Thanks a lot for clearing this up!</p>",
        "id": 153832028,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1465394643
    }
]