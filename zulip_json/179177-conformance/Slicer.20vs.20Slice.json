[
    {
        "content": "<p>An issue has come up for Lloyd and I from doing test cases for snapshot generation that I'd like to get wider consensus about. </p>",
        "id": 153880165,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1490735272
    },
    {
        "content": "<p>it appears to be implicit - but not obvious - that if you define constraints on the slicing element (and sub-elements) - which are constraints on every slice - that any slices will be proper constraints on the slicer as well as the base structure definition</p>",
        "id": 153880166,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1490735351
    },
    {
        "content": "<p>is that something everyone agrees to? Should we make it explicit?</p>",
        "id": 153880167,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1490735376
    },
    {
        "content": "<p>the corrollary to this is the question of what happens in snapshot generation: should the snapshot generator copy constraints from the slicer into the slices in the snapshot? </p>",
        "id": 153880168,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1490735431
    },
    {
        "content": "<p>I don't see any alternative interpretation.  We already agreed on a special name for a \"default\" slice, which is the only other interpretation I can think of for constraints declared on the slicing element and children.  (And that would have been a bit odd.)</p>",
        "id": 153880169,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490735454
    },
    {
        "content": "<p>thinking about how to do this - 3 way merge - makes my had hurt. And I wonder how anyone (well, any normal person, not including Lloyd) could ever understand what is going on here</p>",
        "id": 153880170,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1490735482
    },
    {
        "content": "<p>In the snapshot, I would expect that when you look at a particular element, you see all constraints that hold for that element - that's sort of the point.  So I think we have to incorporate constraints from the slicer into the slices for it to work.</p>",
        "id": 153880171,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490735508
    },
    {
        "content": "<p>(And thanks for implicitly including me in the set of 'normal person' ;))</p>",
        "id": 153880172,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490735525
    },
    {
        "content": "<p>i don't  knwo if i categorize as a normal person, but i'm trying to understand whats going on here:-) i think implicit was my assumption to, how would I have it do to make it explicit?</p>",
        "id": 153880186,
        "sender_full_name": "Oliver Egger",
        "timestamp": 1490737865
    },
    {
        "content": "<p>Hi Grahame, interesting question!</p>\n<p>We had an extensive discussion about this topic within our team about two weeks ago and decided on the following approach.</p>\n<p>Differential element constraints are merged onto (override) the associated snapshot element definition in the base profile.<br>\nThis also applies to slice entries and named slices.<br>\nConstraints on the slice entry apply to all the individual slices.<br>\nSo a validator should also verify individual slices against the slice entry constraints.<br>\nHowever IMO this aspect does not effect the behavior of the snapshot generator.<br>\nDifferential constraints on named slices are only merged with the associated element in the base profile - NOT with the slice entry constraints.<br>\nSo there is no three-way merging.<br>\nIt is up to the validator to verify named slices against the associated slice definition as well as the slice entry constraints.</p>\n<p>Example 1<br>\n- the base element has an example binding to a valueset.<br>\n- The slice entry constrains the binding to a specific required valueset.<br>\n- Then in the snapshot, the named slices do NOT explicitly repeat the binding from the slice entry.<br>\n  However they can (and often will) fix the element to a specific value.</p>\n<p>Example 2<br>\n- base element has cardinality 0...1<br>\n- slice entry has cardinality 1...1 (mandatory)<br>\n- individual slices have cardinality 0...1 (optional)<br>\n  Note that the individual slices should NOT inherit minimum cardinality 1 from the slice entry...!<br>\n  Otherwise a profile can no longer introduce options.<br>\n  So a named slice always has a base minimum cardinality of 0, regardless of the minimum cardinality of the associated base element.</p>",
        "id": 153880228,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490780609
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/3I-GIeJEEo_R8irN-hZwx3Kg/SliceBase.png\" target=\"_blank\" title=\"SliceBase.png\">SliceBase.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/3I-GIeJEEo_R8irN-hZwx3Kg/SliceBase.png\" target=\"_blank\" title=\"SliceBase.png\"><img src=\"/user_uploads/10155/3I-GIeJEEo_R8irN-hZwx3Kg/SliceBase.png\"></a></div>",
        "id": 153880234,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490781954
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/r_ksOiV6F8P-xjBm8w2ZOJYF/SliceBase2.png\" target=\"_blank\" title=\"SliceBase2.png\">SliceBase2.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/r_ksOiV6F8P-xjBm8w2ZOJYF/SliceBase2.png\" target=\"_blank\" title=\"SliceBase2.png\"><img src=\"/user_uploads/10155/r_ksOiV6F8P-xjBm8w2ZOJYF/SliceBase2.png\"></a></div>",
        "id": 153880235,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490781979
    },
    {
        "content": "<p>Hope this helps.</p>",
        "id": 153880236,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490781993
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> What's the point of declaring constraints on the slicing element if those constraints aren't enforced on all slices?  I don't understand why a profile would declare constraints that would affect anything other than derived profiles but would have no impact on validating instances against that profile.  (Keep in mind that we have a separate way of declaring constraints on elements that don't match any of the named slices.)</p>",
        "id": 153880244,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490796296
    },
    {
        "content": "<p>But the constraints on the slicing entry SHOULD be enforced! This is the responsibility of the validator. However in the snapshot representation, slicing entry constraints are not merged onto named slices. These are different aspects and one does not affect the other. This way, the author has complete freedom to author constraints on slicing entry level and/or named slice level. It is also up to the validator to verify that slicing entry constraints don't conflict with constraints on named slices. However, a profile with conflicting constraints is not automatically invalid; it's just that no resources will match the profile, so it is probably not what the author intended. A validator could e.g. flag this with a warning.</p>",
        "id": 153880251,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490797399
    },
    {
        "content": "<p>That's kind of evil if you ask me.  The whole point of the snapshot is to say \"these are all the rules that apply here\".  Needing to look in multiple places makes things harder.   That said, the cardinalities have to be able to be different, so there are certainly some propagation rules that aren't the same here as they are when propagating from base.</p>",
        "id": 153880252,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490797589
    },
    {
        "content": "<p>Suppose that the snapshot generator would merge the slicing entry constraints on the named slices. This implies that named slices now inherit constraints from an element in the same profile (instead of an element in the base profile like everywhere else). That's like trying to hit a moving target...<br>\nAlso, suppose the slicing entry constrains cardinality from 0...* to 1...*. Now if we would merge these onto named slices, then the profile can no longer introduce an optional named slice with cardinality 0...1. This would prevent profiles to model common use cases.</p>",
        "id": 153880253,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490797644
    },
    {
        "content": "<p>Merging the cardinality in is the one thing you can't do.  But I don't see how it's hitting a moving target.  The snapshot reflects whatever the differential says.  As the differential changes, the snapshot will change.  Merging the slicing and slice rules together doesn't change that aspect</p>",
        "id": 153880255,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490797823
    },
    {
        "content": "<p>I realize that this is quite subtle. Initially, we tried to implement the proposed behavior (merge slice entry constraint onto named slices). But we received feedback from our customers who found the behavior unpredictable and counterproductive. So we had a team discussion about this topic and analyzed a number of differerent use cases. This resulted in the current behavior, as I described above.</p>",
        "id": 153880256,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490797869
    },
    {
        "content": "<p>Yes, snapshot generation is relatively straightforward. But e.g. in Forge, we need to dynamically maintain references to the correct base element in order to determine what information to include in the differential. It turns out that these in-memory base element references are not 1-1 equal to snapshot element definitions, as Forge also needs to merge external type profiles and extension definitions. This becomes much harder if the base element references point to another element in the referencing profile itself.</p>",
        "id": 153880257,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490798071
    },
    {
        "content": "<p>Also note that Forge needs to expand *all* elements, even without child constraints, in order to generate a full element tree. This involves an additional processing step after snapshot generation.</p>",
        "id": 153880258,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490798165
    },
    {
        "content": "<p>So although the snapshot is definitely useful, it does not provide *ALL* information. In general, this is not even possible due to recursive relations (i.e. Identifier.assigner / ResourceReference.identifier).</p>",
        "id": 153880259,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490798293
    },
    {
        "content": "<p>Ewout's validator e.g. dynamically pulls in external type profiles on demand.</p>",
        "id": 153880261,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490798328
    },
    {
        "content": "<p>So there is always a need for additional processing.</p>",
        "id": 153880262,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490798332
    },
    {
        "content": "<p>Does Forge ensure that constraints in the slices don't conflict with constraints in the slicing element?  What about descriptive information?  Do slices inherit the generic descriptions of the parent instead of the more specific descriptions of the slicing element?</p>",
        "id": 153880263,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490799221
    },
    {
        "content": "<p>Both the API snapshot generator as well as Forge do NOT actively merge slice entry constraints onto named slices. However Forge already provides a number of validation warnings for insensical/conflicting constraints, and we will improve this continously in future builds.</p>",
        "id": 153880264,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490799584
    },
    {
        "content": "<p>Slice entries and named slices inherit constraints from the associated element in the base resource. Note that this only affects what is included in/excluded from the differential. Named slices in the same profile inherit constraints (including e.g. description, but specifically excluding min cardinality) from the associated element in the base profile. This can be an unsliced element, a slice entry or a named slice. But elements never inherit constraints from other elements *in the same profile*, and a named slice also never inherits from the slice entry *in the same profile*.</p>",
        "id": 153880266,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490799874
    },
    {
        "content": "<p>Again, all this does NOT imply that constraints on a slice entry don't apply to named slices - this still holds. It only affects the contents of differential and snapshot representations.</p>",
        "id": 153880267,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490799955
    },
    {
        "content": "<p>If I override a definition or usage notes in the \"slicing\" section, it's going to be somewhat annoying to have to do the same override on every single slice (or to end up inheriting the documentation of the base)</p>",
        "id": 153880268,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490800047
    },
    {
        "content": "<p>If you want to explicitly include inherited slice entry constraints in the profile, then you can create a base profile with a slice entry (but no slices) and a derived profile that actually introduces named slices. Then the named slices in the snapshot of the derived profile WILL inherit constraints from the slice entry in the base profile.</p>",
        "id": 153880269,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490800087
    },
    {
        "content": "<p>Creating extra profiles is rather kludgy</p>",
        "id": 153880270,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490800155
    },
    {
        "content": "<p>I see your point. It definitely helps to get a clear picture of all the different use cases. That's how we finally realized that minimum cardinality of named slices should not follow normal inheritance rules.</p>",
        "id": 153880271,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490800165
    },
    {
        "content": "<p>Sure.  I get the cardinality difference.  But I don't see any other negative impacts.  What other impacts did your users report?</p>",
        "id": 153880272,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490800226
    },
    {
        "content": "<p>Well they found the (old style) snapshot merging to be confusing.</p>",
        "id": 153880273,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490800632
    },
    {
        "content": "<p>Specifically, the NHS has been a tremendous help in testing all the different slicing scenario's and use cases.</p>",
        "id": 153880274,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490800697
    },
    {
        "content": "<p>They have built a custom profile rendering tool that depends on the snapshot. Their experiences with publishing (complex) profiles led to a number of change requests for Forge and the API.</p>",
        "id": 153880276,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490800829
    },
    {
        "content": "<p>Given that the merging *does* occur from a validation perspective, I'm curious what aspects they found confusing</p>",
        "id": 153880279,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490805619
    },
    {
        "content": "<p>Late to the game...I agree with <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  (see here: <a href=\"https://github.com/chrisgrenz/FHIR-Primer/wiki/Snapshots-Determining-Refines#new-specializations\" target=\"_blank\" title=\"https://github.com/chrisgrenz/FHIR-Primer/wiki/Snapshots-Determining-Refines#new-specializations\">https://github.com/chrisgrenz/FHIR-Primer/wiki/Snapshots-Determining-Refines#new-specializations</a>) - a named slice (e.g. MRN) refines it's slice root (e.g. Patient.identifier) and accumulates any constraints there, in this case a combination of Element, Identifier, Patient.identifier, and slice MRN.  A reslice (MRN/MyLegacyEHR) refines it's root (MRN) and would accumulate from there.  How to accumulate is already pretty well defined I think?  Not sure where <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> is seeing a 3-way merge? It's straight accumulation up the path.</p>",
        "id": 153880297,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1490814816
    },
    {
        "content": "<p>3-way merge is base + slicing root from differential + slice from differential</p>",
        "id": 153880302,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490815976
    },
    {
        "content": "<p>That's not 3-way, that's 2-way twice (slice + slice root, combination + base).  We already do this *lots*.</p>",
        "id": 153880309,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1490816456
    },
    {
        "content": "<p>Well, 2 2-way merges is still a 3-way.  It's just a question of how you architect it.  It actually gets a tad more fun if you're constraining existing slices.  In that case, it's a 4-way merge - New slice snapshot needs to include the intersection of the original slice differential + the application of new slice base on old slice base + new slice constraints.  It's not overly pretty to do.</p>",
        "id": 153880311,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490816663
    },
    {
        "content": "<p>But it's even less pretty for downstream systems to have to integrate the slice base constraints and slice constraints every time they need to use the snapshot</p>",
        "id": 153880312,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490816702
    },
    {
        "content": "<p>It's more than that. You also have to include constraints from the types.  And yes, the snapshot tooling should do all that up front - downstream systems shouldn't be dealing with *any* of this complexity</p>",
        "id": 153880313,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1490816770
    },
    {
        "content": "<p>Right.  It's an evil thing to do, so do it all in one place.  I'd really like more information about where the NHS had concerns with doing this.  Any insights <span class=\"user-mention\" data-user-id=\"191362\">@Richard Kavanagh</span> ?</p>",
        "id": 153880321,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490817268
    },
    {
        "content": "<p>Can I just confirm (in my simple clinFHIR way) Lloyds comment that a snapshot represents \"all the rules that apply here\". The details of this discussion are a bit deep for me, but I just want to be sure that when I get StructureDefinition resource, the snapshot is all I need to build the UI...</p>",
        "id": 153880347,
        "sender_full_name": "David Hay",
        "timestamp": 1490836571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191321\">@David Hay</span> The Forge UI needs to expand all elements with a complex datatype - so the user can define new constraints on child elements. The snapshot does not contain sufficient information, as complex elements are only expanded when the profile introduces differential constraints on child elements. So Forge needs to perform post-processing of the snapshot anyway, this is unavoidable.</p>",
        "id": 153880378,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490862097
    },
    {
        "content": "<p>And consider nested content references. Such a profile can be expanded to an infinitely deep nesting level. Those elements always need to be expanded on demand.</p>",
        "id": 153880379,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490862327
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span>, <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> concerning the merging of sliced elements in the snapshot, I strongly recommend that we always resolve the merge base from the (external!) base profile. Resolving base elements from the same differential introduces a can of worms, as now the base is no longer stable. Please keep in mind that not all logic works as a pipeline. A profile editor such as Forge needs to dynamically process changes throughout a profle in any order. Specifically, a user could create a named slice and subsequently go back and edit the constraints on the associated slice entry. According to the proposed merging scheme, all the existing named slices would then need to be re-merged with the updated slice entry, while handling all kinds of possible conflicts. I actually tried this and it proved to be extremely complex (as in: unfeasible) to implement correctly and confusing for the end user.</p>",
        "id": 153880380,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490862947
    },
    {
        "content": "<p>Ewout suggested that Forge could assist the modeller by automatically initializing newly created named slices by duplicating the constraints on the associated slice entry. All constraints on named slices would then be included in the differential and in the snapshot, as they are not actually inherited from the base.</p>",
        "id": 153880381,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490863215
    },
    {
        "content": "<p>This approach would provide a convenient workflow to the modeller, while still keeping the complexity of snapshot generation to a feasible/reasonable level...</p>",
        "id": 153880382,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490863329
    },
    {
        "content": "<p>Again, it is important to keep in mind that not all systems can be implemented as a pipeline. If we keep Introducing additional complexity in the snapshot generation rules, then the implementation of dynamic systems (such as editors) becomes unfeasible.</p>",
        "id": 153880383,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490863576
    },
    {
        "content": "<p>Therefore I'd strongly recommend for base elements to *always* be stable, i.e. resolved from external profiles.</p>",
        "id": 153880384,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490863811
    },
    {
        "content": "<p>Of course, a modeller can create a derived profile and then update the underlying base profile. Forge can detect this, re-load the derived profile and re-generate the snapshot. So this will kick of the pipeline, so to say.</p>",
        "id": 153880385,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1490863992
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> We dont have any specific issues regarding re-slicing at the moment but that's probably because we dont use that capability yet. My understanding is that this is only an issue if you \"profile a profile\" something which we do not yet do. We definitely have a requirement for this though concerns around tooling have meant we have deferred this for the moment.</p>",
        "id": 153880390,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1490875382
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> It doesn't matter what you do with your in-memory representation at runtime.  What we're talking about here is what's done when you persist.  And when you persist, <em>all</em> of the merging of the different pieces that come into play should have been performed.  Downstream applications who receive a snapshot shouldn't have to do any merging at all.  (Because merging is complicated and ugly and we want to limit the number of pieces of software that have to deal with that as much as possible.)</p>",
        "id": 153880410,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490894423
    },
    {
        "content": "<p>The resource is, by definition, a pipeline because it represents how data is exchanged.  It's not a representation of what you do dynamically in memory.</p>",
        "id": 153880411,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490894471
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191362\">@Richard Kavanagh</span> What I'm actually interested in is not re-slicing, but rather why you would not want the snapshot view of a slice to include the rules that you've set for all slices.</p>",
        "id": 153880412,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490894511
    },
    {
        "content": "<p>Yes, that what I was checking - that the snapshot in the saved resource was complete...</p>",
        "id": 153880481,
        "sender_full_name": "David Hay",
        "timestamp": 1490906440
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> not sure I have a view on this. It's really not an area of FHIR I am dealing with.</p>",
        "id": 153880514,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1490911865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> Who from the NHS was objecting to the integration of the slicing base into the slices in snapshot?  And was that driven by runtime behavior (which doesn't really matter for this conversation) or for persistence?</p>",
        "id": 153880519,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1490913049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> reading this thread makes it clear that these kind of issues should be discussed more widely than just in your team. Will save you (and me) from having to re-work...</p>",
        "id": 153880709,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1491190476
    },
    {
        "content": "<p>Michel, I'm confused by your description of the problem in Forge. What  Lloyd proposed is that the *snapshot* merge all this stuff. Are you implying that the user edits the snapshot?</p>",
        "id": 153880710,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1491190689
    },
    {
        "content": "<p>I've given this a lot of thought. Tomorrow I'm going to discuss the issue with Ewout. Then we'll get back on this.</p>",
        "id": 153880777,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1491217006
    },
    {
        "content": "<p>ok</p>",
        "id": 153880778,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1491217145
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> How did the discussion go?</p>",
        "id": 153881067,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1491450370
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> we've had a fruitful discussion about this issue. I've written down our findings in a presentation that I'd like to share. As all this is quite involved, Ewout &amp; I suggest that we schedule a Skype call to discuss this with you, Grahame, Chris and anyone else interested in this topic.</p>",
        "id": 153881078,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1491466118
    },
    {
        "content": "<p>Sounds good to me.  Perhaps send a doodle poll out to the FHIR list?  (and cc it on this thread)</p>",
        "id": 153881117,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1491490926
    },
    {
        "content": "<p>Sure, we could do a community poll - for the happy few that understand the topic...</p>",
        "id": 153881119,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1491491577
    },
    {
        "content": "<p>I'll be interested to join too.</p>",
        "id": 153881423,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1491603739
    },
    {
        "content": "<p>Me too ...</p>",
        "id": 153881430,
        "sender_full_name": "David Hay",
        "timestamp": 1491611734
    },
    {
        "content": "<p>+1</p>",
        "id": 153881432,
        "sender_full_name": "Eric Haas",
        "timestamp": 1491615965
    },
    {
        "content": "<p>+1</p>",
        "id": 153881450,
        "sender_full_name": "Oliver Egger",
        "timestamp": 1491670646
    },
    {
        "content": "<p>Maybe we can discuss this topic in today's infrastructure call?</p>",
        "id": 153881561,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1491813905
    },
    {
        "content": "<p>Mon Apr 10, 2017 03:00 PM (US Eastern Time, GMT -4 DST)<br>\nPlease consult <a href=\"http://www.timeanddate.com/worldclock/fixedtime.html?iso=20170410T1500&amp;p1=784\" target=\"_blank\" title=\"http://www.timeanddate.com/worldclock/fixedtime.html?iso=20170410T1500&amp;p1=784\">http://www.timeanddate.com/worldclock/fixedtime.html?iso=20170410T1500&amp;p1=784</a> for your local times. </p>",
        "id": 153881562,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1491813921
    },
    {
        "content": "<p>FYI: the discussion about slicing base has been scheduled for the FHIR-I call on Monday April 24th. Feel free to join!</p>",
        "id": 153881694,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1491898533
    }
]