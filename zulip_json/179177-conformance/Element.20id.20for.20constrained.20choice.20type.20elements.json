[
    {
        "content": "<p>Another question.</p>\n<p>We've defined  rules for generating a standard element id. For renamed choice type elements constrained to a single type, the convention is the generate an id that includes both the original and the new element name:<br>\n\"{parent-path}.{original-element-name}:{new-element-name}\"<br>\nFor example: \"Observation.value[x]:valueString\"</p>\n<p>The element id generator in the FHIR .NET API picks up the second part (after \":\") from the sliceName property. So when the user constrains a choice type elements to a single type:<br>\n1. Forge determines the new element name, depending on the selected type<br>\n2. Forge updates the .path property to include the new element name<br>\n3. Forge initializes the .sliceName property with the new element name<br>\n4. Forge re-generates the element id from the new element name and sliceName</p>\n<p>This actually introduces a sliceName value on an unsliced choice type element without a slice entry. Rick Geimer pointed out that this may be invalid...?</p>\n<p>If FHIR does not allow assigning a slice name to an unsliced choice type element, then the element id generator would have to detect renamed choice type elements by inspecting ElementDefinition.Base.Path - which is generally unavailable in the differential...</p>",
        "id": 153911252,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1506610543
    },
    {
        "content": "<p>Type choices are implicitly sliced by type with slices for each allowed type.  In other words, it is NOT valid to directly slice value[x].  You may reslice one of the existing slices: <code>Extension.value[x]:valueCoding/loinc-slice</code></p>",
        "id": 153911262,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1506615151
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span>, thank you for chipping in. Do you mean that my current approach is invalid, i.e. it is NOT allowed to initialize the sliceName property for a renamed choice type element? So instead, I should explicitly leave sliceName empty and generate the correct element Id using different means.</p>",
        "id": 153911667,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1506949232
    },
    {
        "content": "<p>valueString is already a slice of value[x]. A slice then would actually be a re-slice of valueString:<br>\n<code>Extension.value[x]:valueString/mySlice</code></p>",
        "id": 153911680,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1506949623
    },
    {
        "content": "<p>Following your interpretation, so if we consider valueString to be an (implicit) slice on value[x], then FHIR dictates we SHALL initialize the sliceName property, in this case to \"valueString\b\"?<br>\nIn other words, my current logic is correct and I should report back to Rick that this approach is actually valid/mandatory?</p>",
        "id": 153911683,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1506949887
    },
    {
        "content": "<p>I'd say to be consistent, the snapshot should include valueString as slice name for the type slice. This could not be modified in the differential (similar to the discriminator on Resource.extension)</p>",
        "id": 153911711,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1506951104
    },
    {
        "content": "<p>Great, then I don't need to change my current logic! ;p<br>\nThank you for your help. I'll inform Rick about our discussion.</p>",
        "id": 153911795,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1506955409
    },
    {
        "content": "<p>Trying to follow this.. It doesn't entirely make sense to me. What is the approach we are concluding, to indicate in a profile that value[x] SHALl be valueString? (limiting the selection of value[x] to JUST valueString). There are two criteria that I can think would be considered:<br>\n1) what type is allowed by value[x]? (how do you limit the selection of type to one or just a few types?)<br>\n2) is value[x] required? (how do you indicate that value[x] is required, even if the options are limited to a smaller subset)?</p>",
        "id": 153911836,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1506961192
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191505\">@Sean McIlvenna</span> valueString is a slice (an implicit type slice) of value[x].  In STU3 there's some ambiguity about this and that ambiguity will be resolved in R4.  <em>Some</em> implementations in R3 interpreted the presence of valueString to be a constraint on value[x] limiting all instances to string. Some did not.  Directly to your questions:<br>\n1) the type element of ElementDefinition on the value[x] declaration limits the valid types.  To further constrain allowable types, restate the type block in a differential for the value[x] element.<br>\n2) making value[x] required means adding min=1 (or more) to the value[x] element.</p>",
        "id": 153911855,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1506967275
    },
    {
        "content": "<p>So it sounds like for both of these scenarios, all that needs to exist is:</p>\n<div class=\"codehilite\"><pre><span></span>&lt;element id=&quot;Observation.value[x]&quot;&gt;\n  &lt;min value=&quot;1&quot; /&gt;\n  &lt;type&gt;\n    &lt;code value=&quot;Quantity&quot; /&gt;\n  &lt;/type&gt;\n  &lt;type&gt;\n    &lt;code value=&quot;string&quot; /&gt;\n  &lt;/type&gt;\n&lt;/element&gt;\n</pre></div>",
        "id": 153911856,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1506968277
    },
    {
        "content": "<p>It sounds like what you're saying is that slices are NOT needed/desired to represent this scenario...</p>",
        "id": 153911857,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1506968336
    },
    {
        "content": "<p>Makes the value mandatory and of type String or Quantity. As stated, this will work in all validators.</p>",
        "id": 153911858,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1506968353
    },
    {
        "content": "<p>So, I don't think this is the same way that <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> is doing this... <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> , can you confirm?</p>",
        "id": 153911859,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1506968409
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191505\">@Sean McIlvenna</span>, Forge supports both. If you constrain value[x] to a <em>single</em> type, then the element is renamed to e.g. valueString. But if you specify multiple type constraints, then the element retains the original name e.g. value[x].</p>",
        "id": 153912033,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1507026687
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> , So when does Forge decide to create a slice out of the choice?</p>",
        "id": 153912075,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1507042802
    },
    {
        "content": "<p>The user decides, by clicking on the \"slice\" button. Then Forge creates an actual slice entry and allows you to add slices. Forge detects when you slice a choice type element and automatically initializes the slicing discriminator for a type slice to { Type = \"Type\", Path = \"$this\" }. The user should make sure that all the slices have different type constraints, Forge does not validate this (yet).</p>",
        "id": 153912076,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1507043443
    },
    {
        "content": "<p>Constraining a choice type element to a single type is considered an \"implicit slice\". This causes the element to be renamed, but it does not introduce an actual slice entry (in both differential and snapshot).</p>",
        "id": 153912077,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1507043630
    },
    {
        "content": "<p>Note that if you constrain a slice of a choice type element to a single type, Forge maintains the original element name. Element renaming only applies if a choice type element is constrained to a <em>single</em> datatype (and not sliced).</p>",
        "id": 153912080,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1507043929
    },
    {
        "content": "<p>Why would the element be \"renamed\" due to the presence of a type slice? It should just have a sliceName of the reserved name (valueString).</p>",
        "id": 153912116,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1507060189
    }
]