[
    {
        "content": "<p>With the arrival of the new packaging feature in Simplifier, we have reopened the discussion of how to handle versioning of profiles.<br>\nThe precise use case is that we are maintaining national profiles, that are still immature, so they we expect to have occational breaking changes in the future but people are already starting to derive their profiles from our profiles and need a way to be able to reference a stable version.<br>\nPackages give us a way to do this. but the question we're still undecided about is whether we also need to maintain version numbers in the canonical urls, e.g. <code>.../Patient-core/1.0</code>  followed by <code>.../Patient-core/2.0</code> in the next release.</p>\n<p>The only reason (we're aware of) why we would want to do this is that it allows an instance of a resource to calim conformance to a specific version of a profile.<br>\nHowever, it's a big effort to maintain this (just imagine having to update all references to Patient in your IG/package...)</p>\n<p>So the question is: <br>\n1. What are good reasons why instances need version specific profile.meta references? <br>\n2. Are there reasons why they shouldn't ?<br>\n3. Why was the use of canonical ruled out for profile.meta, that would have allowed an optional addition of the version in a pipe-separated notation such  as <code>.../Patient-core|2.0</code>?<br>\n4. How are other IG authors handling this?</p>",
        "id": 154002502,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538256689
    },
    {
        "content": "<p>Erk.  Um, I don't know why meta.profile doesn't allow canonical.  I know I've got implementation guides that use it that way...</p>",
        "id": 154002517,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538256896
    },
    {
        "content": "<p>Certainly wanting your profile reference to be version-specific is a reasonable thing to want.  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, is this something that would be an allowed change in a future version or are we now stuck?</p>",
        "id": 154002519,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538256948
    },
    {
        "content": "<p>i can see benefits for both ways: specifying the profile including the version, and without. <br>\nWith uri as profile datatype in meta you can't do both. With canonical as profile dataType this would be possible and much easier.</p>",
        "id": 154002545,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1538257577
    },
    {
        "content": "<p>\"Certainly wanting your profile reference to be version-specific is a reasonable thing to want.\" <br>\n<span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> , can you give me some reasons why?</p>",
        "id": 154002546,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538257581
    },
    {
        "content": "<p>Because there's no expectation that different versions of a profile will impose the same constraints or be compatible</p>",
        "id": 154002550,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538257917
    },
    {
        "content": "<p>So when you declare conformance, you want to be specific.</p>",
        "id": 154002551,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538257934
    },
    {
        "content": "<p>But you don't necessarily want the canonical URL to change.</p>",
        "id": 154002552,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538257948
    },
    {
        "content": "<p>Why is it important for the client to declare version specific conformance?<br>\nCouldn't the instance by chance still be conformant with a newer version even if a breaking change has been made? <br>\n(Like a newer version has added a requirement that has already been voluntarily satisfied by the client implementation).<br>\nShould a server reject a resource solely based on version mismatch in the declaration even if the resource validates against the server's requirements?<br>\nShould servers rely on a client's conformance claim without running validations against their own profiles?</p>",
        "id": 154002558,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538258399
    },
    {
        "content": "<p>Client declaration gives a hint as to what validation a server should perform.  It's costly for servers to validate against all possible profiles - or even all possible versions.  A client declaration isn't an indication of everything they're conformant with, but is an indication of what they believe they're conformant with that they believe recipients are likely to care about/use</p>",
        "id": 154002559,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538258530
    },
    {
        "content": "<p>Why would a server support more than one version of a profile at the same time?</p>",
        "id": 154002560,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538258787
    },
    {
        "content": "<p>I‘m not saying that it shouldn’t, I just don’t see a real world use case that’s 80% enough to convince me of the necessity for versioned canonicals (especially considering the pain that comes with them)</p>",
        "id": 154002562,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538258952
    },
    {
        "content": "<p>Servers support multiple versions because the clients don't all move at the same time</p>",
        "id": 154002564,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538259255
    },
    {
        "content": "<p>I've got a couple of clients already doing exactly that.</p>",
        "id": 154002566,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538259271
    },
    {
        "content": "<p>Couldn‘t this be addressed by attempting validation against the preferred version and - if that fails - try any supported older version before  refusing the resource?</p>",
        "id": 154002575,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538261252
    },
    {
        "content": "<p>Do you have an example of an IG that uses versioned canonicals?</p>",
        "id": 154002576,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538261295
    },
    {
        "content": "<p>Is there any tooling for publishing versioned canonical IGs or is that manual labor?</p>",
        "id": 154002577,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538261433
    },
    {
        "content": "<p>No public IGs.  Two private ones.  The server doesn't want to validate against more than one version.  It wants the client to tell it what it's claiming and then to check that and process it or reject it.  There could be 3 or 4 versions in use at any given time.</p>",
        "id": 154002596,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538264486
    },
    {
        "content": "<p>One of the problems of profile (canonical) versioning is that profiles don't live in isolation.  And once resources start conforming (meta.profile) to individual versioned profiles, they will also have to start versioning all references.</p>",
        "id": 154002620,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538295716
    },
    {
        "content": "<p>Profiles can evolve at different speeds. And so it's very easy to create incompatible round trips. Something now suddenly the client will have to solve.</p>",
        "id": 154002621,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538295839
    },
    {
        "content": "<p>And they won't</p>",
        "id": 154002622,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538295894
    },
    {
        "content": "<p>And a resource is likely to conform to a range of profile versions that are backwards compatible. But I don't see resources having semver ranges and wildcards in their url.</p>",
        "id": 154002623,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538296121
    },
    {
        "content": "<p>Generally the dependencies are managed at the IG level, not the profile level.  And IG relationships are always version -specific.  Profiles inherit their version from the IG they're released in.</p>",
        "id": 154002642,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538306773
    },
    {
        "content": "<p>Even if they didn't change since the previous IG version?<br>\nWe currently do the same for the German base profiles, but doing this manually, including changing all the IG internal references to the profiles (e.g. targetProfile), is a lot of work and prone to error. Therfor the question about tooling.</p>",
        "id": 154002643,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538308077
    },
    {
        "content": "<p>The power of the packaging draft we have now is that it uses npm SemVer ranges to manage backward compatibility. We've have implemented this in our package manager client. And sofar the results are promising. This issue is not new. It has been solved already in various degrees of success in the 'bigger' programming languages. nuget in C#, npm in js. etc. Just replace profile with 'class'.</p>",
        "id": 154002646,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538309261
    },
    {
        "content": "<p>The problem is: we have to decide <em>now</em> whether we version our URLs or not and whatever we decide, we will have to maintain it and live with it forever. So we really would like to hear as many opinion and experiences as possible.<br>\nIMO the ideal solution would have been the canonical notation which makes the use of versions optional (unless a profile indicates otherwise) and removes the requirement to maintain the versioned URLs independently or struggle with reference integrity.</p>\n<p>But it seems this option is out of the game. Was it a conscious decision or an oversight that profile.meta is not canonical?</p>",
        "id": 154002658,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538310672
    },
    {
        "content": "<p>Yes.  The profiles get versioned whether they changed or not (and whether the changes were substantive or breaking or not)</p>",
        "id": 154002663,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538311659
    },
    {
        "content": "<p>It's not mandatory to do that when you use the IG publisher, but I believe all of the HL7-published IGs do so and all the clients I've worked with have used that approach.  It also ties into the package-baged publication approach for IGs</p>",
        "id": 154002666,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538311746
    },
    {
        "content": "<p>I'm not sure if we aren't artifically lowering interoperability when servers expect a certain version, but get another and reject it, when in fact the profiles didn't  change at all. (...or maybe just added a new required field, that the client has always been populating anyway)<br>\nI'd much rather have the server to at least make an attempt to validate the instance and then decide upon the result wether to reject or accept it.</p>\n<p>I would also expect (many?/most?) servers to have additional constraints to whatever profile they support (like e.g. a maximum number of addresses per Patient or additional required fields) so it would have to test the instances anyway regardless of their conformance claim.</p>\n<p>If servers don't validate incoming resources but simply try to run them through whatever processing they do, the processing might either succeed or fail. So why not just try regardless of profile version and accept or reject depending on the outcome?</p>",
        "id": 154002687,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538312983
    },
    {
        "content": "<p>I think that openness may be one valid behavior, while in other cases you definitely want to bind your instance to an explicit version of a profile.</p>",
        "id": 154002689,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538313147
    },
    {
        "content": "<p>canonical with pipe notation would (would have?) allow(ed) that</p>",
        "id": 154002691,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538313180
    },
    {
        "content": "<p>True, I'm just not sure yet, how \"corner\" these cases are and if they could not be solved with a version-extension on profile.meta (assuming that pipe notation is out) and not burden the rest of the world (both IG authors and implementers) with this added complexity.</p>",
        "id": 154002693,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538313332
    },
    {
        "content": "<p>Agreed on a core extension as a possible solution for the instance profile version claim.</p>\n<p>Another issue in this context is that derived profiles definitely need to be able to tell the exact version of the profile they derive from. Everything may result in any kinds of strange behavior.<br>\nSD.baseDefinition is of type canonical, so that's fine from a spec point of view. Maybe the importance of using [URL]|[version] here should be pointed out somewhere.<br>\nAsking the Toolsmith: <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> Does/will Forge support automagically adding \"|version\" into baseDefinition?<br>\nAlso the reference server need to support that</p>",
        "id": 154002714,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538313830
    },
    {
        "content": "<p>I agree that servers requiring profile declaration of any sort isn't super-friendly, but it's a relatively cheap thing for clients to do and it means a considerable saving on the server side.  It does mean that servers have to be in a situation where they can demand changes to a client instance - and that won't always be the situation.</p>",
        "id": 154002752,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538315472
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191436\">@Stefan Lang</span> but that's exactly the problem that packaging solves quite neatly. The only thing packages don't solve is the declaration in the instance...</p>",
        "id": 154002766,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538316022
    },
    {
        "content": "<p>True. If everybody uses packages ...</p>",
        "id": 154002769,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538316094
    },
    {
        "content": "<p>Still, as far as I understand it, once a package is loaded into a FHIR server, every profile stands on it's own.<br>\nThe FHIR server does not know anything about package versions (...if they are not identifical to SD.version ...). Sound like an indeterminancy here?</p>",
        "id": 154002794,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538316638
    },
    {
        "content": "<p>In most cases a fhir server will have an implicit a \"scope\" or \"context\" that has several packages. I can imagine that such a context deserves it's own endpoint. Because that is a much more natural language for a FHIR client and far less hassle.</p>",
        "id": 154002806,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538317156
    },
    {
        "content": "<p>Client software having to keep track of canonical URL versions is hard to enforce and error prone.</p>",
        "id": 154002811,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538317253
    },
    {
        "content": "<p>Because it's the client defining it's own rules on the server.</p>",
        "id": 154002826,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538317610
    },
    {
        "content": "<p>Yes, Grahame and I were just shortly discussing this: it is true that the complexity is now on the client. The instance the client pushes would have to be explicit about the version of the structuredefinition. But it does not stop there. That structuredefinition should then also be explicit about the SDs it itself references.  So, when uploading a StructureDefinition, the client should be explicit about the versions in the canonical references, if multiple can exist on the server. That does not sound attractive.  One solution is that when you POST a StructureDefinition, the server knows about the versioning context and resolves it at that early point. Another would be that you somehow specify the context the moment you call $validate.</p>",
        "id": 154002838,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538317849
    },
    {
        "content": "<p>Actually, I wasn't thinking about Clients posting SDs, I was thinking about Clients posting Resource Instances which conform to a specific version of a profile... e.g.: a Patient resource conforming to <a href=\"http://fhir.de/StructureDefinition/patient-de-basis\" target=\"_blank\" title=\"http://fhir.de/StructureDefinition/patient-de-basis\">http://fhir.de/StructureDefinition/patient-de-basis</a>  in the version 0.8</p>",
        "id": 154002852,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538318563
    },
    {
        "content": "<p>Right now, the client doesn't have a way of saying that it's 0.8</p>",
        "id": 154002854,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538318595
    },
    {
        "content": "<p>(apart from having the version as part of the SD's canonical url, that is ...)</p>",
        "id": 154002856,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538318630
    },
    {
        "content": "<p>Yep. but as I understand it, the whole point of packaging is to avoid just that.</p>",
        "id": 154002857,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538318662
    },
    {
        "content": "<p>Yes, but before that there was at least some entity that installed those structuredefinitions on the server - that's what I meant with \"client\" here. The moment you submit a set of conformane resources to a server, you could resolve all canonicals to make them explicit about the version they refer to.</p>",
        "id": 154002858,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538318673
    },
    {
        "content": "<blockquote>\n<p>Right now, the client doesn't have a way of saying that it's 0.8</p>\n</blockquote>\n<p>Patient.meta.profile= \"<a href=\"http://mysource.org/fhir/mysd|0.8\" target=\"_blank\" title=\"http://mysource.org/fhir/mysd|0.8\">http://mysource.org/fhir/mysd|0.8</a>\"  you mean?</p>",
        "id": 154002859,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538318721
    },
    {
        "content": "<p>Yes, we can't do that because meta.profile is of type uri, not canonical</p>",
        "id": 154002860,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538318756
    },
    {
        "content": "<p>I mean \"<a href=\"http://mysource.org/fhir/mysd/0.8\" target=\"_blank\" title=\"http://mysource.org/fhir/mysd/0.8\">http://mysource.org/fhir/mysd/0.8</a>\" or similar, since meta.profile does not allow for \"|\"</p>",
        "id": 154002861,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538318764
    },
    {
        "content": "<p>well, uri is a superset of canonical, so you can.</p>",
        "id": 154002862,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538318792
    },
    {
        "content": "<p>uh? is it?</p>",
        "id": 154002863,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538318813
    },
    {
        "content": "<p>But does any server support that?</p>",
        "id": 154002864,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538318814
    },
    {
        "content": "<p>I thought we had introduced canonical because uri didn't allow pipes....?</p>",
        "id": 154002866,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538318849
    },
    {
        "content": "<p>\"The canonical type differs from a uri in that it has special meaning in this specification, and in that it may have a version appended, separated by a vertical bar (|).\"</p>",
        "id": 154002867,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538318857
    },
    {
        "content": "<p>That implies url does not allow pipe</p>",
        "id": 154002869,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538318878
    },
    {
        "content": "<p>That bit of text is from R4, where Meta.profile is a canonical, so that's not a problem.  Note that we should <em>not</em> forbid a pipe in a url - but there is already a ballot comment to fix that formulation.</p>",
        "id": 154002877,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319079
    },
    {
        "content": "<p>Nope: <a href=\"http://build.fhir.org/resource.html#Meta\" target=\"_blank\" title=\"http://build.fhir.org/resource.html#Meta\">http://build.fhir.org/resource.html#Meta</a>  it's uri</p>",
        "id": 154002878,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538319136
    },
    {
        "content": "<p>sound like black magic:<br>\n<a href=\"/user_uploads/10155/xHBzv21w-AyiWVJeUePmtKVX/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/xHBzv21w-AyiWVJeUePmtKVX/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/xHBzv21w-AyiWVJeUePmtKVX/pasted_image.png\"></a></div>",
        "id": 154002882,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319183
    },
    {
        "content": "<p>;-) Are you sure you are looking at <a href=\"http://build.fhir.org\" target=\"_blank\" title=\"http://build.fhir.org\">build.fhir.org</a>?</p>",
        "id": 154002885,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319243
    },
    {
        "content": "<p>canonical: A URI that refers to a canonical URI. The canonical type differs from a uri in that it has special meaning in this specification, and in that it may have a version appended, separated by a vertical bar (|). Note that the type canonical is not used for the actual canonical URls that are the target of these references, but for the URLs that refer to them, and may have the version suffix in them. Canonical URLs may also have #fragment references</p>",
        "id": 154002887,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538319282
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/KF4uynyCPRR1-mwc1-2yUEVf/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/KF4uynyCPRR1-mwc1-2yUEVf/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/KF4uynyCPRR1-mwc1-2yUEVf/pasted_image.png\"></a></div>",
        "id": 154002888,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538319289
    },
    {
        "content": "<p>It's not updated here: 2.26.3.7</p>",
        "id": 154002889,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319293
    },
    {
        "content": "<p>yep.</p>",
        "id": 154002890,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319297
    },
    {
        "content": "<p>That's an ouch ...</p>",
        "id": 154002891,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538319317
    },
    {
        "content": "<p>nah, that's a gForge issue.</p>",
        "id": 154002894,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319327
    },
    {
        "content": "<p>Is it already?</p>",
        "id": 154002895,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538319348
    },
    {
        "content": "<p>Ok, can we reset this conversation, please :D</p>",
        "id": 154002898,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538319425
    },
    {
        "content": "<p>the authortitative source for Meta.profile is that able below the one Simone quotes above. that's a typo we can just fix.</p>",
        "id": 154002899,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1538319426
    },
    {
        "content": "<p><a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=18985\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=18985\">GF#18985</a></p>",
        "id": 154002900,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319490
    },
    {
        "content": "<p>you beat Lloyd</p>",
        "id": 154002901,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1538319500
    },
    {
        "content": "<p>and me :P</p>",
        "id": 154002902,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538319518
    },
    {
        "content": "<p>Well, at least now everyone reading this is aware of this subtle R4 change ;-)</p>",
        "id": 154002904,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319563
    },
    {
        "content": "<p>Sooooo....about versiones URLs.... anyone still care about those? Or can we all go home now?</p>",
        "id": 154002905,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538319565
    },
    {
        "content": "<p>(regarding R4 of course).<br>\nYou'll probably still need them to work around the absence of \"canonical\" in STU3...</p>",
        "id": 154002906,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538319631
    },
    {
        "content": "<p>If the reference servers support pipe notation here, I'm completely happy.</p>",
        "id": 154002907,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538319638
    },
    {
        "content": "<p>STU3 is sooooo 2018 ...</p>",
        "id": 154002909,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538319660
    },
    {
        "content": "<p>This was possible in STU3 too, but we didn't call it out explicitly - that's one of the reasons we introduced \"canonical\". You don't have to read the details description of a property to see you can use it logically as a canonical reference. In STU3 you had to dive into the description to see that.</p>",
        "id": 154002911,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319733
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191436\">@Stefan Lang</span>  - guilty as charged, our server doesn't yet.</p>",
        "id": 154002912,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319791
    },
    {
        "content": "<p>where do we need to support it?</p>",
        "id": 154002914,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1538319834
    },
    {
        "content": "<p>We don't yet resolve |version to the correct version of a conformance resource. (e.g. in Meta.profile)</p>",
        "id": 154002915,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319922
    },
    {
        "content": "<p>when do we resolve?</p>",
        "id": 154002916,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1538319934
    },
    {
        "content": "<p>behind the $valdiate operation - any other time?</p>",
        "id": 154002917,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1538319949
    },
    {
        "content": "<p>yes, snapshot time</p>",
        "id": 154002918,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538319960
    },
    {
        "content": "<p>I'll add getting this sorted to my list of things to do</p>",
        "id": 154002919,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1538320013
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> do you have any plans to migrate from hardcoded versioned urls to canonical versioned urls in the future, or do you still see advantages in hardcoding them?</p>",
        "id": 154002923,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538320143
    },
    {
        "content": "<p>both models will continue going forward</p>",
        "id": 154002924,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1538320224
    },
    {
        "content": "<p>I guess the same holds true for valuesets.</p>",
        "id": 154002926,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538320277
    },
    {
        "content": "<p>y</p>",
        "id": 154002927,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1538320283
    },
    {
        "content": "<p>I use canonical versioned urls</p>",
        "id": 154003004,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538321660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191436\">@Stefan Lang</span> </p>\n<blockquote>\n<p>Does/will Forge support automagically adding \"|version\" into baseDefinition?</p>\n</blockquote>\n<p>Currently not. Do you think we should address this?</p>",
        "id": 154003012,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538321934
    },
    {
        "content": "<p>yes, that would be nice</p>",
        "id": 154003016,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1538321971
    },
    {
        "content": "<p>Definitely. For those deterministic guys like me ;)</p>",
        "id": 154003020,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538322040
    },
    {
        "content": "<p>Another place where the servers will have to support pipe notation then, also <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span></p>",
        "id": 154003030,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538322187
    },
    {
        "content": "<p>OK, good to know. I will definitely look into this when we start working on Forge for R4 (after final FHIR R4 publication). Do you also need this for STU3?</p>",
        "id": 154003035,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538322260
    },
    {
        "content": "<p>Does it make sense to append the version to all canonical references when creating a package?</p>",
        "id": 154003099,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538323437
    },
    {
        "content": "<p>To me, it feels redundant, but I know that Stefan disagrees :)</p>",
        "id": 154003102,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538323469
    },
    {
        "content": "<p>I do :D</p>",
        "id": 154003104,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538323478
    },
    {
        "content": "<p>It's just not deterministic.<br>\nHow can I specify a clear derived profile when I don't say which profile exactly I'm deriving from?</p>",
        "id": 154003105,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538323530
    },
    {
        "content": "<p>That brings us back to the point where everyone has to deal with the added complexity simply because we want to satisfy those who don't use packages.</p>",
        "id": 154003106,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538323583
    },
    {
        "content": "<p>And I don't see how packaging (in it's current state) would help here, since the FHIR server doesn't know about packages ... at least not mandatory</p>",
        "id": 154003107,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538323619
    },
    {
        "content": "<p>It would really help if there is a 'standard' way of describing how a FHIR server can conform to a package, a set of package or an IG. In my slowly evolved thought process around packages, I now call that a Context.</p>",
        "id": 154003110,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538323742
    },
    {
        "content": "<p>Which is basically a list of package references.</p>",
        "id": 154003111,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538323763
    },
    {
        "content": "<p>And which includes the indirect package dependencies.</p>",
        "id": 154003112,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538323785
    },
    {
        "content": "<p>The best part is that a single package itself conforms to the definition of a context.</p>",
        "id": 154003113,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538323804
    },
    {
        "content": "<p>So each resource from a package would have a reference to that context attached somehow?<br>\nWould that also work without a FHIR server (there are people who use FHIR file based)?<br>\nLike an extension referring to the context in each SD?</p>",
        "id": 154003121,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538323919
    },
    {
        "content": "<p>Would it make sense to have the packaging-tool automatically update all canonical resources to version specific resources?<br>\n(Whatever the versions of the resources are at the time of packaging?)</p>",
        "id": 154003145,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538324439
    },
    {
        "content": "<p>Right, that would be great. Some preprocessing to add the version within the SD right before publishing (aka packaging)</p>",
        "id": 154003153,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1538324640
    },
    {
        "content": "<p>@Simone do you mean update all canonical resource references?</p>",
        "id": 154003158,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538324691
    },
    {
        "content": "<p>I'm afraid so</p>",
        "id": 154003159,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538324717
    },
    {
        "content": "<p>So IIUC, you'd like to explicitly inject |version into all unversioned canonical urls in all profiles (all conformance resources?) in the package?</p>",
        "id": 154003161,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538324770
    },
    {
        "content": "<p>Although: In fact only those  targeting resources in the same package</p>",
        "id": 154003162,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538324797
    },
    {
        "content": "<p>I'm somewhat reluctant in that providing this feature could be perceived as encouraging users to do this...</p>",
        "id": 154003164,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538324839
    },
    {
        "content": "<p>Maybe tuck it away in an advanced menu option or something.</p>",
        "id": 154003165,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538324861
    },
    {
        "content": "<p>Why would we want to discourage it? <br>\n(Which brings us back to the question we started with): What are the pros/cons of explicit references?</p>",
        "id": 154003167,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538324908
    },
    {
        "content": "<p>Personally I am against explicit version referencing, exactly because you would need tooling to bulk-fix stuff. And conceptually it does the exact same thing as defining a context. Except that now the client tools need to be aware of it - and fix it with each update. And there won't be tools bulk-fixing the client software.</p>",
        "id": 154003178,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538325257
    },
    {
        "content": "<p>If you choose to allow each profile to have it's own version - you'll enter version hell. If you choose to have all profiles upgrade the version with rest the group, you create false incompatibility. So: it's every which way but loose.</p>",
        "id": 154003179,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1538325342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191450\">@Simone Heckmann</span> mainly because it is \"contageous\" (like async)</p>",
        "id": 154003180,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538325389
    },
    {
        "content": "<p>Anyone interested in having a session about this (Maybe in FHIR-I) ?<br>\n<span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> ?</p>",
        "id": 154003219,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538329948
    },
    {
        "content": "<p>Pre-processing all canonicals has one more big drawback: you cannot let the consumer of the package override version resolution anymore. Now, this is advanced, but if you include two packages, let's say A and B, and these two reference a different version of C, you need to be able to override either A and Bs dependency resolution at the moment of consumption of A and B. If you have turned all canonicals into hard-versioned ones, that is not possible anymore.</p>",
        "id": 154003306,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1538332783
    },
    {
        "content": "<p>I understand ( to some degree) however Stefan's concern, that if two people who download the same derived profile and implement it, they may end up with completely different (potentially incompatible) implementations, depending on how they resolved the dependencies.<br>\nWe're assuming here, that everyone will use packaging and get packaging right. But that's probably not how it's going to be anytime soon...</p>",
        "id": 154003347,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1538334051
    },
    {
        "content": "<p>Packages address so many challenges that I think this will soon become crucial and infrastructure for FHIR. Same as IDEs.</p>",
        "id": 154003369,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538335683
    },
    {
        "content": "<p>We will tightly integrate packages into our Firely tools (Forge, Simplifier, Vonk, Torinox). Our goal is to make the UI/UX as easy and simple as possible. I hope this will help drive adoption.</p>",
        "id": 154003378,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1538335920
    },
    {
        "content": "<p>My take is that if IG 1 depends on IG2 version A, then any profile that IG 1 that references another profile defined in IG 1, it's referring to the profile that's the same version it is.  If it's pointing to a profile defined in IG 2, it's referring to the version A version of the profile.  As such, you don't need to make the references version-specific.</p>",
        "id": 154003431,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538338931
    },
    {
        "content": "<p>We'll see where we're at with scheduling items for this meeting.  We might be able to afford another session on versioning.</p>",
        "id": 154003435,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1538338971
    },
    {
        "content": "<p>Thanks</p>",
        "id": 154003726,
        "sender_full_name": "Eric Haas",
        "timestamp": 1538404934
    },
    {
        "content": "<blockquote>\n<p>Why would we want to discourage it? <br>\n(Which brings us back to the question we started with): What are the pros/cons of explicit references?</p>\n</blockquote>\n<p>Pro: you know exactly what you conform to - (on a side note, if you stick to  semver, your representation of a resource may be syntactically compliant against a SD eventough the semantics have changed)<br>\nPro: there is never any 'implicit' magic<br>\nCon: sounds like on <span class=\"user-mention\" data-user-id=\"191436\">@Stefan Lang</span> that you are about to embrace nondeterminism<br>\nCon: being explicit can be cumbersome to maintain manually</p>\n<p>If SD's can/should be treated as interfaces as in eg. Java, C#, Go, typescript ... whatever - then I wouldn't expect any other or better solutions to this matter other than what can already be found in regards to how interfaces are handled in those languages. 'Just' pick the poison you like the best</p>\n<p>If I was a world dictator I would favour explicitness due to the fact that SD's describes the interface of  a system - and I prefer to have that very clearcut carved in stone and welded in steel</p>",
        "id": 154004179,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1538433731
    }
]