[
    {
        "content": "<p>Reading the spec, when we try to delete a non-existing resource, we should get a success code - 200 / 202 / 204 response. (I'd guess a 204?) .<br>\nI was asked if this contradicts the RFC7321 which describes that the code 404 can be used also when a server does not want to reveal whether a resource exists.</p>\n<p>My take on this is that  the 200 is more opaque - it just says that the server accepts to process the delete request, without saying it is an error or not. Is this a correct summay?</p>",
        "id": 220664646,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1608621519
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span></p>",
        "id": 220692804,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1608646450
    },
    {
        "content": "<p>There are many ways that an attacker can infer information thru sending delete requests. An attacker can see different return codes, and could then determine if the resource existed or did not exist. Thus leaking knowledge, however small...    As with any access control failure, the actual returned code should be driven by policy.  This is especially true for those apps or users without rights to do the action.<br>\nThe problem is that an authorized app needs to get useful codes so that it can tell if the resource was properly deleted.</p>\n<p>THIS does not address your specific situation of an authorized app deleting a non-existing resource... I would still recommend that the client be ready for MANY possible results including 404, 200, 202...</p>\n<p>I am not sure how RFC7321 applies. Did you mean this?</p>\n<p>So are you proposing that the use-case of an authorized app deleting a non-existent resource be expressed in the spec? Or is the IETF specifications sufficient reference? FHIR should be careful not to overly specify infrastructure that we are based upon..</p>",
        "id": 220694118,
        "sender_full_name": "John Moehrke",
        "timestamp": 1608647304
    },
    {
        "content": "<p>The question I was asked is \"doesn't this conflict with the RF 7321?\" </p>\n<ul>\n<li>I think not, because RFC7321 only specifies the meaning of the codes (even if it leaves space for ambiguous interpretations.</li>\n</ul>",
        "id": 220700665,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1608650776
    },
    {
        "content": "<p>I don't think you mean RFC7321...  I think you mean RFC7231</p>",
        "id": 220700933,
        "sender_full_name": "John Moehrke",
        "timestamp": 1608650923
    },
    {
        "content": "<p>yes. You see why I failed my piano lessons</p>",
        "id": 220701612,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1608651295
    },
    {
        "content": "<p>Perhaps we can specifically explain that a DELETE of a resource should return a 200 /(or 202?) independently of whether the resource is accessible or not. And  a short note why this should not give different response codes for those cases.</p>",
        "id": 220702112,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1608651580
    },
    {
        "content": "<p>btw, Is it 200 or 202, or up to servers to decide?<br>\nIIRC, HAPI returns 200.</p>",
        "id": 220702189,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1608651619
    },
    {
        "content": "<p>an authorized app (authorized to interact, but not to delete) should be able to know that the delete did fail because delete is not allowed.</p>",
        "id": 220702221,
        "sender_full_name": "John Moehrke",
        "timestamp": 1608651636
    },
    {
        "content": "<p>that is dependent on if the server completed the delete, or just queued the delete to happen. I presume HAPI always knows that the delete completed. With 200 the resource needs to be gone... with 202 it is possible (small window of opportunity, but possible) that the resource still exists post returning 202</p>",
        "id": 220702407,
        "sender_full_name": "John Moehrke",
        "timestamp": 1608651762
    },
    {
        "content": "<p>a journaled database would tend to just put the delete in a queue and return 202.. or a highly federated database that requires the delete to propigate to many data-centers might also use 202</p>",
        "id": 220702480,
        "sender_full_name": "John Moehrke",
        "timestamp": 1608651817
    },
    {
        "content": "<p>hence... why FHIR should not constrain things... and why clients must be robust (Postel's Law)</p>",
        "id": 220702584,
        "sender_full_name": "John Moehrke",
        "timestamp": 1608651865
    }
]