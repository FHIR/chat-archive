[
    {
        "content": "<p>When profiling resources, we currently have no way to express that certain elements are \"not used/not relevant\" for a specific use case.<br>\nEspecially in the early stages of adopting FHIR, I see many profiles around, that use less than 50% of the elements in a resource.</p>\n<p>When rendering a resource (like in IG or on Simplifier) there's no way to get a view of the profile that shows only what's relevant to the implementer.<br>\nThe current options of displaying profiles only get us half way:</p>\n<ul>\n<li>the differential view doesn't do that, because just the fact that an element hasn't been changed doesn't mean it's not relevant</li>\n<li>I see many profiles that constrain everything that's not relevant to 0..0, which is nice in terms of how the profile is presented but desastrous when this profile is used for validation.</li>\n<li>the must support flag could be used to distinguish relevant from irrelevant elements but the semantics aren't quite the same. Just the fact that an IG <em>uses</em> an element doesn't mean that all implementations have to support it.</li>\n</ul>\n<p>What I would like to suggest is the introduction of a boolean \"muted\"-Extension to ElementDefinition. So specifiers can mark everything the implementer doesn't have to bother with in the scope of a profile.</p>\n<p>Registries like Simplifier or IG publishing tools could then offer views that omit the muted elements (or somehow format them as <em>not important</em>).</p>",
        "id": 153957143,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525864226
    },
    {
        "content": "<p>Have you looked at mustSupport?  Those things marked as mustSupport are relevant/need to be supported.  Those not can be ignored/are not relevant</p>",
        "id": 153957144,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525864922
    },
    {
        "content": "<p>Here's an example:<br>\nThis view of the US Core AllergyIntolerance shows only the \"must support\" fields. Assuming that there'd be other data elements from the CCDS that are \"<em>can</em> support\" and have resulted in no chages to the core specification, they wouldn't show up in the differential.<br>\n<a href=\"/user_uploads/10155/1-NQHIR4IGo1CTg7LedP16ET/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/1-NQHIR4IGo1CTg7LedP16ET/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/1-NQHIR4IGo1CTg7LedP16ET/pasted_image.png\"></a></div><p>I'm afraid that implementers are inclined to look at the differential and think \"that's all I have to know\", when in fact, it isn't. <br>\nAs a specifier, I would like to be able to create a view that means \"this is all you have to know\".</p>",
        "id": 153957146,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525865020
    },
    {
        "content": "<p>\"Can support\" is everything that's not 0..0.  mustSupport is what's relevant and you can count on interoperability with</p>",
        "id": 153957147,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525865405
    },
    {
        "content": "<p>Another problem with mustSupport:<br>\nOnce a mustSupport Flag is set, the element can't be un-mustSupported in derived Profiles.</p>\n<p>Example: If we were to mark all relevant Elements for a MedicationPlan-IG as mustSupport, we couldn't derive a Profile for a simple patient-facing App that wouldn't need to deal with half of the elements because it's just supposed to tell the Patient \"how much of which, when\".</p>",
        "id": 153957148,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525865432
    },
    {
        "content": "<p>Looking at only the differential is a really bad idea because things like mustSupport can be inherited</p>",
        "id": 153957149,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525865440
    },
    {
        "content": "<p>True.  If something is mustSupport, then it's mustSupport always.  Which means you shouldn't be defining your profile for the patient-facing app from the MedicationPlan-IG</p>",
        "id": 153957150,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525865536
    },
    {
        "content": "<p>I don't know. Like, in the USCore profile, how do you distinguish elements that are part of the CCDS but not mandatory from elements that don't have anything to do with the CCDS at all? Or are you just in the happy situation that everything in the CCDS is mandatory ;-) ?</p>\n<p>I'm still struggeling with how to distinguish the sematic \"this profile doesn't use element x\" from \"this profile uses element x but it's not mustSupport\".</p>",
        "id": 153957151,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525866130
    },
    {
        "content": "<p>For the Medication Plan we'd have a common data model and everything that's in that data model would be considered \"relevant\".<br>\nBut in this scenario we'd have practitioner-facing EHRs, patient-facing Apps, pharmacist-facing Systems etc. We could slap on the mustSupport flags for actor-specific profiles but I'm thinking about the top level profile. I wouldn't want to make assumptions there about mustSupport. I just want to say what's in and what's out...</p>",
        "id": 153957152,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525866527
    },
    {
        "content": "<p>I don't know what CCDS is :)  Not mandatory means minOccurs = 0.  You can have something that's mustSupport but not mandatory.</p>",
        "id": 153957153,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525866938
    },
    {
        "content": "<p>I don't understand \"this profile uses it, but it's not mustSupport\".  If it's being used, it's being supported - though it might be minOccurs = 0</p>",
        "id": 153957154,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525866969
    },
    {
        "content": "<p>What's your objective of saying something is \"in\" if you don't want to say it must be supported?  If you wanted to say \"this data should never be present and it would be an error for it to appear\", you could set maxOccurs to 0 (e.g. on deceasedDate if the use-case doesn't allow dealing with deceased patients).  Be cautious about this though because you don't want to prohibit data that might legitimately exist.</p>",
        "id": 153957155,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525867071
    },
    {
        "content": "<blockquote>\n<p>I don't know what CCDS is :) </p>\n</blockquote>\n<p>The underlying data model for US Core Profiles (I think)</p>",
        "id": 153957159,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525869029
    },
    {
        "content": "<p>Ah.  Common Clinical Data Set</p>",
        "id": 153957160,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525869219
    },
    {
        "content": "<p>Yep. That thing :)</p>",
        "id": 153957161,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525869250
    },
    {
        "content": "<p>Doe the distinction between mandatory (minOccurs=1+) and mustSupport meet your needs?</p>",
        "id": 153957162,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525869269
    },
    {
        "content": "<p>Well it might if we were to asssume that mustSupport in the context of a profile that describes a common data model means \"this element is part of the model\" and we accept, that all implementations that implement that model but support only parts of it will never be able to derive their profiles from the common model.<br>\nWhich doesn't make me very happy.</p>",
        "id": 153957164,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525869453
    },
    {
        "content": "<p>But then again, that hole mustSupport-semantic / derived Profile isnt't really my point... <br>\nwait, I try to remeber what my point was...</p>",
        "id": 153957166,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525869719
    },
    {
        "content": "<p>The point is: we don't have a convenient view for implementers that shows them only the relevant parts of a profile.</p>",
        "id": 153957167,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525869762
    },
    {
        "content": "<p>You agreed that differntial view is not what implementer's should look at. That's a technical representation that should only be relevant to specifiers.</p>",
        "id": 153957168,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525869801
    },
    {
        "content": "<p>So we want implementers to look at the snapshot always.<br>\nNow going back to the US Core AllergyIntolerance Profile....when looking at the Snapshot of the profile, there's about 80% irrelevant information there.</p>",
        "id": 153957169,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525869861
    },
    {
        "content": "<p>So, what I'm suggesting is that we add a label to elements, that a specifier thinks can safely be ignored by the implementer when reading the spec.</p>",
        "id": 153957171,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525869959
    },
    {
        "content": "<p>For the sake of this discussion, let's call it the \"Implementer's view\"</p>",
        "id": 153957172,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525869988
    },
    {
        "content": "<p>I agree with Simone, on the need beyond mustSupport. IHE has run into this too. There are a few grey conditions that the current conformance rules are simply too strong. mustSupport is problematic because it is not defined, which is also powerful so do want something that is profile defined. However there is a need to indicate ( a ) that an element could be populated, but is not used by this IG (aka O); ( b ) that an element can be empty, but if the data is known it must be populated (aka RE, R2); ( c ) that  this element has a condition that when true makes the element required (aka C). Usually these are activated more at the IG level, and what IHE has done this far is to make multiple blunt StructureDefinitions (see MHD).</p>",
        "id": 153957175,
        "sender_full_name": "John Moehrke",
        "timestamp": 1525870595
    },
    {
        "content": "<p>Actually, there's a \"grid view\" component that gets produced by the IG publisher that only shows those elements that are marked as mustSupport.  I added it for one of my clients.  It's available for any IG though if you include it in your templates</p>",
        "id": 153957179,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525871473
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> <br>\na) mustSupport=false, minOccurs=0, maxOccurs!=0<br>\nb) mustSupport=true, minOccurs=0, maxOccurs!=0<br>\nc) mustSupport=true, minOccurs=0, maxOccurs!=0, invariant defining condition</p>",
        "id": 153957180,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525871566
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191450\">@Simone Heckmann</span>  <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>   I think the USCore is doing what you are asking for.   We list only the stuff that you need to worry about.</p>\n<ul>\n<li>1..1 + Must Support  = Mandatory</li>\n<li>0..1 or 0..*+ Must Support = Send it if you have it<br>\n0..0 =  not supportted</li>\n</ul>\n<p>everything else is undefined in the profile..   This follows the conformance section in V2 Chapter 2b which is how I think about it and how I cut my teeth on profiles.</p>\n<p>So I get some push back on making the 1..1 + Must Support but I think it makes it clearer.   but what other category do you want?  \"a gee this would be nice too\"? </p>\n<p>And yes profiles are layered you constrain atop the base then uscore (for example) then your profile.</p>",
        "id": 153957206,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525877469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  conditionals are handled by invariants + Must Support.  I haven;t seen a use case that runs into problems.  Its usually becuase the use case is ill defined and the implementer wants it both ways.</p>",
        "id": 153957207,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525877606
    },
    {
        "content": "<p>Yes that is how IHE is doing it as well.. I just think that it is possibly not as obvious as it could be. I don't have a better recommendation or I would have made it.   This use of mustSupport is indeed documented as such in IHE.</p>",
        "id": 153957208,
        "sender_full_name": "John Moehrke",
        "timestamp": 1525877617
    },
    {
        "content": "<p>The main part of is that is not obvious is that everyone gets to define mustSupport differently. If it was always defined the same way, then that would clear things up.</p>",
        "id": 153957209,
        "sender_full_name": "John Moehrke",
        "timestamp": 1525877674
    },
    {
        "content": "<p>It would be great if we could create views of the layered differential like I did here but the tooling ( I hear ) is difficult )   here is an example of what I mean....</p>",
        "id": 153957210,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525877757
    },
    {
        "content": "<p><a href=\"https://argonautproject.github.io/clinicalnotes/StructureDefinition-example-dr.html\" target=\"_blank\" title=\"https://argonautproject.github.io/clinicalnotes/StructureDefinition-example-dr.html\">https://argonautproject.github.io/clinicalnotes/StructureDefinition-example-dr.html</a></p>",
        "id": 153957212,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525877799
    },
    {
        "content": "<p>this requires the poor hapless profile editor to create all the intermediate profiles and hack the template...</p>",
        "id": 153957213,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525877836
    },
    {
        "content": "<p>but I think that helps solve one of Simone's concerns</p>",
        "id": 153957214,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525877910
    },
    {
        "content": "<p>For clarification:<br>\n0..0 - prohibited (rather than just 'not supported')  I.e. You're not allowed to deal with animals if you want to claim conformance with US Core.<br>\n0..* mustSupport=false would be \"not supported\"</p>",
        "id": 153957234,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525879039
    },
    {
        "content": "<p>0..*  without a must Support  is undefined in my book.... is that documented as \"not supported?\"  because if so a tracker is coming :)</p>",
        "id": 153957239,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525879243
    },
    {
        "content": "<p>@Lloyd what do you mean by 'not supported'  ?</p>",
        "id": 153957241,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525879302
    },
    {
        "content": "<p>for me \"not supported\" means an error can be  raised if the element comes down the wire.</p>",
        "id": 153957242,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525879360
    },
    {
        "content": "<p>so I think we mean the same thing</p>",
        "id": 153957243,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525879428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> <br>\n1. \"We list only the stuff that you need to worry about.\" <br>\nJust looking at the differential, though convenient, isn't the solution.<br>\nIn the snapshot - granted - you have nice red flags in the things that are relevant for the implementers, but there's a lot of noise around them.<br>\nSo - where's that \"list of stuff you need to worry about\"? ;-)</p>\n<p>2. \"but what other category do you want? \"a gee this would be nice too\"?\"<br>\nActually yes. There  can be elements in a data model that everyone agrees are relevant but not everyone can/will support.<br>\nKnowing that they are a part of that model makes it likely that other systems will implement these elements, if they find them useful, even though it's not must support, whereas with any element that just happens to be there because it's in the core spec, that's rather unlikely.</p>\n<p>3. \"And yes profiles are layered you constrain atop the base then uscore (for example) then your profile\"<br>\nSo how do I say: \"My system is compliant to this profile(produces valid resources), but we don't support some of the mustSupport elements because they're irrelveant to our use case?\" You can't do that by layering/deriving because you can't make the mustSupport flag go away.</p>",
        "id": 153957244,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525879554
    },
    {
        "content": "<p>For your #2, we use R2 for this. Which is an indication that it is desired but not critical. It is a bit more encouraging that it be filled in, but essentially it is desired but not critical.</p>",
        "id": 153957247,
        "sender_full_name": "John Moehrke",
        "timestamp": 1525879676
    },
    {
        "content": "<p>1. I would say the differential <em>is</em> the place you list the stuff you need to worry about</p>\n<p>2. You want it both ways - I would suggest you define your Must Support to include the fuzzy support too.</p>\n<p>3. profile A either conforms to profile B or it doesn't there is no almost conforms.  I'm not sure there should be either.</p>",
        "id": 153957251,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525879964
    },
    {
        "content": "<p>for 2 you could create an extension for MaySupport...</p>",
        "id": 153957252,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525880129
    },
    {
        "content": "<p>too complicated for my simple mind.  :-)</p>",
        "id": 153957253,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525880153
    },
    {
        "content": "<p>Here is a copy/paste of the IHE conventions that we use today in FHIR profiles. Clearly R vs R+ are obvious in a StructureDefinition.  This is published in our Appendix Z</p>\n<p>Z.10 Profiling conventions for constraints on FHIR<br>\nThe following terms refer to the values used in the OPT column of tables in ITI Technical Framework Volumes 2, 3, and 4 that define constraints being profiled:<br>\nR   Required. This element is required by FHIR. A sending application shall populate the element with a non-empty value. A receiving application may ignore the information conveyed by the element. A receiving application shall not raise an error solely due to the presence of the element, but may raise an error due to the absence of the element.<br>\nR+  Required. This element is required by IHE profiling, but is not a required element by FHIR. This element shall be treated as \"R\", above.<br>\nR2  Required if known. If the sending application has data for the element, it is required to populate the element with a non-empty value. If the value is not known, the element may be omitted. A receiving application may ignore the information conveyed by the element. A receiving application shall not raise an error solely due to the presence or absence of the element.<br>\nO   Optional. At its discretion, a sending application may populate the element with a non-empty value. A receiving application may ignore the information conveyed by the element. A receiving application shall not raise an error solely due to the presence or absence of the element.<br>\nC   Conditional. There is a stated condition associated with the element. If the condition is true, the element shall be treated as \"R\", above. If the condition is false, the element shall be treated as \"O\", above.<br>\nX   Not supported. A sending application shall not populate the element. A receiving application may, if the element is received, ignore the information conveyed by the element, or may raise an error due to the presence of the element.</p>",
        "id": 153957256,
        "sender_full_name": "John Moehrke",
        "timestamp": 1525880449
    },
    {
        "content": "<p>\"Not supported\" absolutely doesn't mean an error can be rasied if the element comes down the wire - it just means the receive might not retain it or do anything useful with it.</p>",
        "id": 153957259,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525880830
    },
    {
        "content": "<p>\"Prohibited\" means an error can be raised if the element comes down the wire - and that's what maxOccurs=0 is for.  You use it when it's clearly an error if the element is present (not just that it's a piece of data you don't happen to need/want)</p>",
        "id": 153957260,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525880874
    },
    {
        "content": "<p>\"not supported\" == mustSupport = false</p>",
        "id": 153957261,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525880915
    },
    {
        "content": "<p>Differential is the place you list what's different from the parent profile.  The stuff you need to worry about is the sum total of all differentials for all ancestor profiles where elements are marked with \"mustSupport\" or have other constraints that impact implementation (e.g. maxOccurs=0)</p>",
        "id": 153957263,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525880979
    },
    {
        "content": "<p>So looking at differential is only useful as your sole view if the parent of the profile is the FHIR resource.</p>",
        "id": 153957264,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525881006
    },
    {
        "content": "<p>V2 mappings for FHIR are:<br>\nR: minOccurs = 1+<br>\nR2: minOccurs=0, mustSupport=true<br>\nO: minOccurs=0, mustSupport=false<br>\nC: closest would be minOccurs=0, mustSupport=true, with an invariant.  We have no notion at present of mustSupport being conditional, only of the presence in the instance being conditional.  If you support the element some of the time, then you \"support the element\"</p>",
        "id": 153957265,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525881171
    },
    {
        "content": "<p>X = maxOccurs=0</p>",
        "id": 153957266,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525881184
    },
    {
        "content": "<p>So I agree with Lloyd on this with the semantic difference in what I think the words 'not supported' mean:  to me not supported == undefined.</p>",
        "id": 153957279,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525882362
    },
    {
        "content": "<p>in other words the implementation is silent on the element.  I didn't make this up I am repeating the sage word from Rob Snelick with probably a little Frank in there as well.</p>",
        "id": 153957281,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525882427
    },
    {
        "content": "<p>Possibly related, I recall a discussion during the EU connectathon about layered profiles,</p>",
        "id": 153957292,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1525884250
    },
    {
        "content": "<p>And the fact that as we profile on top of profiles, and the implementers will only see the upper layer,</p>",
        "id": 153957294,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1525884319
    },
    {
        "content": "<p>It is good to be able to say 'this field is not touched by this layer, but there are layers below where this field is touched\"</p>",
        "id": 153957295,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1525884403
    },
    {
        "content": "<p>If the profile is declaring the capabilities of the system, it means it's not going to yell if the data is there, but you can't count on it doing anything with the data if it is there.   If the profile is declaring the \"desired\" capabilities of a system, then it's saying it couldn't care less what happens to the element.</p>",
        "id": 153957308,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525885780
    },
    {
        "content": "<blockquote>\n<p>It is good to be able to say 'this field is not touched by this layer, but there are layers below where this field is touched\"</p>\n</blockquote>\n<p>I think it should be possible to compute such an \"aggregated differential\" view. You could try and abuse Forge to hack this manually, as I explained to Eric before:<br>\nOpen your aggregated profile in Forge, save with snapshot. Now open the file in a text editor and replace the differential component with the generated snapshot. Then replace the base definition from the immediate parent profile to the underlying core profile. Now open the hacked profile in Forge. Forge will now generate an \"aggregated differential\" that contains the sum of all constraints in the layered profiles. If you save the profile, it will contain the aggregate differential component.<br>\nThis is not a scalable solution, but it does demonstrate the possibility to create helpful tooling.</p>",
        "id": 153957356,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1525892229
    },
    {
        "content": "<p>I remember having a discussion with Simone about a \"rebase\" command in Forge, in NOLA iirc. It's certainly feasible, but I haven't implemented it yet.</p>",
        "id": 153957359,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1525892445
    },
    {
        "content": "<p>Hm... so let's assume I derive from a national base profile which has some ValueSet bindings for optional elements.  The aggregated differential would show all the elements that have been touched by the base profile, regardless of whether they're relevant for my current profile or not. In this case I'd be better off sprinkling some mustSupport flags over the profile and present the <em>actual</em> differential to the implementer.<br>\nI'd still feel more comfortable with the idea of having a more <em>explicit</em> way of  creating an \"implementer's view\".</p>",
        "id": 153957397,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525893912
    },
    {
        "content": "<p>Or maybe the idea of an \"Implementer's view\" would be consistent with an aggregated differential minus everything that's not mustSupport??</p>",
        "id": 153957402,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525895260
    },
    {
        "content": "<p>Differential is only a useful view if you want to see \"how is this profile different from the one it's based on?\"  It has nothing to do with \"what's important for an implementer to know\".  What implementers need to know, generally, are what elements are constrained and what they need to support.</p>",
        "id": 153957403,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525895265
    },
    {
        "content": "<p>What you actually want is the snapshot showing only mustSupport elements - and possibly other elements that have been constrained (e.g. maxOccurs=0)</p>",
        "id": 153957404,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525895316
    },
    {
        "content": "<p>Because implementers will need to see the usage notes, data types, etc. inherited from the core resource - and those won't be in the aggregated differential.</p>",
        "id": 153957405,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525895346
    },
    {
        "content": "<p>The existing \"grid view\" renders the shapshot elements where mustSupport = true.  It doesn't currently worry about constrained non-must-support elements, though that would be reasonable to add.</p>",
        "id": 153957406,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525895398
    },
    {
        "content": "<p>Right. Snapshot limited to mustSupport and constrained Elements makes sense. But do we have a computable way of deciding wether a change to an element has been a constraint? reducing maximum cardinality would be. Adding ValueSetBinding and invariants too. Adding an alias or changing the definition wouldn't. If we were to display everything that's been <em>changed</em> rather than <em>constrained</em> we'd be veering back into the differential direction...</p>",
        "id": 153957409,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525895646
    },
    {
        "content": "<p>But I'd lean to displaying every element that's been changed rather than constrained. Relevant information for an Implementer may as well come in form of plain text in a definition or comment.</p>",
        "id": 153957412,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525895794
    },
    {
        "content": "<p>Bindings that are required or extensible would be.  Others wouldn't matter.  size limits, regexs, etc.  We'd have to go through the list and figure out which ones matter.  In most cases, systems don't bother setting constraints on things that are mustSupport = false because the general expectation is they'll ignore them - which is what they should do.  It makes no sense to enforce a constraint on something you don't need or care about.</p>",
        "id": 153957413,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525895814
    },
    {
        "content": "<p>Well, I guess the question is whether you want to see all of the stuff that's been commented on that you don't actually need to pay any attention to.  And if so, do you have a reason to want to see the profile author's comments, but not HL7's?</p>",
        "id": 153957414,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525895889
    },
    {
        "content": "<p>The german national base Profiles don't make any assumptions of what the use case is going to be, they just bind to national vocabulary, add national extensions, define common identifier namespaces etc. <br>\nSo they constrain, but don't set elements to \"mustSupport\". Currently, we can't differentiate \"this element is totally irrelevant in Germany\" from \"this unconstrained element is commonly used in Germany but not necessarily mustSupport\". </p>\n<p>We could weasle our way out of this by just adding some comment to force it on the list of <em>changed</em> and thereby <em>relevant</em> elements. But that feels like a hack.</p>",
        "id": 153957421,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525897041
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191450\">@Simone Heckmann</span>    That is what I do to get a differential of what matters.  and why I add must supports to all the 1..1 elements upon which the profile is based.  Otherwise they would not show up.  As an editor you have control over this and can exploit it so some may call this hack a feature!</p>",
        "id": 153957423,
        "sender_full_name": "Eric Haas",
        "timestamp": 1525898623
    },
    {
        "content": "<p>On occasion, you may want something to be 1..1, mustSupport=false.  I.e. it's ok for systems to ignore it or always send a fixed value and not pay any attention to it.  But that's unusual.</p>",
        "id": 153957426,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525899172
    },
    {
        "content": "<p>The German national profiles would need to make some sort of assumptions about use-case if they're going to enforce vocabulary bindings (e.g. human vs. veterinary; care delivery vs. billing - as commonly the bindings will need to vary for those.)</p>",
        "id": 153957427,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1525899222
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> your hack still has some issues ;-)<br>\n- the differential is not reliable for derived profiles<br>\n- you can manually aggregate it, but you may end up with changed stuff from the parent profiles that isn't relevant and there's no way to get rid of it</p>",
        "id": 153957429,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525899267
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> we can for example make the assumption of an inpatient setting and define appropriate valueset bindings but we still wouldn't set any mustSupport flags. Think of Coverage: In some settings insurance type and number will suffice, others need all insurance details.  In the base profiles we only say <em>how</em> to use Elements, not <em>if</em>.</p>",
        "id": 153957432,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525899625
    },
    {
        "content": "<p>Our approach was to keep the profiles so broad and open, that any use case specific profile can be derived from the base profile.  Assumptions about the usecase usually start one level deeper.</p>",
        "id": 153957433,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525899795
    },
    {
        "content": "<p>Actually, I think the \"hybrid\" view in Simplifier remains the best approach to the issue. It's basically a snapshot with the changes highlighted. That in combination with the \"fake comment\" hack is probably sufficient for most use cases.</p>",
        "id": 153957437,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1525901697
    },
    {
        "content": "<p>Very interesting discussion. If you like, we could organize a little break out session in Cologne. If there is sufficient demand from the community, then maybe we could look into implementing such a representation into Simplifier.</p>",
        "id": 153957503,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1525947183
    },
    {
        "content": "<p>Count me in for a breakout</p>",
        "id": 153957509,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1525950055
    }
]