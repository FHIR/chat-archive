[
    {
        "content": "<p>According to the <a href=\"http://hl7.org/fhir/R4/profiling.html#discriminator\">R4 spec for discriminators</a>:</p>\n<blockquote>\n<p>Each slice must use the element definition for the element(s) in the discriminator(s) to ensure that the slices are clearly differentiated by assigning an appropriate value domain, depending on the discriminator type. If the type is value, or pattern, then the element definition must use either:</p>\n<ul>\n<li>ElementDefinition.fixed[x], or</li>\n<li>ElementDefinition.pattern[x], or</li>\n<li>if the element has a terminology binding, a required binding with a Value Set that enumerates the list of possible codes in the value set (\"extensional definition\")</li>\n</ul>\n</blockquote>\n<p>I take this to mean that if a discriminator type is <code>pattern</code> then the element pointed to by the discriminator <code>path</code> must have either a <code>pattern[x]</code> or <code>binding</code> property directly on it (and <em>maybe</em> a <code>fixed[x]</code> would be OK - not sure).</p>\n<p>But... I've found that the IG Publisher doesn't seem to care.  The following FSH produces <em>no</em> errors or warnings in the IG Publisher:</p>\n<div class=\"codehilite\"><pre><span></span><code>CodeSystem: ExampleComponentCS\nId: example-component-cs\n* #foo &quot;Foo&quot; &quot;Foo&quot;\n* #bar &quot;Bar&quot; &quot;Bar&quot;\n* #boo &quot;Boo&quot; &quot;Boo&quot;\n* #far &quot;Far&quot; &quot;Far&quot;\n\nValueSet: BooFarVS\nId: boo-far-vs\n* ExampleComponentCS#boo &quot;Boo&quot;\n* ExampleComponentCS#far &quot;Far&quot;\n\nProfile: PractitionerBadSlicing\nParent: Practitioner\n* identifier ^slicing.rules = #open\n* identifier ^slicing.discriminator.type = #pattern\n* identifier ^slicing.discriminator.path = &quot;$this&quot; // &lt;-- $this\n* identifier contains foo 0..1 and bar 0..1 and booFar 0..2\n* identifier[foo].type = ExampleComponentCS#foo    // &lt;-- NOT on $this\n* identifier[bar].type = ExampleComponentCS#bar    // &lt;-- NOT on $this\n* identifier[booFar].type from BooFarVS            // &lt;-- NOT on $this\n</code></pre></div>\n\n\n<p>I expected some flack from the publisher because the <code>identifier</code> discriminator type is <code>pattern</code> and the path is <code>$this</code> -- but the <code>pattern[x]</code> and <code>binding</code> are not on <code>identifier</code> (which is <code>$this</code>), but rather are on <code>identifier.type</code>.</p>\n<p>Am I misunderstanding?  Are patterns and binding on nested elements (below the discriminator path) valid for discrimination on?  Or is the IG Publisher just not flagging this even though it is invalid?</p>",
        "id": 203035876,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594066722
    },
    {
        "content": "<p>well, I think it looks wrong, and I would've expected an error. how can I reproduce this?</p>",
        "id": 203222763,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1594172268
    },
    {
        "content": "<p>Is a standalone StructureDefinition that demonstrates it good enough?  Or do you prefer a whole buildable IG?  And if you think this is a bug, then I should file it in Jira, right?</p>",
        "id": 203225340,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594175835
    },
    {
        "content": "<p>filing it with Jira is good. Ideally, I'll a structure definition and a valid and an invalid example. then I can add it to the unit tests</p>",
        "id": 203230030,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1594182157
    },
    {
        "content": "<p>I'm just wondering if $this pattern slicing above would work in case slices are defined on different sub-elements of identifier, e.g. the last 3 lines would be:</p>\n<ul>\n<li>identifier[foo].type = ExampleComponentCS#foo</li>\n<li>identifier[bar].system = <a href=\"http://myidsystem.com/bar\">http://myidsystem.com/bar</a></li>\n<li>identifier[booFar].type from BooFarVS</li>\n</ul>\n<p>Alternatively, would this require slicing on discriminator=type and re-slicing on discriminator=system? <br>\nIs this a valid scenario generally speaking?</p>",
        "id": 203232032,
        "sender_full_name": "Igor Sirkovich",
        "timestamp": 1594185049
    },
    {
        "content": "<p>Issue filed here: <a href=\"https://jira.hl7.org/browse/FHIR-27927\">https://jira.hl7.org/browse/FHIR-27927</a></p>",
        "id": 203266511,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594214780
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191393\">@Igor Sirkovich</span> -- I <em>think</em> there needs to be a constraint on the direct element the discriminator path points to (based on my reading of the spec).  So you would probably need a <code>patternIdentifier</code> that specifies the <code>type</code> and <code>system</code> for that to work.  If constraints on sub-path elements also counted for discrimination then I'm not sure why we would ever discriminate on anything other than <code>$this</code>.</p>",
        "id": 203267026,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594215061
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> </p>\n<p>Would the following definition work in this case? I'm just trying to ensure I understand your explanation.</p>\n<div class=\"codehilite\"><pre><span></span><code>* identifier ^slicing.rules = #open\n* identifier ^slicing.discriminator.type = #pattern\n* identifier ^slicing.discriminator.path = &quot;$this&quot;\n* identifier contains foo 0..1 and bar 0..1 and booFar 0..2\n* identifier[foo].type = ExampleComponentCS#foo\n* identifier[bar].system = http://myidsystem.com/bar\n* identifier[booFar].type from BooFarVS\n</code></pre></div>\n\n\n<p><span class=\"user-mention silent\" data-user-id=\"191469\">Chris Moesel</span> <a href=\"#narrow/stream/179177-conformance/topic/pattern.20discriminators.20and.20pattern.5Bx.5D.2Fbinding/near/203267026\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"191393\">Igor Sirkovich</span> -- I <em>think</em> there needs to be a constraint on the direct element the discriminator path points to (based on my reading of the spec).  So you would probably need a <code>patternIdentifier</code> that specifies the <code>type</code> and <code>system</code> for that to work.  If constraints on sub-path elements also counted for discrimination then I'm not sure why we would ever discriminate on anything other than <code>$this</code>.</p>\n</blockquote>",
        "id": 203268660,
        "sender_full_name": "Igor Sirkovich",
        "timestamp": 1594215911
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191393\">@Igor Sirkovich</span> -- no, I don't think so.  The FSH above says to discriminate by <code>pattern</code> on <code>$this</code> -- which is <code>identifier</code>.  So I think there <em>should</em> be a <code>patternIdentifier</code> constraint on the <code>identifier</code> element in each slice.  Instead that FSH produces the following constraints:</p>\n<ul>\n<li><code>patternCodeableConcept</code> on <code>identifier.type</code> (in <code>foo</code> slice)</li>\n<li><code>patternUri</code> on <code>identifier.system</code> (in <code>bar</code> slice)</li>\n<li><code>binding</code> on <code>identifier.type</code> (in <code>booFar</code> slice)</li>\n</ul>\n<p>It's also not quite correct because the slices are not mutually exclusive.  For example, if an identifier had a <code>type</code> that matched the <code>foo</code> slice <em>and</em> a <code>system</code> that matched the <code>bar</code> slice, it's ambiguous which slice it belongs to.</p>",
        "id": 203270268,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594216711
    },
    {
        "content": "<p>Also note that right now... SUSHI only supports patterns on arbitrary datatypes by using caret syntax.  Fixing my original example to use patterns on <code>identifier</code> you'd need to do this:</p>\n<div class=\"codehilite\"><pre><span></span><code>Profile: PractitionerBadSlicing\nParent: Practitioner\n* identifier ^slicing.rules = #open\n* identifier ^slicing.discriminator.type = #pattern\n* identifier ^slicing.discriminator.path = &quot;$this&quot;\n* identifier contains foo 0..1 and bar 0..1 and booFar 0..2\n* identifier[foo] ^patternIdentifier.type = ExampleComponentCS#foo\n* identifier[bar] ^patternIdentifier.type = ExampleComponentCS#bar\n* identifier[booFar].type from BooFarVS // &lt;-- This is actually still wrong, but there&#39;s no way to apply it at the `identifier` level\n</code></pre></div>\n\n\n<p>FSH supports another way, but it's not yet supported in SUSHI</p>\n<div class=\"codehilite\"><pre><span></span><code>Instance: FooIdentifier\nInstanceOf: Identifier\nUsage: #inline\n* type = ExampleComponentCS#foo\n\nInstance: BarIdentifier\nInstanceOf: Identifier\nUsage: #inline\n* type = ExampleComponentCS#foo\n\nProfile: PractitionerBadSlicing\nParent: Practitioner\n* identifier ^slicing.rules = #open\n* identifier ^slicing.discriminator.type = #pattern\n* identifier ^slicing.discriminator.path = &quot;$this&quot;\n* identifier contains foo 0..1 and bar 0..1 and booFar 0..2\n* identifier[foo] = FooIdentifier\n* identifier[bar] = BarIdentifier\n* identifier[booFar].type from BooFarVS // &lt;-- This is actually still wrong, but there&#39;s no way to apply it at the `identifier` level\n</code></pre></div>\n\n\n<p><strong>EDIT: Actually, it's pretty much impossible to fix it for the VS constraint (since we can pop it up a level and we can't represent it in <code>patternIdentifier</code>.  So I had to edit that out.</strong></p>",
        "id": 203273152,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594218139
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span>. This is super helpful. Complex slicing is always a lot of fun :)</p>",
        "id": 203340086,
        "sender_full_name": "Igor Sirkovich",
        "timestamp": 1594254759
    },
    {
        "content": "<p>Just a thought: any chance the following might work?</p>\n<div class=\"codehilite\"><pre><span></span><code>* identifier[booFar] ^patternIdentifier.type from BooFarVS\n</code></pre></div>\n\n\n<p>I've never seen this, so I assume it's not valid, but probably worth checking.</p>",
        "id": 203340210,
        "sender_full_name": "Igor Sirkovich",
        "timestamp": 1594254935
    },
    {
        "content": "<p>I don't think there is a way to say that something in a <code>pattern[x]</code> should be bound to a value set.  <code>binding</code> is a property on <code>ElementDefinition</code>, as is <code>pattern[x]</code> -- so they're at the same level, making it difficult to apply one to the other.  Although <code>pattern[x]</code> allows you to specify values from a child path (via the pattern itself), I think <code>binding</code> can only be applies to the exact element it is on (no child paths).</p>\n<p>It's hard to explain, and I feel like I'm probably not saying it very well, but hopefully that is helpful anyway!</p>",
        "id": 203347130,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594263971
    }
]