[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> I have committed all the changes from Thursday night discussion at Baltimore (svn revision 10025). Please check that there are no remaining issues</p>",
        "id": 153853167,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1476879046
    },
    {
        "content": "<p>Will do!</p>",
        "id": 153853177,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1476881170
    },
    {
        "content": "<p>I've downloaded the new definitions.zip from <a href=\"http://hl7-fhir.github.io\" target=\"_blank\" title=\"http://hl7-fhir.github.io\">hl7-fhir.github.io</a>. The contained xml files have timestamp 2016-10-18 10:45 - Is that the most recent version?</p>",
        "id": 153853186,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1476893965
    },
    {
        "content": "<p>Github hasn't been updating - see the committer's chat</p>",
        "id": 153853187,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1476894065
    },
    {
        "content": "<p>OK, thanks Lloyd!</p>",
        "id": 153853188,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1476894083
    },
    {
        "content": "<p>I'll try again tomorrow.</p>",
        "id": 153853189,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1476894157
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Seeing the following differences to my implementation when comparing the Patient profile. Not sure all of these are agreed upon:</p>\n<ul>\n<li><a href=\"http://Patient.id\" target=\"_blank\" title=\"http://Patient.id\">Patient.id</a>: base.max:\"*\" - appears often, should be max:\"1\"</li>\n<li>ele-1 constraint (and condition) not inherited, also ext-1.  Is included on BackboneElement?</li>\n<li>No base element where element introduced, e.g. Patient.identifier - not sure if this is intentional? Thought base was to be included always to simplify implementations?</li>\n<li>Not including mappings from types (see Patient.identifier - Identifier type mappings not included)</li>\n<li><a href=\"http://Patient.contact.id\" target=\"_blank\" title=\"http://Patient.contact.id\">Patient.contact.id</a> - comments not included</li>\n</ul>",
        "id": 153853487,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1476993696
    },
    {
        "content": "<p>found and fixed the base.max problem - was getting cardinalities from the parent not the child</p>",
        "id": 153853552,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1476999000
    },
    {
        "content": "<p>don'tf follow the ele-1 issue - it's appearing everywhere I think it should</p>",
        "id": 153853553,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1476999014
    },
    {
        "content": "<p>same for ext-1</p>",
        "id": 153853558,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1476999208
    },
    {
        "content": "<p>base: 'is provided when the element definition is not the original definition of an element'</p>",
        "id": 153853559,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1476999245
    },
    {
        "content": "<p>I don't think think constraints and mappings should be cloned out of the type - they apply, so they shouldn't be denormalised </p>",
        "id": 153853560,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1476999285
    },
    {
        "content": "<p>and I don't follow the issue about comments on <a href=\"http://Patient.contact.id\" target=\"_blank\" title=\"http://Patient.contact.id\">Patient.contact.id</a></p>",
        "id": 153853561,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1476999357
    },
    {
        "content": "<p>I think ele-1/ext-1 and comments are both how we're handling inheritance from the types - I grab everything from the types the same way as from base (type upstream from base).  I think this was the consensus from Thursday as well as between <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span>  and I.  It's in line with the thinking that <em>all</em> things needed to validate an element should be included in the snapshot (if the element is present, all relevant constraints are included).</p>",
        "id": 153853716,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477060698
    },
    {
        "content": "<p>definition of base is unfortunate...makes a parser look in 2 places. We planned to use base.max in our JSON/XML converter to determine whether an element is an array - now have to look in 2 places and hope that a snapshot provided doesn't elect to omit base (it's optional?).  Would rather see it mandatory.</p>",
        "id": 153853717,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477060851
    },
    {
        "content": "<p>base is not optional. It must be provided if the definition is not the original definition</p>",
        "id": 153853741,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477080666
    },
    {
        "content": "<p>I don't recall agreeing that we would inline everything from the types into the snapshot. In fact, what I remember is that I was passionately opposed to that, but we agreed that there are some cases in which it would make sense to inline everything into the snapshot, and so a snapshot generator could choose to do that. but I don't have time to do that as an option between now and my milestone deadline</p>",
        "id": 153853742,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477080754
    },
    {
        "content": "<p>as it happens, I fixed a bug in my code around the dual location for max yesterday, so I can see the point of just making base mandatory</p>",
        "id": 153853743,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477080801
    },
    {
        "content": "<p>do you want to propose a task?</p>",
        "id": 153853744,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477080810
    },
    {
        "content": "<ul>\n<li>\n<p>Concerning the merging of type profiles, I seem to remember from the Baltimore discussion that we agreed that this is the correct and desired approach. I specifically asked for confirmation that all elements should inherit the \"ele-1\" constraint from Element root, and @Gramahe I seem to recall that you agreed on this. IMHO, this makes the snapshot much more complete and useful. (Sorry Grahame...)</p>\n</li>\n<li>\n<p>Concerning <a href=\"http://Patient.contact.id\" target=\"_blank\" title=\"http://Patient.contact.id\">Patient.contact.id</a> - comment should be merged from the string datatype profile<br>\n  =&gt; \"RFC 4122\"</p>\n</li>\n<li>\n<p>Same for Patient.photo - comment should be merged from Attachment datatype profile <br>\n  =&gt; \"When providing a summary view (for example with Observation.value[x]) Attachment should be represented with a brief display text such as &amp;quot;Attachment&amp;quot;.\"</p>\n</li>\n<li>\n<p>Concerning ElementDefinition.Base - IIRC we agreed that we only generate these for elements that are actually derived from a base, and not for newly introduced elements. (Sorry Chris...)</p>\n</li>\n</ul>",
        "id": 153853885,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477303505
    },
    {
        "content": "<p>Note that if a profile specifies a constraint on a child element of a type profile, than the snapshot need to merge these onto the original child element definitions from the type profile. So we need to implement logic to merge type profiles anway, right?</p>",
        "id": 153853887,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477303824
    },
    {
        "content": "<p>hey Michel. We agree that ele-1 would be on all types, including all anonymous types. I've made it so </p>",
        "id": 153853888,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477304575
    },
    {
        "content": "<p>Chris wants more - he wants to inline content from the types to the containing models</p>",
        "id": 153853889,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477304606
    },
    {
        "content": "<p>we agree that this could be a useful option for generating snapshots, but would not be necessary</p>",
        "id": 153853890,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477304624
    },
    {
        "content": "<p>but your next 2 comments make it sound as though you think some information should be inlined. I don't agree</p>",
        "id": 153853891,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477304678
    },
    {
        "content": "<p>I think I do type profiles correctly now</p>",
        "id": 153853892,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477304692
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I've noticed that fully merging type profiles has huge benefits in Forge &amp; Simplifier. It makes it completely explicit to the end user which constraints are being inherited. Also this allows Forge to completely verify that your differential constraints are valid and don't conflict with any of the inherited constraints. For example, a profiler may not define a custom mapping on any element with id \"ele-1\". It also works great for extensions, by merging in the underlying extension definition. Without type profile merging, all of this becomes implicit and is no longer verifiable based on the snapshot. IMHO this conflicts with the ultimate goal of making everything fully computable.</p>\n<p>Frankly, I don't really see a valid reason not to merge type profiles into the snapshot, except maybe for the additional burden on the library implementers. However many users will rely on the existing open source FHIR API libraries. And if not, then they can inspect the existing .NET/Java library source code as a guideline for their own custom implementation. I've found that the hardest challenge is solving the recursion problem. Eventually I've realized that you can avoid recursion by doing a breadth-first expansion. The .NET library currently implements a simplified version of this, just smart enough to handle <a href=\"http://Element.id\" target=\"_blank\" title=\"http://Element.id\">Element.id</a> and Extension.extension.</p>\n<p>Considering that the FHIR .NET library is already capable of merging type profiles, and it provides such useful benefits in Forge &amp; Simplifier, we'd really like to maintain and leverage our current implementation. We could easily make this behavior configurable, but imho providing various snapshot options will only confuse the community so I'm not a strong proponent of that.</p>\n<p>I fully understand that you have serious time constraints and won't be able to implement this anytime soon. However imho this shouldn't hold us back from correcting/clarifying the spec. Maybe we can assist by generating official snapshots from the current .NET library, until the build can handle this?</p>",
        "id": 153853894,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477308435
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/x0noqvUv7h0f4nje_FFUj6bp/Patient.structuredefinition.xml\" target=\"_blank\" title=\"Patient.structuredefinition.xml\">Patient.structuredefinition.xml</a> </p>",
        "id": 153853895,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477308473
    },
    {
        "content": "<p>Attached an example snapshot of the default DSTU-2 Patient resource by the current .NET API.</p>",
        "id": 153853896,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477308511
    },
    {
        "content": "<p>Taking a step back, if FHIR defines the snapshot component in such a form that by default, it does not provide sufficient information for profiling tools such as Forge &amp; Simplifier, then what is the use of generating and including this? In that case, profiling tools would always need to implement their own differential completion logic anyway. Which seems to defeat the purpose of serializing the snapshot component. Right?</p>",
        "id": 153853897,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477309247
    },
    {
        "content": "<p>\"Chris wants more - he wants to inline content from the types to the containing models\"</p>\n<p>What Chris and I are proposing is to always merge the constraints of the <strong>root</strong> element of the datatype. However datatype child nodes are only inlined if the user profile specifies any child constraints. So for example, <strong>Patient.identifier</strong> is merged with constraints from <strong>Identifier</strong> datatype root element definition. However e.g. <strong>Identifier.system</strong> is not inlined, unless the user profile specifies any constraints on children of <strong>Patient.identifier</strong>. In that case, the snapshot generator inlines all the child elements of the <strong>Identifier</strong> datatype and merges any user profile child constraints on top of them.</p>\n<p>For example, primitive datatypes are merged with the base profile Element:<br>\n- Merge primitive root element on top of base profile root = <strong>Element</strong> (=&gt; datatype root inherits \"ele-1\")<br>\n- Inline children of base profile = <strong>Element.id</strong>, <strong>Element.extension</strong></p>\n<p>So eventually, <strong>Element.id</strong> recursively picks up the \"ele-1\" constraint from Element root:<br>\n- <strong>string</strong> root inherits \"ele-1\" from <strong>Element</strong> snapshot root<br>\n- <strong>identifier</strong> root inherits \"ele-1\" from <strong>string</strong> snapshot root<br>\n- <strong>Element.id</strong> inherits \"ele-1\" from <strong>identifier</strong> snapshot root</p>",
        "id": 153853902,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477315376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> Agree. If an element is included, it should include everything needed to validate.  Note that this makes no statement about <em>which</em> elements to include.</p>",
        "id": 153853903,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477317081
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> Correct, that is what I meant to explain.</p>",
        "id": 153853905,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477317217
    },
    {
        "content": "<p><a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12179\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12179\">GF#12179</a> supports this viewpoint...moved by Grahame?</p>",
        "id": 153853907,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477319333
    },
    {
        "content": "<p>So my memory isn't failing me... thx Chris ;p</p>",
        "id": 153853913,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477327695
    },
    {
        "content": "<p>Anyway <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> considering your huge workload, I think that for now it would be sufficient to clearly define the desired behavior in the spec. I don't think it's that big of a problem if it takes a while for the official build to support this functionality. Forge &amp; Simplifier will be able to generate their own (complete) snapshots anyway, even for core datatypes and profiles. Also the FHIR .NET API library can provide a customized version of definitions.xml.zip that contains complete snapshots. So delayed implementation in the build wouldn't keep us from progressing.</p>",
        "id": 153853914,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477328016
    },
    {
        "content": "<p>BTW I'd rather keep ElementDefinition.Base empty for newly introduced elements. IMHO this better conveys the intended meaning than a self-referential Base declaration, which to me seems a bit of a leaky abstraction. <span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> if it is more convenient for your implementation to always have a base, then couldn't you add a simple pre-processing step to fill in missing Base elements? This way, self-referential base elements remain an internal implementation detail of your logic and don't need to be serialized to the snapshot.</p>",
        "id": 153853915,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477328427
    },
    {
        "content": "<p>it's certainly possible either way - I don't find it a \"leaky abstraction\" - the base of a new element is itself.</p>",
        "id": 153853916,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477328494
    },
    {
        "content": "<p>The intent is to convey the original cardinality, not convey whether the element in hand is a new specialization or not.</p>",
        "id": 153853917,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477328541
    },
    {
        "content": "<p>And if it were, having base in all cases explicitly indicates whether a new element *is* the introduction/specialization - no further inspection needed.</p>",
        "id": 153853918,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477329064
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span>  I see your point, your suggestion does improve symmetry/uniformity. I don't have a very strong opinion on this. Just seems a bit noisy, but I guess I can live with it. Impact on our implementation is minimal.</p>",
        "id": 153853919,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477329140
    },
    {
        "content": "<p>Yeah, I wasn't crazy about base being introduced at all since it's redundant.  But if it's there, might as well ensure it's consistent (which current technical constraints don't/cannot).</p>",
        "id": 153853920,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477329246
    },
    {
        "content": "<p>I agree we should inline types when we can - the challenge is that type profiles might not all be available at the time the snapshot is generated.  I don't think we want to make snapshot generation dependent on the availability of all profiles.  That in turn means that snapshots may not generate the same each time.  Is that something we're ok with?</p>",
        "id": 153853921,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1477330423
    },
    {
        "content": "<p>I think we define a \"standard\" form and then describe the ways in which it may degrade (or expound) based on need.  It may degrade primarily due to lack of access to dependent profiles.  It could also degrade due to app specific needs (such as omitting descriptive elements) within the limits of the constraints.</p>",
        "id": 153853925,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477331886
    },
    {
        "content": "<p>so I think you're using confusing language here:</p>",
        "id": 153853928,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477332323
    },
    {
        "content": "<p>why would we inline some things from a type, and why would we not? </p>",
        "id": 153853929,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477332466
    },
    {
        "content": "<p>We would unless the type profile wasn't available for some reason</p>",
        "id": 153853930,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477332487
    },
    {
        "content": "<p>firstly, are you claiming that if you don't duplicate the constraints out of a type, to the element, then they don't apply? </p>",
        "id": 153853931,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477332491
    },
    {
        "content": "<p>Not at all. The inverse - since they apply, they should be inlined.</p>",
        "id": 153853932,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477332519
    },
    {
        "content": "<p>and if you claim that the do apply after all, then why inline *some* things from a type - which things? - and confuse matters by putting them in 2 places?</p>",
        "id": 153853933,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477332546
    },
    {
        "content": "<p>The proposal was that the element lineage passes up the resource lineage (e.g. Patient, DomainResource, Resource) and then into the type lineage (Patient.meta.tag -&gt; Resource.meta.tag -&gt; Meta.tag -&gt; Coding -&gt; Element)</p>",
        "id": 153853938,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477332673
    },
    {
        "content": "<p>I don't understand how that is an answer to my questions</p>",
        "id": 153853939,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477332701
    },
    {
        "content": "<p>A \"standard\" snapshot should accumulate/inherit from all points in this lineage</p>",
        "id": 153853941,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477332728
    },
    {
        "content": "<p>what we agreed was that (a) types should inherit properly - and I think i do that now - and (b) you could inline things from elements to types if you wanted</p>",
        "id": 153853942,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477332856
    },
    {
        "content": "<p>\"if you wanted\" meaning a snapshot form other than the \"standard\" (\"canonical\"? not sure what the best word is here) one.</p>",
        "id": 153853944,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477332938
    },
    {
        "content": "<p>my memory of the discussion is that we agreed that you could inline into the snapshot if you wanted. Though I have no memory of talking about inlining *some* things from a type and not others</p>",
        "id": 153853945,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477333011
    },
    {
        "content": "<p>So in <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> 's case, if the type profiles weren't available, a legal snapshot could omit them, but they wouldn't match to the \"standard\" profile.  The build was intended to implement this \"standard\" snapshot (which would for instance included ele-1 for all elements).</p>",
        "id": 153853946,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477333013
    },
    {
        "content": "<p>I don't remember that either - *all* \"things\" from a type should be inlined</p>",
        "id": 153853947,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477333054
    },
    {
        "content": "<p>which would include ele-1</p>",
        "id": 153853948,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477333068
    },
    {
        "content": "<p>Lloyd's case beats me. It's degenerate. I can't generate or process things correctly when things are missing</p>",
        "id": 153853949,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477333088
    },
    {
        "content": "<p>but you're saying that children elements are not inlined. so you're saying some things</p>",
        "id": 153853950,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477333107
    },
    {
        "content": "<p>the selection of *which* elements is a separate topic.  For the ones that are included, they should include the complete elementdefinition (inherited from the entire lineage).</p>",
        "id": 153853951,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477333141
    },
    {
        "content": "<p><a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12179\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12179\">GF#12179</a> is explicit on the inheriting from types even including the ele-1 example...</p>",
        "id": 153853952,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477333291
    },
    {
        "content": "<p>no. I have *no idea* what you and Michel are on about then. I inherit everything correctly, so far as I can tell, and you're talking about something else. </p>",
        "id": 153853953,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477333360
    },
    {
        "content": "<p>In the current build for <a href=\"http://hl7-fhir.github.io/patient.profile.xml.html\" target=\"_blank\" title=\"http://hl7-fhir.github.io/patient.profile.xml.html\">Patient</a>, the snapshot for the Patient.telecom element has no constraints.  The lineage for Patient.telecom is (Patient.telecom -&gt; ContactPoint -&gt; Element).  Therefore, the snapshot should include 2 constraints, cpt-2 and ele-1.</p>",
        "id": 153853956,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477333634
    },
    {
        "content": "<p>this is *not* a matter of inheritance at all</p>",
        "id": 153853957,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477333706
    },
    {
        "content": "<p>you are saying that information from the type should inlined in the element so that you can process it correctly without access to the type. But only some information, so you can only process it partially correctly </p>",
        "id": 153853958,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477333748
    },
    {
        "content": "<p>sorry, but I'm not making sense of that </p>",
        "id": 153853959,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477333758
    },
    {
        "content": "<p>Your point is that since I don't include Patient.telecom.system, I'm not including *all* the type information?</p>",
        "id": 153853960,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477333828
    },
    {
        "content": "<p>yes</p>",
        "id": 153853962,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477333884
    },
    {
        "content": "<p>I think our point was that selection of which elements to include was an independent decision from what is the correct form of a single element.</p>",
        "id": 153853964,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477333980
    },
    {
        "content": "<p>And that the contents of a single element in \"standard form\" should be character-wise comparable (possibly with some ordering concessions) with any generated snapshot.</p>",
        "id": 153853965,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477334035
    },
    {
        "content": "<p>I disagree with that and what I remember is that the inclusion of any duplicative information was a choice for the generator, and that a snapshot comparision tool had to allow for that</p>",
        "id": 153853967,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477334079
    },
    {
        "content": "<p>What were you supporting in <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12179\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12179\">GF#12179</a> ?</p>",
        "id": 153853968,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477334125
    },
    {
        "content": "<p>doing the inheritence correctly, which I had not been</p>",
        "id": 153853969,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477334154
    },
    {
        "content": "<p>If I created a Patient profile (my-patient) and constrained Patient.telecom.system min=1, would Patient.telecom *then* include cpt-1 and ele-1 (since all children of telecom would be included)?</p>",
        "id": 153853973,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477334407
    },
    {
        "content": "<p>I don't follow your 'since'</p>",
        "id": 153853975,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477334526
    },
    {
        "content": "<p>once a child of telecom is included, all children would be included.</p>",
        "id": 153853977,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477334546
    },
    {
        "content": "<p>telecom.system, .value, .use, .rank, etc.</p>",
        "id": 153853978,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477334571
    },
    {
        "content": "<p>oh yes. I mis read that. Yes, you would inline all of it in the snapshot.</p>",
        "id": 153853979,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477334674
    },
    {
        "content": "<p>so then cpt-1 and ele-1 would appear in Patient.telecom</p>",
        "id": 153853980,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477334695
    },
    {
        "content": "<p>then they would, yes, because you inlining the data tyep</p>",
        "id": 153853989,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477335162
    },
    {
        "content": "<p>and I did check that this works properly now too </p>",
        "id": 153853990,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477335178
    },
    {
        "content": "<p>you're adding things profile-by-profile...I'm adding them element-by-element. Our world-views are different....</p>",
        "id": 153853993,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477335253
    },
    {
        "content": "<p>sufficiently different that I don't even know what you mean</p>",
        "id": 153853996,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477335368
    },
    {
        "content": "<p>I have all the profiles loaded into my tool and build all the lineages as I describe.  I then generate snapshots by deciding which (fully populated) elements to include.  I'm not loading or not loading additional profiles to add to the snapshot.</p>",
        "id": 153853997,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477335453
    },
    {
        "content": "<p>So my point of view was to agree upon what a *complete* element looks like.</p>",
        "id": 153853998,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477335490
    },
    {
        "content": "<p>\"the challenge is that type profiles might not all be available at the time the snapshot is generated. I don't think we want to make snapshot generation dependent on the availability of all profiles. That in turn means that snapshots may not generate the same each time.\"</p>\n<p>To quote Grahame, seems like we're moving the deckchairs around.</p>\n<p>If we want to validate conformance against a profile that has references to external profiles, then we always need access to the information in those external profiles. If we allow the snapshot component to omit information from external profiles because they may be missing, then we put the burden to resolve the external profiles on the consuming application. If the application can't resolve external profiles either, then all bets are off and any computations against the profile are unreliable, esp. validation.</p>\n<p>Therefore, I don't see the benefits of allowing a \"partial\" snapshot by defining type profile merging as optional. If an application cannot rely on the snapshot to provide all required structural and type information, then the whole effort of serializing the snapshot seems moot. Because in that case, profile-based applications will have to dynamically resolve and generate all the required information necessary to compute reliable results anyway. So then why serialize a useless partial snapshot?</p>\n<p>Concrete, I propose:<br>\n- if the differential contains an element constraint with a single type, then for the snapshot we merge those diff constraints on top of the snapshot root element from the target type profile<br>\n- if the differential also specifies constraints on child elements, then we inline all the datatype child elements and merge the diff constraints on top of them</p>\n<p>Note: the snapshot generator in the .NET API library tries to handle errors (such as unresolved external references) gracefully by trying to continue generating the snapshot, finally returning a partial, incomplete result and a set of operation outcome issues. This way, a client application can detect and interpret errors and decide how to deal with the returned partial and incomplete snapshot. If the generator reports any issues, then the generated snapshot is not reliable.</p>",
        "id": 153854056,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477386275
    },
    {
        "content": "<p>what we said in baltimore was:<br>\n- generated types need to get inheritance right. I've done that now<br>\n- inlining the types would be optional. I'm not doing that right now, but I may get to it later (to make it optional)<br>\n- if you don't inline the types, any consuming software will have to resolve the types<br>\n- if you do inline the types, you could have consistency issues because editors won't have authority to update dependent profiles </p>\n<p>I don't think that a minimal snapshot is useless. The hard part of snapshot is doing the actual snapshot; following a link and applying a new set of rules is really quite trivial by comparison. </p>",
        "id": 153854064,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477386843
    },
    {
        "content": "<p>According to general FHIR principles, I'd rather move the burden to the server implementers and resolve external type profiles at authoring time, when tools can provide useful feedback to the profile author.</p>",
        "id": 153854065,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477386846
    },
    {
        "content": "<p>well, you can. But I object strenuously to making it always required</p>",
        "id": 153854067,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477386902
    },
    {
        "content": "<p>Off course in practice there will be situations where an external profile cannot be resolved. That's why the FHIR .NET API tries to handle this gracefully. But the resulting snapshot will be incomplete and unreliable.</p>",
        "id": 153854071,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477386975
    },
    {
        "content": "<p>\"if you do inline the types, you could have consistency issues because editors won't have authority to update dependent profiles\" <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> can you explain this?</p>",
        "id": 153854073,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477387007
    },
    {
        "content": "<p>so Author A writes type profile Ta<br>\nAuthor B write resource profile Rb<br>\nRb uses Ta, so it inlines Ta<br>\nNow Author A updates profile Ta to version 2. <br>\nRb is now wrong</p>",
        "id": 153854075,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387153
    },
    {
        "content": "<p>Yes, but IIRC FHIR states that if a new version of a profile introduces any breaking changes, then the new version should have a new, unique canonical url. Right?</p>\n<p>- Author A creates Ta*, <strong>compatible</strong> with Ta<br>\n- Profile author B regenerates Tb* by inlining Ta*.<br>\n  Then profile Tb* is compatible with profile Tb.<br>\n  After all, the total set of resource instances conforming to Tb* is the same as the set that conforms to Tb.<br>\n  So for profile validation, Tb and Tb* are interchangeable.<br>\n  So author B is not strictly required to update the snapshot.<br>\n  However if he chooses to, then the author is allowed to republish Tb* as a new version of Tb with the same canonical url.<br>\n- Author A creates Ta2, <strong>incompatible</strong> with Ta and Ta*<br>\n- Profile author B regenerates Tb2 by inlining Ta2.<br>\n  Then profile Tb2 is <strong>incompatible</strong> with profile Tb and Tb*.<br>\n  So profile Tb2 must be published with a new canonical url.</p>",
        "id": 153854105,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477388346
    },
    {
        "content": "<p>actually, your interpretation of breaking changes is not correct</p>",
        "id": 153854108,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477388400
    },
    {
        "content": "<p>Can you please enlighten me?</p>",
        "id": 153854109,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477388415
    },
    {
        "content": "<p>you've said that compatible means they are interchangeable for validation, but what we've said is that as long as instances conformant to Ta are also conformant to Ta*, then this is not a breaking change</p>",
        "id": 153854110,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477388471
    },
    {
        "content": "<p>so they are not interchangable</p>",
        "id": 153854111,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477388497
    },
    {
        "content": "<p>Ah so Ta* is allowed to relax constraints of Ta, so a bigger set of resources would now be conformant?</p>",
        "id": 153854114,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477388553
    },
    {
        "content": "<p>yes</p>",
        "id": 153854115,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477388609
    },
    {
        "content": "<p>I think the definition of \"breaking changes\" is problematic. Since there will be definitions of both the old version and the new version - both with the same canonical uri living in the world. So from the author perspective, there is backwards compatibility. But from a collaboration perspective, this order is not guaranteed.</p>",
        "id": 153854121,
        "sender_full_name": "Martijn Harthoorn",
        "timestamp": 1477389147
    },
    {
        "content": "<blockquote>\n<p>Chris wants more - he wants to inline content from the types to the containing models</p>\n</blockquote>\n<p>Yes, if a differential moves into a type, that type should be included in the snapshot. At least, that's the assumption I've been working with in my validator and the previous versions of the snapshot generator.</p>",
        "id": 153854122,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1477389204
    },
    {
        "content": "<p>no he wants something different to that. If you reference a type he wants to duplicate some information from the type into the profile - when you don't walk into it</p>",
        "id": 153854123,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477389317
    },
    {
        "content": "<p>@<strong>Martijn</strong> yes the definition is problematic, but the converse - Michel's definition - is much more problematic, because it means that there's no forwards migration path that doesn't mean a rewrite for trivial changes. In CDA space, this has proven a major issue</p>",
        "id": 153854124,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477389379
    },
    {
        "content": "<p>- Author A publishes Ta* which relaxes Ta constraints<br>\n- profile Tb*, which inlines Ta*, describes a new version of the implemented system</p>\n<p>- Assume that Sb represents the set of profiles that validate against Tb<br>\n  Assume that Sb* represents the set of resources that validate against Tb*<br>\n  So Sb* contains Sb and some additional resources</p>\n<p>- I don't think that there is a reasonable expectation that a system that has implemented Tb will automatically support Tb*<br>\n  Since it is not guaranteed that the system is able to handle the additional resources in set Sb*<br>\n  So profile Tb* is not guaranteed to describe the actual capabilities of the implemented system<br>\n- So profile Tb still describes the <strong>guaranteed</strong> capabilities of the implemented system<br>\n  So I wouldn't say Tb is now wrong.</p>",
        "id": 153854125,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477390267
    },
    {
        "content": "<p>there is a reaonable assumption unless the reference was version specific </p>",
        "id": 153854126,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477390317
    },
    {
        "content": "<blockquote>\n<p>so Author A writes type profile Ta<br>\nAuthor B write resource profile Rb<br>\nRb uses Ta, so it inlines Ta<br>\nNow Author A updates profile Ta to version 2. <br>\nRb is now wrong</p>\n</blockquote>\n<p>This issue exists when the profile \"walks into\" Ta as well.  Author B -when he wrote his profile- looked at type profile Ta when he produced his profile. and added applicable child constraints. It's debatable whether author B would like his profile to \"automatically\" accepts a broader set of instances if author A decides to change Ta by easing a constraint. Though I do agree that is our current methodology.   It's even more debatable for developers, who probably want a \"snapshotted\" version at compile time of their software.  Except maybe for some generic servers, I expect most developers don't want their software to automagically adapt if a type profile they depend on changes.</p>",
        "id": 153854127,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1477390458
    },
    {
        "content": "<p>How can there be an expectation on a system to support additional resources that it wasn't originally designed for?</p>",
        "id": 153854128,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477390485
    },
    {
        "content": "<p>Well, Spark could do that for example. But systems built on top of an existing database - no you can't expect them to do that.</p>",
        "id": 153854129,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1477390516
    },
    {
        "content": "<p>Yes, I was thinking about e.g. a (non-dynamic) user interface such as an input form.</p>",
        "id": 153854130,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477390581
    },
    {
        "content": "<p>is that how you design your software? clone type definitions so that when the source type definition is changed, you also have to manually update all the things that use it to tell them to use the new version?</p>",
        "id": 153854131,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477390629
    },
    {
        "content": "<p>Yes, I fully expect Epic to work this way for example.  They will implement Argonaut, but they will take a snapshot at the moment they implement and test the software. Any changes to dependent types will be done - but manually when the Epic team decides to update the dependent definitions. And this is the moment snapshots are re-generated.</p>\n<p>But Spark - no - it will adapt immediately</p>\n<p>Simplifier - yet another situation: we'd like to generate Snapshots once, not every single time someone requests the StructureDefinition. This requires dependency tracking.</p>",
        "id": 153854132,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1477392341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-email=\"grahame@healthintersections.com.au\">@Grahame Grieve</span> software design &amp; implementation usually depends on the requirements and budget of the client. For specific use cases, I expect that systems implement a final, vetted version of the IG that both client and vendor/integrator agreed upon (and may even be set into law). In such cases, I don't think there is an expectation for the implemented system to support unforeseen future requirements. Otherwise, vendors would have to rethink their business model... ;p</p>\n<p>Also, the term \"snapshot\" suggests that the component represents the state of some information at a specific moment in time (specified by StructureDefinition.date).</p>",
        "id": 153854141,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477395235
    },
    {
        "content": "<p>While I'm certainly interested in how we'll handle dependencies between profiles, determining the \"standard\" element format is a separate issue.  ALL snapshots will have dependency management issues - we've been dealing with that for years at this point.<br>\nMy question is: \"Should an element included in a snapshot contain all known parts (mappings, constraints, aliases, etc.) including those parts inherited from base *and* type profiles?\"</p>",
        "id": 153854150,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477405785
    },
    {
        "content": "<p>Changing the canonical URLs of all impacted profiles as soon as there's a breaking change to one of them is a huge pain.</p>",
        "id": 153854158,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1477412716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> the answer to your question is no. When you say that an element has a type, then you are saying that the value domain of the type applies to the element. It is not necessary to copy any of the value domain into the element that is assigned the type in order for those things to apply. </p>",
        "id": 153854160,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477415234
    },
    {
        "content": "<p>you can choose to duplicate some information as a matter of publishing convenience but it should never be required to do so, and replicating some, but not all, is problematic for any consumer since they are required to find the source in order to know what you have and haven't duplicated</p>",
        "id": 153854162,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477415356
    },
    {
        "content": "<p>While I understand your position (I think), to the casual observer you are advocating just that - replicating some but not all of what's needed to evaluate/describe an element (not including anything \"brought in\" from the type).  If we can be clear enough about that, I might be amenable.</p>\n<p>I don't much care for though the contents of a single element changing based on (what looks like) the addition of child elements, e.g. the content of the element for Patient.maritalStatus changes if Patient.maritalStatus.system is included (since now everything from CodeableConcept is inlined).  I understand *why* that happens, but it's subtle to an observer.</p>",
        "id": 153854167,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477415749
    },
    {
        "content": "<p>I don't understand in which respect I am advocating some but not all </p>",
        "id": 153854168,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477415798
    },
    {
        "content": "<p>Again, you're \"building up\" the snapshot by applying whole profiles incrementally.  I'm assembling the whole thing and then determining which elements to include.</p>",
        "id": 153854169,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477415829
    },
    {
        "content": "<p>If something forces the application of the type profile (including a child), then Patient.maritalStatus will include the ele-1 constriant.  If not, it won't.  What's included in an element depends on outside factors (even though the constraint is effective either way).</p>",
        "id": 153854170,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477416004
    },
    {
        "content": "<p>Running use cases in my head...</p>",
        "id": 153854171,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477416051
    },
    {
        "content": "<p>I'm not sure what you mean 'application of the type profile' </p>",
        "id": 153854172,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477416123
    },
    {
        "content": "<p>if the profile uses a type profile, and the adds additional constraints on it by walking into it, then the snapshot has to include all the type it references </p>",
        "id": 153854173,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477416161
    },
    {
        "content": "<p>Different mental model here - when you \"walk into\" the type, you apply the type profile at that point.  I hold everything in memory/model and link together a lineage - Patient.maritalStatus -&gt; CodeableConcept -&gt; Element.  I then build each element by aggregating the contents of the lineage.  That why my element contents don't change when I opt to include more/less elements in the snapshot.</p>",
        "id": 153854176,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477417382
    },
    {
        "content": "<p>so what's the difference between 'there are no children' and 'I didn't include the children'?</p>",
        "id": 153854177,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477417458
    },
    {
        "content": "<p>in the snapshot, nothing. By either of our methods.</p>",
        "id": 153854178,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477417496
    },
    {
        "content": "<p>In my model, not include Patient.maritalStatus.system is just suppression of extra detail.  In yours, it's an effect of not considering (\"walking into\") the type at all.  I think both are understandable (after extensive discussion!) - which would the average IT person assume?</p>",
        "id": 153854180,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477417926
    },
    {
        "content": "<p>maybe dependent on whether you're a modeler (my viewpoint) or an implementer (yours).</p>",
        "id": 153854181,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477418041
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> 's coming at it from a modeling standpoint as well...</p>",
        "id": 153854182,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477418088
    },
    {
        "content": "<p>I think he's primarily looking at from a publishing view point - it's about dependencies. you've got an element focus, not a type focus. What I was establishing is that your interest is different to Michel's focus</p>",
        "id": 153854183,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477418176
    },
    {
        "content": "<p>True...</p>",
        "id": 153854184,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477418207
    },
    {
        "content": "<p>I still think that we should stick to what we agreed in Baltimore: It's not necessary to inline profiles, but you can to the degree you find it useful. You and Michel have differing degrees to each (and to me)</p>",
        "id": 153854185,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477418219
    },
    {
        "content": "<p>Interesting how we can come out of meetings nodding together with different ideas in our heads!</p>",
        "id": 153854186,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477418319
    },
    {
        "content": "<p>I can get on board with a type focus....</p>",
        "id": 153854187,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477418335
    },
    {
        "content": "<p>breaks my tooling</p>",
        "id": 153854188,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477418342
    },
    {
        "content": "<p>badly</p>",
        "id": 153854189,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477418358
    },
    {
        "content": "<p>now I have to decide how deeply to navigate \"up\" the tree and stop (maybe) before I jump into the types.</p>",
        "id": 153854190,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477418391
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> - how does Forge work - do you decide which elements to include independently of calculating the contents of an element? Or do the elements \"appear\" as profiles are added (Patient.maritalStatus.system appears when CodeableConcept is added/applied)?</p>",
        "id": 153854192,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1477418777
    },
    {
        "content": "<p>Forge goes further than a regular snapshot; when loading/creating a profile, Forge expands the children of all complex types, regardless of wether the profile specifies differential child constraints - so the author can select the children and constrain them. The fully expanded structure is kept in memory. A separate layer generates the differential by including only nodes with actual constraints.<br>\nOn order to determine which elements to expand, Forge inspects the element type. If an element has a single complex type, then the children are being expanded (recursively).<br>\nRecently I've integrated the new and improved snapshot generation logic from the FHIR .NET API into Forge. I'm now reimplementing change tracking. When change tracking is finished, I want to leverage the new API snapshot generator logic to dynamically expand elements on the fly. So for example, if you constrain a choice type to single complex type such as CodeableConcept, then I'd like Forge to inline the child elements on the fly. Same for extensions. Also I want to implement a command to allow authors to manually expand elements with name references.</p>",
        "id": 153854342,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477480913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I agree that merging a (partial) type profile should not (and does not) change the meaning of the element definition, as the merged constraints are implied by the type profile constraint. However it does affect the completeness/usefulness of the snapshot component.</p>\n<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span>:</p>\n<div class=\"codehilite\"><pre><span></span> &quot;I don&#39;t much care for though the contents of a single element changing based on (what looks like) the addition of child elements&quot;\n</pre></div>\n\n\n<p>Agreed. Let's consider Grahame's approach for a profile with and without child constraints on Patient.identifier.system:</p>\n<p>(1) Patient profile with constraint on identifier, but without any child constraints:</p>\n<p>Patient.identifier          =&gt; not merged</p>\n<p>(2) Patient profile with constraint on identifier and additional child constraints:</p>\n<p>Patient.identifier          =&gt; merged onto Identifier<br>\nPatient.identifier.use      =&gt; merged onto Identifier.use</p>\n<p>So snapshot representation of the element \"Patient.identifier\" depends on the existance of nested child constraints...? So for example, element mappings and constraints inherited from the type profile root element are not merged into the snapshot, unless there are child constraints. This seems strange and could become a source of confusion.</p>\n<p>I agree that for convenience, we should be able to generate a (partial) snapshot even if some external profiles are unavailable. However it should be clear to the author that the resulting snapshot will be incomplete.</p>",
        "id": 153854349,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477493971
    },
    {
        "content": "<p>so the basic problem is that a user of the snapshot does not know when they need to consult with the type or not? I've been deciding that based on whether there is children or not - and automatically doing it for primitive types</p>",
        "id": 153854387,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477513359
    },
    {
        "content": "<p>Correct. I think the snapshot is generally more useful if individual snapshot ElementDefinitions always include relevant type constraints. Regardless of the presence or content of associated child constraints in the differential.<br>\nMaximizing completeness improves the usefulness of the snapshot, as well as minimizing variance. The latter also facilitates comparison.</p>",
        "id": 153854537,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1477577773
    },
    {
        "content": "<blockquote>\n<p>I think there are excellent patterns already in place for package management in Java and .NET (and others) - should we have something similar in the FHIR SD model?</p>\n</blockquote>\n<p>Yes, so this is a different issue than the \"merging\" and \"path walking\" issues above. I don't want to confuse both here, but it's really also true I realized that our dependencies are comparable to what happens in package management for libraries - and that means that our version management can learn from that. We know one of the popular strategies recently is actually doing what I described: give every solution a private copy of the dependencies (and its dependencies). Though it's fair to say there are fierce discussions about what's the right solution there too. </p>",
        "id": 153854828,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1477908313
    }
]