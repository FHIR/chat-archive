[
    {
        "content": "<p>Is it possible/allowed to assign meaning to slices according to their order?<br>\ne.g. I have an ordered, closed set of two slices, that are indistinguishable by their attributes.<br>\nThe first slice is mandatory, the second is optional.</p>\n<p>The reason for slicing is mostly to be able to add distinct documentation to each slice, the validation rules for both are the same.</p>",
        "id": 153916556,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1509140099
    },
    {
        "content": "<p>I don't think that's possible</p>",
        "id": 153916561,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1509145157
    },
    {
        "content": "<p>We've talked about being able to slice by order, but haven't implemented it.  (It would only be meaningful if the element being sliced is defined as having a semantic order.)</p>",
        "id": 153916565,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1509147609
    },
    {
        "content": "<p>In our case, it's about the payor element in Coverage.<br>\nWe always have a primary payor, in some cases, there's also a secondary. They're both references to Organizations conforming to the same profile.<br>\nI don't know how to convey that in my Coverage profile...</p>",
        "id": 153916588,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1509185908
    },
    {
        "content": "<p>I mean. There <em>are</em> ways to solve that. But all I could come up with so far (adding a \"secondaryPayor\"-Extension to Coverage or extending the Reference type to include a priority) seem kind of bulky compared to just simply saying: \"The first payor is primary and the second payor is secondary.\"</p>",
        "id": 153916589,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1509186247
    },
    {
        "content": "<p>Primary vs. secondary can be claim specific.  So I'd expect each to be a separate Coverage instance.  The Claim would then list them in order of precedence.</p>",
        "id": 153916602,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1509202975
    },
    {
        "content": "<p>No, actually that's what's on the data on our statutory health insurance card. It's the same coverage, except that some insurances don't handle the claim stuff themselves but refer it to another insurance. That's why we sometimes have two payor references that have slightly different semantics:<br>\nthe first is always the primary contact for everything whereas the secondary (if present) only handles the claims.</p>",
        "id": 153916610,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1509205873
    },
    {
        "content": "<p>The intention is to keep the mapping of the card data to the Coverage resource as straightforward as possible.</p>",
        "id": 153916611,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1509205963
    },
    {
        "content": "<p>Ah, so one is providing the coverage and one is doing the processing?</p>",
        "id": 153916613,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1509225582
    },
    {
        "content": "<p>Sort of, yes. I don't even know the details about it. The explanation I got from reading the card data spec wasn't very verbose.<br>\nOn second thought, I think the best way to go forward is to simply set the payor cardinality to 1..2 and add some prose to the definition of what it means if there's a second payor in an instance. In terms of validation it doesn't make a difference since both slices adhere to the same rules.</p>",
        "id": 153916621,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1509271770
    },
    {
        "content": "<p>Is tagging with an extension not an option?</p>",
        "id": 153917044,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1509526723
    },
    {
        "content": "<p>When we discussed this in the past, here's how it was suggested (by Grahame).  A simple use case was first name vs. middle name(s). I have no idea if any current infrastructure support this.  A profile would:<br>\n1. Declare an ordered slicing for an element (slicing.ordered:true) and no discriminator.<br>\n2. Create the first slice with a max:1<br>\n3. Create a second (and, if you desire, many more) with an appropriate max.<br>\nThe validator/parser would then \"consume\" the slices in order.<br>\nIt's tricky and error prone since the intent is relatively hidden.<br>\n<span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> - would your validators handle this?</p>",
        "id": 153917327,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1509637170
    },
    {
        "content": "<p>If there's no discriminator, then there must be a slicing description - and the validators would presume that the slicing mechanism is non-computable.  They certainly wouldn't presume that the slicing was based solely on order.</p>",
        "id": 153917333,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1509640716
    },
    {
        "content": "<p>Forge at least doesn't currently permit to create slicing as you describe. If the descriminator is empty, that's a hard error.</p>",
        "id": 153917338,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1509641397
    },
    {
        "content": "<p>Yep.  <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=9729\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=9729\">GF#9729</a> was to address this issue with the description I gave above given as the solution. And thus, the request was withdrawn.  If we don't think that works and nobody supports it, then we need to re-open the issue.</p>",
        "id": 153917371,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1509648053
    },
    {
        "content": "<p>Probably best to raise a new issue and point to the old one and explain why it needs to be readdressed</p>",
        "id": 153917514,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1509678518
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191450\">@Simone Heckmann</span> Forge simply tries enforce the standard invariants, including eld-1: \"On ElementDefinition.slicing: If there are no discriminators, there must be a definition\".<br>\nSo if you define an ordered slicing according to Chris' approach and fill in the slicing.description field, then the eld-1 invariant will hold.</p>",
        "id": 153917538,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1509717171
    },
    {
        "content": "<p>Ah! <em>That's</em> where I went wrong... Thanks!</p>",
        "id": 153917539,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1509717694
    },
    {
        "content": "<blockquote>\n<p>When we discussed this in the past, here's how it was suggested (by Grahame).  A simple use case was first name vs. middle name(s). I have no idea if any current infrastructure support this.  A profile would:<br>\n1. Declare an ordered slicing for an element (slicing.ordered:true) and no discriminator.<br>\n2. Create the first slice with a max:1<br>\n3. Create a second (and, if you desire, many more) with an appropriate max.<br>\nThe validator/parser would then \"consume\" the slices in order.<br>\nIt's tricky and error prone since the intent is relatively hidden.<br>\n<span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> - would your validators handle this?</p>\n</blockquote>\n<p>Sorry for the late reply, but no: as long as the repeats \"validate\" in the slice (since there's no discriminator, a repeat just needs to validate to the constraints of the slice), it will keep on \"filling\" that slice - disregarding the cardinality. You'll get an error saying that 1..1 was expected, but many were found...</p>",
        "id": 153921821,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1511869481
    }
]