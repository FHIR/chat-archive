[
    {
        "content": "<p>Can I perhaps direct your collective attention to a blog post by Marc Hadley, suggesting an alternate method of representing extensions? It is on <a href=\"http://lightmyfhir.org\" target=\"_blank\" title=\"http://lightmyfhir.org\">lightmyfhir.org</a> (<a href=\"http://lightmyfhir.org/2016/02/26/an-alternate-xml-syntax-for-fhir-extensions\" target=\"_blank\" title=\"http://lightmyfhir.org/2016/02/26/an-alternate-xml-syntax-for-fhir-extensions\">http://lightmyfhir.org/2016/02/26/an-alternate-xml-syntax-for-fhir-extensions</a>). I don't know if Marc's suggestion has gotten any eyeballs yet.  The post deals with XML, but we are also preparing a post with a JSON version. Marc did this in response to Grahame's call for feedback (see <a href=\"http://www.healthintersections.com.au/?p=2467\" target=\"_blank\" title=\"http://www.healthintersections.com.au/?p=2467\">http://www.healthintersections.com.au/?p=2467</a>) so I hope some of you will have a look.</p>",
        "id": 153813896,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1457101753
    },
    {
        "content": "<p>Thanks for the link <span class=\"user-mention\" data-user-id=\"191447\">@Mark Kramer</span> ! There was definitely <a href=\"http://wiki.hl7.org/index.php?title=FHIR_Extensions_Working_Page\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_Extensions_Working_Page\">some discussion of namespaces</a> (see \"Brian's Thoughts\"). I'm interested to see <span class=\"user-mention\" data-user-id=\"191438\">@Marc Hadley</span>'s JSON-focused follow-up.</p>",
        "id": 153813900,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457125740
    },
    {
        "content": "<p>I do so abominate namespaces, but I will reserve further comment until I've seen the JSON representation</p>",
        "id": 153813921,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457140014
    },
    {
        "content": "<p>this would also be possible:</p>",
        "id": 153813922,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457140042
    },
    {
        "content": "<div class=\"codehilite\"><pre>&lt;Patient\n    xmlns=&quot;http://hl7.org/fhir&quot;\n    xmlns:fhir=&quot;http://hl7.org/fhir&quot;&gt;\n  &lt;id value=&quot;patient-example&quot;/&gt;\n  ...\n  &lt;ct:clinicalTrial\n      xmlns:ct=&quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot;\n      fhir:isModifier=&quot;false&quot;&gt;\n    &lt;ct:NCT xsi:type=&quot;string&quot; value=&quot;NCT01647425&quot;/&gt;\n    &lt;ct:Period xsi:type=&quot;Period&quot;&gt;\n      &lt;start value=&quot;2012-04-01&quot;/&gt;\n      &lt;end value=&quot;2013-09-30&quot;/&gt;\n    &lt;/ct:Period&gt;\n    &lt;ct:Reason xsi:type=&quot;CodeableConcept&quot;&gt;\n      &lt;coding&gt;\n        &lt;system value=&quot;http://snomed.info/sct&quot;/&gt;\n        &lt;code value=&quot;254637007&quot;/&gt;\n        &lt;display value=&quot;NSCLC - Non-small cell lung cancer&quot;/&gt;\n      &lt;/coding&gt;\n    &lt;/ct:Reason&gt;\n  &lt;/ct:clinicalTrial&gt;\n  ...\n&lt;/Patient&gt;\n</pre></div>",
        "id": 153813923,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457140104
    },
    {
        "content": "<p>And: \"Code generation still works, tools like JAXB have no problem with XML schemas that include extensions defined elsewhere\"</p>",
        "id": 153813924,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457140191
    },
    {
        "content": "<p>is that true about lax? jaxb ignores anything in other namespaces, or it just blows up?</p>",
        "id": 153813925,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457140211
    },
    {
        "content": "<p>what about other code generators? </p>",
        "id": 153813926,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457140224
    },
    {
        "content": "<p>however, this explicitly breaks my most important requirement as I noted on a task on the original post, which has been ignored: all implementers can read and write all extensions when they generate code</p>",
        "id": 153813927,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457140347
    },
    {
        "content": "<p>as for: \"I don't know if Marc's suggestion has gotten any eyeballs yet\" - I hadn't seen it until you posted it here. Should I have seen it from elsewhere? </p>",
        "id": 153813928,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457140405
    },
    {
        "content": "<p>Grahame, thank you for the feedback. I don't understand what you mean by \"breaks my most important requirement...all implementers can read and write all extensions when they generate code.\"  Can you explain the situation where you envision there being a problem? Why wouldn't they be able to read and write extensions under Marc's proposed representation?</p>",
        "id": 153813972,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1457217251
    },
    {
        "content": "<p>I didn't mean to imply anything, just asking for feedback.</p>",
        "id": 153813974,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1457218923
    },
    {
        "content": "<p>hi Mark. In the approach you are proposing, If I generate code from the base schema, I'll lose all the extensions, yes?</p>",
        "id": 153813982,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457251584
    },
    {
        "content": "<p>Grahame , when you say \"generate code from the base schema\", do you mean you want to use code that navigates exclusively the vocabulary defined in the schema to serialize extensions?</p>",
        "id": 153814178,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1457346821
    },
    {
        "content": "<p>You wouldn't lose all of the extensions, at least you wouldn't if you were using JAXB. An xsd:any is mapped to a property of type Object[]. That array will be populated with either Element objects or instances of JAXB objects defined in extension schemas that were included in the JAXB context. See the examples here and the documentation of the lax annotation property: <a href=\"https://jaxb.java.net/nonav/2.1.3/docs/api/javax/xml/bind/annotation/XmlAnyElement.html\" target=\"_blank\" title=\"https://jaxb.java.net/nonav/2.1.3/docs/api/javax/xml/bind/annotation/XmlAnyElement.html\">https://jaxb.java.net/nonav/2.1.3/docs/api/javax/xml/bind/annotation/XmlAnyElement.html</a>.</p>",
        "id": 153814189,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457361891
    },
    {
        "content": "<p>I posted the accompanying proposal for an alternate JSON syntax here: <a href=\"http://lightmyfhir.org/2016/03/07/an-alternate-json-syntax-for-fhir-extensions/\" target=\"_blank\" title=\"http://lightmyfhir.org/2016/03/07/an-alternate-json-syntax-for-fhir-extensions/\">http://lightmyfhir.org/2016/03/07/an-alternate-json-syntax-for-fhir-extensions/</a></p>",
        "id": 153814190,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457362355
    },
    {
        "content": "<p>Hmm. This is sort of JSON-LD inspired, sure. You say that you have not adopted to JSON LD wholesale, but actually I think what you have proposed  here is not even quite compatible with that specification. Because you are relying on certain implicit behavior  to handle nested complex extensions. So you could not use a JSON LD library out of the box. Is that right?</p>",
        "id": 153814192,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457364378
    },
    {
        "content": "<p>That's right. Really the only part of JSON-LD used in this proposal is the namespacing of extension names.</p>",
        "id": 153814193,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457365294
    },
    {
        "content": "<p>That might confuse folks so it might be better to not use @context but rename it to @namespace or some such</p>",
        "id": 153814194,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457365353
    },
    {
        "content": "<p>note that RDF &lt;&gt; json-ld. We can't use json-ld</p>",
        "id": 153814213,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457377501
    },
    {
        "content": "<p>what's the scope of @context? There's a reason we studiously avoid manifests in HL7 content - you won't find it anywhere else</p>",
        "id": 153814214,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457377631
    },
    {
        "content": "<p>this question is a very big deal for me in with regard to this proposal </p>",
        "id": 153814215,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457377682
    },
    {
        "content": "<p>and relates directly to why we can't use json-ld</p>",
        "id": 153814216,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457377693
    },
    {
        "content": "<p>note that we could also move the type into the manifest too</p>",
        "id": 153814217,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457377761
    },
    {
        "content": "<p>anyway, I think you should be narrow, and call this @extension and way that the extension definition applies to siblings of the element on which it is declared, and on all children, but *not* on parents or siblings of parents (e.g. same scope as xml namespaces)</p>",
        "id": 153814269,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457386205
    },
    {
        "content": "<p>.. and say.. not .. and way... (don't know why I can't edit that one)</p>",
        "id": 153814270,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457386210
    },
    {
        "content": "<p>Grahame,  agreed. I'd go a bit further and say that definitions do not apply to grandchildren or their descendants. If, e.g. I define a \"code\" extension that shouldn't apply to any deeper scoped use of that name as those are already defined by the semantics of the parent.</p>",
        "id": 153814278,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457387002
    },
    {
        "content": "<p>have to repeat the extension definition ad nauseam?</p>",
        "id": 153814279,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457387066
    },
    {
        "content": "<p>IOW, the @extension just applies to the extensions at this level. If you extend extensions then you need to add in a new @extension to identify the extensions extension.</p>",
        "id": 153814280,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457387129
    },
    {
        "content": "<p>I'm thinking of the case .. in code system and questionaire .. where concepts contain concepts and questions contain questions</p>",
        "id": 153814281,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457387176
    },
    {
        "content": "<p>I feel another example coming on...</p>",
        "id": 153814282,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457387182
    },
    {
        "content": "<p>if you use an extension on a concept, you're likely to use them on contained concepts too </p>",
        "id": 153814283,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457387195
    },
    {
        "content": "<p>Good point. I think there are pros and cons here.</p>",
        "id": 153814284,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457387271
    },
    {
        "content": "<p>Maybe we could say that the @extension defines names of extensions but doesn't override existing properties with the same name.</p>",
        "id": 153814291,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457388139
    },
    {
        "content": "<p>yes it sure can't do that. Wonder if there's naming restrictions we would need to ensure that you don't create name clashes</p>",
        "id": 153814292,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457388483
    },
    {
        "content": "<p>Marc, thinking more about this- I think this has real problems</p>",
        "id": 153814307,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457401920
    },
    {
        "content": "<div class=\"codehilite\"><pre>patient = {...second example above...}\nnct = patient[&quot;patient-clinicalTrial&quot;].NCT.valueString\n</pre></div>",
        "id": 153814308,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457401948
    },
    {
        "content": "<p>only, you can't. you actually have a much worse problem than that the original code  </p>",
        "id": 153814310,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457402013
    },
    {
        "content": "<div class=\"codehilite\"><pre>patient = {...first example above...}\nclinicalTrials = element for name as found in @context @id is &quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot;\nnct = nct.clinicalTrails.valueString\n</pre></div>",
        "id": 153814311,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457402106
    },
    {
        "content": "<p>e.g. we would be subsituting looking up the extension for looking up the name gained by looking up the extension. I think this is worse, not better</p>",
        "id": 153814312,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457402132
    },
    {
        "content": "<p>I just re-read all the blog posts. I think I now understand what you think you mean by 'treat extensions and normal elements the same' and, I'm afraid, you won't be able to treat them the same - and, in fact, you haven't even started to do so. They're different. Sorry</p>",
        "id": 153814339,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457434661
    },
    {
        "content": "<p>I see what you are getting at, but I still think its better. Compare:</p>",
        "id": 153814384,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457441874
    },
    {
        "content": "<div class=\"codehilite\"><pre>clinicalTrials = (extension for extension in patient.extension when extension.url is &quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot;)\nncts = (extension for extension in clinicalTrials[0].extension when extension.url is &quot;NCT&quot;)\nnct = ncts[0].valueString\n</pre></div>",
        "id": 153814385,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457441926
    },
    {
        "content": "<p>vs</p>",
        "id": 153814386,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457441935
    },
    {
        "content": "<div class=\"codehilite\"><pre>localname = (localname for localname, defn of patient2[&quot;@context&quot;] when defn[&quot;@id&quot;] is &quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot;)[0]\nnct = patient2[localname].NCT.valueString\n</pre></div>",
        "id": 153814387,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457441985
    },
    {
        "content": "<p>so you made complex extensions slightly easier at the price of making simple extensions harder</p>",
        "id": 153814388,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442013
    },
    {
        "content": "<p>(the second being the proposed, the first being current)</p>",
        "id": 153814389,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442026
    },
    {
        "content": "<p>and it's unsafe, since almost all javascript programmers will refuse to use that method, and just use the 'fixed' name, only it's not fixed, and can't be </p>",
        "id": 153814390,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442066
    },
    {
        "content": "<p>Are simple extensions actually harder though? With the current representation you still have to loop over an array looking for the one you want.</p>",
        "id": 153814392,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442095
    },
    {
        "content": "<p>here, you have a double loop </p>",
        "id": 153814395,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442136
    },
    {
        "content": "<p>to get the name you want. </p>",
        "id": 153814396,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442143
    },
    {
        "content": "<p>then use it </p>",
        "id": 153814397,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442147
    },
    {
        "content": "<p>as opposed to just looking for the extension you want</p>",
        "id": 153814398,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442157
    },
    {
        "content": "<p>There's only one loop</p>",
        "id": 153814399,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442185
    },
    {
        "content": "<p>this is much harder than simply using the full extension name as the property, which was roundly rejected when we tried that </p>",
        "id": 153814401,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442197
    },
    {
        "content": "<p>The other approach would be to move further away from JSON-LD and invert the extension map to put URI as the key then its just map lookups all the way</p>",
        "id": 153814406,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442274
    },
    {
        "content": "<p>I think that's what we tried. As simple as we could. and it got voted down strongly</p>",
        "id": 153814408,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442310
    },
    {
        "content": "<p>it wasn't perfect; we still had to deal with modifier extensions. </p>",
        "id": 153814409,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442331
    },
    {
        "content": "<p>so I'm skeptical. I think </p>",
        "id": 153814410,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442347
    },
    {
        "content": "<p>I included modifiers in my proposal</p>",
        "id": 153814411,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442357
    },
    {
        "content": "<p>but lets see other opinions</p>",
        "id": 153814412,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442359
    },
    {
        "content": "<p>Example:</p>\n<div class=\"codehilite\"><pre>patient = {\n  &quot;@extension&quot; : {\n    &quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot;: {\n      &quot;@localname&quot;: &quot;clinicalTrial&quot;,\n      &quot;@isModifier&quot;: false\n    }\n  }\n  &quot;resourceType&quot; : &quot;Patient&quot;,\n  &quot;clinicalTrial&quot; : {\n    &quot;NCT&quot; : {\n      &quot;valueString&quot; : &quot;123456789&quot;\n    },\n    &quot;period&quot;: { \n      &quot;valuePeriod&quot; : {\n         &quot;start&quot; : &quot;2009-03-14&quot; \n      }   \n    },\n    &quot;reason&quot;: {\n      &quot;valueCodeableConcept&quot; : {\n          &quot;coding&quot; : {\n             &quot;system&quot; : &quot;http://acme.org/codes/general&quot;,\n             &quot;code&quot; : &quot;tt14j&quot;\n          }\n       }\n    }\n  }\n}\n</pre></div>",
        "id": 153814416,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442408
    },
    {
        "content": "<p>so I still iterate the @extension, which needs to be an array, right? and then find the name then look for then name... why not just iterate the extensions? </p>",
        "id": 153814418,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442478
    },
    {
        "content": "<div class=\"codehilite\"><pre>localname = patient[&quot;@extension&quot;][&quot;@localname&quot;]\nnct = patient[localname].NCT.valueString\n</pre></div>",
        "id": 153814420,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442534
    },
    {
        "content": "<p>@extension is an object since the keys are unique</p>",
        "id": 153814422,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442563
    },
    {
        "content": "<p>so you can only have one extension on an element at once? </p>",
        "id": 153814424,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442610
    },
    {
        "content": "<p>one @extension with multiple children, one per extension</p>",
        "id": 153814425,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442635
    },
    {
        "content": "<p>remind me, what happens in javascript, if the extension is not defined, or not present, and you use the code above?</p>",
        "id": 153814427,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457442746
    },
    {
        "content": "<div class=\"codehilite\"><pre>&quot;@extension&quot; : {\n  &quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot;: {\n    &quot;@localname&quot;: &quot;clinicalTrial&quot;,\n    &quot;@isModifier&quot;: false\n  }\n  &quot;http://hl7.org/fhir/StructureDefinition/us-core-race&quot;: {\n    &quot;@localname&quot;: &quot;race&quot;,\n    &quot;@isModifier&quot;: false\n  }\n}\n</pre></div>",
        "id": 153814430,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442818
    },
    {
        "content": "<p>Just realized I messed up the code there, should have been:</p>\n<div class=\"codehilite\"><pre>localname = patient[&quot;@extension&quot;][&quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot;][&quot;@localname&quot;]\nnct = patient[localname].NCT.valueString\n</pre></div>",
        "id": 153814435,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457442988
    },
    {
        "content": "<p>In this code if there's no @extension then you'd get back undefined which would throw a TypeError when you tried to get the local name property</p>",
        "id": 153814437,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457443065
    },
    {
        "content": "<p>so the code is going to get more complex yet</p>",
        "id": 153814438,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457443080
    },
    {
        "content": "<p>Same goes for the current representation, I didn't put any error handling in that either</p>",
        "id": 153814439,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457443123
    },
    {
        "content": "<p>well, the loop form is kind of more tolerant of missing items by it's nature. kind of </p>",
        "id": 153814440,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457443234
    },
    {
        "content": "<p>I'm still not persauded. but it's sleep time, and so I'll see what others think</p>",
        "id": 153814441,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457443253
    },
    {
        "content": "<p>Personally I think the loop code is more complicated. A robust implementation has to handle missing and duplicate entries etc. My short code snippet just assumes there is one extension with the right URL and that it has one child extension for NCT (hence the [0] in a couple of places). These would blow the code up if the assumptions failed.</p>",
        "id": 153814444,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457443679
    },
    {
        "content": "<p>BTW, a more robust code snippet in CoffeeScript:</p>\n<div class=\"codehilite\"><pre>localname = patient[&quot;@extension&quot;]?[&quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot;]?[&quot;@localname&quot;]\nnct = patient[localname]?.NCT?.valueString\n</pre></div>\n\n\n<p>this yields <code>undefined</code> for <code>nct</code> if anything is missing</p>",
        "id": 153814445,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457443890
    },
    {
        "content": "<p>Three concerns with the XML approach: <br>\n- xs:ANY is going to encourage people to send any XML they can dream up - including attributes and attributes with namespaces and other things that can't be round-tripped to JSON.  We could introduce invariants, but it'd be complicated<br>\n- it's harder for people to handle extensions generically.  There are times when you want to take all extensions and store them in a single way or to count them.  (E.g. If you've got narrative that was generated from extensions, you want to quickly scan through all of the extension elements to see which ones you recognize)<br>\n- (minor) HL7-defined extensions would need a distinct namespace from the base spec, which makes resolving them to html more complicated</p>\n<p>I share Grahame's concerns about the JSON.  I see a lot of implementers taking the easy (wrong) route.</p>",
        "id": 153814456,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457452100
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> could you give an example of what you mean by invariants in your first bullet above?</p>",
        "id": 153814463,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457461825
    },
    {
        "content": "<p>Well, we could have an invariant as an xpath that indicated that only specific attributes are allowed.  E.g. context = @*, assertion name=('id', ...)</p>\n<p>However, that won't work as a FHIRPath because FHIRPath doesn't distinguish elements and attributes.  So we might actually allow a new element on StructureDefinition to support doing this.</p>",
        "id": 153814466,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457462315
    },
    {
        "content": "<p>HL7 defined extensions - that's a problem, because they're in the same namespace</p>",
        "id": 153814473,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457463542
    },
    {
        "content": "<p>I missed that</p>",
        "id": 153814474,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457463547
    },
    {
        "content": "<p>Do they have to be in the same namespace? Possible to add some kind of ns suffix like /extension ?</p>",
        "id": 153814484,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457464316
    },
    {
        "content": "<p>no, they're not. scratch that. They are in a differnt namespace (just same root)</p>",
        "id": 153814485,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457464379
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> does the @context/@extension preamble meet your requirements for identifying extensions in the JSON format? Not sure of the best way to do that for XML, would prefer to avoid a wrapper element if possible.</p>",
        "id": 153814491,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457467140
    },
    {
        "content": "<p>Easy enough in XPath I guess: <code>/*/*[namespace-uri(.)!=\"http://hl7.org/fhir\"]</code></p>",
        "id": 153814498,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457470413
    },
    {
        "content": "<p>I think you'd skip one of the /*, because you'd want direct children, but yes, that could work.   @context doesn't work terribly well if it appears as a manifest at the top of the instance.  It would need to be declared inside each node where extensions appear.</p>",
        "id": 153814501,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457470971
    },
    {
        "content": "<p>The first /* was to match any top level resource. Your use case is to find all extensions at any level or just those at the top level?</p>",
        "id": 153814502,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457471119
    },
    {
        "content": "<p>The use-case is to find extensions for the current node</p>",
        "id": 153814503,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457471146
    },
    {
        "content": "<p>so <code>./*[namespace-uri(.)!=\"http://hl7.org/fhir\"]</code> in XPath.</p>",
        "id": 153814504,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457471206
    },
    {
        "content": "<p>We didn't settle on scoping of @context/@extension, I was advocating for one per level of nesting but Grahame pointed out that would be a pain for extensions to types that nest.</p>",
        "id": 153814505,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457471365
    },
    {
        "content": "<p>Manifests are a pain in general - they're either all over the place or they aren't in the context where you need them.  Hard to find the right balance.</p>",
        "id": 153814506,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457472026
    },
    {
        "content": "<p>... or they are out of step with the actual content</p>",
        "id": 153814581,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457540858
    },
    {
        "content": "<p>Yeah, that can be a challenge too.</p>",
        "id": 153814582,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457541223
    },
    {
        "content": "<p>You have to spell things out for me. I'm assuming you are referring to code generated at design time. At that time, there are no instances of resources, and no instances of extensions, so how can extensions they be lost?  There are StructureDefinitions, but one can't assume a full set. Nonetheless, you can still parse and store whatever comes down the wire under our suggestion. You just don't know what the extensions mean, necessarily. I must be totally missing your point.</p>",
        "id": 153814595,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1457544147
    },
    {
        "content": "<p>The code written for processing an instance needs to be able to  easily find the list of all extensions beneath a particular node.  We have a solution that works for XML.  The solution works for JSON only if the context is declared on every node (including recursive nodes.</p>",
        "id": 153814599,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457549068
    },
    {
        "content": "<p>One of the concerns with the proposed JSON representation is that the \"local name\" in JSON is essentially insignificant but naive developers might assume that it is fixed and ignore the mapping to a URI. I'm wondering if the team considered using qualified names to disambiguate local names, e.g.:</p>\n<div class=\"codehilite\"><pre>patient = {\n  &quot;resourceType&quot; : &quot;Patient&quot;,\n  &quot;org.hl7.clinicalTrial&quot; : {\n    &quot;@extension&quot;: &quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot;,\n    &quot;@isModifier&quot;: false\n    &quot;NCT&quot; : {\n      &quot;valueString&quot; : &quot;123456789&quot;\n    },\n    &quot;period&quot;: { \n      &quot;valuePeriod&quot; : {\n         &quot;start&quot; : &quot;2009-03-14&quot; \n      }   \n    },\n    &quot;reason&quot;: {\n      &quot;valueCodeableConcept&quot; : {\n          &quot;coding&quot; : {\n             &quot;system&quot; : &quot;http://acme.org/codes/general&quot;,\n             &quot;code&quot; : &quot;tt14j&quot;\n          }\n       }\n    }\n  }\n}\n</pre></div>",
        "id": 153814601,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457549317
    },
    {
        "content": "<p>The above also breaks up the manifest and puts the extension id as a child of the top level extension (just like you use url in the current representation).</p>",
        "id": 153814602,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457549391
    },
    {
        "content": "<p>How would you make those globally unique if they weren't a URI?  And why have both?</p>",
        "id": 153814603,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457549428
    },
    {
        "content": "<p>I used a java-like <code>org.hl7.clinicalTrial</code> but other naming schemes could work just as well.</p>",
        "id": 153814604,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457549430
    },
    {
        "content": "<p>It seems weird to have two globally unique names</p>",
        "id": 153814605,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457549469
    },
    {
        "content": "<p>OIDs are globally unique without being URIs...</p>",
        "id": 153814606,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457549476
    },
    {
        "content": "<p>Right.  But we don't use OIDs</p>",
        "id": 153814607,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457549503
    },
    {
        "content": "<p>I think you mentioned earlier that developers didn't like using URIs as keys</p>",
        "id": 153814608,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457549510
    },
    {
        "content": "<p>Right.  They didn't like long strings as keys.</p>",
        "id": 153814609,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457549530
    },
    {
        "content": "<p>OIDs can be URIs. urn:oid:OID-HERE</p>",
        "id": 153814610,
        "sender_full_name": "Rick Geimer",
        "timestamp": 1457549565
    },
    {
        "content": "<p>And this isn't going to be significantly shorter than the URL and would also be redundant with the URL.</p>",
        "id": 153814611,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457549569
    },
    {
        "content": "<p><code>org.hl7.clinicalTrial</code> is intended to work like an old, the authority <code>org.hl7</code> is the only org that can use ids starting with that string and is responsible for ensuring uniqueness.</p>",
        "id": 153814612,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457549586
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191407\">@Rick Geimer</span> True, but we discourage doing that.  (And avoid doing it for anything HL7 Int'l is responsible for)</p>",
        "id": 153814613,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457549605
    },
    {
        "content": "<p>But in general I find my developers like the URIs with somewhat meaningful names. </p>",
        "id": 153814614,
        "sender_full_name": "Rick Geimer",
        "timestamp": 1457549607
    },
    {
        "content": "<p>And it's easier to teach someone to make up a URI for their company's patient IDs or internal codes than it is to ask them to get an OID from HL7. </p>",
        "id": 153814615,
        "sender_full_name": "Rick Geimer",
        "timestamp": 1457549651
    },
    {
        "content": "<p>Especially now that they have to pay for the privilege of an OID once they've wrapped their heads around what it is . . .</p>",
        "id": 153814616,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1457549692
    },
    {
        "content": "<p>I'd actually be OK with using URIs for keys like this:</p>\n<div class=\"codehilite\"><pre>patient = {\n  &quot;resourceType&quot; : &quot;Patient&quot;,\n  &quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot; : {\n    &quot;@isModifier&quot;: false\n    &quot;NCT&quot; : {\n      &quot;valueString&quot; : &quot;123456789&quot;\n    },\n    &quot;period&quot;: { \n      &quot;valuePeriod&quot; : {\n         &quot;start&quot; : &quot;2009-03-14&quot; \n      }   \n    },\n    &quot;reason&quot;: {\n      &quot;valueCodeableConcept&quot; : {\n          &quot;coding&quot; : {\n             &quot;system&quot; : &quot;http://acme.org/codes/general&quot;,\n             &quot;code&quot; : &quot;tt14j&quot;\n          }\n       }\n    }\n  }\n}\n</pre></div>\n\n\n<p>but I didn't suggest it as I thought that was already rejected</p>",
        "id": 153814617,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457549696
    },
    {
        "content": "<p>Exactly Lloyd. </p>",
        "id": 153814618,
        "sender_full_name": "Rick Geimer",
        "timestamp": 1457549775
    },
    {
        "content": "<p>If we want a short globally unique name there aren't many alternatives to some kind of naming convention like that used in Java.</p>",
        "id": 153814620,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457550051
    },
    {
        "content": "<p>Marc - indeed that was already rejected, and I think it's better than your proposal. </p>",
        "id": 153814636,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457555946
    },
    {
        "content": "<p>which suggests to me that all this discussion is actually moot. :-(</p>",
        "id": 153814637,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457555964
    },
    {
        "content": "<p>and it wasn't rejected because they were long, but because it deviated from the conceptual model which creates cognitive dissonance. </p>",
        "id": 153814639,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457556120
    },
    {
        "content": "<p>Grahame, I'm coming to the same conclusion but before I give up can you explain what you mean by \"deviated from the conceptual model\" - what conceptual model is that, where can I read about it?</p>",
        "id": 153814648,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457557295
    },
    {
        "content": "<p>Still noodling on this as I'm convinced we can get to a more readable/natural representation that the current one. How about the following:</p>\n<div class=\"codehilite\"><pre>{\n  &quot;resourceType&quot; : &quot;Patient&quot;,\n  &quot;extension&quot; : [\n    {\n      &quot;url&quot;: &quot;http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial&quot;,\n      &quot;isModifier&quot;: false\n      &quot;NCT&quot; : {\n        &quot;valueString&quot; : &quot;123456789&quot;\n      },\n      &quot;period&quot;: { \n        &quot;valuePeriod&quot; : {\n           &quot;start&quot; : &quot;2009-03-14&quot; \n        }   \n      },\n      &quot;reason&quot;: {\n        &quot;valueCodeableConcept&quot; : {\n            &quot;coding&quot; : {\n               &quot;system&quot; : &quot;http://acme.org/codes/general&quot;,\n               &quot;code&quot; : &quot;tt14j&quot;\n            }\n         }\n      }\n    }\n  ]\n}\n</pre></div>",
        "id": 153814770,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457623742
    },
    {
        "content": "<p>This is quite close to the current representation in that all extensions live in an array and are identified by url. The key difference is that the members of a complex extension (e.g. NCT) are first class children of the extension rather than being nested extensions. You could still add nested extensions as you would now but at least code that understands an extension could path into it directly rather than doing a loop comprehension over the nested extensions.</p>",
        "id": 153814771,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457623893
    },
    {
        "content": "<p>And you'd say: to identify the properties in a complex extension, look for all properties within an extension <strong>other than</strong> <code>url</code>, <code>isModifier</code>, <code>extension</code> and <code>modifierExtension</code>?</p>",
        "id": 153814772,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457624588
    },
    {
        "content": "<p>You could do that. I was kind of assuming that if you know the extension then you know the properties you are expecting. If you don't know the extension and just want to treat it generically then you can treat all the properties generically.</p>",
        "id": 153814774,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457624859
    },
    {
        "content": "<p>Agreed, if you \"know\" the extension you just examine and use the properties you know. That generic treatment is what I was trying to understand/specify.</p>",
        "id": 153814775,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457625237
    },
    {
        "content": "<p>IOW, if my code knows about the clinical trial extension then it know that there should be an NCT property. Same as if my code knows how to work with Patient resources it knows to expect names and telecoms etc. This is what we meant by treating extensions the same as core elements in our proposed requirements. </p>",
        "id": 153814776,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457625255
    },
    {
        "content": "<p>i.e. what would the \"generic treatment\" algorithm look like?</p>",
        "id": 153814777,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457625256
    },
    {
        "content": "<p>What is your generic treatment algorithm intended to accomplish?</p>",
        "id": 153814779,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457625313
    },
    {
        "content": "<p>For example, you'd want a generic algorithm that could convert from JSON to XML.</p>",
        "id": 153814780,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457625824
    },
    {
        "content": "<p>Or one that could display relevant details to a human when you don't know how to compute on an extension. </p>",
        "id": 153814781,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457625826
    },
    {
        "content": "<p>If we went this route we'd need to figure out the corresponding XML representation. Without giving it too much thought I think we could go with a top level extension element with local name extension and ns URI corresponding to the structure def URL. You'd map properties other than url, isModifier to child elements and map isModifier to an attribute on the extension element.</p>",
        "id": 153814782,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457626297
    },
    {
        "content": "<p>Yes -- this is the kind of stuff I mean :-)</p>",
        "id": 153814783,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457626337
    },
    {
        "content": "<p>For human readable display then you can map the JSON to some kind of HTML view of the content, kind of the way Java IDEs display JavaBeans.</p>",
        "id": 153814784,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457626409
    },
    {
        "content": "<p>Having regular local names rather than URLs would help I think</p>",
        "id": 153814785,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457626446
    },
    {
        "content": "<p>Quite. I like this, for what it's worth. </p>",
        "id": 153814786,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457626586
    },
    {
        "content": "<p>How would you distinguish arrays vs. single values?</p>",
        "id": 153814787,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457626640
    },
    {
        "content": "<p>(In a way that allows round-tripping with XML, \"generically\").</p>",
        "id": 153814788,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457626660
    },
    {
        "content": "<p>If the property cardinality is &gt; 1 then always use an array in JSON, use repeating elements in XML.</p>",
        "id": 153814789,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457626770
    },
    {
        "content": "<p>so if NCT were multivalued then the value would be an array of objects, each with a single valueString property.</p>",
        "id": 153814790,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457626826
    },
    {
        "content": "<blockquote>\n<p>If the property cardinality is &gt; 1 then always use an array in JSON, use repeating elements in XML.</p>\n</blockquote>\n<p>The concern  with this rule is that you can't tell from the XML how to generate the JSON (you see one element, but maybe it's a repeating list that just happens to have one member in this particular instance).</p>",
        "id": 153814803,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457629766
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span>  Yes that's an issue. Two alternatives are to always use arrays or to use an array when there is more than one value. The former would be unfortunate if the goal is to make the JSON more natural, the latter adds complexity since code needs to handle both cases whenever a field can have more than one value.</p>",
        "id": 153814863,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457640361
    },
    {
        "content": "<p>Right. The third option is adding an <code>isArray=\"true\"</code> attribute to the XML.</p>",
        "id": 153814864,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457640399
    },
    {
        "content": "<p>I would never agree to 'use an array when there is more than one value' - in one short step, you destroy the value proposition completely </p>",
        "id": 153814865,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457640443
    },
    {
        "content": "<p>When we've discussed this before, we have generally reluctantly come around to adding metadata to xml, but that's going to problematic </p>",
        "id": 153814866,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457640475
    },
    {
        "content": "<p>I'm not feeling great about the course of this discussion; it seems to me that we haevn't begun to have the kind of wider discussion that would get this through ballot. Irrespective of the technical merits of any of the proposals. </p>",
        "id": 153814867,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457640535
    },
    {
        "content": "<p>Any suggestions to get wider input? I'd be happy to write up a new blog post that captures the essence of the discussion so far and shows a couple of examples of the latest proposal.</p>",
        "id": 153814871,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457640695
    },
    {
        "content": "<p>well, we're discussing it here - a very few of us. I've had some out of band comments about the discussion but they haven't indicated that people are afraid of the discussion, just the possible outcome. and we've emailed the list, and you've blogged about it. So there's nothing methodological that we haven't done that we usually do. It's just not getting traction with people</p>",
        "id": 153814873,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457640811
    },
    {
        "content": "<p>I've done what I can to prod things gently. I could be less gentle, I guess, but I'm not sure it's worth doing that</p>",
        "id": 153814874,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457640867
    },
    {
        "content": "<p>Looks like there are very few complex extensions currently and for simple extensions I think the current format is OK. It wasn't until we tried to build the first round of CDS extensions with multiple levels of nested extensions that it really occurred to me that a better representation was needed.</p>",
        "id": 153814884,
        "sender_full_name": "Marc Hadley",
        "timestamp": 1457642285
    },
    {
        "content": "<p>+1 I'm with you on this, <span class=\"user-mention\" data-user-id=\"191438\">@Marc Hadley</span> </p>",
        "id": 153814885,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457642387
    },
    {
        "content": "<p>yes that's not unreasonable. But CDS extensions on Basic weren't really what we designed extensions for</p>",
        "id": 153814888,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457644250
    },
    {
        "content": "<p>ad-hoc extensions to well understood contents is a totally different ball game to taking basic and building a whole set of stuff on it. I looked at that stuff and winced. But not because of syntax, but because other decisions forced us to that point. </p>",
        "id": 153814889,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457644312
    },
    {
        "content": "<p>Speaking of extensions, I'm working on a CDS app using FHIR that is planning on using extensions to represent relative timings in Order Sets (where there's structure to when actions should be performed, but the start date / patient isn't known). Is there a particular way you all would recommend structuring that, or do you know if there are any modifications to Timing coming down the pipe?</p>",
        "id": 153814890,
        "sender_full_name": "Andrew Ross",
        "timestamp": 1457644415
    },
    {
        "content": "<p>True, they weren't designed for Basic, but my perception is that there aren't a whole lot of complex extensions out in the wild yet, but I expect that over time there will be. So, fixing complex extensions now  to make them easier and nice forever more makes sense.</p>",
        "id": 153814891,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1457644433
    },
    {
        "content": "<p>There is always proposals to extend the timing data type to make the timing relative to some arbitrary event, but the nature of the event and the linkage vary wildly. So we don't think that putting these details in TIming make sense - we think that this is something that belongs on the context where it is used. At least, that's what I think, and the analysis of reuqirements is certainly wildy variant</p>",
        "id": 153814893,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457644596
    },
    {
        "content": "<p>jason - maybe.. but I think they are already easy and nice. Or to be more clear, what we have now is a compromise between 'easy and nice' from various perspectives, and it's not clear that the alternatives we've discussed here represent a more optimal approach overall than the current arrangement</p>",
        "id": 153814894,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457644691
    },
    {
        "content": "<p>@Andrew, we are working on modeling exactly that relationship between elements within the OrderSet resource. Agree with Grahame that the relationships should be stated at the container, rather than on the Timing element directly.</p>",
        "id": 153814899,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1457644837
    },
    {
        "content": "<p>ok, that's good to hear. If you have any examples of what you're thinking so far, or if you have an estimate of the timing (no pun intended) when you think that would be released, it would be great to know</p>",
        "id": 153814902,
        "sender_full_name": "Andrew Ross",
        "timestamp": 1457644893
    },
    {
        "content": "<p>we're hoping that our system will integrate with multiple others, so we can't just make an ad-hoc agreement with one</p>",
        "id": 153814908,
        "sender_full_name": "Andrew Ross",
        "timestamp": 1457644929
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191516\">@Andrew Ross</span> I'll get an example over the next few days. Agree about one way to do it, we're putting this in the OrderSet resource itself, it won't be an extension (so it's probably not an appropriate topic for this stream anymore :)).</p>",
        "id": 153814929,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1457647903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> awesome :) i appreciate it!</p>",
        "id": 153814933,
        "sender_full_name": "Andrew Ross",
        "timestamp": 1457648681
    },
    {
        "content": "<p>I personally did not mind the &gt; year old proposal for Json to have the extension url as the object member name, and I think these discussions have converged on that format again. I was at the meeting (it was the connectathon actually) where that extension format was voted down. I also would not mind having \"repeat=yes\" attribute or whatever in the xml to make interconversion easier.</p>",
        "id": 153815429,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1457975674
    },
    {
        "content": "<p>The main problem I'd have with URLs as object property name is that it \"breaks\" the JS in JSON, since you can't have property names with <code>/</code> and <code>.</code> in JS.</p>",
        "id": 153815440,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1457979324
    },
    {
        "content": "<p>Well, you can't address those properties with the <code>.</code> operation. You can, of course, with quotes, as in :</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">var</span> <span class=\"nx\">a</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"s2\">&quot;simple&quot;</span><span class=\"o\">:</span> <span class=\"s2\">&quot;as&quot;</span><span class=\"p\">,</span>\n  <span class=\"s2\">&quot;can/be&quot;</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">a</span><span class=\"p\">.</span><span class=\"nx\">simple</span><span class=\"p\">,</span> <span class=\"nx\">a</span><span class=\"p\">[</span><span class=\"s2\">&quot;can/be&quot;</span><span class=\"p\">]);</span>\n</pre></div>\n\n\n<p>(I know this is already clear to <span class=\"user-mention\" data-user-id=\"191339\">@Pascal Pfiffner</span>. I'm just being explicit/pedantic here.)</p>",
        "id": 153815442,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1457979537
    },
    {
        "content": "<p>Agreed, my argument comes purely from a style perspective.</p>",
        "id": 153815443,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1457979658
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> - I am not in favour of repeating that just for the sake of it</p>",
        "id": 153815469,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1457986313
    }
]