[
    {
        "content": "<p>I'm looking at implementing a federated approach to publishing a resource, where instances of it will exist in many places with a syncing mechanism - the HealthcareService in particular. </p>\n<p>Different HealthcareService resource's \"master source of truth\" instance may exist in different places, and various directories could hold either a copy or the master instance of any given HealthcareService. For updates, ideally a directory would know where to look to get the its \"master\" instance.</p>\n<p>Is there a preferred approach to this type of model? I'm currently thinking of either:<br>\n1) creating an extension that points to the master instance of a resource - or -<br>\n2) Putting the URL of the master instance of the HealthcareService into an identifier, with one (or more?) of .use/.system/.type to indicate what the purpose is.</p>\n<p>What might the best approach to this be?</p>",
        "id": 207173595,
        "sender_full_name": "Tim Berezny",
        "timestamp": 1597685989
    },
    {
        "content": "<p>Provenance resource?</p>",
        "id": 207190937,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597694796
    },
    {
        "content": "<p>one question: is your \"directory\" a thing? Are these resources packaged in some way for being distributed (like a List or Composition)? or the sync is just on each of the resources individually?</p>",
        "id": 207191024,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597694852
    },
    {
        "content": "<p>Provenance, that's an interesting/appealing thought. So essentially, would the Provenance.target reference the distributed instance, and the \"Provenance.entity.what(role=source)\" referencing the master instance?</p>\n<p>No, it is not pre-packaged, the directory is intended to be query-able, so you can get a bundle of many or just one HealthcareService at a time (and its related Organization/Location/Endpoint resources)</p>",
        "id": 207195544,
        "sender_full_name": "Tim Berezny",
        "timestamp": 1597697211
    },
    {
        "content": "<p>Yes that is how you would use Provenance.</p>",
        "id": 207195937,
        "sender_full_name": "John Moehrke",
        "timestamp": 1597697414
    },
    {
        "content": "<p>You could additionally mark the copy as a \"COPY\" -- <a href=\"http://build.fhir.org/v3/ActCode/cs.html#v3-ActCode-COPYMark\">http://build.fhir.org/v3/ActCode/cs.html#v3-ActCode-COPYMark</a>... that way you would see in the meta.security of the copy a clear indication that it is a copy, thus you would know to look for a Proveanance.target equal to that copy, so that you could then follow the Provenance.entity to the original</p>",
        "id": 207196154,
        "sender_full_name": "John Moehrke",
        "timestamp": 1597697562
    },
    {
        "content": "<p>Oh very interesting, it sounds like a very robust and viable approach. Thanks <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> / <span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> !</p>",
        "id": 207209709,
        "sender_full_name": "Tim Berezny",
        "timestamp": 1597707835
    },
    {
        "content": "<p>it is robust... in theory... let us know how well it works in reality... hoping that theory and reality are similar... :-)</p>",
        "id": 207258404,
        "sender_full_name": "John Moehrke",
        "timestamp": 1597757011
    }
]