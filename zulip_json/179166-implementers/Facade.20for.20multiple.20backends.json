[
    {
        "content": "<p>Suppose I have a facade/gateway FHIR server that serves multiple backends. Suppose I sometimes want to get data from \"all\" systems, and sometimes want to get data from \"a specific system\".</p>\n<p>In our case we would have a facade on our national spine serving FHIR for thousands of systems. The normal current setup for query would be that you ask for e.g. MedicationDispense irrespective of where the data comes from and the national spine would look up where data is and return data from all relevant places. However we also want to support MedicationDispense specifically from systemA.</p>\n<p>We see two options:</p>\n<ul>\n<li>RESTful:                     [base]/systemA/...</li>\n<li>Query parameter: [base]/...?_endpoint=systemA</li>\n</ul>\n<p>Anybody else looked at this and how did you solve that?</p>\n<p><span class=\"user-mention\" data-user-id=\"194863\">@reli</span>, <span class=\"user-mention\" data-user-id=\"191834\">@Tom de Jong</span>, <span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span></p>",
        "id": 153921004,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511352251
    },
    {
        "content": "<p>Certainly did not solve it already. Both approaches will require some custom handling as it is not defined in FHIR itself. As for Vonk, Query parameter is a bit better fit to Vonk's programming model.<br>\nA thorough approach might be using Provenance for this.</p>",
        "id": 153921005,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1511352477
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span> ,</p>\n<p>One part I do not see addressed in your question, but I believe you have to do for the cross-system query is make sure that every resource returned is decorated with a tag that indicates from which system the resource was returned.</p>\n<p>Once you have done that, I think the logical solution would be to query for the system specific tag (or tags) when you want to filter data from a subset of systems.</p>",
        "id": 153921010,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1511354454
    },
    {
        "content": "<p>Oh, and just to be sure, if you define your own query parameters, make sure these do not start with an underscore, that is reserved for system parameters!</p>",
        "id": 153921011,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1511354666
    },
    {
        "content": "<p>I think I quite like the elegance of querying for a tag. Would that be something for Vonk too <span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> ?</p>",
        "id": 153921015,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511356377
    },
    {
        "content": "<p>this would be another use for Resource.meta.source (which I proposed in a different topic here, which would be a url)</p>",
        "id": 153921031,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511360378
    },
    {
        "content": "<p>(which is also not in the current builds right?)</p>",
        "id": 153921123,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1511387135
    },
    {
        "content": "<p>I'm also considering implementing this, which in my case is a federator.</p>",
        "id": 153921124,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1511387172
    },
    {
        "content": "<p>yes not in current build</p>",
        "id": 153921141,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511393561
    },
    {
        "content": "<p>Does that work for push too? I.e. could I POST something to a specific backend the same way?</p>",
        "id": 153921240,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511428309
    },
    {
        "content": "<p>The standard Vonk server does not behave this way, but I think the architecture makes this very well possible. 'Federation' - on the todo list :-)</p>",
        "id": 153921244,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1511428995
    },
    {
        "content": "<p>you could make it so. Server decision.</p>",
        "id": 153921248,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511429349
    },
    {
        "content": "<p>I added Resource.meta.source to R4 so people can look see, btw</p>",
        "id": 153921249,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511429363
    },
    {
        "content": "<p>For push: would you not need Resource.meta.target (too)</p>",
        "id": 153921251,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511431023
    },
    {
        "content": "<p>How would Resource.meta.source|target stack up against FHIR Messaging? If you do FHIR Messaging: do you still need Resource.meta.source|target?</p>",
        "id": 153921252,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511431121
    },
    {
        "content": "<p>target is wrong. that's a messaging view; set it to source to say what it will be</p>",
        "id": 153921253,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511431184
    },
    {
        "content": "<p>So source behaves as \"targetSource\" then. I get it now you explained it, but be prepared to explain this over and over again. When I push something to a specific system, then for all sense and purposes that is form of messaging, regardless of it being RESTful or FHIR Messaging. <br>\nNormally the endpoint is enough as target system. With a gateway/facade it might not be. Calling that target system \"source\" feels counter intuitive</p>",
        "id": 153921262,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511434884
    },
    {
        "content": "<p>well, messaging and rest are not the same, and this is one area of difference. In a message, if you wanted to specify a target, you'd use Bundle.entry.link</p>",
        "id": 153921263,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511434938
    },
    {
        "content": "<p>That works if it is a Bundle you are sending</p>",
        "id": 153921266,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511437085
    },
    {
        "content": "<p>But more importantly: some unification in how to handle this would be nice. So if the Resource.meta.source is \"the thing\", then I would not use Bundle.entry.link anymore, but the Bundle.meta.source or Bundle.entry.Resource.meta.source. (the last one only if I somehow try to upload a Bundle where different entries target different systems, but that sounds really funky)</p>",
        "id": 153921267,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511437366
    },
    {
        "content": "<p>In looking at <a href=\"http://build.fhir.org/resource-definitions.html#Meta.source\" target=\"_blank\" title=\"http://build.fhir.org/resource-definitions.html#Meta.source\">http://build.fhir.org/resource-definitions.html#Meta.source</a> it currently does not feel suited for use when I want to say \"Hey gateway, please hand this resource to system X\".</p>\n<p>Current wording<br>\n<em>Identifies the system that is the source of the information in this resource.</em></p>\n<p>When I push something, it feels like the way to tell the other end something about me as sender.</p>",
        "id": 153921268,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511437596
    },
    {
        "content": "<p>in messaging, you will have a bundle, and you should still use Bundle.entry.link.</p>",
        "id": 153921269,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511438758
    },
    {
        "content": "<p>in REST, you are telling the server to 'make it so' - and so when it makes the source so, it talks to the system you identify as the source</p>",
        "id": 153921270,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511438780
    },
    {
        "content": "<p>For the record: we're doing RESTful, not Messaging.</p>",
        "id": 153921271,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511438829
    },
    {
        "content": "<p>The behavior of POST-ing a Bundle to an endpoint with meta.source, telling the server \"make it so\" identifying the meta.source as intended target, just is not something I can wrap my head around</p>",
        "id": 153921272,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511438906
    },
    {
        "content": "<p>Could be my limitation</p>",
        "id": 153921273,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511438922
    },
    {
        "content": "<p>Trying again.</p>\n<p><strong>Use case 1</strong>: I want to query a specific endpoint 903 through an intermediary gateway</p>\n<div class=\"codehilite\"><pre><span></span>GET [base]/Condition?_tag=http://aorta-zorg.nl/apps|903\n</pre></div>\n\n\n<p><strong>Use case 2</strong>: I want to push contents to a specific endpoint 903 through an intermediary gateway</p>\n<div class=\"codehilite\"><pre><span></span>POST [base]/Condition?_tag=http://aorta-zorg.nl/apps|903\n</pre></div>\n\n\n<p>Use case 1 would not have an HTTP body. Use case 2 would have an HTTP body where the *.meta.source would be <em>my system</em>. The reason for that is that my system might also be behind a gateway for multiple systems making it less obvious which system is pushing data.</p>",
        "id": 153921275,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511439278
    },
    {
        "content": "<p>so the second is not valid following the spec. but as I say, if you were using source:</p>\n<div class=\"codehilite\"><pre><span></span>GET [base]/Condition?_source=http://aorta-zorg.nl/apps/903\n\nPOST [base]/Condition\n\n&lt;[Resource]&gt;\n  &lt;meta&gt;\n    &lt;source value=&quot;http://aorta-zorg.nl/apps/903&quot;/&gt;\n  &lt;/meta&gt;\n&lt;/[Resource]&gt;\n</pre></div>",
        "id": 153921327,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511469522
    },
    {
        "content": "<p>the second is saying: set the state of this new resource as if source was <a href=\"http://aorta-zorg.nl/apps/903\" target=\"_blank\" title=\"http://aorta-zorg.nl/apps/903\">http://aorta-zorg.nl/apps/903</a>. The server makes it so - which in this case, means, posting it through to the <a href=\"http://aorta-zorg.nl/apps/903\" target=\"_blank\" title=\"http://aorta-zorg.nl/apps/903\">http://aorta-zorg.nl/apps/903</a> server</p>",
        "id": 153921328,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511469577
    },
    {
        "content": "<p>How would I then tell the target system that some of my contents came from source A and others from source B if the meta.source cannot be used for that because it is repurposed to mean target?</p>",
        "id": 153921333,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511470285
    },
    {
        "content": "<p>it's not repurposed. If you've moved the goal posts to mean that some of the content of a resource comes from one server, and some from another, and the client needs to know about the derivation, then I don't think there's a solution in RESTful for you. And it sounds like a bad idea</p>",
        "id": 153921334,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511470581
    },
    {
        "content": "<p>Provenance?</p>",
        "id": 153921335,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511470598
    },
    {
        "content": "<p>maybe. for reads. Sounds like a really difficult thing for post. though it's just going to be difficult anyway.</p>",
        "id": 153921336,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511470633
    },
    {
        "content": "<p><strong>Use case 1</strong>: I want to query a specific endpoint 903 through an intermediary gateway</p>\n<div class=\"codehilite\"><pre><span></span>GET [base]/Condition?_source=http://aorta-zorg.nl/apps/903\n</pre></div>\n\n\n<p><strong>Use case 2</strong>: I want to push contents to a specific endpoint 903 through an intermediary gateway</p>\n<div class=\"codehilite\"><pre><span></span>POST [base]/Condition\n\n&lt;[Resource]&gt;\n  &lt;meta&gt;\n    &lt;source value=&quot;http://aorta-zorg.nl/apps/903&quot;/&gt;\n  &lt;/meta&gt;\n&lt;/[Resource]&gt;\n</pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"192814\">@Theo Stolker</span>, <span class=\"user-mention\" data-user-id=\"194863\">@reli</span>, <span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span>, <span class=\"user-mention\" data-user-id=\"191834\">@Tom de Jong</span>  Thoughts? Objections? Support? Since we need it in STU3 we probably need a tag for it, but that can be arranged</p>",
        "id": 153921337,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511470721
    },
    {
        "content": "<p>The source to me has nothing to do with messaging, its about where the original content came from (very useful in curated or federated content)<br>\nIts not asking it to go somewhere, its a little on its heritage (and the provenance will have the full detail) I'd like to see this as multi-cardinality if there were multiple contributors to the content. Just a thought though.</p>",
        "id": 153921358,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1511484741
    },
    {
        "content": "<p>I deliberately made it singular, even though a resource might have multiple sources, because there's real complexity there</p>",
        "id": 153921361,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511485958
    },
    {
        "content": "<p>Great, thanks.</p>",
        "id": 153921363,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1511486301
    },
    {
        "content": "<p>How does this tie in with a metadata registry (a record locator) like the Dutch LSP or IHE XDS ? I'd like to see seamless integration with those in case we need to do GET [base]/Bundle/[x]?_source=yyyyyyyyyy or GET [base]/Binary/[x]?_source=yyyyyyy.  Normally I'd expect the record locator to work out where something is (and hide it from me when GETting), but there may be use cases where one wishes to explicitly request a specific application.</p>\n<p>And you'd better use Provenance when doing POST in this context (i.e. always post a Bundle inclusive of Provenances), otherwise one will have no clue as to who was responsible for the posted content. Create Graphdefinition that states that each posted resource SHALL have an associated Provenance resource.</p>",
        "id": 153921401,
        "sender_full_name": "René Spronk",
        "timestamp": 1511502358
    },
    {
        "content": "<p>René this whole thing is exactly about the LSP/AORTA and the FHIR Facade that will be in front of thousands of systems and potentially all XDS regions too. The usual query on the LSP/AORTA does not have any target system: the LSP figures out where stuff is and queries them all on your behalf and finally Bundles it all up in 1 single Response Bundle to you. The Bundle contains enough information to determine which information came from which system (all in V3). </p>\n<p>Translating that to FHIR could amount to a Bundle of Bundles where each sub-Bundle is marked with meta.source and/or Provenance. We could use Provenance too to carry the V3 payload at least for debugging scenarios.</p>\n<p>The reason I'm asking is because in the MedMij PHR scenarios we anticipate PHRs will want to target specific systems for a query after receiving a notification for a running subscription. Also PHRs will want to push observations from devices to specific systems. Hence use case 1 and 2</p>\n<p>GraphDefinition is something someone once asked us about and I've not looked at that yet. I doubt many people will know what to do with it, but I might be wrong.</p>\n<p>Grahame/Brian, if meta.source sometimes is \"the source\", and sometimes is \"the intended future source\" (aka \"target\" in my vocabulary), it is not going to work for me. It should be the one or the other.</p>",
        "id": 153921462,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511527221
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>The source to me has nothing to do with messaging, its about where the original content came from (very useful in curated or federated content)\nIts not asking it to go somewhere, its a little on its heritage (and the provenance will have the full detail)\n</pre></div>\n\n\n<p>Fully agree. meta.source is about origin. Grahame however extended that notion to include additional semantics upon posting data. In posting data, now the meta.source means \"please make it so that the source is X\". This is not what I want to accomplish. I want my data to be routed to a particular system that is behind the facade that is my initial endpoint.</p>\n<p>Maybe compare my situation with Aegis Touchstone: unless I send an HTTP header carrying my organizational/personal (API) key, the system will not know what party is testing and will not know how to route the incoming data.</p>",
        "id": 153921467,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511527892
    },
    {
        "content": "<p>I would have never expected the source to be a target. To me this property should be for where the content came from. anything further should be in provenance.</p>",
        "id": 153921469,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1511527946
    },
    {
        "content": "<p>Ok so this</p>\n<div class=\"codehilite\"><pre><span></span>GET [base]/Condition?_source=http://aorta-zorg.nl/apps/903\n</pre></div>\n\n\n<p>Only works if the only system serving Conditions from source 903 is in fact system 903 itself. Suppose a second system would be serving data from 903 we would be getting multiple responses. This is not allowed on the LSP/AORTA. Thusfar you may only serve contents that you are owner of</p>",
        "id": 153921470,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511528109
    },
    {
        "content": "<p>Nonetheless it seems that source is not our thing then and we're better off creating a custom meta.tag for it. All still assuming that using a tag could work for Vonk (<span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> ), HAPI-FHIR (<span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span>) and other facades as a means to address a system behind the facade.</p>\n<p>An alternative is something along the lines of the facade hosting endpoints per backend system, and a public/generic endpoint. So</p>\n<div class=\"codehilite\"><pre><span></span>GET https://aorta-zorg.nl/allapps/fhir/3.0.1/\nGET https://aorta-zorg.nl/app/903/fhir/3.0.1/\nGET https://aorta-zorg.nl/app/904/fhir/3.0.1/\nGET https://aorta-zorg.nl/app/904/fhir/4.0.0/\n</pre></div>\n\n\n<p>You would host thousands of endpoints like that.</p>",
        "id": 153921471,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511528271
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span> , looks great, I'll support this! And I meant that on your earlier post about the use of meta.source :)</p>",
        "id": 153921487,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1511533484
    },
    {
        "content": "<p>you're just not doing RESTful stuff when you describe it this way, and so you're finding that the RESTful interface can't do this. I'm not finding that surprising</p>",
        "id": 153921497,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511534074
    },
    {
        "content": "<p>\"Grahame/Brian, if meta.source sometimes is \"the source\", and sometimes is \"the intended future source\" (aka \"target\" in my vocabulary), it is not going to work for me. It should be the one or the other.\" - but no, you're misunderstanding. It's always the source. But when you put the resource to the server, you are asserting that in it's new state, this is now the source.</p>",
        "id": 153921498,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511534144
    },
    {
        "content": "<p>I.e. In the old version of the Patient instance, demographics came from system X, but I've updated the instance so the demographics now come from system Y which I believe to be more authoritative.</p>",
        "id": 153921499,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511534243
    },
    {
        "content": "<p>I totally get how you intended it Grahame/Lloyd. I just don't agree with the idea. I was not at the point where we had a solution. I was at a point where we were looking for one. Turns out the problem is lesser known territory than I thought I would be.</p>\n<p>Being purely RESTful would mean those thousands of endpoints. That way it is as if I'm talking to the system itself even if it is a facade serving for those thousands of systems. Works for both push and pull.</p>\n<p>We however thought that would be unpractical. Secondly most queries would probably still go to the generic endpoint targeting <em>all</em> systems and then the response would need markers to indicate source. For that purpose, the meta.source just might be a reasonable thing, but since we might use Provenance for more details anyway, the meta.source then seems redundant. </p>\n<p>Still hoping to hear from <span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> about what seems reasonable for Vonk considering I understand Vonk is a likely candidate to <em>be</em> the facade we're discussing.</p>",
        "id": 153921578,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511645310
    },
    {
        "content": "<p>What about the idea do you disagree with?  Even if we don't have \"source\", each version of a resource can have a distinct source from a Provenance perspective.  Source can't really disagree with Provenance.</p>",
        "id": 153921580,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511649182
    },
    {
        "content": "<p>I think source  should be just <em>source</em>, or as Brian put it <em>origin</em>. When you offer data to a server you are telling the server where it came from, not where you want that data to to come from in the future.</p>\n<p>I can understand how you would like the result of your upload to be that some receiving system needs to be the new authorative source after processing what you have sent. But that is about the intention of your upload, not about <em>origin</em> at time of upload. The intention of your upload (just store, act on the data, accept you are now the new source of the data) is what messaging is about, the dynamic model if you will. Meta.source does not do for that purpose.</p>\n<p>You are right that Provenance and meta.source bear overlap, which is why said that when you have Provenance which carries much more information, the meta.source seems redundant.</p>",
        "id": 153921583,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511688120
    },
    {
        "content": "<p>Ok - that's my understanding of how \"source\" would work - it mirror's provenance.  It tells the source of a create or update.  It has nothing to do at all with where the data will be stored.  There's no mechanism in FHIR to direct data to a specific storage location beyond the URL you POST/PUT to.</p>",
        "id": 153921610,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511729113
    },
    {
        "content": "<p>The primary use-case for meta.source is so you don't have to retrieve a copy of the provenance to know where the data came from.</p>",
        "id": 153921611,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511729149
    },
    {
        "content": "<p>And likely to know that there is a provenance of significance.</p>",
        "id": 153921614,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1511735999
    },
    {
        "content": "<p>well, there's multiple reasons why you could populate source but not create a provenance</p>",
        "id": 153921615,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511736290
    },
    {
        "content": "<p>I'm looking for a solution to address a system behind a facade in a RESTful way. I'm aware that what I ask has not been done before, but it is not possible that the problem didn't exist yet: Vonk and HAPI are or will be used in front of many systems.</p>\n<p>Grahame told me meta.source exists as-of R4, but meta.source does not have the semantics I'm looking for. That doesn't make meta.source the solution, but it doesn't make the problem go away either.</p>\n<p>So maybe a step back: do we at least share the idea that the problem as stated is relevant to solve?</p>",
        "id": 153921622,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511765293
    },
    {
        "content": "<p>you can't ask for a RESTful solution, and then reject a RESTful solution. What are you looking for here? Do you really want a single RESTful facade to a bunch of servers such that the client doesn't need to worry about the bunch of servers in the background?</p>",
        "id": 153921623,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511767808
    },
    {
        "content": "<p>won't we all :D</p>",
        "id": 153921634,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511778523
    },
    {
        "content": "<p>Let me see if I can summarize your issue - you don't really want a \"facade\" - as the client will know - must know in fact - that there are multiple servers.  But the client won't know the address of any of those servers.  Instead they talk to a single aggregating endpoint and POST to that endpoint but somehow communicate to the endpoint what server they want the result sent to.  Is that accurate <span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span>?</p>",
        "id": 153921649,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511793157
    },
    {
        "content": "<p>Sorry for the delay. Discussed it a bit with <span class=\"user-mention\" data-user-id=\"191363\">@Vadim Peretokin</span> as well.<br>\nThe easiest solution in our opinion is to design a custom search parameter for this, probably on Resource (let's say 'fromsource').<br>\nAfter that in the Facade implementation you can handle this parameter by limiting the queries to the backend systems to just that source.<br>\nIt would then - with a little extra work - even be possible to extract this searchparameter from the path as you suggested above, but it may be easier for clients to just add the searchparameter (&amp;fromsource=903).</p>",
        "id": 153922008,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1511944631
    },
    {
        "content": "<p>Reminds of me of a v3 discussion around messaging, one that we never managed to wrap up because consensus could simply not be reached. Trying to influence the delivery of messages beyond the designated end-point (here: the Facade) leads to lots of issues.</p>\n<p>Anyways: I can see the use case for wishing a subset of systems (perhaps only 1) instead of asking the Facade to forward the query to all. But in terms of addressing I would not want to use a system URL, but an organization Id or even a healthcare Practitioner Id. They may move their data from one repository to another one, the author stays the same.  Kind of a GET [base]Condition?_has:Provenance:agent.identifier=903 (that's probably not valid, but you get the idea). The Facade has to be smart enough to resolve that 'agent.identifier' into a URL (or a set of URLs in case that agent uses multiple repositories).</p>",
        "id": 153922062,
        "sender_full_name": "René Spronk",
        "timestamp": 1511968921
    },
    {
        "content": "<p>I think it's wrong to claim that it's a 'facade' if the client has to know anything about it</p>",
        "id": 153922065,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511969103
    },
    {
        "content": "<p>if the client has to know about it, I think 'agent' is the right word</p>",
        "id": 153922066,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511969117
    },
    {
        "content": "<p>Yes that’s accurate Lloyd</p>\n<p>After some back n forth we’ll go with a url based solution for the first test drive and decide from there if we need something different. The url will be something like</p>\n<p><a href=\"https://aorta-zorg.nl/fhir/[fhirVersion]/apps/[appId]\" target=\"_blank\" title=\"https://aorta-zorg.nl/fhir/[fhirVersion]/apps/[appId]\">https://aorta-zorg.nl/fhir/[fhirVersion]/apps/[appId]</a></p>\n<p>This is fully RESTful and is comparable to a 1-to-1 facade/system solution. </p>\n<p>Since the URLs are all registered in the national system/endpoint registry the discovery is no biggie.</p>",
        "id": 153922137,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511981776
    },
    {
        "content": "<p>The question to find the right endpoint is “get me endpoints for organization X that support application role Y”. As we have application role based certification in place for systems for them to be recognized on the network that will work. Questions like “what’s the uri for getting the medication from my pharmacy” could be answered with <a href=\"https://aorta-zorg.nl/fhir/3.0.1/apps/903/\" target=\"_blank\" title=\"https://aorta-zorg.nl/fhir/3.0.1/apps/903/\">https://aorta-zorg.nl/fhir/3.0.1/apps/903/</a>.</p>",
        "id": 153922138,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511982144
    },
    {
        "content": "<p>Grahame: maybe the word facade isn’t entirely accurate but it’s close enough I think. It’s a FHIR entrance to a non-FHIR network of servers</p>",
        "id": 153922139,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511982334
    },
    {
        "content": "<p>René/Vadim/Christiaan: a query param based solution is still on the table, but we had to make an initial decision before December 1 to start trialing with and landed on url. We’ll know within 7 months what the final answer will be during the big test drive of it all</p>",
        "id": 153922140,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511982561
    },
    {
        "content": "<p>Thanks all for your valuable input. I’ll post updates on the experience, good or bad, here for those interested</p>",
        "id": 153922142,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1511982873
    },
    {
        "content": "<p>Intermediary</p>",
        "id": 153922146,
        "sender_full_name": "John Moehrke",
        "timestamp": 1511985826
    },
    {
        "content": "<p>Conductor</p>",
        "id": 153922147,
        "sender_full_name": "John Moehrke",
        "timestamp": 1511985845
    },
    {
        "content": "<p>Intermediary I'd go for.<br>\nFor me the facade hides all the details of operation behind it.</p>",
        "id": 153922379,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1512075522
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span> I should add that we're doing pretty much the same thing, IIUC: using a FHIR API as frontend for multiple backing systems. In our case, each system has what we call a facade that sits between the frontend and the non-FHIR system.</p>",
        "id": 153922995,
        "sender_full_name": "Mattias Flodin",
        "timestamp": 1512490815
    },
    {
        "content": "<p>Though we envision some future systems will implement the FHIR API directly and can be used without a facade.</p>",
        "id": 153922996,
        "sender_full_name": "Mattias Flodin",
        "timestamp": 1512490892
    },
    {
        "content": "<p>Good to know thanks <span class=\"user-mention\" data-user-id=\"193772\">@Mattias Flodin</span><br>\n<span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> I would say that the url thing actually gives every backend system its own ‘front door’. So every front door then qualifies as facade while the whole ‘house with all front doors’ or ‘host of facades’ might go by a different name conceptually.</p>",
        "id": 153922997,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1512491184
    },
    {
        "content": "<p>We call that the service platform. It also contains a messaging system outside of the FHIR scope, that allows systems to broadcast events to other systems.</p>",
        "id": 153922998,
        "sender_full_name": "Mattias Flodin",
        "timestamp": 1512491405
    },
    {
        "content": "<p>at the Australian connectathon yesterday we were using the term 'federation'</p>",
        "id": 153923034,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1512500412
    },
    {
        "content": "<p>And I implemented a simple POC to cover some of the issues that may satisfy the needs in the specific context. It's only a partial implementation, but does show some useful stuff<br>\n<a href=\"https://github.com/brianpos/FhirFederation\" target=\"_blank\" title=\"https://github.com/brianpos/FhirFederation\">https://github.com/brianpos/FhirFederation</a></p>",
        "id": 153923303,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1512635704
    },
    {
        "content": "<blockquote>\n<p>René this whole thing is exactly about the LSP/AORTA and the FHIR Facade that will be in front of thousands of systems and potentially all XDS regions too. The usual query on the LSP/AORTA does not have any target system: the LSP figures out where stuff is and queries them all on your behalf and finally Bundles it all up in 1 single Response Bundle to you. The Bundle contains enough information to determine which information came from which system (all in V3). </p>\n<p>Translating that to FHIR could amount to a Bundle of Bundles where each sub-Bundle is marked with meta.source and/or Provenance. We could use Provenance too to carry the V3 payload at least for debugging scenarios.</p>\n<p>The reason I'm asking is because in the MedMij PHR scenarios we anticipate PHRs will want to target specific systems for a query after receiving a notification for a running subscription. Also PHRs will want to push observations from devices to specific systems. Hence use case 1 and 2</p>\n<p>GraphDefinition is something someone once asked us about and I've not looked at that yet. I doubt many people will know what to do with it, but I might be wrong.</p>\n<p>Grahame/Brian, if meta.source sometimes is \"the source\", and sometimes is \"the intended future source\" (aka \"target\" in my vocabulary), it is not going to work for me. It should be the one or the other.</p>\n</blockquote>\n<p>Interesting. It seems we (Sweden) and Netherlands have the same national HIE architecture. We are however - not yet into FHIR, but are shaping up our plans. In management- and professional settings, we sometimes use the term \"Virtual EHR\" to label our concept of federation. It also reflects that we do not open up for end-to-end coupling by requiring clients to know / create dependencies to the system topology behind the \"facade\". We also have the exception of using \"source system targeting\" when responding to record locator event subscriptions. Since the event betrays the source of the event. We don't have XDE in the picture, though. Would be interesting to meet and share thoughts and strategies for national FHIR migration.</p>",
        "id": 153924746,
        "sender_full_name": "Johan Eltes",
        "timestamp": 1513176391
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> 404 on <a href=\"https://github.com/brianpos/FhirFederation\" target=\"_blank\" title=\"https://github.com/brianpos/FhirFederation\">https://github.com/brianpos/FhirFederation</a> - think you meant <a href=\"https://github.com/brianpos/FhirFederator\" target=\"_blank\" title=\"https://github.com/brianpos/FhirFederator\">https://github.com/brianpos/FhirFederator</a></p>",
        "id": 153926364,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1513729308
    },
    {
        "content": "<p>This feature: <em>Aggregated CapabilityStatement</em> seems to me to be particularly tricky; how do you merge them?</p>",
        "id": 153926365,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1513729442
    },
    {
        "content": "<p>Yes, that's right, thanks <span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span></p>",
        "id": 153926366,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1513730130
    },
    {
        "content": "<p>That aggregated CapabilityStatement is a work in progress.<br>\nIts using the first as a template, then grafting in the others with an extension to indicate which services support which bits.<br>\n(need to do that for the search params too)</p>",
        "id": 153926411,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1513744502
    }
]