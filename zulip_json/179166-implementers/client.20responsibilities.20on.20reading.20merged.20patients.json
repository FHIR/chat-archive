[
    {
        "content": "<p>I'm not sure if this has been discussed before... (.. if so, please point me to it..)<br>\nAfter reading up on the proposed procedure for merging a patient (by setting a \"replace\" link from  the inactive to the active patient), I realized that this means that all responsibilities for displaying the correct patient information to the user, lies on the client implementation.<br>\nMeaning whenever a client reads a Patient resource, it SHOULD check if there is a replace link (at least if the read patient is inactive) and either display the active patient instead or at least show a warning to the user, indicating that this patient has been merged.</p>\n<p>Is that correct? If so, I'm afraid the specification as is does not sufficently inform client implementers of this responsibility...</p>",
        "id": 153843137,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470729056
    },
    {
        "content": "<p>what do you think would be sufficiently informing? </p>",
        "id": 153843138,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1470729741
    },
    {
        "content": "<p>I have just added a note about this to the implementer's safety checklist</p>",
        "id": 153843139,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1470729759
    },
    {
        "content": "<p>...maybe a sentence containing the verb \"should\" in this chapter: <a href=\"https://www.hl7.org/fhir/patient.html#links\" target=\"_blank\" title=\"https://www.hl7.org/fhir/patient.html#links\">https://www.hl7.org/fhir/patient.html#links</a><br>\nBut safety notes are presumeably a better place to give client implementer a heads up about this.</p>",
        "id": 153843142,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470729931
    },
    {
        "content": "<p>well I think the section is clear, but it may not be pointed enough... </p>",
        "id": 153843143,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1470729973
    },
    {
        "content": "<p>you could create a task to this effect. The note in the safety check list mightn't go for enough either</p>",
        "id": 153843144,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1470730129
    },
    {
        "content": "<p>\"My system ensures checks for patient links (and/or merges) and handles data that is linked to patients accordingly\"</p>",
        "id": 153843145,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1470730151
    },
    {
        "content": "<p>Maybe the place where it's most likely to get the reader's attention would be here:<br>\n<a href=\"/user_uploads/10155/ngIny6bs6bnveT6DE18RPJS5/pasted_image.png\" target=\"_blank\" title=\"/user_uploads/10155/ngIny6bs6bnveT6DE18RPJS5/pasted_image.png\">pasted image</a> <br>\nBy adding a Cave to the active flag that says: \"whenever you read an inactive patient: pay attention to the patient.link - it may have been replaced!\" <br>\n?</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/ngIny6bs6bnveT6DE18RPJS5/pasted_image.png\" target=\"_blank\" title=\"/user_uploads/10155/ngIny6bs6bnveT6DE18RPJS5/pasted_image.png\"><img src=\"/user_uploads/10155/ngIny6bs6bnveT6DE18RPJS5/pasted_image.png\"></a></div>",
        "id": 153843146,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470730239
    },
    {
        "content": "<p>I think that would be a good task to create</p>",
        "id": 153843147,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1470730852
    },
    {
        "content": "<p>though I think that this is something that comes naturally to an experienced healthcare app developer, and there's almost nothing we could say that would make any difference to a novice</p>",
        "id": 153843148,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1470730889
    },
    {
        "content": "<p>my experience is that eyes glaze over when you try to explain this </p>",
        "id": 153843149,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1470730909
    },
    {
        "content": "<p><a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=10434\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=10434\">GF#10434</a></p>",
        "id": 153843152,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470732508
    },
    {
        "content": "<p>Concering this issue with GET/SEARCH on merged records: <a href=\"http://wiki.hl7.org/index.php?title=FHIR_Specification_Feedback_(DSTU_2)\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_Specification_Feedback_(DSTU_2)\">http://wiki.hl7.org/index.php?title=FHIR_Specification_Feedback_(DSTU_2)</a></p>\n<p>I was thinking about how to implement the V2 merge event as a FHIR transaction and came up with this:</p>\n<p>Whenever I receive a V2 merge message, I update the merged Patient A by setting it inactive and adding the replace link to the master Patient B.<br>\nBut I'd also add the master Patient's identifier to the merged Patient's identifier list.</p>\n<p>This way a client may miss the information still linked to A when performing a search  as /Observation?patient=B<br>\nBut when searching by identifier (e.g. Observation?patient.identifier=12345) it will always be able to retrieve a complete list.</p>\n<p>The downside would be that a search for /Patient?identifier=12345 would return two Resources, even though identifiers would be expected to be unique, however only one of there resources would be set to \"active\".</p>\n<p>Does that make sense?</p>",
        "id": 153843403,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470856484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191372\">@René Spronk</span> : You wrote the above mentioned comment on the issue with search/get... what do you think?</p>",
        "id": 153843404,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470856635
    },
    {
        "content": "<p>i would have thought in that uery you would have also selected to only retrieve the active patients, which would filter that one out</p>",
        "id": 153843411,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1470859581
    },
    {
        "content": "<p>Agree with Brian, but the overall pattern makes sense</p>",
        "id": 153843419,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1470860349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> my thoughts exacly (otherwise my beloved conditional PUT/POST/references would blow up in my face)</p>",
        "id": 153843561,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470898956
    },
    {
        "content": "<p>aaaand... they do blow up after all!</p>\n<p>At least for the ORU-Message scenario, when I try to link an Observation to a Patient by adding a conditional POST on the Patient to the transaction.<br>\nIf the if-none-exist-condition is Patient?identifier=1234, the transaction fails on  the active Patient, because the criteria returns 2 results.<br>\nIf I set the condition to Patient?identifier=1234&amp;active=true, it'll work for the active Patient.<br>\nHowever, if the ORU message delivers an Observation for the inactive merged Patient (that happens, unfortunately),<br>\nthe condition Patient?identifier=1234&amp;active=true will return no results and the conditional POST would subsequently create a new Patient with the identifier 1234. So all subsequent ADT updates on this Patient would fail because now there are two active Patients with the same identifier.</p>\n<p>This scenario only works, if the Observations are linked using conditional References with Observation.subject=Patient?identifier=1234&amp;active=true, because these don't create new resources in case of a no-match.<br>\nIn this case the Transaction would succeed linking the Observation to an active Patient and fail if the targeted Patient was inactive/merged. (Which I guess is ok in most use cases. Most EHR systems I know reject messages for merged patients... </p>",
        "id": 153843566,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470921670
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191450\">@Simone Heckmann</span> this is why it is important to resolve links within the patient itself. </p>",
        "id": 153843600,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470929964
    },
    {
        "content": "<p>consider a mature system where you have a lot of clinical data referencing a particular patient record that is then merged into another patient record. if a system cannot resolve the link from the original patient to the survivor, your only other option is to update all references. and that won't scale.</p>",
        "id": 153843601,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470930048
    },
    {
        "content": "<p>True. But what if the client queries for all Observations for Patient/123 (assuming there's another Patient/456 that has been merged and linked to Patient/123) How does the Client know that Patient/456's clinical data has to be retrieved as well? There is no link from Patient/123 pointing at Patient/456! Only vice versa.</p>",
        "id": 153843602,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470930302
    },
    {
        "content": "<p>If the Client \"enters\" through the wrong Patient/456, it  will find the Patient inactive and a reference to the current Patient resource.<br>\nBut Clients entering through the correct Patient imho have no reason to suspect that ther's another Patient Resource holding significant information for this Patient.</p>",
        "id": 153843603,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470930495
    },
    {
        "content": "<p>Right .... as a part of a merge transaction, you could add a \"seealso\" link from Patient/123 to Patient/456. That's why I feel creating and resolving links are the responsibility of a server.</p>",
        "id": 153843604,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470930666
    },
    {
        "content": "<p>In that same merge transaction, the server woud also create a \"replace\" link from Patient/456 back to Patient/123.</p>",
        "id": 153843605,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470930751
    },
    {
        "content": "<p>And it thus becomes the responsibility of the server responding to queries to interrogate those links when gathering referenced clinical resources.</p>",
        "id": 153843606,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470930800
    },
    {
        "content": "<p>Yes, but it is nowhere specified that a merge should also create a \"see also\" link from Patient/123 to Patient/456, or does it?</p>",
        "id": 153843607,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470930833
    },
    {
        "content": "<p>Maybe it should. ;)</p>",
        "id": 153843608,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470930845
    },
    {
        "content": "<p>Brian will weigh in, I hope, when Oz wakes up.</p>",
        "id": 153843609,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470930873
    },
    {
        "content": "<p>The link type description for \"see also\" states that <br>\n<code>This link does not indicate any relative importance of the resources concerned, \nand both should be regarded as equally valid.</code> <br>\nwhich does not apply to a merge</p>",
        "id": 153843610,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470930916
    },
    {
        "content": "<p>k ... how about \"refer\", that might be better.</p>",
        "id": 153843611,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470930986
    },
    {
        "content": "<p>Nope. Wrong direction.</p>",
        "id": 153843612,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470931029
    },
    {
        "content": "<p>also, the spec does say that how merges or linking is handled is still not set and implementer feedback is welcome. </p>",
        "id": 153843613,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470931029
    },
    {
        "content": "<p>...and that's what we're doing right here :D</p>",
        "id": 153843614,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470931053
    },
    {
        "content": "<p>you're confusing me with facts. ok ...</p>",
        "id": 153843615,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470931067
    },
    {
        "content": "<p>maybe we need a new item here that satisfies this use case.</p>",
        "id": 153843616,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470931085
    },
    {
        "content": "<p>a link type that sez \"replaced\"</p>",
        "id": 153843617,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470931112
    },
    {
        "content": "<p>or \"replacedBy\"</p>",
        "id": 153843618,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470931125
    },
    {
        "content": "<p>..or maybe just slightly adapt the \"see also\" description..</p>",
        "id": 153843619,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470931308
    },
    {
        "content": "<p>that's better ... \"seealso\" should work here.</p>",
        "id": 153843620,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470931329
    },
    {
        "content": "<p>It could work for the surviving record. As you say, maybe just updating the description a bit to indicate this is how it might be used in a classic merge scenario.</p>",
        "id": 153843621,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470931383
    },
    {
        "content": "<p>But then it should be emphasized even  more that clients ALWAYS need to look at the links, not only if the Patient is inactive!<br>\nAnd I still wonder whether to (additionally) stick to my idea of adding the current business identifier to the merged patient's identifier list, otherwise there is no way a client can get the Patient's complete record in one query.</p>",
        "id": 153843622,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470931681
    },
    {
        "content": "<p>If you were implementing this with strict adherence to REST, I could see a server responding with a redirect for a patient that has been merged - a 301 response with a link to the surviving patient resource in the Location header. not sure this point has gotten much discussion.</p>",
        "id": 153843628,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470938251
    },
    {
        "content": "<p>Nice. But still only half of the solution.</p>",
        "id": 153843630,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1470938543
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 153843638,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470939683
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 153843639,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470939907
    },
    {
        "content": "<p>Ok, after client dereferences that 301 location and submits a new request the server would find relationship back to inactive merged patient record and gather all the data referenced from both patient records. Maybe an outcome message would help as explanation that response includes “linked” data?</p>",
        "id": 153843674,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1470947541
    },
    {
        "content": "<p>Yes, this is the part that we are looking for implementer feedback on.<br>\nI agree that this is highly likely that we would want to make this a server responsibility.<br>\nUsing the redirect approach, the implication on the observations that reference the old patient need to be considered.<br>\n(Should they be re-written as art of the return?)<br>\nHowever there is another situation where the link references a record in a distributed system, but that's a story for another time.</p>",
        "id": 153843694,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1470953332
    },
    {
        "content": "<p>I would like more proscription on this matter in the spec, but getting agreement around this area is *very hard work* </p>",
        "id": 153843707,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1470958011
    },
    {
        "content": "<p>I do think that there's grounds for a $merge and/or $link operation to ask a server to do all the merging server side. This is particularly  appropriate given that a client may not have access to all the data linked to a patient even though they have the right to merge the patient. I think we should make a task asking PA to define one. But it's certainly a challenge to figure out how it would work</p>",
        "id": 153843858,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471036843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> I would leave the patient references as they were in the response. And if a client requested that \"old\" patient record, well, the same server logic would result in the surviving patient record being returned via a 301 redirect.</p>",
        "id": 153843867,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1471042025
    },
    {
        "content": "<p>Would be interesting to implement the $unmerge as a rollback looking through the history via an auditevent that touched all the things.<br>\nNot something that could have been done without these other bits. Just a thought.</p>",
        "id": 153843869,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1471047966
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> $unmerge makes sense, but I would argue that it would only remove the links between the originally \"merged” Patient records. Leaving the original references to clinical data as they are during merge makes this simple to revert the \"merge\". I know from hard experience that merging related data is prohibitively difficult to untangle.</p>",
        "id": 153844314,
        "sender_full_name": "Peter Bernhardt",
        "timestamp": 1471535853
    },
    {
        "content": "<p>yep. it's not too hard to unmerge after a merge until any new changes are made after the merge. After that, it's just a mess, and humans can't usually figure it out. My recommendation when people ask is not to try for unmerge. When you get to that point, you should just build new records afresh. Not that easy either. all options are bad</p>",
        "id": 153844331,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471546584
    }
]