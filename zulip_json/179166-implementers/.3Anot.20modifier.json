[
    {
        "content": "<p>I have a question about the <strong>:not</strong> modifier that can be used with search for token parameter types. Should a query like \"GET [base]/Patient?gender:not=male\" return also patients that contain no gender information? (Basically include  also what the :missing modifier would return)</p>",
        "id": 153844602,
        "sender_full_name": "Corina Ciocanea",
        "timestamp": 1471868046
    },
    {
        "content": "<p>yes</p>",
        "id": 153844677,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471898186
    },
    {
        "content": "<p>Two questions on this, 1) It's not clear in the spec that this is the behavior, and 2) Is it a concern that this behavior is inconsistent with the usual approach to dealing with missing information?</p>",
        "id": 153844679,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471900210
    },
    {
        "content": "<p>well, you could create a task to clarify that. As for the usual approach.... I don't know. It is different from the sql approach, but I'm not sure that qualifies as 'the usual approach'. this is not the same context as sql...</p>",
        "id": 153844702,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471915934
    },
    {
        "content": "<p>This behaviour is what you'd get in XML if the value was missing, i.e. <code>not(gender/@value = 'male')</code>would return \"true\" if there was no <code>gender</code> element or the <code>gender</code> element had no <code>value</code> attribute.</p>",
        "id": 153844704,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1471916234
    },
    {
        "content": "<p>Note, however, that <code>gender/@value != 'male'</code> could behave differently.</p>",
        "id": 153844705,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1471916277
    },
    {
        "content": "<p>Because the first says there exists no <code>gender/@value</code> with a value of \"male\" and the second says there exists at least one <code>gender/@value</code> which does not have a value of \"male\".  In this case, the point is probably moot because there should be at most one <code>gender</code> element anyway and so the two sets are the same, but it's something to watch out for.</p>",
        "id": 153844707,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1471916475
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> , I think it's very similar to SQL in that it's a data access context and there is missing information involved. My concern is with the meaning and interpretation of the results. If I ask for gender = 'male', do I get results that have no gender element? I think the answer is no, and that's expected, because I interpret the server as saying \"here are Patients that are known to have a gender value of 'male'\".</p>",
        "id": 153844708,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471916493
    },
    {
        "content": "<p>If I'm asking for gender != male, I interpret that as \"here are Patients that are known to have a gender value of not 'male'\".</p>",
        "id": 153844709,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471916587
    },
    {
        "content": "<p>In SQL the same set rules apply.  <code>not(x = y)</code> and <code>x != y</code> are not the same thing.  The first should behave as described by Grahame, the 2nd will not.</p>",
        "id": 153844711,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1471916624
    },
    {
        "content": "<p>If the Patient doesn't have a gender element, the server isn't justified in saying that the gender is not male, the gender isn't known, it might be male, but it might not.</p>",
        "id": 153844712,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471916627
    },
    {
        "content": "<p>the server is returning records that don't have gender = female. </p>",
        "id": 153844713,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471916673
    },
    {
        "content": "<p>?</p>",
        "id": 153844714,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471916685
    },
    {
        "content": "<p>gender:not=female - return records that don't have gender=female</p>",
        "id": 153844715,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471916714
    },
    {
        "content": "<p>With the :not modifier, you are asking for records where the item is anything other than the value; ones with missing value fall into this set.  If you want to ask for items where a value is present and it is not the one supplied, that's a different query (which, I suspect, is not covered).</p>",
        "id": 153844717,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1471916855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191366\">@Stephen Royce</span> Are you sure about the not(x = y) &lt;&gt; x != y in SQL? That doesn't seem right to me.</p>",
        "id": 153844718,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471916901
    },
    {
        "content": "<p>It's been a while since I worked with SQL, so I could be wrong, but I think you'll find that if y is null then <code>x=y</code> returns \"false\" and so <code>not(x=y)</code> returns true, whereas <code>x!=y</code> returns false still.</p>",
        "id": 153844719,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1471917009
    },
    {
        "content": "<p>If the behavior is \"the item is anything other than the value\" then that's fine, but we need to be clear about that in the spec. I disagree with that interpretation of missing information, but so long as the spec is clear and consistent, that's okay. I'll submit a task to track it.</p>",
        "id": 153844720,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471917025
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191366\">@Stephen Royce</span> , hmmm.... <code>x=y</code> returns <code>null</code> if <code>y</code> is <code>null</code>, and negating a null will also return a null.</p>",
        "id": 153844721,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471917090
    },
    {
        "content": "<p>Yeah, I was just thinking that, but is not(null) true or false?</p>",
        "id": 153844722,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1471917123
    },
    {
        "content": "<p>It's null. i.e. the server is saying \"I don't know\"</p>",
        "id": 153844723,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471917141
    },
    {
        "content": "<p>Ultimately, the server has to make a call though because it has to decide which rows are in the set if it's part of the where clause.  Thinking about it, MySQL and Oracle would both treat the condition as false, so my assertion is wrong about SQL.  It's definitely not about XPath though.</p>",
        "id": 153844724,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1471917278
    },
    {
        "content": "<p>Right, when it hits a where clause, the server will interpret a \"null\" as false, but until it hits a where clause, it will propagate through the expression.</p>",
        "id": 153844726,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471917537
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 153844727,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1471917553
    },
    {
        "content": "<p>so we don't have a language that allows you to manage this, like SQL. that's the way in which this is different. So we have to make a binary choice: return the null case or not. </p>",
        "id": 153844728,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471917619
    },
    {
        "content": "<p>it's safer to return the nulls - the client can filter them out</p>",
        "id": 153844729,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471917634
    },
    {
        "content": "<p><img alt=\":thumbs_up:\" class=\"emoji\" src=\"/static/third/gemoji/images/emoji/thumbs_up.png\" title=\":thumbs_up:\"> </p>",
        "id": 153844730,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1471917755
    },
    {
        "content": "<p>Is the same true for numbers and ne?</p>",
        "id": 153844731,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471917860
    },
    {
        "content": "<p>And :not-in</p>",
        "id": 153844732,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1471917919
    },
    {
        "content": "<p>don't know about ne. The qualifier is on the value not the parameter there. </p>",
        "id": 153844737,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471918659
    },
    {
        "content": "<p>I think it's the same for :not-in. you can add them to the request for clarification</p>",
        "id": 153844738,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471918691
    },
    {
        "content": "<p>When I use the :not-modifier with a list e.g. <code>gender:not=male,female</code><br>\nwill it return all Patients with a gender other than male or female (other, unknown, null) or will it return all Patients, because the list is treated as OR and every patient is either not male OR not female...?</p>",
        "id": 272094641,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1645005601
    },
    {
        "content": "<p>not \"gender=male, female\". Compare with \"code:not-in=male-female-valuset\". IMHO wouldn't make sense to have the logic any other way.</p>",
        "id": 272096661,
        "sender_full_name": "René Spronk",
        "timestamp": 1645006680
    },
    {
        "content": "<p>I agree, that it makes more sense, but strictly from looking the spec, the list should behave as logical OR</p>",
        "id": 272097703,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1645007311
    },
    {
        "content": "<p>Here's the definition of OR in the spec: <a href=\"https://build.fhir.org/search.html#combining\">https://build.fhir.org/search.html#combining</a></p>\n<blockquote>\n<p>If, instead, the search is to find patients that speak either language, then this is a single parameter with multiple values, separated by a ,. For example, /Patient?language=FR,NL. This is known as an OR search parameter, since the server is expected to respond with results which match either value. Every search parameter may be used with comma-separated values in this fashion; this includes the use of search parameters with modifiers, such as `?code:text=this,that.</p>\n</blockquote>\n<p>...it explicity allows the use of modifiers but it doesn't say that the meaning changes in case of <code>:not</code></p>",
        "id": 272098172,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1645007609
    },
    {
        "content": "<p>Apparently both HAPI and Firely Server have it implemented as AND, see <a href=\"https://hapi.fhir.org/baseR4/Patient?gender:not=male,female&amp;gender:missing=false\">https://hapi.fhir.org/baseR4/Patient?gender:not=male,female&amp;gender:missing=false</a> (only returns genders unknown and other)</p>",
        "id": 272098440,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1645007776
    },
    {
        "content": "<p>I think one could (and should) interpret the spec as </p>\n<p>NOT (gender = male OR female), so basically this should return other/unknown/empty</p>",
        "id": 272098812,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1645008025
    },
    {
        "content": "<p>I think the definition of :not also says that:</p>\n<p>\":not   Reverse the code matching described in the paragraph above: return all resources that do not have a matching item\"</p>",
        "id": 272099087,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1645008194
    },
    {
        "content": "<p>The code matching would be male/female, the reverse other/unkown/empty</p>",
        "id": 272099217,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1645008270
    },
    {
        "content": "<p>It's worth opening an issue to address this explicitly, including an example.</p>\n<p>We had a similar \"gotcha\" with the definition of :not when applied to elements with <code>..*</code> cardinality (are you looking for resources that have no matching elements in their array, or results that have any elements that don't match  -- the answer is no the former but this was not obvious from the original definitions.)</p>",
        "id": 272122338,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1645021549
    }
]