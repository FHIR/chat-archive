[
    {
        "content": "<p>I'm looking at the following use case:</p>\n<p>A source system with FHIR RESTful API shall export all data of a given scope (at the maximum: all resource instances it contains - ignore file sizes and splitting of data for the moment), including all prior versions of all instances. That, obviously, could easily be achieved using the history interaction.</p>\n<p>Now I want to push all data I received from the source to a destination system, using the FHIR RESTful API as well.<br>\nMy idea would be to transform the history Bundle I received to a transaction Bundle and throw it at the destination.<br>\nNevertheless, there are references in the source data (say: a Condition instance references a Patient instance), so the destination needs to keep track of the original ids during import. So the \"Update as create\" mechanism ( <a href=\"http://hl7.org/fhir/http.html#upsert\" target=\"_blank\" title=\"http://hl7.org/fhir/http.html#upsert\">http://hl7.org/fhir/http.html#upsert</a> ) would also be necessary (which is defined for R4, but not for STU3). This implies every POST and PUT from the source would become a PUT in the transaction.</p>\n<p>If I follow that concept and make up such a transaction Bundle, containing 2 Patient resources with the same id, but meta.versionId being 1 and 2 respectively, I get errors:<br>\nHAPI complains with \"Transaction bundle contains multiple resources with ID: Patient/myId\"<br>\n<a href=\"http://test.fhir.org\" target=\"_blank\" title=\"http://test.fhir.org\">test.fhir.org</a> says \"Unknown message MSG_Transaction_DUPLICATE_ID (entry 2)\".<br>\nThis of course is true, but seems to kill my idea of how to replay a history to another server.</p>\n<p>So, hopefully I overlooked something? Maybe there's also advice from FHIR Bulk Data that I didn't find?</p>",
        "id": 159071973,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1550759783
    },
    {
        "content": "<p>Don't think there is a way to 'reply the history' to another server. It sort of runs counter the idea of versioning itself: it is managed internally by each server, not controlled / controllable from outside</p>",
        "id": 159072398,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1550760112
    },
    {
        "content": "<p>The idea is: if I replay all actions, the destination will build a history that is equivalent to the one in the source system</p>",
        "id": 159072492,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1550760172
    },
    {
        "content": "<p>only if you also turn-back-time.... lastupdated..  I presume your definition of 'equivalent' is recognizing these kind of differences?</p>",
        "id": 159074038,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550761257
    },
    {
        "content": "<p>Well, lastupdated would be another problem to solve in this context. But for the timestamp I think there would be ways to sufficiently document the original timestamp (in the context of my use case)</p>",
        "id": 159074396,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1550761467
    },
    {
        "content": "<p>The alternative, as far as I see, would be to simply use a collection (or maybe also transaction) Bundle and define a custom operation</p>",
        "id": 159075659,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1550762420
    },
    {
        "content": "<p>as soon as you start adding exceptions, you are not using standards... Yes you could define that lastupdated would be preferred in your use-case</p>",
        "id": 159075685,
        "sender_full_name": "John Moehrke",
        "timestamp": 1550762446
    },
    {
        "content": "<p>The goal is to comply to the standard, which is why I'm asking. I thought more of like a \"lastUpdatedInSource\" extension or similar to handle that, which should be sufficient here.<br>\nBut the duplicate id issue can't be solved this way.</p>",
        "id": 159076115,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1550762741
    },
    {
        "content": "<p>There is no way to \"restore\" a server that retains history right now.  It's been discussed previously, though I'm not sure if we have a change request to add that yet.  There's no way to do it using the HTTP actions defined so far.</p>",
        "id": 159077664,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550763720
    },
    {
        "content": "<p>Thanks Lloyd, that clarifies it in terms of the original idea.<br>\nSo best practice for now would be profiling a Bundle (collection or transaction?) with an accompanying custom operation?</p>",
        "id": 159077931,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1550763870
    },
    {
        "content": "<p>Yes.  An operation that takes a \"history\" Bundle would work.</p>",
        "id": 159078181,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550764020
    },
    {
        "content": "<p>Right, \"history\" might be even better - I just wasn't sure whether POSTing a history Bundle would throw an error in the very early stages of validation</p>",
        "id": 159078329,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1550764109
    },
    {
        "content": "<p>Operations can consume pretty much anything.  No reason for it to throw an error.</p>",
        "id": 159078693,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550764354
    },
    {
        "content": "<p>Thanks again. That sounds like a way to go.</p>",
        "id": 159079105,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1550764666
    },
    {
        "content": "<p>it has been discussed but parked for now - it'll come up again in the bulk data import discussion</p>",
        "id": 159105256,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550783946
    },
    {
        "content": "<p>My server implements this through a back door channel, as there is a lot of other information that is not in the resources, specifically around security context data, and some other internal stuff.</p>",
        "id": 159813448,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1551558650
    }
]