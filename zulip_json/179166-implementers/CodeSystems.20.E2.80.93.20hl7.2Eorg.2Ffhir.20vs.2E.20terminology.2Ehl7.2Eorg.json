[
    {
        "content": "<p>Is there a pattern behind whether a CodeSystem uses \"<a href=\"http://hl7.org/fhir\" target=\"_blank\" title=\"http://hl7.org/fhir\">hl7.org/fhir</a>\" as its defining URL (e.g. <code>http://hl7.org/fhir/CodeSystem/medicationrequest-status</code>) or uses \"<a href=\"http://terminology.hl7.org\" target=\"_blank\" title=\"http://terminology.hl7.org\">terminology.hl7.org</a>\" (e.g. <code>http://terminology.hl7.org/CodeSystem/condition-ver-status</code>)? I notice some have moved away from \"<a href=\"http://terminology.hl7.org\" target=\"_blank\" title=\"http://terminology.hl7.org\">terminology.hl7.org</a>\" in the build when compared to R4 (like <a href=\"http://build.fhir.org/valueset-medicationdispense-status.html\" target=\"_blank\" title=\"http://build.fhir.org/valueset-medicationdispense-status.html\">http://build.fhir.org/valueset-medicationdispense-status.html</a>) but this is not universal.</p>",
        "id": 189869486,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1583480767
    },
    {
        "content": "<p>yes. if the URL appears in the instance, or it's a v2 or v3 code system, it will use <a href=\"http://terminology.hl7.org\" target=\"_blank\" title=\"http://terminology.hl7.org\">terminology.hl7.org</a>. if it's a code the gets converted to an enum in generated code, it's maintained with the fhir spec itself, and lives in <a href=\"http://hl7.org/fhir\" target=\"_blank\" title=\"http://hl7.org/fhir\">hl7.org/fhir</a>.</p>",
        "id": 189869749,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1583481077
    },
    {
        "content": "<p>note that this means that you should allow for codes in <a href=\"http://terminology.hl7.org\" target=\"_blank\" title=\"http://terminology.hl7.org\">terminology.hl7.org</a> to change - to have a different life cycle from the specification itself, where as the <a href=\"http://hl7.org/fhir\" target=\"_blank\" title=\"http://hl7.org/fhir\">hl7.org/fhir</a> codes are locked in to the release they are defined with</p>",
        "id": 189869880,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1583481212
    },
    {
        "content": "<p>That does indeed make sense, thanks!</p>",
        "id": 189870248,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1583481570
    },
    {
        "content": "<p>Can you say more about lifecycle? Like, for a required binding to a nonversioned \"<a href=\"http://terminology.hl7.org\" target=\"_blank\" title=\"http://terminology.hl7.org\">terminology.hl7.org</a>\" valueset, is it just \"validator should use the latest version available\"?</p>",
        "id": 189890881,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1583500340
    },
    {
        "content": "<p>That's a great question. I was wondering the same for profile links without a version. Does this imply latest? How is latest defined as version is just a string. Would latest then be: _lastUpdated?</p>",
        "id": 189893189,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1583502169
    },
    {
        "content": "<p>Update policies (and capabilities) will vary.  One system might get an update a few seconds after it happens.  It might not propagate to another system for weeks.  But yes, _lastUpdated is the best way to determine 'latest'.  However, servers are also allowed to host multiple versions simulateously - same canonical URL, different version.  However, I don't see any mechanism for an old release to indicate it's an old release.  <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> ?</p>",
        "id": 189906363,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1583510201
    },
    {
        "content": "<p>server discretion.</p>",
        "id": 189931068,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1583526658
    },
    {
        "content": "<p>I would slightly modify <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span>'s suggestion for the case of a required binding to a nonversioned \"<a href=\"http://terminology.hl7.org\" target=\"_blank\" title=\"http://terminology.hl7.org\">terminology.hl7.org</a>\" valueset, to \"validator should use the latest version that it is aware of\".  I think that would be the usual expectation, but, as Grahame said, it is up to server discretion.   For determining the latest version, as Lloyd said, updates schedules may differ markedly between various entities/organization.  But I'm not seeing why we would need or want to have a mechanism for an old release to indicate that it's an old release?  I think that normally _lastUpdated or the versions themselves (which often either are or include the date or a numeric sequence) should be sufficient.</p>",
        "id": 189931926,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1583527334
    },
    {
        "content": "<p>it would be nice to have the guidance that conformance resources should use semver in their version field.</p>",
        "id": 189971834,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1583590057
    },
    {
        "content": "<p>Semantic versioning isn't straight-forward to do comparisons on (neither numeric nor alphabetic comparisons work, which makes searching a pain).  Plus, if it's a \"SHOULD\", that doesn't help for the numerous situations where - based on historical convention or otherwise - artifacts will use something else.</p>",
        "id": 189975507,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1583596754
    },
    {
        "content": "<p>_lastUpdated is useless for determining an old release because old releases can be maintained once a new release is out.  I.e. _lastUpdated on the 2016 release could be more recent than _lastUpdated on the 2019 release.  And .version isn't computably comparable because .version might be \"2016\" or \"Honeycomb\" or \"0.5.266.17\" or \"Beta 2\" or any number of other things - each of which would require a different comparison algorithm.</p>",
        "id": 189975590,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1583596914
    },
    {
        "content": "<p>Server discretion doesn't help when the server may not have a clue what the algorithm even is - and when the author of the artifact isn't even required to stick with the same algorithm over time.</p>",
        "id": 189975641,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1583596962
    },
    {
        "content": "<p>The cleanest thing to do, I think, is that if there's a new release, you update the old release to point to the new release.  The newest release is the one that doesn't have a pointer.  However, if it's too hard to update he old items, you can have the new release point to the old release.  To find the newest release, you start with the release you've got and chain through, looking for the release that points to what you've got and continue searching until you can't find a release that replaces the one you have.</p>",
        "id": 189975704,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1583597099
    },
    {
        "content": "<p>That's more processing intensive, but doesn't force updating of historical releases.  And at least it's reliably computable...</p>",
        "id": 189975715,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1583597129
    },
    {
        "content": "<p>I agree that there are potential issues with this.  It's just that from a practical standpoint I haven't seen people struggling with it much (if at all) for the code systems that are generally of interest to the various communities.  The suggestions that you made above (whichever direction the pointers go) would work - as long as someone agrees to and reliably does maintain the pointers.  If for whatever reason that doesn't occur, then you're not better off (and may be worse off) than you were without any pointers.</p>",
        "id": 189975927,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1583597464
    },
    {
        "content": "<p>I think that's driven by two things:</p>\n<ul>\n<li>systems aren't exposing multiple versions of a given code system; or</li>\n<li>systems are only exposing systems they know well and have custom logic to support</li>\n</ul>",
        "id": 189983404,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1583610207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179166-implementers/topic/CodeSystems.20.E2.80.93.20hl7.2Eorg.2Ffhir.20vs.2E.20terminology.2Ehl7.2Eorg/near/189975507\" title=\"#narrow/stream/179166-implementers/topic/CodeSystems.20.E2.80.93.20hl7.2Eorg.2Ffhir.20vs.2E.20terminology.2Ehl7.2Eorg/near/189975507\">said</a>:</p>\n<blockquote>\n<p>Semantic versioning isn't straight-forward to do comparisons on</p>\n</blockquote>\n<p>for releases i think it is pretty straight forward. 3 positive integers with a defined hierarchy. Or am i missing something?</p>",
        "id": 190012206,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1583670373
    },
    {
        "content": "<p>The question is whether it works with a simple database comparison operation.  I.e. Can you search for MAX(version) and have it reliably work on all databases.  That's going to be driven by how \".\" compares with \"0\" in a string compare.</p>",
        "id": 190015643,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1583677608
    },
    {
        "content": "<p>But the other challenge is that semantic versioning isn't required (and can't be), which means that using a generic mechanism for comparing versions can't be done</p>",
        "id": 190015650,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1583677651
    },
    {
        "content": "<p>Several issues here:</p>\n<ol>\n<li><code>_lastUpdated</code> has nothing to do with business versions.  Version ordering of terminology resources is about business versions.</li>\n<li>What are the circumstances where a  \"<a href=\"http://terminology.hl7.org\" target=\"_blank\" title=\"http://terminology.hl7.org\">terminology.hl7.org</a>\" valueset will be unversioned?  <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> do you mean the ValueSet itself has no version or that the binding does not specify a version?</li>\n</ol>",
        "id": 190035357,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1583716217
    },
    {
        "content": "<p>Lesser thing(s):</p>\n<ol start=\"3\">\n<li>Semver makes sense when you want to convey some kind of compatibility story (hence 1 and 2-digit variants and complexity in comparing them). Without a clear compatibility story there's no criteria for which digit to change; best to use date-stamps since they have a simple comparison story.</li>\n</ol>",
        "id": 190035701,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1583717041
    },
    {
        "content": "<p>I have to admit this thread just reinforces my belief that we really don't understand how to do terminology versioning (how should semver work? we've struggle with this) and how use of versioning should apply in use cases where it actually matters. Yes, this has been around long enough that we've got ideas, but we've not really tested this at connectathon. I'd love to hear some ideas on how to get some experience with the need for and a better approach then \"server discretion\" when that ends up meaning it's a crap-shoot.</p>",
        "id": 190199433,
        "sender_full_name": "Robert McClure",
        "timestamp": 1583860577
    },
    {
        "content": "<p>I am probably blind and/or ignorant, but why shouldn't semver work?</p>",
        "id": 190295242,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1583940862
    },
    {
        "content": "<p>We've had problems clearly determining what kind of change results in an increment in which part of the semver. And even if we figure something out for code system, it will be a bit different for value sets. And then others create this content and we reuse it and they never use semver, so there will be LOTS of inconsistency. That said, the UTG will be using a semver approach with the current plan noted <a href=\"https://confluence.hl7.org/display/VOC/UTG+Versioning+Requirements\" target=\"_blank\" title=\"https://confluence.hl7.org/display/VOC/UTG+Versioning+Requirements\">here</a></p>",
        "id": 190317988,
        "sender_full_name": "Robert McClure",
        "timestamp": 1583952857
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 190320806,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1583954442
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 190320818,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1583954452
    }
]