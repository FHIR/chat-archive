[
    {
        "content": "<p>Someone else has taken a stab at the syntax for extensions in JSON: <a href=\"http://community.fhir.org/t/suggestion-for-extensibility-in-json/369/2\" target=\"_blank\" title=\"http://community.fhir.org/t/suggestion-for-extensibility-in-json/369/2\">http://community.fhir.org/t/suggestion-for-extensibility-in-json/369/2</a>. This is a new variant we haven't discussed before. </p>",
        "id": 153874793,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488743055
    },
    {
        "content": "<p>procedurally, It's really hard for me to imagine that this is something we'd change at all, let alone now, but I know that not everyone is happy with where we are...</p>",
        "id": 153874794,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488743099
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> i've written about this 5 month ago and we implemented it in aidbox as additional json+aidbox format :) <a href=\"https://gist.github.com/niquola/0f66419274af5e3add9a33766e21b8c7\" target=\"_blank\" title=\"https://gist.github.com/niquola/0f66419274af5e3add9a33766e21b8c7\">https://gist.github.com/niquola/0f66419274af5e3add9a33766e21b8c7</a></p>",
        "id": 153874795,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488743825
    },
    {
        "content": "<p>this particular syntax? I don't recall this particular variant being discussed?</p>",
        "id": 153874797,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488743875
    },
    {
        "content": "<p><a href=\"https://chat.fhir.org/#narrow/stream/implementers/topic/Extensions.20-.20Representation\" target=\"_blank\" title=\"https://chat.fhir.org/#narrow/stream/implementers/topic/Extensions.20-.20Representation\">https://chat.fhir.org/#narrow/stream/implementers/topic/Extensions.20-.20Representation</a></p>",
        "id": 153874798,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488743947
    },
    {
        "content": "<p>again, not this particular syntax</p>",
        "id": 153874799,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488743989
    },
    {
        "content": "<p>The core idea - it should be key-value, not collection</p>",
        "id": 153874801,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488744043
    },
    {
        "content": "<p>Please, read gist above - there are also couple of ideas about polymorphics &amp; primitive extensions</p>",
        "id": 153874803,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488744288
    },
    {
        "content": "<p>Or may be i have to ask Mostafa Sholkamy to present it :)</p>",
        "id": 153874805,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488744899
    },
    {
        "content": "<p>As you ask in that thread, there's the open issue of where the outermost extension key comes from.<br>\nAlso, the XSLT example is brittle, so it's not as simple as it makes out; the matching doesn't restrict to <code>http://hl7.org/fhir/StructureDefinition/patient-clinicalTrial</code> and could be broken by other extensions that have overlapping sub-parts</p>",
        "id": 153874828,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1488757796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> this issue could be solved by embedding schema like this:</p>\n<div class=\"codehilite\"><pre><span></span>....\nextension: {\n  $schema: {\n    livingArrangement: {url: &quot;http://hl7.org/fhir/ValueSet/v3-LivingArrangement&quot;, type: &#39;CodeableConcept&#39;}\n    race: {url: &quot;http://hl7.org/fhir/StructureDefinition/us-core-race&quot;, type: &#39;CodeableConcept&#39;},\n    adoption: {url:&quot;http://hl7.org/fhir/StructureDefinition/patient-adoptionInfo&quot;, type:  &#39;string&#39;},\n    whenAdopted: {url:&quot;http://narus.com/when-adopted&quot;, type: &#39;date&#39;},\n    occupation: {url:&quot;http://hl7.org/fhir/ValueSet/anzsco-occupations&quot;, type: &#39;string&#39;}\n    marriedDate: {url:&quot;http://narus.com/fhir/date-married&quot;, type: &#39;date&#39;},\n    employer: {url:&quot;http://narus.com/fhir/supportive-employer&quot;, type: &#39;boolean&#39;}\n  },\n\n  livingArrangement: {coding: ...},\n  race: {coding: ....},\n  adoption: &quot;no&quot;,\n  whenAdopted: &quot;1980&quot;\n  occupation: &quot;Telecommunications Engineer&quot;,\n  marriedDate: &quot;2001&quot;\n  employer:  true\n}\n...\n</pre></div>",
        "id": 153874893,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488782304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> we can introduce new JSON format as not breaking change - let's just support both current and new one with different mime types</p>",
        "id": 153874894,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488782620
    },
    {
        "content": "<p>So the element names could vary from instance to instance and would essentially be made up by the serializer?</p>",
        "id": 153874895,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1488782678
    },
    {
        "content": "<p>This is well known namespacing problem and solution. If we have name clash - we could use aliasing like \"alias1/key\" and \"alias2/key\" like in most of modern programming languages</p>",
        "id": 153874898,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488782953
    },
    {
        "content": "<p>Probability of name clash is not so heigh, and, i think, usability profit worth it</p>",
        "id": 153874900,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488783065
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> Sorry, I was responding to <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> .  However, the problem with the $schema syntax is that a client can't just say, for example,  <code>resource.extension.whenAdopted</code> since 'whenAdopted' could be mapped to any extension URL (or none at all).  Yes, this is the well known namespacing problem, but it's clients that pay the price</p>",
        "id": 153874901,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1488783074
    },
    {
        "content": "<p>all extensions go into separate key <code>extensions</code> so you always know it's extension</p>",
        "id": 153874902,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488783126
    },
    {
        "content": "<p>If you are not sure about it's semantic or have a conflict or merge, you lookup $schema resolution object - but in many of applications you will know your extensions</p>",
        "id": 153874903,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488783283
    },
    {
        "content": "<p>If I'm writing a generic client that's looking for a well-known (to me) extension (let's say \"<a href=\"http://narus.com/when-adopted\" target=\"_blank\" title=\"http://narus.com/when-adopted\">http://narus.com/when-adopted</a>\").  I can't assume that every server is going to serve resources with that URL mapped to \"whenAdopted\".  How should I consume/navigate this JSON in a safe way?</p>",
        "id": 153874904,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1488783422
    },
    {
        "content": "<p>You could do schema resolution (i.e. very simple transformation):</p>\n<div class=\"codehilite\"><pre>extension: {\n   $schema: {key: &quot;narus.com/whenAdopted&quot;}\n    whenAdopted: ....\n}\n\n=&gt;\nextension: {\n    &quot;narus.com/whenAdopted&quot;: .....\n}\n</pre></div>",
        "id": 153874905,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488783538
    },
    {
        "content": "<p>Which we could have had in the first place?</p>",
        "id": 153874909,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1488783636
    },
    {
        "content": "<p>This  pure transformation (i.e. do not require any external knowledge) will provide you with safe aggregation format (very simmilar to json-ld)</p>",
        "id": 153874910,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488783665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> excuse me, do not understand question :(</p>",
        "id": 153874911,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488783719
    },
    {
        "content": "<p>What I meant was, why not start with</p>\n<div class=\"codehilite\"><pre>extension: {\n    &quot;narus.com/whenAdopted&quot;: .....\n}\n</pre></div>",
        "id": 153874913,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1488783909
    },
    {
        "content": "<p>Yes it's valid, but developers prefer simple short names  -  so why do not give them aliasing tools</p>",
        "id": 153874914,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488783964
    },
    {
        "content": "<p>The <code>$schema</code> stuff just looks like a compression technique?  If you want short names, do the reverse transformation where you're in control of the target names.<br>\nIt's just my gut saying that they should not be part of the wire protocol.</p>",
        "id": 153874915,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1488784077
    },
    {
        "content": "<p>We introduced this format half year ago and our clients prefer it for internal API calls,  while for external integrations we automatically convert to  current FHIR JSON format</p>",
        "id": 153874916,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488784078
    },
    {
        "content": "<p>$schema also could be used to put some critical metadata like types or isModifier </p>",
        "id": 153874917,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488784152
    },
    {
        "content": "<p>But this is details - if we agree on key-value representation of extensions - that's cool</p>",
        "id": 153874918,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488784221
    },
    {
        "content": "<p>so you can do that transformation now. We don't need to change anything for that. This is pretty much where we ended up last time...</p>",
        "id": 153874929,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488789085
    },
    {
        "content": "<p>Ok, let's wait more feedback on JSON from real users :)</p>",
        "id": 153874934,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488791349
    },
    {
        "content": "<p>Essential problem with current JSON, that it does not play  well with design of JSON schema - you could not express some constraints (polymorphics, primitive extensions, extensions) in JSON-schema bacause current JSON format not enough jsonish :( So standard JSON schema (without custom extensions) able only partialy validate FHIR resources.</p>",
        "id": 153874935,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488791540
    },
    {
        "content": "<p>I could prepare talk for May 2017 HL7 International Conference &amp; Working Group Meeting about JSON related issues and possible solutions</p>",
        "id": 153874938,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488791704
    },
    {
        "content": "<p>You do realize that json-schema isn't the only JSON schema package around, right?</p>",
        "id": 153874939,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1488791732
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191678\">@Abigail Watson</span>  what do you mean - concrete JSON schema engine? We've implemented json-schema in clojure and used several npm packages.</p>",
        "id": 153874940,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488791823
    },
    {
        "content": "<p>JSON-schema is specification not package :)</p>",
        "id": 153874941,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488791855
    },
    {
        "content": "<p>Or you are talking about antoher schemata for json. JSON schema is very popular and core of Swagger specification  - that's why, i think, it's right direction for FHIR to have good support for it.</p>",
        "id": 153874942,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488792056
    },
    {
        "content": "<p>There is some \"internal logic\" or \"JSON thinking\" and other specs like GraphQL, avro etc expect it - but FHIR breaks this expectations</p>",
        "id": 153874943,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488792184
    },
    {
        "content": "<p>Just try to express in JSON schema required value[x] parameter, primitive extensions or validation for custom extension - and you will understand, what i'm talking about.</p>",
        "id": 153874944,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488792245
    },
    {
        "content": "<p>I'm talking about other schemata.  The Meteor ecosystem has an isomorphic schema layer that handles most of those things on the server and client, and lets us use FHIR schemas as our database schema.  We've got extentions, multi parameter matching, versioning, and the other things you're talking about mostly solved.  I've been implementing them.  So I basically know exactly what you're talking about.  </p>",
        "id": 153874946,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1488792609
    },
    {
        "content": "<p>It's super late here and I'm crashing for the evening; but um...  I think the ecosystem is a bit bigger than you seem to think it is.  (Although I'll grant you one thing... JSON Schema having IETF Draft is a compelling argument.  I'm going to bring it up to the Simple Schema folks and do a bit more research. )</p>",
        "id": 153874947,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1488792838
    },
    {
        "content": "<p>Interesting - I presume you mean <a href=\"https://www.meteor.com/\" target=\"_blank\" title=\"https://www.meteor.com/\">https://www.meteor.com/</a> -- there are many \"Meteor\"s out there and this is one I had not come across</p>",
        "id": 153874951,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1488794804
    },
    {
        "content": "<p>Thx <span class=\"user-mention\" data-user-id=\"191678\">@Abigail Watson</span> I will take a look at meteor's schema. If you have your FHIR extensions in open source - please send me a link. Does meteor's schema has specification? After we could discuss it in more details ;) We also played a lot with graphql and avro - have you seen it?</p>",
        "id": 153874959,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488803078
    },
    {
        "content": "<p>Yes, Meteor refers to <a href=\"http://meteor.com\" target=\"_blank\" title=\"http://meteor.com\">meteor.com</a>. I believe all Abigail's Clinical Meteor codebase is open source and can be found at <a href=\"https://github.com/clinical-meteor\" target=\"_blank\" title=\"https://github.com/clinical-meteor\">https://github.com/clinical-meteor</a></p>",
        "id": 153875047,
        "sender_full_name": "Igor Sirkovich",
        "timestamp": 1488817889
    },
    {
        "content": "<p>The following package implements the FHIR Patient Resource and passes the Touchstone API tests for version 1.6.0. <br>\n<a href=\"https://github.com/clinical-meteor/hl7-resource-patient\" target=\"_blank\" title=\"https://github.com/clinical-meteor/hl7-resource-patient\">https://github.com/clinical-meteor/hl7-resource-patient</a></p>\n<p>It basically uses 'node-simple-schema<code>, and does the same thing that Swagger does, using some Meteor specific packages called</code>JsonRoutes<code>and</code>Collection2`.  I'm not saying that everybody should drop what they're doing, and use Meteor.  However, we've put a year or two of work into this ourselves, and have got an isomorphic schema layer that's working for API endpoints, server collections, client collections, our database schemas, *and* subscriptions.  Understandably, we're reluctant to toss all that work away, and sort of like things how they are.</p>\n<p>In particular, lines 73 through 75 show how we're building composite resources that can handle extensions.  <br>\n<a href=\"https://github.com/clinical-meteor/hl7-resource-patient/blob/master/lib/Patients.js#L73-L75\" target=\"_blank\" title=\"https://github.com/clinical-meteor/hl7-resource-patient/blob/master/lib/Patients.js#L73-L75\">https://github.com/clinical-meteor/hl7-resource-patient/blob/master/lib/Patients.js#L73-L75</a></p>\n<p>And the latest <code>node-simple-schema</code> package has support for <code>SimpleSchema.oneOf</code>which can support the <code>Resource.value[x]</code> pattern.<br>\n<a href=\"https://github.com/aldeed/node-simple-schema#multiple-definitions-for-one-key\" target=\"_blank\" title=\"https://github.com/aldeed/node-simple-schema#multiple-definitions-for-one-key\">https://github.com/aldeed/node-simple-schema#multiple-definitions-for-one-key</a>  </p>",
        "id": 153875050,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1488821071
    },
    {
        "content": "<p>As for graphql, there's the Apollo project from the Meteor Development Group.  <br>\n<a href=\"http://www.apollodata.com/\" target=\"_blank\" title=\"http://www.apollodata.com/\">http://www.apollodata.com/</a></p>\n<p>We've been waiting until it had a Subscription implementation before moving over.  Classic Meteor included a pub/sub technology called DDP/Livedata that was loosely based on the old PubSubHubBub protocol.  So Meteor has had Subscriptions for like 4 years now; in an implementation very familiar to what's used in Radiology and Laboratories.  We've been waiting for Apollo to catch up with it's Subscription implementation, so we can do a clean refactor and swap the one infrastructure out for the other.  It's probably going to break isomorphicity on the database schemas layer though; and break the rest of our tooling pipeline.  </p>\n<p>So...   we're heading in the GraphQL direction, but we're happy to take our time.  We may not adopt for another year or two yet.  The DDP/Livedata implementation is 4 years mature, and meets the needs of Radiology, Laboratory, etc; whereas GraphQL is only 1 or 2 years mature at this point.  </p>",
        "id": 153875054,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1488821628
    },
    {
        "content": "<p>Keep in mind that *no* schema language (XML or JSON) is going to be able to enforce all the constraints of a profile - slicing, terminology bindings, FHIRPath invariants, etc.</p>",
        "id": 153875074,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1488828467
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> just as example if extensions will be key-value - it's possible to express slicing by JSON schema very naturally, JSON schema could be easyly extended to validate terminology bindings. FHIR tools also unable to enforce all buisness validations on resources :( - so we are fighting to express as much as possible in a declarative way.</p>",
        "id": 153875186,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488876733
    },
    {
        "content": "<p>can you be specific about all these please </p>",
        "id": 153875187,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488876787
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> do you mean, how to describe slicing by JSON-schema or validate terminology bindings?</p>",
        "id": 153875189,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488877044
    },
    {
        "content": "<p>both of those, and also which business validations that the FHIR validation tooling can't enforce that json schema could</p>",
        "id": 153875190,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488877107
    },
    {
        "content": "<p>I mean, not FHIR not JSON schema could enforce a lot of real-world app invariants </p>",
        "id": 153875191,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488877176
    },
    {
        "content": "<p>Because this invariants involve a lot of resources and relationships</p>",
        "id": 153875192,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488877231
    },
    {
        "content": "<p>Schema or FHIR could validate structure of resource and  some invariants of it's internal parts</p>",
        "id": 153875193,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488877333
    },
    {
        "content": "<p>About slicing - it's activelly used to describe extensions, because they are collections. <br>\nIf extensions would be objects like:</p>\n<div class=\"codehilite\"><pre>extension: {\n    &quot;us/race&quot;: ....\n    ...\n}\n</pre></div>\n\n\n<p>It's easy to specify schema for it:</p>\n<div class=\"codehilite\"><pre>extension: { \n    type: object,\n    properties: {\n          &quot;us/race&quot;:   { type:  object, ................}\n    }\n   required: [&quot;us/race&quot;]\n}\n</pre></div>",
        "id": 153875194,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488877702
    },
    {
        "content": "<p>but you can still slice without that. It's just a little less direct</p>",
        "id": 153875195,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488877784
    },
    {
        "content": "<p>Yes but this approach is more natural, at least for me. </p>",
        "id": 153875198,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488878000
    },
    {
        "content": "<p>As a developer i want to access race as <code>Patient.extension.race</code> not <code>Patient.extension.where(url=\"race\")[0]</code>, i would like to say there is only one race per patient etc</p>",
        "id": 153875199,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488878111
    },
    {
        "content": "<p>Because in FHIR i do <code>Patient.name</code> not <code>Patient.elements.where(prop=\"name\")</code></p>",
        "id": 153875200,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488878187
    },
    {
        "content": "<p>That's the diff between what <code>FHIR force me</code> and <code>if i would do it by myself or how it's done by my framework etc</code> (i.e. without standard) - this <code>impedance</code> will be in mind of many developers</p>",
        "id": 153875201,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488878334
    },
    {
        "content": "<p>I consulted several projects, which thinking about or starting using FHIR - and most of developers compare standard approach to their personal approach or industry approach to model entities, build API etc. The more impedance means less chances to choose FHIR as foundation for system design and decide  -  it's only transport format (like others).</p>",
        "id": 153875202,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488878929
    },
    {
        "content": "<p>How would this work with JSON schema - where the presumption is all FHIR instances in the world need to validate against a single schema?</p>",
        "id": 153875253,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1488911346
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> I think this would best done client-side as a transformation on the JSON coming in and again in reverse before the JSON goes out.<br>\nThen, as a client, I could <em>know</em> that the extension was mapped to <code>race</code> and not, for example, <code>us_race</code>.</p>",
        "id": 153875375,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1488931523
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> yes for clinet side we do this, but we still have some problems with schema and database, which are on a backend (<a href=\"https://gist.github.com/niquola/0f66419274af5e3add9a33766e21b8c7\" target=\"_blank\" title=\"https://gist.github.com/niquola/0f66419274af5e3add9a33766e21b8c7\">https://gist.github.com/niquola/0f66419274af5e3add9a33766e21b8c7</a>).</p>",
        "id": 153875480,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488962700
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> this <a href=\"https://gist.github.com/niquola/0f66419274af5e3add9a33766e21b8c7\" target=\"_blank\" title=\"https://gist.github.com/niquola/0f66419274af5e3add9a33766e21b8c7\">solution</a>  is looking good</p>",
        "id": 153875544,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1488990438
    },
    {
        "content": "<p>@<strong>Abigail Watson </strong>  I'm building a GraphQL server for FHIR <a href=\"https://github.com/shalkam/gql-fhir\" target=\"_blank\" title=\"https://github.com/shalkam/gql-fhir\">here</a> using express.js server for apollo,  if you can take a look</p>",
        "id": 153875551,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1488991883
    },
    {
        "content": "<p>Hi Mostafa.   Fantastic bit of work there.  If you don't mind, I'm going to include a link in the Clinical Meteor SDK, so people can keep track of this project.  Very promising.  I'm also checking up on the recommended build pipeline.  We use a Meteor pipeline, but Webpack/Babel isn't necessarily a deal breaker.  This architecture actually aligns well with the SNOMED-CT server from IHTSDO.  </p>",
        "id": 153875567,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1488997650
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> Do you have a publicly available javascript function that implements the transform?</p>",
        "id": 153875698,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489038716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> it's in clojure, but we can port to js, if you are interested</p>",
        "id": 153875715,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489046137
    },
    {
        "content": "<p>If you want to port it that would be awesome, but I'm pretty sure I could do it myself if I could take a look at your clojure implementation</p>",
        "id": 153875945,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489117371
    }
]