[
    {
        "content": "<p>My question is in the title. Are all FHIR Search requests supposed to not return a resource twice? IMHO it would be common sense to require this behaviour. But I didn't find anything in the spec regarding this requirement.</p>",
        "id": 251630198,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1630530647
    },
    {
        "content": "<p>It's enforced by the rules for bundles: <a href=\"http://hl7.org/fhir/bundle.html#bundle-unique\">http://hl7.org/fhir/bundle.html#bundle-unique</a></p>",
        "id": 251630526,
        "sender_full_name": "Paul Church",
        "timestamp": 1630530794
    },
    {
        "content": "<p>So, within a page, they'll generally be unique.  Across pages they might not be.</p>",
        "id": 251631473,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1630531261
    },
    {
        "content": "<p>They're definitely not unique across pages for includes. I'm not sure if I can point to anything other than common sense that says the primary results shouldn't be duplicated across pages.</p>",
        "id": 251631698,
        "sender_full_name": "Paul Church",
        "timestamp": 1630531392
    },
    {
        "content": "<p>I don' t know that we guarantee uniqueness even for the base resource across pages.  Servers <em>SHOULD</em> ensure uniqueness, but some paging mechanisms could potentially result in the same resource popping up more than once due to changes in the resource set.  (Those same servers would also risk missing resources entirely.)</p>",
        "id": 251642614,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1630537784
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> Thanks for the pointer to the Bundle. </p>\n<p>In my implementation, I have no problem to provide a stable set (snapshot) of the database even through very long paginations. However currently, with OR-searches, it is possible that a resource appears multiple times over pages, if it is a match regarding more than one OR-case. So I somehow have to make the returned resources unique. And I like to do this under O(n) where n is the number of results. Currently I have O(k) where k is the number of results in one page.</p>",
        "id": 251677427,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1630568490
    },
    {
        "content": "<p>I think the goal is that the final merged bundle (all pages combined into a single bundle) would have a distinct set of resources. (no duplicates)<br>\nUnfortunately due to the fact that we live in an ever changing world this will remain a goal.<br>\nIf the server isn't doing snapshots, it's entirely possible that the last row of page n, becomes the 1st row of page n+1 between the time between when pages n and n+1 are requested.<br>\nThat also means that the new resource that pushed that resource to the next page, won't be seen at all by the requester.<br>\nI'd say that this is ok, as the situation is unlikely to occur during treatment, instead only during research where the study has 999,999 items instead of 1,000,000.</p>\n<p>Any consumer will have to take into account that they might get the same row twice, when spanning pages and update their store appropriately.<br>\nIf the server is doing snapshots, then the chances are you won't get duplicates, but you'll still miss that new data.</p>\n<p><span class=\"user-mention\" data-user-id=\"197470\">@Alexander Kiel</span> If I do an OR query against you where if A=A or B=B and there is a row that satisfies both conditions you'll return the row twice? Seems like your snapshot would reduce that down to a single row.</p>",
        "id": 251706707,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1630585772
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"335936\">@Daniel Venton</span> Yes, if I have an OR and a resource satisfies both criteria, it will be returned twice, because I'll find it as match of both criteria. That is the case because I don't simply scan through all resources and evaluate the OR, instead I use an index for each criteria and iterate that index. I have to do an incremental distinct join somehow.  So it has nothing todo with my snapshots, just with the implementation of evaluating an OR.</p>",
        "id": 251707775,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1630586316
    },
    {
        "content": "<p>The total work required can't be less than O(number of results), right? At the end of the day you're serializing all of these resources and sending them out over the wire. Are you concerned about how O(n) work is amortized across paginated requests, or mainly about the constant factor associated with the O(n) work?</p>",
        "id": 251722962,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1630592464
    },
    {
        "content": "<p>There are different ways to handle paging.  Ideally, when you start a query, a snapshot is taken of the entire result set and subsequent paging happens against that snapshot.   \"includes\" will absolutely be duplicated across pages - they must be because there's no presumption that a simple client accessing a new page has any access to information received on previous pages.  Also, there's no guarantee that pages will be accessed in order.  Some one might jump from first page to last page and then navigate backward - and then maybe jump back to the beginning and page forward.</p>",
        "id": 251739012,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1630598432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191315\">Josh Mandel</span> <a href=\"#narrow/stream/179166-implementers/topic/Should.20FHIR.20Search.20return.20a.20distinct.20set.20of.20resources.3F/near/251722962\">said</a>:</p>\n<blockquote>\n<p>Are you concerned about how O(n) work is amortized across paginated requests, [...]</p>\n</blockquote>\n<p>Yes, I like to be able to return the first page without O(n) work and I like to keep the cost of returning a page constant. Most implementations will either need O(n) work for the first page and store the result somehow or use an offset into a stream of resources that will make the first page cheap but the last page costing O(n) because you have to skip through all not needed pages. </p>\n<p>My implementation uses a stream of resources that comes from an index of the first search param. For the first page, I take _count + 1 resources from that stream. In addition to the search value, I can also use a resource ID to seek into that index. So for the next link, in addition to the original search params, I store the resource ID of the first resource of that next page. If I have to deliver that next page, I can seek into the index as described. So every page has equal cost. </p>\n<p>For OR searches, I have multiple streams that I concat together. The problem with this approach is, that I have to somehow concat the streams so that I get one big stream of distinct resources.</p>",
        "id": 251740047,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1630598792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179166-implementers/topic/Should.20FHIR.20Search.20return.20a.20distinct.20set.20of.20resources.3F/near/251739012\">said</a>:</p>\n<blockquote>\n<p>There are different ways to handle paging.  Ideally, when you start a query, a snapshot is taken of the entire result set and subsequent paging happens against that snapshot.   </p>\n</blockquote>\n<p>As my database engine provides snapshots after every transaction(write) automatically to the upper application layer, I don't need to materialize query results. I can just obtain a stable snapshot of the database using a simple integer identifier, the transaction number. Also the snapshots are queryable. So I can run every query on every snapshot, subject to garbage collection after some time.</p>\n<blockquote>\n<p>\"includes\" will absolutely be duplicated across pages - they must be because there's no presumption that a simple client accessing a new page has any access to information received on previous pages. </p>\n</blockquote>\n<p>That is clear.</p>\n<blockquote>\n<p>Also, there's no guarantee that pages will be accessed in order.  Some one might jump from first page to last page and then navigate backward - and then maybe jump back to the beginning and page forward.</p>\n</blockquote>\n<p>Because I don't use simple integer offsets, and links should be opaque anyway, client cant jump until they have obtained all links. I also provide only next links, no prev and no last link. For my use cases that next link is sufficient. But that may change in the future.</p>",
        "id": 251741352,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1630599255
    },
    {
        "content": "<p>Thanks for the details here -- this is super clear and helpful. I don't think you can do &lt;O(n) work to generate the first page and have <em>constant</em> work per page, but you can at least defer the set difference calculations until they're actually required. Like, if you have multiple streams of resources (A, B, C) resulting from \"OR\" queries, so each stream is a proper set, but the streams may overlap with each other, you can create a table <code>R</code> of returned results that starts off empty, and gets resources added to it only when you actually return a page of results. (<code>R</code> here is like a snapshot in that it accumulates state and grows with the size of your result set :( ... but  it grows incrementally so work is deferred :))</p>\n<ul>\n<li>Draw from <code>A</code> until A is consumed, accumulating into <code>R</code> and skipping items already in <code>R</code> (n.b. won't actually skip any items yet, since items in <code>A</code> are unique)</li>\n<li>Draw from <code>B</code> until B is consumed,  accumulating into <code>R</code> and  skipping items already in <code>R</code> (n.b. this takes &gt; <em>constant</em> work because you can't be sure how much \"skipping\" you'll need to do, but it's work proportional to your returned page size at least)</li>\n<li>Draw from <code>C</code> as for <code>B</code></li>\n</ul>\n<p>I don't see how to do better than this, while still giving clients a clean set of results. Of course, now you have snapshot management challenges (state management! what if they're big? how long do you keep them alive / when to evict and \"kill\" an open search?)</p>",
        "id": 251744532,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1630600499
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> Thats exactly my current solution. The state management part of it is the biggest challenge, especially as I have to sync that state between different nodes in my cluster.</p>",
        "id": 251861446,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1630666666
    }
]