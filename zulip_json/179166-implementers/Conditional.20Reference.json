[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191450\">@Simone Heckmann</span> Looking at the proposed connectathon track for conditional references.  This is a HUGE need - thank you for taking it on!</p>",
        "id": 153820103,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1459990939
    },
    {
        "content": "<p>I have a question about scenario step 3 - what if the client knows that the referenced item will arrive out of order?  There are times, esp. in emergent scenarios, where registration data may lag the order feed for instance.  We would like to be able to save the order, retaining the conditional linkage until the referenced data arrives.</p>",
        "id": 153820104,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1459991063
    },
    {
        "content": "<p>However, this:  a) causes the server to have to re-check for the conditional linkage later, and b) introduces the possibility of undetectable (to the client) mis-matches.</p>",
        "id": 153820105,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1459991134
    },
    {
        "content": "<p>Right now, we're using contained resources to handle this scenario - we create a contained resource with only what we know about the referenced resource.  The server then (preferably on write, but possibly on read for late arriving) resolves the match.  If the match can't be resolved, the contained resource remains and the reference remains internal.</p>",
        "id": 153820106,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1459991257
    },
    {
        "content": "<p>Does anyone see pros/cons to either approach?  (as described vs. <a href=\"http://wiki.hl7.org/index.php?title=201605_Conditional_Reference_Connectathon_Proposal\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=201605_Conditional_Reference_Connectathon_Proposal\">http://wiki.hl7.org/index.php?title=201605_Conditional_Reference_Connectathon_Proposal</a>)</p>",
        "id": 153820107,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1459991290
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> ??</p>",
        "id": 153820108,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1459991324
    },
    {
        "content": "<p>Talking to myself a bit...contained allows the server more latitude to create a meaningful resource (conditional create) if that fits the server's use case better (contained could contain some arbitrarily large amount of data about the referenced resource).  However, there would need to be some directive by the client that the intent is to match/convert the contained resource. </p>",
        "id": 153820109,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1459991898
    },
    {
        "content": "<p>Conditional reference is more explicit and could still serve the late-arriving use case if the conditional reference was allowed to remain in the resource after POST/PUT.</p>",
        "id": 153820110,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1459991961
    },
    {
        "content": "<p>Technically if the inbound instance has a contained resource, the server would have to do an \"update\" such that the original version (with any signature) was retained.  I'm not a fan of storing a conditional reference.</p>",
        "id": 153820112,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1460001399
    },
    {
        "content": "<p>What you could do is to pack both the referencing and the referenced resource into a transaction, using temp uuids to point from the referencing to the referenced resource. </p>",
        "id": 153820156,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460020670
    },
    {
        "content": "<p>The server sill then replace the temporal ID with the actual ID ans update the reference</p>",
        "id": 153820157,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460020693
    },
    {
        "content": "<p>If - at th point of submission - you have no information about the referenced resource, you can submit whatever you have (at least the business identifier) as a conditional create.</p>",
        "id": 153820158,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460020786
    },
    {
        "content": "<p>That way, the server sill create your resource, if it doesn't exist or pick an already existing resource with the same identifier and reference to that resource instead without updating it. (Provided, your condition is the matching of the business identifier)</p>",
        "id": 153820159,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460020892
    },
    {
        "content": "<p>Once the actual data arrives, you can update the resource by using a conditional update. (Once again by matching the identifier)</p>",
        "id": 153820160,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460020965
    },
    {
        "content": "<p>This way you can have a unidirectional data stream to the server without ever having to query for IDs (which is pretty much what sending V2 streams to a fhir server is all about)</p>",
        "id": 153820162,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460021040
    },
    {
        "content": "<p>I think the conditional reference is only a good choice if you can savely assume that the referenced resource already exists on the target server.</p>",
        "id": 153820163,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460021090
    },
    {
        "content": "<p>e.g. every Hospital in a region/country is commonly known by a unique national identifier. In this scenario I could simply always reference to a Organisation with that identifier, without having to look up the different IDs of the different servers you're talking to. In such scenarios, you'd explicitly WANT your submission to fail, because a no match by identifier means that the referenced hospital is not participating in your network.</p>",
        "id": 153820165,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460021669
    },
    {
        "content": "<p>or: you have some sort of automated workflow where a barcode  sticker (case number) is read from a sample, a test is performed and the result is transmitted back to the HIS. In that scenario you have a strong reason to belive that the case number is known to the HIS because it printed the barcode sticker in the first place.</p>",
        "id": 153820167,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460021914
    },
    {
        "content": "<p>I like the idea. I currently use contained resources to just pass around the ESB/Hospital indentifiers and so in most cases they just contain identifier.system and identifier.value. I don't use the contained resources to create resources (within the hospital/ESB). It's a bit tedious to build and process. If a shorthand reference was available I would just use that.</p>",
        "id": 153820175,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1460023612
    },
    {
        "content": "<p>+1 to Simone's recommendation</p>",
        "id": 153820184,
        "sender_full_name": "James Agnew",
        "timestamp": 1460030951
    },
    {
        "content": "<p>FYI: James has that already implemented conditional references in HAPI. </p>",
        "id": 153820187,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460034916
    },
    {
        "content": "<p>The Transaction/Conditional Update/Conditional Create- Workflow I described above has been successfully tested at the Connectathon in Atlanta.</p>",
        "id": 153820188,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460034976
    },
    {
        "content": "<p>Not sure about the other servers, though.</p>",
        "id": 153820189,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460035003
    },
    {
        "content": "<p>I actually like the conditional reference - it's simple.  But take a moment to read the description of contained resources (and references to them): <a href=\"https://www.hl7.org/fhir/references.html#contained\" target=\"_blank\" title=\"https://www.hl7.org/fhir/references.html#contained\">https://www.hl7.org/fhir/references.html#contained</a>  They exist for a flavor of this scenario - a client knows only a little about the referenced resource, so it creates a contained.  The intent (usually) is *not* that the contained remain forever, but rather that the correct match and reference be made.  Contained is a concession to the reality of imperfect information.</p>",
        "id": 153820190,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460038155
    },
    {
        "content": "<p>The description of contained would lead me to believe that we should be defining some directives on what a server should do with these things - not defining matching logic necessarily, but at least a way for the client to say \"please try and match this partial data to something you know about\".</p>",
        "id": 153820192,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460038344
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191450\">@Simone Heckmann</span> A conditional create would be fine IF the server's profile/logic allows. It's certainly plausible though that a Patient record with only an identifier would be considered inadequate to create a resource (as the contained explanation relays).</p>",
        "id": 153820193,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460038542
    },
    {
        "content": "<p>It may be a situation where both (all 3?) approaches are appropriate as long as there is a clear explanation of the utility and appropriateness of each.</p>",
        "id": 153820221,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460039398
    },
    {
        "content": "<p>Contained resources generally would not mean that the server can turn them into non-contained references.  Doing so would certainly break signatures, so it would need to be treated as an update that still retained the existence of the original version if signatures were at all important.</p>",
        "id": 153820328,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1460052686
    },
    {
        "content": "<p>Lloyd - agree that the conversion would be an update, but it seems to me that this should be able to be requested by the client, especially in the messaging world.  I can't think of a scenario that would prefer a partial contained to a real reference. The contained could even be retained for posterity, but the local references should be updated if desired.</p>",
        "id": 153820331,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460053871
    },
    {
        "content": "<p>Also, the signature of a resource with a conditional reference converted to a \"real\" reference would also be altered.</p>",
        "id": 153820332,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460053897
    },
    {
        "content": "<p>I don't think you can assume a server will ever do post-processing.  So a conditional create followed by a subsequent conditional create or conditional update is what would best give the client control over what's going on.</p>",
        "id": 153820395,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1460063064
    },
    {
        "content": "<p>Isn't resolving a conditional reference \"post-processsing\" - a subsequent GET will not return what was just PUT.</p>",
        "id": 153820396,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460063139
    },
    {
        "content": "<p>Resolving a conditional reference is post processing that's done at the time of the create/update.  If it fails, the create/update fails.  I'm talking about deferred post-processing (as would be required for a system to update a resource with a \"contained\" resource to instead point to a non-contained resource.</p>",
        "id": 153820398,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1460063263
    },
    {
        "content": "<p>The contained could be resolved at write time or (if matching fails) retained as-is as a matter of standard operation.  Matching/resolution after that point would be a server-specific choice.</p>",
        "id": 153820402,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460063545
    },
    {
        "content": "<p>I'm not thrilled with it being retained as-is, nor with any implicit assumption that servers \"should\" be responsible for making such updates.  If we're doing REST, I think it's cleaner for things to be client-driven</p>",
        "id": 153820411,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1460065627
    },
    {
        "content": "<p>Isn't that the current operation of contained resources?  I don't know enough to create a resource, so I'll put in whatever I have.  If that's not enough to match, it would be natural to leave it alone, no?</p>",
        "id": 153820412,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460065715
    },
    {
        "content": "<p>Any \"post-processing\" would be up to the implementer.  You're right that a ReST client shouldn't assume.</p>",
        "id": 153820414,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460065823
    },
    {
        "content": "<p>Including assuming that other actors (e.g. a post-processor) won't act on a resource after their operation is complete.</p>",
        "id": 153820415,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460065859
    },
    {
        "content": "<p>When you create a contained resource, you expect it to remain contained until/unless a client updates it.  Which means the client has to remember to update it (which is unlikely).</p>",
        "id": 153820419,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1460066401
    },
    {
        "content": "<p>I disagree.  There's nothing that would prevent the server from implementing (according to its own needs) a process for this, effectively acting as an internal \"re-indexing\" client.  I agree that the standard shouldn't mandate this - it should define only what happens during the client interaction.</p>",
        "id": 153820421,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460066546
    },
    {
        "content": "<p>A client should not assume that it's the only client.</p>",
        "id": 153820423,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460066562
    },
    {
        "content": "<p>@Kevin: We have the same situation in the financtial domain where the identifier for a think is known but the id of a content model (resource) is not - so were also createing contained resources sometimes only to contain the identifier. We have recently change those elements for which this is the case from resouce(x) to Identifier|resource(x) - see CLaim and the examples SOA Dental Claim, which uses contained resources, and SOA Dental Claim with identifiers which doesn't. </p>",
        "id": 153820458,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1460116026
    },
    {
        "content": "<p>Do you have a url for those examples? I'm wondering if contained resources has too much coupling  for the client. National identifiers (UK NHS Number or even EU EHIC Card number) is enough information to reference a patient resource and exchange information. Thinking of an Observation app which for example conforms to a pan EU Observation profile, it's unlikely to support all the Patient profiles in the EU - identifiers yes. It should be the servers job to get the Patient (with the correct profile) if it needs to, in many cases the server will own the master Patient resource.</p>",
        "id": 153820460,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1460117933
    },
    {
        "content": "<p>Looking at the proposal I've seen references such as &lt;reference value=\"Patient?identifier=9876512345\"/&gt; would references such as &lt;reference value=\"Patient?identifier=urn:fhir.nhs.uk:id/NHSNumber|9876512345\"/&gt; work? i.e. also include the system</p>",
        "id": 153820541,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1460187765
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> I notice this is already supported in HAPI, is that 1.4? I have some code which shows the number of lookups we're doing when posting a DocumentReference - it would really speed up the processing if it does (6 calls downto 2). Apache Camel route is here <a href=\"https://github.com/KevinMayfield/Jorvik/blob/master/UKFHIR-HAPI/src/main/java/uk/co/mayfieldis/camelRoute/UKFhirAPI/UKFHIRCamelRoute.java\" target=\"_blank\" title=\"https://github.com/KevinMayfield/Jorvik/blob/master/UKFHIR-HAPI/src/main/java/uk/co/mayfieldis/camelRoute/UKFhirAPI/UKFHIRCamelRoute.java\">https://github.com/KevinMayfield/Jorvik/blob/master/UKFHIR-HAPI/src/main/java/uk/co/mayfieldis/camelRoute/UKFhirAPI/UKFHIRCamelRoute.java</a></p>",
        "id": 153820542,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1460188192
    },
    {
        "content": "<p>As much as I dislike \"contained\" resources, one nice thing about that approach is that it avoids the potential to create invalid references on the server -- e.g. if a client sends data with a \"conditional reference\" and the server doesn't know how to process this, and so the client's submission just lands directly in the server's database. You'd wind up seeing data with references like:</p>\n<div class=\"codehilite\"><pre>&lt;reference value=&quot;Patient?identifier=123&quot;/&gt;\n</pre></div>\n\n\n<p>Since a reference is just a string, this is pretty likely in some server designs. And following the reference would resolve a bundle instead of a resource, which would be surprising/unpleasant for clients.</p>",
        "id": 153820583,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1460307276
    },
    {
        "content": "<p>@Kevin: In FM resources to support situations such as national patient identifiers, national practitioner identifiers etc we put in the choice of a resource reference or an identifier so you could have patient system = \"<a href=\"http://nationalsystem.com/patientidetifier\" target=\"_blank\" title=\"http://nationalsystem.com/patientidetifier\">http://nationalsystem.com/patientidetifier</a>\" value = \"AB123456\". We are starting to hear pushback that we should instead create a separate resource, included the reference to that and either make you come read that resource too or we can include the original resource and all of the other created resource instances in a larger structure (bundle, message, document, etc). Not very efficient, nor usefull especially when you aren't giveing the end party a patient to add or update on their system, we are just tryin to say 'it's patient/provider/whatever number 12345'. Doable but is the pain worth the gain?</p>\n<p>The NHS or EHIC card number is an identifier not a <a href=\"http://resource.id\" target=\"_blank\" title=\"http://resource.id\">resource.id</a> and FM has been trying to discourage confusing them and avoiding unnecessary overhead. All the providers who service that patient would give you completely different resource.ids to locally created resources which contain the same identifier. It seemed to us to be more efficient as you indicated to just give the identifier as that is what you need to know.</p>\n<p>We were trying to be explicit by allowing one to declare and provide the identifier. If that's not allowed the above seems more obscure but still closer to the same efficientcy, my example could be: &lt;reference value=Patient?identifier?=http://nationalsystem.com/patientidentifier|AB123456\"/&gt;.</p>",
        "id": 153820586,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1460313636
    },
    {
        "content": "<p>The intention with the reference approach would be that the submission would fail unless the reference could be resolved to an existing resource though.</p>",
        "id": 153820589,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1460320300
    },
    {
        "content": "<p>catching up on this thread: contained resources were created for the case where you don't have enough information to identify the resource. Which is the exact opposite of when you have an identifier that can be resolved. So contained resources are a different problem to the one being discussed here</p>",
        "id": 153820610,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460349854
    },
    {
        "content": "<p>Ok then the pattern which has emerged is that if you can uniquely identify the thing you should create a resource and reference that not create a contained resource. <br>\nSo that would eliminate having bodySite as a choice of the code and the resource as the code would uniquely identify the resource.</p>",
        "id": 153820816,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1460396608
    },
    {
        "content": "<p>where do we have bodysite as a choice of code and resource?</p>",
        "id": 153820827,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460398491
    },
    {
        "content": "<p>We do in claim but I got that from somewhere else, we just need the code, - I'll look.</p>",
        "id": 153820828,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1460398665
    },
    {
        "content": "<p>Observation uses bodySite[x] codeableConcept|Reference(BodySite)</p>",
        "id": 153820829,
        "sender_full_name": "Andy Stechishin",
        "timestamp": 1460398727
    },
    {
        "content": "<p>not in DSTU 2 or the current version</p>",
        "id": 153820830,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460399179
    },
    {
        "content": "<p>DeviceuseRequest, DeviceUseStatement, MedicationAdministration for a start  and MedicationAdministration uses the same pattern to Medication in current build.</p>",
        "id": 153820831,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1460399968
    },
    {
        "content": "<p>ok tahnks</p>",
        "id": 153820832,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460400229
    },
    {
        "content": "<p>I think those have open trackers to change or should have them</p>",
        "id": 153820851,
        "sender_full_name": "Eric Haas",
        "timestamp": 1460403780
    },
    {
        "content": "<p>And Careplan and Procedure and SupplyRequest use the same pattern too.</p>",
        "id": 153820852,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1460403962
    },
    {
        "content": "<p>And Specimen and maybe ModuleDefinition.</p>",
        "id": 153820854,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1460404616
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191430\">@Paul Knapp</span>  not in dstu2 and current build all PC and OO resource only have codeableconcept for Bodysite</p>",
        "id": 153820880,
        "sender_full_name": "Eric Haas",
        "timestamp": 1460408387
    },
    {
        "content": "<p>For BodySite, it was decided that the reference to the resource was extension space.  However, for referencing Medication, both codes and ability to point to a full-blown resource (for things like compounds) are both in the 80%.  Whether the code is sufficient to be \"identifiable\" varies - sometimes yes, sometimes no.</p>",
        "id": 153820962,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1460431497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-email=\"eric@w3.org\">@Eric Prud'hommeaux</span>: Specimen appears to use the pattern in question just not for BodySite.</p>\n<p><span class=\"user-mention\" data-user-email=\"lloyd@lmckenzie.com\">@Lloyd McKenzie</span>: Was anyone told it was extension space? By that do you mean that resources which use the code need to use an extension rather than a choice to use a reference? What medictions can you specifiy by code which you could not put in a Medication resource?</p>",
        "id": 153820993,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1460440109
    },
    {
        "content": "<p>It's not that you can't specify them in a medication resource, it's just that many applications simply use a code, and the committee came to the conclusion that it was appropriate to allow either a code or a reference to a medication resource - and for many medication terminologies, we'll be defining formal equivalence between their codes and an equivalent medication resource.</p>",
        "id": 153820995,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460441024
    },
    {
        "content": "<p>I don't know what you mean by 'told it was extension space' - the committees are presently making the determination of what is common or not</p>",
        "id": 153820996,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460441061
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194909\">@Kevin Mayfield</span> Re Conditional reference in HAPI, it's only supported as of 1.5 and FYI it needs to be explicitly enabled in the JpaConfig since it's only an experiment for now. You can try it out with the current snapshots, and we'll be launching 1.5 this week most likely.</p>",
        "id": 153821239,
        "sender_full_name": "James Agnew",
        "timestamp": 1460470491
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> WIll take a look</p>",
        "id": 153821250,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1460474009
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191430\">@Paul Knapp</span> The extension is defined in the extensions associated with the BodySite resource.  Not sure what you mean about \"telling\".  If implementers find they need something that isn't in core, the first thing they should do is look to see if there's a standard extension.  Some of the medications are \"abstract\" - e.g. \"Aspirin\" or might even just have a name (CodeableConcept.text) without a code at all.  In those cases, a stand-alone Medication couldn't be used, though a contained resource could be.  But it was decided that forcing a contained Medication when the use-case of having a bare code was super common (probably 70%+ of instances) was inappropriate.  In the case of Patient, the considerations are a bit different.  We don't have Compartments for Medication.  And querying for orders or other resources by Medication or joining resources in queries by Medication is quite uncommon, while querying and joining by Patient happens all the time.  So the considerations are different.  That doesn't mean we can't allow the pattern, but if the pattern gets used, it should be used everywhere and we need to think carefully about the additional ramifications.</p>",
        "id": 153821260,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1460475159
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> my concern with \"conditional references\" in POSTed resources is that suddenly it's not okay for a server to just persist a reference; it needs to <em>detect</em> when a reference may be conditional, and then behave appropriately. But previously we've said that a reference can be an arbitrary URL. We'd need to document expectations carefully.</p>",
        "id": 153821309,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1460492224
    },
    {
        "content": "<p>well, many servers already enforce that the references are valid. or index according to them (you pretty much have to do that). so merely making a server inspect references is not that radical. Agree that we'd have to be very clear about this though</p>",
        "id": 153821312,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460492581
    },
    {
        "content": "<p>There's also the (still somewhat undecided) idea out there to only support conditional references in Transactions. In that case, the pure REST server could still behave as Josh described. In the Transation, the server has to inspect references anyway, since we already defined the expectation that the server must replace uuids. So nothing new here.</p>",
        "id": 153821419,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1460535997
    }
]