[
    {
        "content": "<p>A small group of us spent some time last night looking at some design patterns in the resources. Our analysis of one of the patterns that we didn't like  lead to a proposal for a new data type: <br>\n<a href=\"https://wiki.hl7.org/Proposal_for_ConceptReference\" target=\"_blank\" title=\"https://wiki.hl7.org/Proposal_for_ConceptReference\">https://wiki.hl7.org/Proposal_for_ConceptReference</a></p>\n<p>Using this type, this:</p>\n<div class=\"codehilite\"><pre><span></span>MedicationRequest\n   - medication[x] : CodeableConcept | Reference(Medication) [1..1] // Medication to be taken\n   - reasonCode : CodeableConcept [0..*] //  Reason or indication for ordering or not ordering the medication\n   - reasonReference : Reference(Condition | Observation) [0..*] // Condition or observation that supports why the prescription is being written\n</pre></div>\n\n\n<p>would become this:</p>\n<div class=\"codehilite\"><pre><span></span>MedicationRequest\n   - medication : ConceptReference(Medication) [1..1] // Medication (code or details) to be taken\n   - reason : ConceptReference(Condition | Observation) [0..*] //  Condition or observation (instance or concept) for ordering or not ordering the medication\n</pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> <span class=\"user-mention\" data-user-id=\"191703\">@Claude Nanjo</span></p>",
        "id": 175602190,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568361051
    },
    {
        "content": "<p>comments welcome</p>",
        "id": 175602222,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568361102
    },
    {
        "content": "<p>1. This seems a good step.<br>\n2. CodeableReference sounds better to me (not being a native English speaker nor from the germanic languages side, I don't really have a say in the order of the words) - but to me this seems not a reference to an existing concept , rather a specification of something which may or not exist as a reference.</p>",
        "id": 175611535,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1568371193
    },
    {
        "content": "<p>Use Case :<br>\nPatient goes to GP and says \"I am taking  a drug called Sucralfate\". Sucralfate is not sold in the GP's country<br>\nPhysician creates a medication usage in their GUI. <br>\n1. What they do is to type \"Sucralfate\". That is the information they start with - the text.<br>\n2. Presumably that concept exists in a terminology (the list of drugs that are known) - then the system sees it as a code and populates the resource (and updates the GUI) accordingly.<br>\n 3. That drug may or not exist in the system as a Medication resource, but the information that the physician wanted to enter is already there.</p>",
        "id": 175611590,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1568371259
    },
    {
        "content": "<p>from what I understand the options, it seems that option 3 is the one that best matches the intent here - not forcing inheritance from either datatype.</p>",
        "id": 175611705,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1568371370
    },
    {
        "content": "<p>+1 for CodeableReference.  ConceptReference sounds like you're pointing to a concept.  CodeableReference sounds like a regular reference that you can sometimes use a code for.  The latter is what we're actually doing.</p>",
        "id": 175613218,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1568372938
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191403\">@Michelle (Moseman) Miller</span> <span class=\"user-mention\" data-user-id=\"191759\">@Melva Peters</span> <span class=\"user-mention\" data-user-id=\"191430\">@Paul Knapp</span> This would likely impact your models - thoughts?</p>",
        "id": 175613244,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1568372983
    },
    {
        "content": "<p>+1 for CodeableReference. I really like the idea of this data type.</p>",
        "id": 175619912,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1568378937
    },
    {
        "content": "<p>Also <span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span></p>",
        "id": 175621459,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1568380067
    },
    {
        "content": "<p>I think this change is an incremental improvement and I could certainly get behind it. (I will note that it is also one step in the direction of just making choice types look the way <span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> prefers. i.e., we could solve this more generally, rather than doing something special for the particular choice type of \"reference or a codeable concept,\" to solve the cardinality problem. I suspect you've already considered and rejected this, and if so, it might be good to include that in the write-up).</p>",
        "id": 175624173,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568381953
    },
    {
        "content": "<p>FWIW, I prefer the first proposal from Grahame's link (not the alternates) with the name CodeableReference.</p>",
        "id": 175624301,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1568382039
    },
    {
        "content": "<blockquote>\n<p>I suspect you've already considered and rejected this</p>\n</blockquote>\n<p>It was too late about R1 for this, really. And it's normative now. And I haven't seen any ground swell for doing json like that anywhere else</p>",
        "id": 175624929,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568382464
    },
    {
        "content": "<p>From the outset, it isn’t clear that concepts and resource references are exchangable alternatives. A concept is an abstract idea or general notion, but a resource is a concrete instance of a single real-world entity. My (least) favorite example is body site (as a code) and BodyStructure (as a resource) which has Patient 1..1. It isn’t only the level of detail that is changing – it is a change from a concept to an instance.</p>",
        "id": 175625441,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1568382815
    },
    {
        "content": "<p>they are not generally exchangable, but we have many places where we have agreed that you can do one or the other</p>",
        "id": 175627376,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568383918
    },
    {
        "content": "<blockquote>\n<p>they are not generally exchangable, but we have many places where we have agreed that you can do one or the other</p>\n</blockquote>\n<p>But what is the disadvantage to just use the polymorphic data element as right now? If both CodeableConcept and Reference are different things, a polymorphic data element does express exactly that. You can either specify a CodeableConcept or a Reference.</p>",
        "id": 175628915,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1568384862
    },
    {
        "content": "<p>well, the way we get reasonCode / reasonReference</p>",
        "id": 175629036,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568384927
    },
    {
        "content": "<p>The biggest challenge is that it makes ordered lists where you have a choice problematic.  For example, ServiceRequest.location (which indicates the 'preferred' location for the service), if you want to point to a mix of specific clinics and general concepts like \"at home\", you need to be able to indicate whether \"at home\" is more or less preferred than \"Clinic A\" and \"Clinic B\"</p>",
        "id": 175637003,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1568389710
    },
    {
        "content": "<p>With imaginary <em>Concept</em> Resource - Coding becomes Reference :)</p>",
        "id": 175639440,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1568391389
    },
    {
        "content": "<p>yeah well, it's still imaginary</p>",
        "id": 175640137,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568391955
    },
    {
        "content": "<p>Is the idea that there would be invariants on these, i.e. you can not have <code>reference</code> if you have the codings/concept?</p>",
        "id": 175649839,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1568398065
    },
    {
        "content": "<p>Personally, from modeling perspective, I like the verbose </p>\n<p>elementCode</p>\n<p>element Reference</p>\n<p>This proposal hides the fact thats is really a  choice of datatypes.  how do you profile only codes or only refs..</p>\n<p>Also from a process perspective: How is a new pattern going to be imposed on the resources if the decisions to change existing resource ultimately lay with the WG.  we may wind up with three ways to do the same thing.</p>",
        "id": 175650025,
        "sender_full_name": "Eric Haas",
        "timestamp": 1568398195
    },
    {
        "content": "<p>Main thing it solves is ordered lists where you need both types</p>",
        "id": 175650612,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1568398597
    },
    {
        "content": "<p>We haven't talked about invariants, but my leaning is that there should be one</p>",
        "id": 175650643,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1568398622
    },
    {
        "content": "<p>Honestly, I don't have a strong opinion -- I think either way works in the sense that the proposal doesn't remove any capabilities, but it does cause work for implementers when uplifting to the next version due to it being a non-compatible change without much ROI (when you don't need the ordered lists).</p>",
        "id": 175652070,
        "sender_full_name": "Michelle (Moseman) Miller",
        "timestamp": 1568399512
    },
    {
        "content": "<p>don't have to use it where there isn't a list... but can. I updated the proposal to say that it's a binary choice.</p>",
        "id": 175694529,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568457246
    },
    {
        "content": "<p>I would always favor composability of simple building blocks over the creation of special case constructs. What is the disadvantage of using a cardinality-many BackboneElement with a single polymorphic element inside it?</p>",
        "id": 175703728,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1568471460
    },
    {
        "content": "<blockquote>\n<p>What is the disadvantage of using a cardinality-many BackboneElement with a single polymorphic element inside it?</p>\n</blockquote>\n<p>well, actually, from my point of view, that would be a special case construct</p>",
        "id": 175703850,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568471631
    },
    {
        "content": "<p>Two advantages<br>\n- it makes clear that you're actually talking about one thing (a reason, a performer, etc.) and that you can have different types rather than two things that happen to be coincidentally start with the same name<br>\n- it allows you to have an ordered collection of those things without requiring a repeating 'grouper' element</p>\n<p>That said, it would only solve this special case.  There may be other (though perhaps not as common) situations where there's a repeating element that needs multiple types</p>",
        "id": 175705865,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1568474279
    },
    {
        "content": "<p>instantiates[x]</p>",
        "id": 175705915,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568474318
    },
    {
        "content": "<p>Yup, that's another one.  And this wouldn't solve that one.</p>",
        "id": 175705927,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1568474359
    },
    {
        "content": "<p>I like the idea! I have often felt, that the concept of <strong>logical references</strong> should extend to using codings instead of identifiers.<br>\nHowever, using Coding instead of Identifiers as a logical reference would correspond with the last alternative that is mentioned on the proposal... having a new datatype that exists <em>next</em> to Reference rather than <em>inheriting</em> from it...</p>",
        "id": 175840588,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1568659729
    },
    {
        "content": "<p>How does one profile only on or the other type os it an invariant?</p>",
        "id": 175860403,
        "sender_full_name": "Eric Haas",
        "timestamp": 1568674512
    },
    {
        "content": "<p>we can define profiles for either to be used when profiling</p>",
        "id": 175862096,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568676070
    },
    {
        "content": "<p>Do we make a list of candidates for using this new type? or it's <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> 's magic?</p>",
        "id": 176380704,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1569253389
    },
    {
        "content": "<p>no, it's up to the committee, I can't do this one as magic</p>",
        "id": 176391204,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1569260497
    },
    {
        "content": "<p>Discussed in ITS but not FM yet. Yes it would change the model but if ConceptReference(list of resources) includes both a CodeableConcept and a Reference(list of resources) then it works and simplifies the appearance of the base models.</p>",
        "id": 176617651,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1569456989
    },
    {
        "content": "<p>One bit of uneasiness I have with this is that ConceptReference sounds too much like it's a reference to a concept.</p>",
        "id": 176620567,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1569460880
    },
    {
        "content": "<p>+1 on <span class=\"user-mention\" data-user-id=\"191450\">@Simone Heckmann</span> comment</p>",
        "id": 176637420,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1569485686
    },
    {
        "content": "<p>CodeableReference is clearer</p>",
        "id": 176798958,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1569631314
    },
    {
        "content": "<p>What does this do to search?  If I want to find all the orders for a given medication identified by a code, for example?</p>",
        "id": 176827088,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1569678813
    },
    {
        "content": "<p>We'd retain the same search capabilities, though the path defining the search parameters would change a bit</p>",
        "id": 176830636,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1569685283
    },
    {
        "content": "<p>Two comments (already on the wiki page): naming option pros and cons, and a need to address overlap between CodeableConcept.text and Reference.display.</p>",
        "id": 178417697,
        "sender_full_name": "Jay Lyle",
        "timestamp": 1571343501
    }
]