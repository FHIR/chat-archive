[
    {
        "content": "<p>(deleted)</p>",
        "id": 201587355,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1592819936
    },
    {
        "content": "<p>Has anyone come across an issue where one User can part update a typical resource and another one the whole resource. <br>\nTake an example medicinalproduct .... authorisationReferenceNumber ... Only a particular user can make sure the product is authroised and hence update the ref number above. How does this get implemented and documented?</p>",
        "id": 201587603,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1592820097
    },
    {
        "content": "<p>That's purely a server side issue, authorisation/access control. Limitations on who's allowed to update are fairly common.</p>",
        "id": 201611855,
        "sender_full_name": "René Spronk",
        "timestamp": 1592835924
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191372\">@René Spronk</span>   Well thats not entirely true... To shed some lights into the details when I wanted to design the API endpoints for two different users each with different sort of user access then I have to define my resource in part definitions. Take the same example where medicinalproduct can partly gets updated by user1 and partly for user2... Then your API endpoints may look like PUT /medicinalproduct/{id}/authorisation  and/or /medicinalproduct/{id}/generaldetails where need to define two different schemas (both based on medicinalproduct) in which you can apply two user scope as you now have two endpoints. Thats one way of handling the above issue... Alternatively you can field check based on the issued scope which is very resource consuming</p>",
        "id": 201643136,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1592850512
    },
    {
        "content": "<p>You can define endpoints that are operations (e.g. /MedicinalProduct/{id}/$updateAuth), and then you can have whatever behaviour you like. But it won't be standard FHIR and only those who work directly with you will support it.</p>",
        "id": 201647868,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1592852931
    },
    {
        "content": "<p>You <em>can</em> expose different CapabilityStatements to systems authenticating with different user ids, so you could expose distinct profiles (and distinct sets of supported operations) based on what the user is allowed to do.  That would be conformant and interoperable with most FHIR solutions.  (Custom endpoints would not.)</p>",
        "id": 201651256,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1592854886
    },
    {
        "content": "<blockquote>\n<p>You can expose different CapabilityStatements to systems authenticating with different user ids</p>\n</blockquote>\n<p>Usually /metadata is unprotected - so not really....</p>",
        "id": 201653956,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1592856324
    },
    {
        "content": "<p>Im sure I am not the only person who come across this as a requirement... I agree with Michele that /metadata is not supported always and having different profile for one resource under the same organisation makes the deployment quiet difficult to manage. What it happens in practice is creating different schema for and different endpoints ex. Post /medicationlist and/or post medicationauth but we know FHIR doesnt like it ... But FHIR also doesnt support the hierarchical process as explained above.</p>",
        "id": 201659841,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1592859381
    },
    {
        "content": "<p>Having said that I do not understand what the issue is: the API calls are always the same and they can / cannot do stuff depending on the user that issue them</p>",
        "id": 201664978,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1592862342
    },
    {
        "content": "<p>It’s a requirement and the issue is the lack of feature/capability to support such requirement</p>",
        "id": 201667424,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1592863835
    },
    {
        "content": "<p>I don't understand the requirement then. User 1 and user 2 do the same FHIR PUT - if one of them tries to change elements they do not have permission for the request fails with a 403 - forbidden, and possibly same more explanation in the response body as an OperationOutcome</p>",
        "id": 201668596,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1592864657
    },
    {
        "content": "<p>No need for separate APIs or anything like that</p>",
        "id": 201668614,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1592864669
    },
    {
        "content": "<p>I thought servers had the ability to decide how they process a create or update API call. Wouldn't that apply here, with the decision based on the API caller? I don't know whether this indeed means that checking the input is resource consuming...</p>",
        "id": 201668799,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1592864813
    },
    {
        "content": "<p>Sorry for not defining this clearly. Both users need to update the resource but user1 can update all the fields on the resource and user2 only part of it</p>",
        "id": 201672956,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1592868164
    },
    {
        "content": "<p>Sure - but you can do that with different profiles.  Alternatively, you can simply yell if a user changes something they shouldn't or (better yet), ignore changes they're not allowed to make and give them a warning message.</p>",
        "id": 201683822,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1592881395
    },
    {
        "content": "<p>Exactly. No need for multiple endpoints or operations - the server just ignores those any data that a particular user isn't allowed to update. If you don't want that, use an operation, which works akin to a PATCH for a well defined subset of the data elements in a resource.</p>",
        "id": 201691663,
        "sender_full_name": "René Spronk",
        "timestamp": 1592894178
    },
    {
        "content": "<p>Thanks  <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  I will probably going ahead with the suggestions on creating operation. Having different profiles and have them mandated in /meta is not something which can be easily done in implementation... Also I define all of my concepts in Swagger and thats even make it harder to clarify on the documentations ...</p>",
        "id": 201700260,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1592901389
    },
    {
        "content": "<p>Different operations means you're not going to interoperate with any other systems that use FHIR, so I'd be really cautious about pursuing that approach.  In general, your objective should be to do things the same as other systems as much as possible - after all, the reason to use a standard is to exchange data with others as seamlessly as possible and minimize the need to write custom code to share with any particular system.</p>",
        "id": 201733485,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1592922684
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> just to clarify that I understood you correctly. If I’ve got to create two profiles for the resource appointment  for any reasons, then should it be under one url endpoint; post /appointment but With one of the two schemas in which the backend system decides which profile is used and then perform the relate actions ? Or I can define it differently which makes it recognisable For the consumer into the two endpoints like post /appointment/v1.0/authorise and post appointment/v1.3/general</p>",
        "id": 201765380,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1592937804
    },
    {
        "content": "<p>re your \"Or\": FHIR doesn't allow those endpoints on a single (logical) server, sorry. That is not the FHIR way.</p>\n<p>You cannot have paths other than /server/{resource} or with an id on the end and/or an $operation. <br>\nTo achieve what you suggest would need two servers (or one acting as two), which is possible but probably not what you want, and totally non-standard. FHIR clients won't expect to target two servers.</p>\n<p>The only way to add custom paths on one server is via operations.</p>\n<p>Your first suggestion (one URL) is better but you don't actually need profiles for the \"modes\". They would just act like a flag set by the client \"I am using profile X, please allow me to do mode X\". </p>\n<p>But that can be abused, and would need cross checking with the permissions, so it doesn't achieve much imho.</p>",
        "id": 201769901,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1592939788
    },
    {
        "content": "<p>The general expectation is that everyone writes to a single endpoint and the server decides what each system is allowed to do - it doesn't expose distinct APIs</p>",
        "id": 201771291,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1592940571
    },
    {
        "content": "<p>the driver here is a limitation of swagger. if you want to express schemas that relate to different permissions, you need different end-points on swagger, even though it's the same resource.</p>",
        "id": 201787475,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1592948546
    },
    {
        "content": "<p>I don't see an easy way to resolve this mis-match given where we are right now. But you can secure /metadata, even if, as <span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> says, this isn't usually done</p>",
        "id": 201787563,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1592948601
    },
    {
        "content": "<p>or you can put up microservices for authorised clients - I've seen several implementers doing this, to the point of putting up microservices for particular work contexts</p>",
        "id": 201787617,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1592948640
    },
    {
        "content": "<p>How do those microservices handle resource identity if resource instances are shared across endpoints?</p>",
        "id": 201788174,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1592948936
    },
    {
        "content": "<p>they don't, I think, from what I saw anyway. It causes cache pollution, but I think the system developers didn't know about that or care about it</p>",
        "id": 201788591,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1592949134
    },
    {
        "content": "<p>not their problem....</p>",
        "id": 201788599,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1592949138
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  Thanks for explaining the underlying issue there as thats exactly the reason I brought this up...</p>",
        "id": 201854000,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1593008805
    },
    {
        "content": "<p>I still not following how Microservices can help here... I have got microservices oriented architecture but the issue as you well defines is that you cant define one endpoints defined twice for two different purpose ( ex. general details updates / Authorisation). You can however add two schemas for the requestbodies and user oneoff type.. That would rectify the issue of how to define two version of a typical resource without mentioning the Profile tag under meta...</p>",
        "id": 201854661,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1593009070
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 201854685,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1593009080
    },
    {
        "content": "<p>The issue is then the back end system on how to handle the request ... The only think that I could think of is that to enforce the Oauth scope to add the user, user's role into it... in which the backend application based on the user role decides the used schema is allowed or not...</p>",
        "id": 201854924,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1593009171
    },
    {
        "content": "<p>Thats would help the issue but still doesnt help the API concumers when it reads the documents to quickly spot which schema must be used unless the openAPI spec comes with more descriptions ...</p>",
        "id": 201855051,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1593009231
    },
    {
        "content": "<p>Or proceed with how <span class=\"user-mention\" data-user-id=\"191651\">@Rik Smithies</span>  suggests there... which then it can rectify the readability of the doc set</p>",
        "id": 201855189,
        "sender_full_name": "Medi Harsini",
        "timestamp": 1593009276
    },
    {
        "content": "<p>Yes your different profiles are a way to document the different fields that are expected, so that can aid spec readability. And they can be used by the client to check they are doing things right and by the server to check its a correctly formatted request. They just can't be your security or modes in themselves.  Profiles profile usage of a single end point, they don't create or enforce multiple physical ones.</p>",
        "id": 201856330,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1593009780
    }
]