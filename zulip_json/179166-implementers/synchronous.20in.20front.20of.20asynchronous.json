[
    {
        "content": "<p>Suppose you have an architecture where the actual storage is asynchronous (e.g. via a queue) but you want to place a synchronous interface in front. The resource is validated by the synchronous end point and assigned an id before being placed on the queue for storage and returning success to the client. <br>\nThe obvious problem is that if the client re-reads the resource too quickly – before the async backend has saved the resource - then it won’t be present. <br>\nThis would certainly be confusing to the client, but is it an absolute prohibition? Ie that the server can only return success to the client after the resource has been persisted and is available for a subsequent read?</p>",
        "id": 153824114,
        "sender_full_name": "David Hay",
        "timestamp": 1462161147
    },
    {
        "content": "<p>I've been contemplating this one quite a bit and come to a happy medium for my server (not implemented yet though)</p>",
        "id": 153824115,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1462161278
    },
    {
        "content": "<p>I'm going to persist the resource, and id and then indexes will update later.</p>",
        "id": 153824117,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1462161407
    },
    {
        "content": "<p>Maybe 1 or 2 core indexes might update in real time, but most will be async.</p>",
        "id": 153824118,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1462161426
    },
    {
        "content": "<p>but, if a client were to retrieve the resource directly by the id, the resource would be returned - right?</p>",
        "id": 153824120,
        "sender_full_name": "David Hay",
        "timestamp": 1462162515
    },
    {
        "content": "<p>The same problem occurs in a threaded synchronous architecture too, where someone asks to read the resource before the response to an update has been processed</p>",
        "id": 153824134,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462171820
    },
    {
        "content": "<p>this is a classical problem in information systems; Martin Fowler has written books about it</p>",
        "id": 153824135,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462171844
    },
    {
        "content": "<p>Does RESTful FHIR  have a position on this? ie does returning 201 (created) mean that the resource is saved and ready for retrieval? The w3 spec states that a 201 response code means <strong>\"The request has been fulfilled and resulted in a new resource being created\"</strong>  and <strong>\"The origin server MUST create the resource before returning the 201 status code. If the action cannot be carried out immediately, the server SHOULD respond with 202 (Accepted) response instead.\"</strong> - suggesting that when the persistent storage is queue based, either the response should wait until confirmation that the resource has been saved (and therefore ready for query), or immediately return a 202 which we don't currently mention...</p>",
        "id": 153824136,
        "sender_full_name": "David Hay",
        "timestamp": 1462172796
    },
    {
        "content": "<p>we don't support 202, right. Complexity... but w3c don't make rules about parallel requests </p>",
        "id": 153824137,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462172848
    },
    {
        "content": "<p>No, but they do make rules about the behaviour of HTTP - is there a case for supporting 202? For that matter, does the fact that it is not explicitly mentioned in the spec mean that a queue based system shouldn't use 202 rather than 201? </p>",
        "id": 153824138,
        "sender_full_name": "David Hay",
        "timestamp": 1462173254
    },
    {
        "content": "<p>but that makes sense - how could you know in advance that you were guaranteed to accept something, without actually accepting it? </p>",
        "id": 153824139,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462175390
    },
    {
        "content": "<p>so a queue based system has to wait for the internal response before responding to the client, since we don't support 202</p>",
        "id": 153824140,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462175390
    },
    {
        "content": "<p>202 is only good for dumb content</p>",
        "id": 153824141,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462175394
    },
    {
        "content": "<p>Why do you say that? 202 only means the request has been accepted (in this case, successfully added to the queue)  It doesn't imply that it will be successfully processed</p>",
        "id": 153824871,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1462560798
    },
    {
        "content": "<p>what happens if it fails? how does the client find out, and why? </p>",
        "id": 153824874,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462567361
    },
    {
        "content": "<p>Generally the 202 response includes a link (Location header) to some kind of status resource (following HATEOAS)<br>\nThis is a handy summary of the approach <a href=\"http://farazdagi.com/blog/2014/rest-long-running-jobs/\" target=\"_blank\" title=\"http://farazdagi.com/blog/2014/rest-long-running-jobs/\">http://farazdagi.com/blog/2014/rest-long-running-jobs/</a></p>",
        "id": 153824882,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1462569016
    },
    {
        "content": "<p>as usual, HATEOS means badly thought out ad-hocness. </p>",
        "id": 153824883,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462569147
    },
    {
        "content": "<p>It's possible we could add this, but it's a fair bit of machinery to make it interoperable</p>",
        "id": 153824884,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462569180
    },
    {
        "content": "<p>Would you need more than a way to represent \"in-progress\" in an OperationOutcome?  Interop wouldn't need you to standardise the Location URL</p>",
        "id": 153824885,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1462569831
    },
    {
        "content": "<p>Why does any of this need to be standardized? This sounds like an implementation detail for a specific scenario... </p>",
        "id": 153824886,
        "sender_full_name": "James Agnew",
        "timestamp": 1462569918
    },
    {
        "content": "<p>success, failure, reason</p>",
        "id": 153824887,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462569947
    },
    {
        "content": "<p>well, depends on whether you want it to be interoperable or not</p>",
        "id": 153824888,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462569977
    },
    {
        "content": "<p>you certainly wouldn't expect any client to understand that a 202 + a location tells you the location a task, not the outcome. And you'd need to inject the location of the outcome into the task response somehow as well. So you could do this, but it would be non-conformant as things stand</p>",
        "id": 153824889,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462570058
    },
    {
        "content": "<p>I guess this is like those two phase accept ACKs you could do in HL7v2 (whose name I'm drawing a blank on right now). I always heard that there were people who actually used this, but I have never witnessed it.</p>\n<p>Do people actually expect an interoperable solution to this problem? Do other APIs of any kind have one? I just fret a bit that we're layering a lot of infrastructure on top of FHIR these days.</p>",
        "id": 153824890,
        "sender_full_name": "James Agnew",
        "timestamp": 1462570250
    },
    {
        "content": "<p>yes, you'd need to standardise this approach to a 202, but I don't see it as a lot:<br>\n202 + task Location which, when resolved, then gives you either:<br>\n  a) OperationOutcome indicating that its still in progress<br>\n  b) OperationOutcome indicating the failure (or success)<br>\n  c) redirect to the success Resource<br>\n d) 404 when the task has been garbage collected</p>",
        "id": 153824892,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1462570614
    },
    {
        "content": "<p>And how many of those with this need can't do messaging?  (Messaging is designed for asynchronous - REST really isn't.)</p>",
        "id": 153824898,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1462577382
    },
    {
        "content": "<p>My understanding of Messaging is that the server needs to send the response nack (to MessageHeader.source.endpoint], but in this use-case there is no endpoint to send responses to</p>",
        "id": 153824920,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1462599675
    },
    {
        "content": "<p>Message delivery can be done by putting things in a \"mailbox\" and having the client poll for new content.  We haven't defined an explicit mechanism for this with FHIR yet, but we had it with v3.  And it might be more appealing than adding complexity to REST.</p>",
        "id": 153824949,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1462620978
    }
]