[
    {
        "content": "<p>Hi there!<br>\nI have two questions about making a profile on the AuditEvent resource. The use case entitles that every action within applications that contain patient information needs to be logged. The two questions:</p>\n<p>1. There is a need to capture the ‘role’ of the participant, which contains in this case a concatenated value of an ID, position and organization. Is it possible to use the AuditEvent.participant.role element for this? If I look at, for example, the extensible valueset beloning to this element I get the idea that this element is meant for something else. The element, however, would cover our need. </p>\n<p>2. For the AuditEvent.object we want to capture the patient, the accessed information and some metadata properties of the information that is accessed (or example the lastmodified date). What would be the best way to model the metadata of the accessed information in our profile?</p>\n<p>Thanks in advance for any suggestions/ideas!</p>",
        "id": 153844290,
        "sender_full_name": "Ardon Toonstra",
        "timestamp": 1471525165
    },
    {
        "content": "<p>#1 - why a concatenation of these things? but position  would be the nearest in intent to role. </p>\n<p>#2 - I think the intent is that these things go in entity.detail. but that looks less appropriate than using extensions, really. name = value pair - you might as well use an extension</p>",
        "id": 153844329,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471546356
    },
    {
        "content": "<p>Ardon,</p>",
        "id": 153844349,
        "sender_full_name": "John Moehrke",
        "timestamp": 1471549898
    },
    {
        "content": "<p>#1 - yes, this can go in agent.role; it is extensible because we have an infinite set of roles. You can concatenate those values to show the relationship, or you could use the fact that your conconcatenation is a form of code.  with the organization is the sysem that issued the 'position' as the value. I don't understand why you would repeat the ID, unless you don't mean the user-ID, but some role-ID?</p>",
        "id": 153844350,
        "sender_full_name": "John Moehrke",
        "timestamp": 1471550092
    },
    {
        "content": "<p>#2 - you would record one AuditEvent.entity that just describes the patient. Likely just an AuditEvent.entity.reference pointing at the Patient resource. You would have another AuditEvent.entity for the data. If you point at the versioned data (AuditEvent.entity.reference pointing to version specific); then you don't need to duplicate the lastmodified (or any other metadata about the data). This would be my recommendation.</p>",
        "id": 153844351,
        "sender_full_name": "John Moehrke",
        "timestamp": 1471550274
    },
    {
        "content": "<p>Thanks for your input.<br>\n#1 is clear to me now, we will use agent.role.<br>\n#2 We have indeed one AuditEvent.entity for the patient with a reference to a Patient Recourse. Also another entity for the data, however we won’t be able to point to versioned resource of the accessed data. <br>\nWe would like to use entity.detail but this seems inappropriate with its base64Binary value element. Wouldn’t it be an improvement to have a value[x] in the entity.detail? </p>",
        "id": 153844428,
        "sender_full_name": "Ardon Toonstra",
        "timestamp": 1471600238
    },
    {
        "content": "<p>that's entity.detail should just be an Extension - that's just a name = value[x] pair</p>",
        "id": 153844433,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1471604144
    },
    {
        "content": "<p>Ardon, so you say you can't use version specific data resource references, so you want to duplicate that which would be in a version specific data resource in the audit? This seems like a bad design. If you need version specific data resources, then you should have them. Trying to use audit as an auxiliary database of metadata is very inefficient. You would need to duplicate this metadata thousands of times over, for every access/use/disclosure.   Do you use Provenance resources? Can you point at a version specific Provenance resource that points at the non-versioned data resource?</p>",
        "id": 153844520,
        "sender_full_name": "John Moehrke",
        "timestamp": 1471711221
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  I'm reviewing my implementation (again) of the population of the AuditEvent resources and noted that the object.type coding seems to have an odd set of values, I would have expected it to have included the resource types in that coded set (yes I could add them as it is extensible).<br>\n<a href=\"http://hl7.org/fhir/auditevent-definitions.html#AuditEvent.object.type\" target=\"_blank\" title=\"http://hl7.org/fhir/auditevent-definitions.html#AuditEvent.object.type\">http://hl7.org/fhir/auditevent-definitions.html#AuditEvent.object.type</a></p>",
        "id": 153866353,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1484099102
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> It is defined to pull in the resource types. Not sure why it isn't. I might need some <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> help.  <a href=\"http://build.fhir.org/valueset-object-type.html\" target=\"_blank\" title=\"http://build.fhir.org/valueset-object-type.html\">http://build.fhir.org/valueset-object-type.html</a> </p>",
        "id": 153866368,
        "sender_full_name": "John Moehrke",
        "timestamp": 1484143102
    },
    {
        "content": "<p>That list comes from atna. I always thought it was crap.</p>",
        "id": 153866381,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1484159906
    },
    {
        "content": "<p>Grahame that is not the question... The question is that the valueset should also include all of the FHIR Resource types. But it appears not to include them...</p>",
        "id": 153866386,
        "sender_full_name": "John Moehrke",
        "timestamp": 1484164103
    },
    {
        "content": "<p>well, we can make it do so. editorially, we would have to :<br>\n- grab the generated code system and value set resources and copy them into the source directory<br>\n- change the binding to reference the value set resource directly <br>\n- add the resource type value set to an include in the value set</p>",
        "id": 153866387,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1484164297
    },
    {
        "content": "<p>+1 for using the FHIR Resource types.  That's roughly how we record events with our current HIPAA Audit Logger, and we'll happily adjust things to use the AuditEvent resource and suitable value sets.</p>",
        "id": 153868802,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1485188411
    },
    {
        "content": "<p>This is now logged as <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12677\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12677\">GF#12677</a></p>",
        "id": 153868810,
        "sender_full_name": "John Moehrke",
        "timestamp": 1485191190
    },
    {
        "content": "<p>Hi All,</p>\n<p>I've couple of queries regarding AuditEvent:</p>\n<ol>\n<li>I can see a dedicated element 'AuditEvent.entity.query' for query. what about read? what is the suggested way to store they 'id' for a read operation? put it in 'AuditEvent.entity.detail'? Any particular reason why 'AuditEvent.entity.query' doesn't have a 'string' option as well?</li>\n<li>What is the best place to record 'x-correlation-id' or similar type of interaction id? We would like to trace all internal events (orchestration) for a particular transaction but at this moment didn't find any such place in AuditEvent resource</li>\n</ol>\n<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>, <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  any suggestion?</p>",
        "id": 191679106,
        "sender_full_name": "Shovan Roy",
        "timestamp": 1585087659
    },
    {
        "content": "<p>I'm going to leave the response for this one to John :)</p>",
        "id": 191684863,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1585091946
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> I'll wait for <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  :)</p>",
        "id": 191685502,
        "sender_full_name": "Shovan Roy",
        "timestamp": 1585092416
    },
    {
        "content": "<p>We have a bit of explanation <a href=\"http://build.fhir.org/auditevent.html#6.4.4.4\" title=\"http://build.fhir.org/auditevent.html#6.4.4.4\">http://build.fhir.org/auditevent.html#6.4.4.4</a></p>",
        "id": 191736373,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585139077
    },
    {
        "content": "<ol>\n<li>The id would go into an entity .what element. Have as many .entity. The example saves more than the id, but I think the id is sufficient as the audit analysis can always lookup by id.    An augmentation of this is to add another .entity with the patient identity, if you know it. This enables privacy use-cases  <a href=\"http://build.fhir.org/auditevent.html#patient\" title=\"http://build.fhir.org/auditevent.html#patient\">http://build.fhir.org/auditevent.html#patient</a></li>\n</ol>",
        "id": 191736729,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585139335
    },
    {
        "content": "<p>The entity.query requires you to base64 encode, so as to protect the query parameters. Prevents query parameter abuse as a vector to attack the database. If they are always base64 encoded then one can't send in fragments of json or xml and cause database overruns. Consistency is important</p>",
        "id": 191737021,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585139501
    },
    {
        "content": "<ol start=\"2\">\n<li>Seems x-coorelation-id would be another .entity.</li>\n</ol>",
        "id": 191737288,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585139647
    },
    {
        "content": "<p>Please submit a CP with recommendation and example</p>",
        "id": 191737311,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585139664
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> , this helps a lot. I'll provide a CP with detailing the scenario</p>",
        "id": 191804596,
        "sender_full_name": "Shovan Roy",
        "timestamp": 1585166985
    },
    {
        "content": "<p>one more thing <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> , in case of conditional create/update/delete, I guess </p>\n<ol>\n<li>The query string will go to the 'query' element </li>\n<li>The 'what' shall not be populated for any of these cases </li>\n<li>The payload will go inside the 'detail' as base 64 for cond create and update</li>\n</ol>\n<p>Is this a correct assumption?</p>",
        "id": 191809038,
        "sender_full_name": "Shovan Roy",
        "timestamp": 1585169380
    },
    {
        "content": "<p>queries are just record of the query with success/failure. The results are not recorded, as it is considered reproducable and to record it is to put sensitive information in the audit log for no good reason</p>",
        "id": 191812792,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585171323
    },
    {
        "content": "<p>or did I misunderstand your question?</p>",
        "id": 191812822,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585171347
    },
    {
        "content": "<p>Sorry <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> , I would have provided a few more details about my quesiton. </p>\n<p>The situation here is that we have received a conditional update API request (PUT [base]/[type]?[search parameters]) from an external party.  We want to create an Audit for that. To capture the details as received in the request, this is what my plan is:</p>\n<ol>\n<li>Use the AuditEvent's 'query' element to record the query as received in API query string ([search parameters]). Unless the guideline is to capture only '_query' value in 'query' element. </li>\n<li>Use the entity.details to capture the payload received as base 64 bin.</li>\n<li>I still need to figure-out where to store the request headers</li>\n</ol>\n<p>is my approach correct here?</p>",
        "id": 191813996,
        "sender_full_name": "Shovan Roy",
        "timestamp": 1585172081
    },
    {
        "content": "<p>Thanks. that was not clear to me originally. Yes this would be situation we have not yet talked about. It is best to model these with someone who is working on the issue, as you are.  Hence why we don't have an example, so good to get an example from you.  I think that you should record this as a UPDATE restful operation, but you should include an .entity with the query parameter. I would recommend against capturing the details, as we try hard to not duplicate sensitive information in the audit log.</p>",
        "id": 191873982,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585224405
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> I'll provide an example..</p>\n<p>Regarding capturing the details in Base 64. I was trying a model where Audit is kept totally in a separate database and works as single source of truth for every single transaction, kind of an event source but not really the event source.. But I see your point..</p>",
        "id": 191971559,
        "sender_full_name": "Shovan Roy",
        "timestamp": 1585276584
    },
    {
        "content": "<p>that functionality is best supported by a technology specific solution. like a jorunaling database.</p>",
        "id": 192007834,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585310741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191404\">John Moehrke</span> <a href=\"#narrow/stream/179166-implementers/topic/AuditEvent/near/191737021\" title=\"#narrow/stream/179166-implementers/topic/AuditEvent/near/191737021\">said</a>:</p>\n<blockquote>\n<p>The entity.query requires you to base64 encode, so as to protect the query parameters. Prevents query parameter abuse as a vector to attack the database. If they are always base64 encoded then one can't send in fragments of json or xml and cause database overruns. Consistency is important</p>\n</blockquote>\n<p>I don't quite follow - query parameters are base64 encoded because of what? Do you consider the parameters in plain text to be a security issue?</p>",
        "id": 194910722,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587550044
    },
    {
        "content": "<p>so that they can survive being converted between FHIR XML, FHIR JSON, FHIR Turtle, FHIR JSON-LD, DICOM XML, etc.</p>",
        "id": 194928565,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587561550
    },
    {
        "content": "<p>it is just a safe way to do that. Do you have an alternative? This model has worked for 20 years in the companion standard ATNA/RFC/DICOM</p>",
        "id": 194928691,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587561603
    },
    {
        "content": "<p>I can't see that is an argument</p>",
        "id": 194928705,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587561610
    },
    {
        "content": "<p>why not convert all strings to base64 then?</p>",
        "id": 194928723,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587561622
    },
    {
        "content": "<p>why is this single string such a security risk while all the others are not?</p>",
        "id": 194928831,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587561671
    },
    {
        "content": "<p>this is not primarily as a security risk, this is primarily as an encoding risk. The query parameters accross all possible query languages (AuditEvent is used for things other than FHIR) are not constrained enough to guarantee an ecoding problem</p>",
        "id": 194929052,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587561758
    },
    {
        "content": "<p>please recognize that AuditEvent is intended to record ALL kinds of audit events, not just FHIR events. Thus it must have a general use way of recording a QUERY regardless of query language</p>",
        "id": 194929149,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587561805
    },
    {
        "content": "<p>should this fact be emphasized in the AuditEvent explanation of why query is execute and why query base64 encodes?  This does seem to be the thing that I need to bring forward often, and that oftenness is usually a good clue to a CP need.</p>",
        "id": 194930090,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587562227
    },
    {
        "content": "<p>Well .. shouldn't the FHIR standard first and foremost make sense in FHIR itself - meaning that query should have been a string - or secondly a multiple type value - either string or base64?</p>",
        "id": 194930863,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587562553
    },
    {
        "content": "<p>I cannot understand why this sort of use (base64) couldn't be handled in an extension or so</p>",
        "id": 194931059,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587562629
    },
    {
        "content": "<p>it seems like a pretty exotic choice</p>",
        "id": 194931085,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587562639
    },
    {
        "content": "<p>That is an interesting proposal. I would need others to weigh in on if that makes sense in all cases. I can't claim to know enough to guarantee that anything someone puts on a query or search could safely be placed into a string element.  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> ?</p>",
        "id": 194933267,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587563492
    },
    {
        "content": "<p>And, it does still  have the security problem...  Given that AuditEvent is also there to record failed queries/search, so that investigation can be accomplished. Where an attacker could send in a query with carefully crafted parameters, such that they KNOW it will not succeed as a query, but they then know that string is encoded into an AuditEvent and processed... thus producing future bad behavior. It is true that base64encoding is a simple and effective way to encode everything consistently thus preserving all evidence as it was used.</p>",
        "id": 194933777,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587563693
    },
    {
        "content": "<p>Again - that argument goes for all strings</p>",
        "id": 194933915,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587563747
    },
    {
        "content": "<p>Thus I could see using a string for successful FHIR queries, but would still require failed queries to be recorded base64 encoded.</p>",
        "id": 194933934,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587563757
    },
    {
        "content": "<p>why? - its still a string</p>",
        "id": 194934024,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587563777
    },
    {
        "content": "<p>whether or not the query goes wrong</p>",
        "id": 194934061,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587563793
    },
    {
        "content": "<p>so you are saying that the normal string escaping mechanics should be sufficient for all of these concerns?</p>",
        "id": 194934155,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587563834
    },
    {
        "content": "<p>I'm saying that you could put garbage data in all the string fields out there</p>",
        "id": 194934356,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587563914
    },
    {
        "content": "<p>and they are not base 64 encoded</p>",
        "id": 194934388,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587563930
    },
    {
        "content": "<p>I am trying to be convinced.</p>",
        "id": 194935168,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587564223
    },
    {
        "content": "<p>well the arguments regarding security does not hold - you said so yourself</p>",
        "id": 194935348,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587564291
    },
    {
        "content": "<p>and if that was the argument, well doesn't that settle it?</p>",
        "id": 194935457,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587564332
    },
    {
        "content": "<p>no I didn't. I said it was not primary</p>",
        "id": 194935466,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587564337
    },
    {
        "content": "<p>ok - bring on the other arguments</p>",
        "id": 194935568,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587564364
    },
    {
        "content": "<p>I already have. bring on the solution.</p>",
        "id": 194935615,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587564386
    },
    {
        "content": "<p>use strings</p>",
        "id": 194935647,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587564404
    },
    {
        "content": "<p>you don't need the envelope of base64 encoding it</p>",
        "id": 194935707,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587564440
    },
    {
        "content": "<p>it brings no value as I see it</p>",
        "id": 194935989,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587564553
    },
    {
        "content": "<p>I have explained the value.</p>",
        "id": 194936261,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587564659
    },
    {
        "content": "<p>you mean the part where it is easier to convert between formats?</p>",
        "id": 194937251,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587565023
    },
    {
        "content": "<p>Lets try a different approach. Can you express what problems you are encountering because of base64 encoding that would not appear with string? I ask this as there was an issue brought up that it was not clear which queries included as their context (parameters or output) the Patient id, thus the problem was that a query for all audit events involving patient X was unsuccesful. Thus we identified that in other cases of this common information model (audit event) there is a requirement that when the Patient id is known, that it is included as an .entity. Thus the overall use-case is satisfied without breaking the model.</p>",
        "id": 194945621,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587568261
    },
    {
        "content": "<p>said another way... what is the problem, vs what is your solution to an unstated problem.</p>",
        "id": 194945968,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587568324
    },
    {
        "content": "<p>I would go with \"keeping it simple\" -&gt; use a plain string. If it is encoded due to interoperability with other standards, my suggestion would be to put it in a standardized extension or so instead. I can imagine that there are all other kinds of standards, legislation and restrictions in many areas that put limitations on a lot of various data types. If you were to embrace all that there would probably be no operational standard in the other end.</p>",
        "id": 194976498,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587582072
    },
    {
        "content": "<p>The 'problem' is that the datatype 'string' seems sufficient to encapsulate what is needed by FHIR, IMHO. If base64 is needed due to needs from others standards / legacy reasons I would suggest to have that stated more clearly in the spec.</p>",
        "id": 194976920,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587582270
    },
    {
        "content": "<p>well, in general I agree with <span class=\"user-mention\" data-user-id=\"191427\">@Jens Villadsen</span> - you cannot ignore encoding issues with any wire format, so it cannot be necessary to base64 encode things to make the wire format safe. And security issues innate to the data apply anyway, after you've base64 decided the content. </p>\n<p>Where base64 might be required is if the query is binary not text</p>",
        "id": 194978287,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1587582998
    },
    {
        "content": "<p>that is an angle that I have not considered - a binary query ...</p>",
        "id": 194978518,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587583115
    },
    {
        "content": "<p>that is a query I would like to see</p>",
        "id": 194978551,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587583129
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> you have any example of that?</p>",
        "id": 194978825,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587583277
    },
    {
        "content": "<p>we don't do any of that in FHIR</p>",
        "id": 194980325,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1587583924
    },
    {
        "content": "<p>Right - but since you mentioned it - I would still like to see an example use /use case</p>",
        "id": 194981255,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587584344
    },
    {
        "content": "<p>dicom query? I'm guessing here... have to go digging through my dicom implementation to be sure</p>",
        "id": 194981352,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1587584386
    },
    {
        "content": "<p>LDAP query for sure, but I don't know that's in scope</p>",
        "id": 194981388,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1587584399
    },
    {
        "content": "<p>those are good factors. As I indicated above, I am not against having a query[x] that allows for the AuditEvent recorder to determine that the query they have is a string vs binary. However, this doesn't really simplify the consumption of AuditEvent as the recipient must be able to decode both string and binary. Even in a pure FHIR environment the recipient must recognize that it is possible that a AuditEvent recorder might have decided to use the binary encoding. So I think all we would accomplish is the appearance of more easy to use, while actually making it harder to use.</p>",
        "id": 194987222,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587587303
    },
    {
        "content": "<p>there are many technical solutions --- what is the problem we are trying to solve? The only problem that has been expressed is that it doesn't fit the picture.</p>",
        "id": 194987325,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587587366
    },
    {
        "content": "<p>note, I am not as negative on this as I appear... but don't want to change without good and clear benefit gained.</p>",
        "id": 194987753,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587587559
    },
    {
        "content": "<blockquote>\n<p>what is the problem we are trying to solve?</p>\n</blockquote>\n<p>having a clean model, would be my answer. Having chosen one datatype in the past does not necessarily make it the right choice. - and, if something doesn't fit the picture, aren't we then obliged to fix it? If the model is easier to understand and interpret by changing the datatype or allowing it to be either binary or not - shouldn't we then do it?</p>",
        "id": 194992336,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587590154
    },
    {
        "content": "<p>If a query might be expressed as actual binary executable, that'd be a good reason to use base64encoded.  If you're going to send something as a string, it ought to meet the semantics of string - i.e. be intended to be human-readable.  If we think we'll need to convey queries from arbitrary standards that don't fit that semantic, then base64encoded as a choice is fine.  But encoding issues should not be an issue - even if round-tripping.  If they are, the solution is to fix the problem, not introduce base64encoded anywhere such issues might exist.</p>",
        "id": 195010906,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1587605657
    },
    {
        "content": "<p>So to sum up: Should I create a CP?</p>",
        "id": 195027989,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587628345
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span></p>",
        "id": 195030238,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587629979
    },
    {
        "content": "<p>So we need to support binary, but it is true that we could better support when a query is known to be a string. So it seems that a query[x] of String and binary might be useful. What I think we must then do is come up with very clear rules on when String can/should be used, or clear rules on when Binary can/should/shall be used. I am understanding that all forms of FHIR query/search can be represented in String safely; right?  If so, that is a nice deterministic rule that is well elaborated in a FHIR spec.</p>",
        "id": 195056524,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587646828
    },
    {
        "content": "<p>I think the base criteria is whether the query value is something that's intended to be directly viewed/written by a human</p>",
        "id": 195071574,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1587653188
    },
    {
        "content": "<p>(The same as we would for attachment)</p>",
        "id": 195071624,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1587653211
    },
    {
        "content": "<p>Also, do we want base64binary or do we actually want Attachment?  The latter would let you specify a mime type so you'd have a clue what to do with the binary content...</p>",
        "id": 195071722,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1587653248
    },
    {
        "content": "<blockquote>\n<p>very clear rules on when Binary can/should/shall be used.</p>\n</blockquote>\n<p>Ain't the rule that if the query contains binary content, it must be base64 encoded?</p>",
        "id": 195103178,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587667633
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> </p>\n<blockquote>\n<p>intended to be directly viewed/written by a human.</p>\n</blockquote>\n<p>that is too vague. Even queries in FHIR expressed in either the URL or in the body of HTTP post is not intended for humans. It is intended for machines</p>",
        "id": 195103409,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587667725
    },
    {
        "content": "<p>HTTP is not intended for human processing. Its intended for machine processing. Somewhat understandable by humans, yes</p>",
        "id": 195103696,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587667835
    },
    {
        "content": "<p>My point was that if your query is XML or JSON, it would be appropriate to use Attachment for those rather than string.</p>",
        "id": 195118846,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1587675565
    },
    {
        "content": "<p>eg. search using HTTP POST?</p>",
        "id": 195118952,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587675604
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span></p>",
        "id": 195122150,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587677526
    },
    {
        "content": "<p>Could be.  Or some non-FHIR mechanism that uses a technical syntax that has some sort of mime type</p>",
        "id": 195130967,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1587683869
    },
    {
        "content": "<p>I think attachment is overkill.  and I would not expect most query languages to have registerd a mimetype</p>",
        "id": 195199602,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587740102
    },
    {
        "content": "<p>are all uses of string datatype intended for human consumption? That doesn't  feel right</p>",
        "id": 195199704,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587740141
    },
    {
        "content": "<p>Search using post would preserve the WHOLE post body in the AuditEvent.entity.query as base64binary.... This likely is not explained well enough so likely could get CR to explain it, and provide an example... I guess I could take the search example and create an auditEvent example off of it... Sound like a good idea?</p>",
        "id": 195200620,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587740521
    },
    {
        "content": "<p>That doesn't mean that it couldn't be using a string datatype rather than base64 binary... right?</p>",
        "id": 195201096,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587740693
    },
    {
        "content": "<p>so we are back to the proposal which is to update AuditEvent.entity.query to a query[x] of type string or base64binary....  with explanation that string should be used when it is known to be a string, with FHIR query and search as examples.   The reader should understand that binary might have been used with strings as the recorder might not have been sure their query was string compatible.</p>",
        "id": 195201493,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587740832
    },
    {
        "content": "<p>does string work with all FHIR query and search?</p>",
        "id": 195201537,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587740852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191404\">John Moehrke</span> <a href=\"#narrow/stream/179166-implementers/topic/AuditEvent/near/195200620\" title=\"#narrow/stream/179166-implementers/topic/AuditEvent/near/195200620\">said</a>:</p>\n<blockquote>\n<p>Search using post would preserve the WHOLE post body in the AuditEvent.entity.query as base64binary.... This likely is not explained well enough so likely could get CR to explain it, and provide an example... I guess I could take the search example and create an auditEvent example off of it... Sound like a good idea?</p>\n</blockquote>\n<p>I created <a href=\"http://jira.hl7.org/browse/FHIR-26093\" title=\"http://jira.hl7.org/browse/FHIR-26093\">J#26093</a> for this post search example</p>",
        "id": 195203453,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587741552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  The <a href=\"https://jira.hl7.org/browse/FHIR-26093\" title=\"https://jira.hl7.org/browse/FHIR-26093\">https://jira.hl7.org/browse/FHIR-26093</a> points some Da Vinci related stuff. Was that intended?</p>",
        "id": 195333995,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587906464
    },
    {
        "content": "<p>If FHIR queries issued as GET can be in thee string then FHIR queries issued as POST should also be in the string as the searches are equivalent AFAIK. The use of base64 should be isolated to binary cases, IMHO</p>",
        "id": 195334121,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587906658
    },
    {
        "content": "<blockquote>\n<p>does string work with all FHIR query and search?</p>\n</blockquote>\n<p>Well, since it must be representable within an URL, I would expect so.</p>",
        "id": 195334200,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587906803
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/pyW0TRnR79_2kMy9ur7aZz9Z/image.png\" title=\"image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/pyW0TRnR79_2kMy9ur7aZz9Z/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/pyW0TRnR79_2kMy9ur7aZz9Z/image.png\"></a></div>",
        "id": 195334205,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587906808
    },
    {
        "content": "<p>From <a href=\"https://www.hl7.org/fhir/http.html#search\" title=\"https://www.hl7.org/fhir/http.html#search\">https://www.hl7.org/fhir/http.html#search</a></p>",
        "id": 195334231,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587906831
    },
    {
        "content": "<p><a href=\"http://jira.hl7.org/browse/FHIR-26938\" title=\"http://jira.hl7.org/browse/FHIR-26938\">J#26938</a></p>",
        "id": 195401883,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587985864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191427\">Jens Villadsen</span> <a href=\"#narrow/stream/179166-implementers/topic/AuditEvent/near/195334121\" title=\"#narrow/stream/179166-implementers/topic/AuditEvent/near/195334121\">said</a>:</p>\n<blockquote>\n<p>If FHIR queries issued as GET can be in thee string then FHIR queries issued as POST should also be in the string as the searches are equivalent AFAIK. The use of base64 should be isolated to binary cases, IMHO</p>\n</blockquote>\n<p>You have somewhat convinced me... the main problem I have is that a consuming application must know how to deal with both string and binary encoded query. Thus adding string does not help consuming apps. So what does adding a string option help? I am not clear on what the benefit is, and I am clear that there is a negative impact on the apps that consume/use the AuditEvent.</p>",
        "id": 195402187,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587986034
    },
    {
        "content": "<p>Well that depends on your approach and how you count. First of all, if you restrict the use of base64 to queries that contain binary elements, then that part would not be rendered anyway - hence, clients can ignore this (besides clients that are really dedicated to that exact use case of rendering binary data). Second, if that first assumption is made, then query strings are directly visible without having to decode the content as it is represented in a normal string. Third, if its a normal string it is more easily made available for searches in the future. Fourth, do you expect the vast majority of clients to be looking for binary encoded content - because I don't. As <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  says: you can hide complexity, but you cannot make it go away. Currently, you are hiding it, by base64 encoding all of the queries.</p>",
        "id": 195405342,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1587988112
    }
]