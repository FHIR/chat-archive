[
    {
        "content": "<p>Task 8697 proposes to add offset and offsetUnit to Timing.repeat. but I do not know why offset would be in anything other than minutes. Adding offset units seems overkill to me. Why don't I just add offset and document that it's in minutes....</p>",
        "id": 153817556,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458720120
    },
    {
        "content": "<p>further, the proposed definition of the element: \"If negative, indicates that the activity should occur this amount of time prior to the occurrence of the event specified by repeat.when.  If positive, indicates that the activity should occur this amount of time after the occurrence of the event specified by repeat.when\" - is problematic; the when includes codes for 'before' and 'after' - should we drop the before and after codes? or make yet another constraint that you can't say -10 minutes after breakfast?</p>",
        "id": 153817557,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458720259
    },
    {
        "content": "<p>moved by <span class=\"user-mention\" data-user-id=\"191403\">@Michelle (Moseman) Miller</span>  and Michael? (Epic?) - Maybe Michelle can comment...?</p>",
        "id": 153817558,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458720350
    },
    {
        "content": "<p>Grahame, you bring up some valid points....  The best I can recall is that offset units could be needed in the future if other values were ever added to the Timing.repeat.when value set, such as to represent a use case like \"5 days after surgery\". However, offset is currently tied to Timing.repeat.when and all of the codes are daily occurrences (e.g. eating, sleeping) more so than events (e.g. surgery, cast removal) so minutes could be assumed for the time being....  Same reasoning on the second question of why the positive/negative support is needed.  If, in the future, the Timing.repeat.when value set is expanded to include a generic event (e.g. surgery, cast removal), then we'd need the positive/negative if the value set didn't include the corresponding before/after codes.</p>",
        "id": 153817851,
        "sender_full_name": "Michelle (Moseman) Miller",
        "timestamp": 1458773384
    },
    {
        "content": "<p>ok. so right now, I'll add offset as minutes, and positive only. The direction indicated by the code. We'll re-assess if we need to after implementation experience</p>",
        "id": 153817854,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458773450
    },
    {
        "content": "<p>more on this task. BID, 30 mins before meal, starting tomorrow for next 10 days. The starting tommorow for next 10 days - can't be done. </p>",
        "id": 153817877,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458775976
    },
    {
        "content": "<p>it's also quite opaque to me whether the code is understood to stand for the entire TIming, or to introduce a base from which the timing builds. </p>",
        "id": 153817878,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458776066
    },
    {
        "content": "<p>for me, it was always the former. I'm going to update the definitions to say that explicitly </p>",
        "id": 153817879,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458776079
    },
    {
        "content": "<p>1) I don't agree with the new comment saying that the code represents the entire Timing structure....  Examples like you gave of \"BID for 14 days\" break that rule, such that BID doesn't convey the boundsDuration of 14 days.  It might be better to scope the \"code\" as an alternative for frequency* and period* elements only</p>\n<p>2) Regarding the \"starting tomorrow for 10 days\" example, it could be represented via a combination of effective (start) date on the order/statement, itself, and timing to convey the 14 days.  Ignoring the possible duplication of dates across timing and other resources, we do support knowing both boundsDuration and boundsPeriod, such that it would be nice to support both.</p>",
        "id": 153817943,
        "sender_full_name": "Michelle (Moseman) Miller",
        "timestamp": 1458845972
    },
    {
        "content": "<p>Scoping the code down to just frequency and period nobbles it though. But you wouldn't have codes the included bounds - so maybe exempt bounds from that?</p>",
        "id": 153817944,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458846204
    },
    {
        "content": "<p>i don't know how you would use both period and bounds..</p>",
        "id": 153817945,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458846243
    },
    {
        "content": "<p>boundsDuration = boundsPeriod.end - boundsPeriod.start when both start and end are known<br>\nOtherwise, it is what you mentioned earlier -- \"starting tomorrow for 14 days\" which is a boundsDuration = 14 days and boundsPeriod.start = tomorrow.</p>\n<p>It could be possible to have a code = BID and when = before meals....so I would want to \"exempt\" bounds and when.  Count is another possible exemption if it was ordered as code = BID and count = 28 (implies a duration of 14 days).</p>",
        "id": 153817956,
        "sender_full_name": "Michelle (Moseman) Miller",
        "timestamp": 1458851383
    },
    {
        "content": "<p>Exempting when from code is exactly what I don't want to do because it is the most complicated.</p>",
        "id": 153817985,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458861137
    },
    {
        "content": "<p>The idea of code is to allow institutions to manage timing by a look up table </p>",
        "id": 153817986,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458861183
    },
    {
        "content": "<p>as for bounds, if you have start as a real date, and duration, you can turn that into a real end. What does allowing you to mix them and contain internal disagreements buy?</p>",
        "id": 153817988,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1458861219
    },
    {
        "content": "<p>If we don't exempt when from code, then are you suggesting the code would be \"BID before meals\" (which is actually what we have in our system)?  The only thing that makes me pause is whether a code = \"BID before meals\" meets the code definition of being \"ubiquitous\" especially since it isn't even defined in the preferred value set. </p>\n<p>Regarding the boundsDuration and boundsPeriod, you are correct that they *should be* conveying consistent information, especially if systems do the calculation you mentioned.  I don't have a strong opinion or reason to support both -- other than just simply stating that our system has the ability to calculate, persist, and return both.  That said, it makes writes/updates more complex if we have to check for disagreements between the two.</p>",
        "id": 153818022,
        "sender_full_name": "Michelle (Moseman) Miller",
        "timestamp": 1458875741
    }
]