[
    {
        "content": "<p>Hi There,</p>\n<p>We are receiving bundle in response from multiple sources and are trying to aggregate all the responses in one bundle and because we have to send out this aggregated response to another server. We are re-writing the full and referenced URL with our own server URL. but we are not finding the elements in bundle where we can specify the original source (name or id or code) so that receiving service have that information and send us back while resolving those URL for us to identify where to re-route the message?</p>",
        "id": 219378253,
        "sender_full_name": "Dheeraj Kumar Pal",
        "timestamp": 1607538802
    },
    {
        "content": "<p>you need to manage this on the server, since the client doesn't know anything about this.</p>",
        "id": 219385879,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1607542200
    },
    {
        "content": "<p>from my devdays presentation about this:</p>",
        "id": 219385942,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1607542210
    },
    {
        "content": "<ul>\n<li>Prefix ids with a server id e.g. s1-[id] (64 chars!)</li>\n<li>Reidentify every resource with random id &amp; Maintain look up table</li>\n<li>use GUIDs &amp; send to all backend servers</li>\n</ul>",
        "id": 219386252,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1607542339
    },
    {
        "content": "<p>those are the options...</p>",
        "id": 219386277,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1607542347
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> !! for quick response. We have currently implemented first option i.e. prefixing the server information in bundle id. One quick question <br>\nReceiver of the response have to use this Server name and send us back in JWT token in case they would like to resolve the URL. (We are including this information in our IG ) . Is this ok and align with FHIR server implementation or we need other approach ?</p>",
        "id": 219391356,
        "sender_full_name": "Dheeraj Kumar Pal",
        "timestamp": 1607544836
    },
    {
        "content": "<p>I don't understand that question. The client doesn't know anything about any of this. it just has a bundle with references that it tries to resolve</p>",
        "id": 219391993,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1607545170
    },
    {
        "content": "<p>We are building a Central service where multiple IHEs are connected to exchange the  fhir based clinical data. <br>\nIf one of these IHE query us for getting the resources from other IHEs. We are pulling the resources from all other IHEs that are connected to us and aggregating the responses (requesting IHE doesn't know anything about other IHE) and sending back to requester. Let's assume, if there is 4 condition from 4 different sources , central service will re-write (over write) the source URL with it's own and send the response to the requester. <br>\nNow,  if requestor is picking up  full URL of one condition and requesting back to us... How should we now figure out where to send this request as request itself doesn't contain the target system. To resolve this scenario, we are sending the target (source from where we received the response bundle) by appending in ID of the bundle and expecting client to send us back the same in JWT token payload, which we use to identify that where to redirect the request. Is this valid implementation?</p>",
        "id": 219393605,
        "sender_full_name": "Dheeraj Kumar Pal",
        "timestamp": 1607545945
    },
    {
        "content": "<p>If you prefixed the ids with the server you will receive a request with the prefixed id - and you know where to send it from the prefix. No need to muck around with JWTs or anything like that</p>",
        "id": 219394075,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1607546178
    },
    {
        "content": "<p>Another question is : why a bundle of bundles? It could just be a flat list of all resources returned by any back end systems, with OperationOutcomes for those systems that can't be reached or have some other sort of issue to report. What's the additional value of a 'bundle of bundles' ?</p>",
        "id": 219439384,
        "sender_full_name": "René Spronk",
        "timestamp": 1607585824
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191372\">René Spronk</span> <a href=\"#narrow/stream/179166-implementers/topic/Aggregating.20multiple.20responses.20(bundle).20in.20one.20bundle/near/219439384\">said</a>:</p>\n<blockquote>\n<p>Another question is : why a bundle of bundles? It could just be a flat list of all resources returned by any back end systems, with OperationOutcomes for those systems that can't be reached or have some other sort of issue to report. What's the additional value of a 'bundle of bundles' ?</p>\n</blockquote>\n<p>We are aggregating all the resources (returned in response) in one bundle and not using bundle of bundle.</p>",
        "id": 220611662,
        "sender_full_name": "Dheeraj Kumar Pal",
        "timestamp": 1608573914
    },
    {
        "content": "<p>Handle the link returned from multiple sources while aggregating the response : Should we include the link from each responding FHIR server (off-course after rebranding it)? or is there a different way to handle the link?</p>",
        "id": 220611833,
        "sender_full_name": "Dheeraj Kumar Pal",
        "timestamp": 1608574039
    },
    {
        "content": "<p>Link as-in: self link, next link?</p>",
        "id": 220613754,
        "sender_full_name": "René Spronk",
        "timestamp": 1608575107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191372\">René Spronk</span> <a href=\"#narrow/stream/179166-implementers/topic/Aggregating.20multiple.20responses.20(bundle).20in.20one.20bundle/near/220613754\">said</a>:</p>\n<blockquote>\n<p>Link as-in: self link, next link?</p>\n</blockquote>\n<p>Yes, previous, self, next link</p>",
        "id": 220671271,
        "sender_full_name": "Dheeraj Kumar Pal",
        "timestamp": 1608628202
    },
    {
        "content": "<p>In the aggregate bundle, you'll have to include URLs created/faked by the aggregator service. The links required for the backend systems should be persisted somehow by the aggregator, in case the client requests the next page.  Especially if the aggregator support _count you'll run into problems, caching results and doing repagination in the aggregator is not always possible, especially not if you also allow for _(rev)includes.</p>",
        "id": 220680828,
        "sender_full_name": "René Spronk",
        "timestamp": 1608637065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191372\">René Spronk</span> <a href=\"#narrow/stream/179166-implementers/topic/Aggregating.20multiple.20responses.20(bundle).20in.20one.20bundle/near/220680828\">said</a>:</p>\n<blockquote>\n<p>In the aggregate bundle, you'll have to include URLs created/faked by the aggregator service. The links required for the backend systems should be persisted somehow by the aggregator, in case the client requests the next page.  Especially if the aggregator support _count you'll run into problems, caching results and doing repagination in the aggregator is not always possible, especially not if you also allow for _(rev)includes.</p>\n</blockquote>\n<p>Multiple FHIR servers response will have their link. Should we create/faked all the links and maintain it in aggregated response with FHIR server ID appended to it (Just in case if receiver query back using the one of the link)?</p>",
        "id": 220681917,
        "sender_full_name": "Dheeraj Kumar Pal",
        "timestamp": 1608638134
    },
    {
        "content": "<p>Your aggregator needs to behave as though it's a single endpoint with a single set of ordered pages.  You'll have to manage the pages returned from the source system and generate your own links.</p>",
        "id": 220692702,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1608646381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179166-implementers/topic/Aggregating.20multiple.20responses.20(bundle).20in.20one.20bundle/near/220692702\">said</a>:</p>\n<blockquote>\n<p>Your aggregator needs to behave as though it's a single endpoint with a single set of ordered pages.  You'll have to manage the pages returned from the source system and generate your own links.</p>\n</blockquote>\n<p>We are pretty clear on creating single endpoint and points to our service instead of the actual source. <br>\nIs there any example or profile.. we can refer to?</p>",
        "id": 220723426,
        "sender_full_name": "Dheeraj Kumar Pal",
        "timestamp": 1608664060
    },
    {
        "content": "<p>Not really, because any example would be indistinguishable from a regular search interface.  A system querying your interface should be completely unaware that there are multiple independently queried systems behind the scenes.  The only possible difference you might see is that the 'source' element of the resources might indicate what server they came from.  The client won't see the page links from any of the source systems.  (And, in some cases, some of the source systems might have different paging sizes or even not support paging at all.)  When the client hits your 'generated' link for a new page, you'll have to look up the cached results from the different source queries and possibly just send more rows from the data you already have or, if necessary, request new pages from one or more of the sources, interpolating results as per the requested sort order.</p>",
        "id": 220728126,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1608667078
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179166-implementers/topic/Aggregating.20multiple.20responses.20(bundle).20in.20one.20bundle/near/220728126\">said</a>:</p>\n<blockquote>\n<p>Not really, because any example would be indistinguishable from a regular search interface.  A system querying your interface should be completely unaware that there are multiple independently queried systems behind the scenes.  The only possible difference you might see is that the 'source' element of the resources might indicate what server they came from.  The client won't see the page links from any of the source systems.  (And, in some cases, some of the source systems might have different paging sizes or even not support paging at all.)  When the client hits your 'generated' link for a new page, you'll have to look up the cached results from the different source queries and possibly just send more rows from the data you already have or, if necessary, request new pages from one or more of the sources, interpolating results as per the requested sort order.</p>\n</blockquote>\n<p>Thank you <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> !! We are pass through central service connecting multiple HIEs and are not authorized to cache the data. that's where the challenge it . We are brainstorming this and will come ack to group with specific question.</p>\n<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  and <span class=\"user-mention\" data-user-id=\"192587\">@David Pyke</span> .. Any insight on this from HIEs perspective?</p>",
        "id": 220734539,
        "sender_full_name": "Dheeraj Kumar Pal",
        "timestamp": 1608671388
    },
    {
        "content": "<p>You have to cache or you can't amalgamate.  The best you could do is have someone send you a batch of queries and let you route them to their respective targets and then consolidate the responses into a batch response.</p>",
        "id": 220734767,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1608671544
    },
    {
        "content": "<p>I don't know of experience in real-world, yet. As Lloyd points out, this is not going to be easy if paging is needed while caching is forbidden. The only possibility I can think of is an intermediary for 10 backends, and take 10 results from 10 backends, add them together into one 100 entry bundle you give back to the client. You would still need to cache the next links from each of the 10 backends, in order to support a next from your client. the paging mechanism does give the server (you in the eyes of your client) the ability to ignore the client's request for paging... but so too your backends might do that to you. being robust to all of these design challenges is... a design challenge ... good fun if you ask me.  I see many other failure-modes related to these design constraints.</p>",
        "id": 220740543,
        "sender_full_name": "John Moehrke",
        "timestamp": 1608675835
    },
    {
        "content": "<p>Even that would be misleading if you're sorting.  For example, if you query for patients and sort by name, the second 10 patients from endpoint 1 could fall alphabetically between some of the patients in the first 10 patients from endpoint 2.</p>",
        "id": 220748313,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1608681323
    },
    {
        "content": "<p>If you <em>only</em> return un-ordered results, you might be able to make it work, but paging with unordered results is pretty useless.</p>",
        "id": 220748404,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1608681383
    },
    {
        "content": "<p>I'm aware of other implementations of aggregators, but I'm not aware quite how they've solved this. Easiest would be for the aggregator to fetch the full result set from all backend systems, cache it (perhaps only in memory), and respond to paging request by using the cache. Anything else would lead to significant implementation challenges.</p>",
        "id": 220768302,
        "sender_full_name": "René Spronk",
        "timestamp": 1608710620
    },
    {
        "content": "<p>indeed adding the demand for ANY kind of sort, also highly complicated. I was responding  with a presumption that sort was not supported by your system. The thinking is what constraints can you place on your API to the clients that make hitting all of these other constraints possible.</p>",
        "id": 220786473,
        "sender_full_name": "John Moehrke",
        "timestamp": 1608728558
    },
    {
        "content": "<p>as to cache... what is their definition of what kind of caching is forbidden? because I certainly could see a definition of caching that would not even allow you to decompose the backend results so as to reassemble them into your results. That instant in time, could be considered a cache. If that instant in time isn't a cache, then is the few-instances-in-time that it takes for the client to request 'next' short enough to not be cache?</p>",
        "id": 220786609,
        "sender_full_name": "John Moehrke",
        "timestamp": 1608728680
    },
    {
        "content": "<p>I think we're dealing with the problem of what caching is.  If you're not allowed to store it long term, that's fine.  However, if you're not allowed to hold onto it for even 1 minute, then you're going to have serious problems.  I would suggest that you take the \"caching\" to mean \"hold until end of transaction\", meaning you can sort, or page it as needed.</p>",
        "id": 220791768,
        "sender_full_name": "David Pyke",
        "timestamp": 1608732825
    },
    {
        "content": "<p>We are not allowed to store. we can hold it in memory and that's how we are collecting responses from all sources and aggregating the response for requestor. As link is very specific to the sources generating the response and we are already seeing different types of link coming in response from different sources. We were wondering if there is similar initiatives and also wanted to understand if standard defines something. I think in IHEs world, it's could be a key issue. There are couple of options we are exploring to map the different sources link to central service.  we will post the options here for feedback and critics. We would request please  share any additional information anyone have with related topic.</p>",
        "id": 220796213,
        "sender_full_name": "Dheeraj Kumar Pal",
        "timestamp": 1608735818
    },
    {
        "content": "<p>The options available are:</p>\n<ul>\n<li>receive a Bundle of search requests and return a Bundle of search responses (using 'batch') - i.e. the client is aware of all the systems you're hitting and you just act as a router</li>\n<li>aggregate all of the data from the different sources and return it without any paging (possibly using bulk data) </li>\n<li>persist the page references in memory across calls and resolve your internally generated page link to the cached set of page links and previously retrieved results to retrieve additional data as necessary and figure out what the pages should look like</li>\n<li>create a custom operation that does whatever you like - but that most systems won't support</li>\n</ul>",
        "id": 220809649,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1608744853
    },
    {
        "content": "<p>Another vector of challenges is how the aggregator will deal with assigning a Bundle level high water security label based on any labeled resources.</p>",
        "id": 220816766,
        "sender_full_name": "k connor",
        "timestamp": 1608749503
    }
]