[
    {
        "content": "<p>Need some remedial instruction here... it's my understanding that in elementdefinition.binding:<br>\n1. Using valueSetUri leads to resolution of the binding via the ValueSet.url field (<code>GET [base]/ValueSet?url=XXX</code>).<br>\n2. Using valueSetReference leads to resolution using a FHIR read.  In the case of a relative URL, resolving locally.  In the case of an absolute URL, resolving by whatever means/policy the server has defined.</p>\n<p>Since:<br>\na. Most servers will make some kind of local copy of the FHIR standard valuesets for performance and security.<br>\nb. Reference absolute URLs don't actually resolve (<code>http://hl7.org/fhir/vs/use-context</code>).<br>\nc. Canonical URLs exist, are stored, and are searchable.</p>\n<p>Why don't the standard profiles use valueSetUri rather than valueSetReference?  In fact, why would *any* system not just use the canonical URL for conformance resources?</p>",
        "id": 153835177,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1467059754
    },
    {
        "content": "<p>canonical URLs in the FHIR specfication resolve. The correct URL is <a href=\"http://hl7.org/fhir/ValueSet/use-context\" target=\"_blank\" title=\"http://hl7.org/fhir/ValueSet/use-context\">http://hl7.org/fhir/ValueSet/use-context</a>. The only time they don't resolve  is when they are defined in the current build, and not yet published</p>",
        "id": 153835179,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467060101
    },
    {
        "content": "<p>Why not just use the canonical URLs?</p>",
        "id": 153835180,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1467060143
    },
    {
        "content": "<p>the important difference between valueSetUri and valueSetReference is that valueSetReference is defined to be an explicit reference to a value set resource, but valueSetUri may be a reference to something that is not an explicit value set </p>",
        "id": 153835182,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467060171
    },
    {
        "content": "<p>I use canonical URLs in valueSetReference</p>",
        "id": 153835183,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467060183
    },
    {
        "content": "<p>Seems to be forcing some gymnastics when storing these locally - I have to do absolute &lt;-&gt; local conversion of the URLs using the same resource id to resolve locally....</p>",
        "id": 153835184,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1467060238
    },
    {
        "content": "<p>or implement some kind of alternate cache with the original URL intact.</p>",
        "id": 153835185,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1467060270
    },
    {
        "content": "<p>It's taboo to search ValueSet.url to resolve valueSetReference, yes?</p>",
        "id": 153835186,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1467060302
    },
    {
        "content": "<p>And a valueSetUri binding *should* try to resolve via ValueSet.url, yes?</p>",
        "id": 153835187,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1467060372
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> is there any doco/examples on how CQL should play with these notions?</p>",
        "id": 153835230,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467067276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192001\">@Erich Schulz</span> CQL provides declarations that allow you to reference value sets, but it is silent about how those identifiers resolve underneath. When using FHIR, the recommendation is to use the URI as the identifier for the value set (so valueSetUri in this context). That may resolve to an actual value set reference on your FHIR server, or it may just be a value set identifier that is passed to a terminology server. Or it may be mapped to an OID, or...</p>",
        "id": 153835231,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1467067615
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> - this is bit of a key issue... a small remnant of the curly brace problem - is it being discussed anywhere?</p>",
        "id": 153835238,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467070665
    },
    {
        "content": "<p>I guess I specifically trying to figure out how to express notions such \"has this code or any subtypes of this code\"</p>",
        "id": 153835240,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467070862
    },
    {
        "content": "<p>Chris - I treat my local value set copies as a cache and look there for the value set reference by URL first before falling back to looking at the actual literal URL. I haven't found that forced, but perhaps I never thought of any other approach </p>",
        "id": 153835251,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467071693
    },
    {
        "content": "<p>it's not taboo to search by URL. but I don't try to do that for ValueSet.uri</p>",
        "id": 153835252,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467071721
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192001\">@Erich Schulz</span> yes, terminology references are an active topic in the various CQF forums. Basically, CQL supports valueset and codesystem membership with the _in_ operator. But we purposely excluded subsumption from the spec (too much possibility for variation of interpretation), but there's nothing that says you couldn't define a subsumption function for use in a particular context. And if you feel it's a necessity, submit a DSTU comment :)</p>",
        "id": 153835257,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1467073471
    },
    {
        "content": "<p>is there any reason why CQL shouldn't assume the existence of the FHIR terminology service, and map to it's operations directly?</p>",
        "id": 153835258,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467073514
    },
    {
        "content": "<p>this could work <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> - the goal is to enable authors of \"shareable knowledge artifacts\" to express knowledge and clinical logic in a standard, transparent manner</p>",
        "id": 153835259,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467073620
    },
    {
        "content": "<p>I'm working on that right now actually. It effectively does assume the existence of a terminology service (or equivalent functionality), the spec just considers that an implementation issue and doesn't specify any particular interface.</p>",
        "id": 153835260,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1467073627
    },
    {
        "content": "<p>that would work internationally and allow easy peer review and validation</p>",
        "id": 153835261,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467073651
    },
    {
        "content": "<p>I think that it should specify the FHIR terminology service, and bind to it. I believe that will work in the CDA context too </p>",
        "id": 153835262,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467073660
    },
    {
        "content": "<p>I'm working on an implementation-level interface that would support the terminology operations as exposed by FHIR.</p>",
        "id": 153835263,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1467073674
    },
    {
        "content": "<p>And then a plugin that can call any FHIR terminology service with that interface.</p>",
        "id": 153835264,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1467073742
    },
    {
        "content": "<p>i think it should simply refernece the snomed code...</p>",
        "id": 153835265,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467073784
    },
    {
        "content": "<p>that is the international standard right?</p>",
        "id": 153835266,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467073793
    },
    {
        "content": "<p>whatever server is providing the subsumption service should be immaterial?? right?</p>",
        "id": 153835268,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467073826
    },
    {
        "content": "<p>(or ICD or LOINC code as needed)</p>",
        "id": 153835269,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467073850
    },
    {
        "content": "<p>Well, it wouldn't reference any particular terminology, just the concept of a terminology service.</p>",
        "id": 153835270,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1467073856
    },
    {
        "content": "<p>Right.</p>",
        "id": 153835271,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1467073859
    },
    {
        "content": "<p>which server is providing the service should be immaterial, but the spec it's conforming to is very relevant</p>",
        "id": 153835273,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467073974
    },
    {
        "content": "<p>sorry - i'm possibly missing some basic stuff...</p>",
        "id": 153835274,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467074726
    },
    {
        "content": "<p>(and on job so bit distracted, not unusually)</p>",
        "id": 153835275,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467074754
    },
    {
        "content": "<p>but how do specify a cql Retrieve which says \"this code on one of its subtypes\"</p>",
        "id": 153835277,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467074814
    },
    {
        "content": "<p>thankfully CQL takes care of all the more complex operations really really well</p>",
        "id": 153835279,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467074844
    },
    {
        "content": "<p>i'm just trying to join the dots... in a way that will be as simple and as standard as possible for CQL authors</p>",
        "id": 153835281,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467074907
    },
    {
        "content": "<p>so <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> I think subsumption is critical</p>",
        "id": 153835301,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467075969
    },
    {
        "content": "<p>i'll submit a comment I guess</p>",
        "id": 153835302,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467075998
    },
    {
        "content": "<p>in meantime I'd be open for guidance on how this should be expressed in a standardish way</p>",
        "id": 153835306,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1467076133
    },
    {
        "content": "<p>FWIW, I'm not comfortable resolving references outside the local server - could be anything at the end of that URL - it's a vector for using a FHIR server to launch a DDOS for example.  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> do you whitelist domains or url patterns for external references?</p>",
        "id": 153836147,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1467433811
    },
    {
        "content": "<p>I ignore them. </p>",
        "id": 153836154,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467455955
    },
    {
        "content": "<p>on the public servers </p>",
        "id": 153836155,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467455962
    },
    {
        "content": "<p>Michael, very useful obseravation for \"Operational\" specifications. Not something a core specification can do much about except to point out that operaional concerns must be addressed. I would entertain adding an additional note to the securty.html page about this URL concern . Can you create a GF tracker with your recommended wording?</p>",
        "id": 153836169,
        "sender_full_name": "John Moehrke",
        "timestamp": 1467476509
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> Reading through this thread it seemed to morph away from the topic! I have a similar question: When creating a binding to a custom ValueSet from a profile, is it best practice to use ValueSetReference or ValueSetUri?.  I've taken the position that ValueSetUri is better as it supports registries exposing the lookup query that you describe (and assuming that the value is the canonical URL of the VS). It seems to me that using ValueSetReference means that the valueset must always be hosted at the indicated address as it's supposed to resolve.   </p>\n<p>But reading Grahames comment, it looks as if best practice is to use the canonical url as the value of ValueSetReference, and if it does not resolve, then look for it in a registry (like simplifier)</p>\n<p>Does that make sense?</p>",
        "id": 153894438,
        "sender_full_name": "David Hay",
        "timestamp": 1497909460
    },
    {
        "content": "<p>ValueSetReference means that you expect the specified URL to resolve to a FHIR value set (either directly or by looking up the canonical URL in a registry).  valueSetUri doesn't expect to resolve to a FHIR value set definition.  At least that's my understanding of the difference.</p>",
        "id": 153894444,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1497910488
    },
    {
        "content": "<p>Ah - I didn't appreciate that the 'looking up in a registry' was an appropriate fallback if the reference didn't resolve as that's not how a normal resource reference works - does it?</p>",
        "id": 153894447,
        "sender_full_name": "David Hay",
        "timestamp": 1497912082
    },
    {
        "content": "<p>Process is a bit different for resources with canonical URLs.</p>",
        "id": 153894454,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1497913332
    },
    {
        "content": "<p>so any reference to a resource with a canonical URL (StructureDefinition, ValueSet, OperationDefinition etc operates in this way? </p>",
        "id": 153894457,
        "sender_full_name": "David Hay",
        "timestamp": 1497917207
    },
    {
        "content": "<p>in which respect?</p>",
        "id": 153894458,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497917312
    },
    {
        "content": "<p>I always thought that the canonical URI was done via the Uri, and not the reference.</p>",
        "id": 153894459,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1497917638
    },
    {
        "content": "<p>in a binding?</p>",
        "id": 153894462,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497917915
    },
    {
        "content": "<p>the canonical URL should be a reference not a URI</p>",
        "id": 153894463,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497917935
    },
    {
        "content": "<p>The question was how to support a registry. I thought that a resource reference MUST resolve to a FHIR resource, so if you are binding a coded item to a ValueSet using binding.ValueSetReference, then the VS had to exist at that location (whether or not the URL is canonical) - if it wasn't found there, then the call would fail to retrieve the VS. That's why I've been using the binding.ValueSetUri - to indicate that the binding was to a canonical URI that could be retrieved from a registry - using a call like [host]/ValueSet?url=xx (as Chris said at the beginning of this thread)</p>\n<p>Lloyd is suggesting that you can still use binding.ValueSetReference, but if the call doesn't resolve to a VS, then you can look in your friendly registry for a VS with that URL value and use that...</p>",
        "id": 153894468,
        "sender_full_name": "David Hay",
        "timestamp": 1497923467
    },
    {
        "content": "<p>yes Lloyd is right. If you look in the standard, we use a URL where it implies a value set - e.g. some of the IETF rfcs</p>",
        "id": 153894474,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497930261
    },
    {
        "content": "<p>So, again on the \"remedial\" theme ;) I could assume:<br>\n1. A binding with valueSetUri is not technically enforceable and will not be validated except perhaps via \"special logic\".<br>\n2. A binding with a relative URL will attempt to be resolved locally (or via a local/preferred terminology service) via a FHIR ReSTful GET.  E.g.: <code>GET http://my.fhir.server/ValueSet/ab123</code><br>\n3. A binding with an absolute URL \"<a href=\"http://x.com/some/uri\" target=\"_blank\" title=\"http://x.com/some/uri\">http://x.com/some/uri</a>\" will attempt resolution via:<br>\n  a. Local/preferred terminology services via <code>GET http://my.fhir.server/ValueSet?url=http://x.com/some/uri</code><br>\n  b. Trusted registry services via <code>GET http://my.trusted.repo/ValueSet?url=XX</code><br>\n  c. If policy allows (probably not) by HTTP GET to the URL.  <code>GET http://x.com/some/uri</code></p>",
        "id": 153894742,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1498054621
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> In your use case, 3.a gets the actual valueset. But waht does 3.b return? I assume it returns a canonical URL for that valueset. Is that right?</p>",
        "id": 153895088,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1498228170
    },
    {
        "content": "<p>I would assume all would return the valueset</p>",
        "id": 153895113,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1498241536
    },
    {
        "content": "<p>Yes. All return the valueset.</p>",
        "id": 153895129,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1498249048
    }
]