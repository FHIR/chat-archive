[
    {
        "content": "<p>When I was using the Crucible to test the conformance of my FHIR implemantation, it showed a message that'Error: Conformance Statement could not be loaded crucible'. Has anyone ever met this issue? (PS:The  CapabilityStatement seems to be fine). Any suggestions?</p>",
        "id": 153975985,
        "sender_full_name": "Adam",
        "timestamp": 1531893746
    },
    {
        "content": "<p>Is crucible alive?</p>",
        "id": 153976017,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1531904222
    },
    {
        "content": "<p>Yes.</p>",
        "id": 153976210,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1531960231
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"196020\">@Adam</span> Can you provide a permalink to the result? Crucible generates those for the tests. If the errors occurs before that, please send the URL directly. Attention <span class=\"user-mention\" data-user-id=\"192576\">@Robert Scanlon</span></p>",
        "id": 153976212,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1531960352
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span>  Do you have harmonisation plans with TestScripts &amp; TouchStone?</p>",
        "id": 153976235,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1531961274
    },
    {
        "content": "<p>I see, TestScript became a part of FHIR - so i think it should be supported by more then one vendor ?!</p>",
        "id": 153976236,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1531961319
    },
    {
        "content": "<p>Crucible supports TestScript. Hell, I was the one who first proposed TestScript resource and added it to the spec in ages long past (<span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> has long maintained this resource, more credit to him). Not all of our tests are based on TestScript. In fact, a majority of Crucible tests are custom ruby code, but we do support the TestScripts built into the specification. There is currently no support for users providing their own scripts. We also don't support all of Touchstone's scripts. One reason is that we do not support <code>TestScript.rule</code> (<a href=\"https://www.hl7.org/fhir/testscript-definitions.html#TestScript.rule\" target=\"_blank\" title=\"https://www.hl7.org/fhir/testscript-definitions.html#TestScript.rule\">https://www.hl7.org/fhir/testscript-definitions.html#TestScript.rule</a>) because it is essentially a magical escape hatch to run your own custom (and maybe proprietary) code -- which means the interoperability of TestScript resources that use <code>rule</code> is zero.</p>",
        "id": 153976296,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1532002568
    },
    {
        "content": "<p>do you propose that we should limit the rules more stritly?</p>",
        "id": 153976298,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532002754
    },
    {
        "content": "<p>I don't have a concrete proposal. I have just identified the potential problem. I have tossed out the idea of using FHIR Path or CQL as a standard language for rule... but then you need a data model for requests and responses... and there may be other problems. I haven't thought deeply enough about it yet.</p>",
        "id": 153976305,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1532003166
    },
    {
        "content": "<p>well,we do have a data model for addressing headers with fhirpath - that's already come up.</p>",
        "id": 153976306,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532003199
    },
    {
        "content": "<p>I'd certainly be comfortable saying that the rules must be either fhirpath or queries</p>",
        "id": 153976307,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532003215
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> should weigh in here, since he has used <code>TestScript.rule</code> much more than I have and has probably a good idea of the uses/edge-cases around it.</p>",
        "id": 153976308,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1532003288
    },
    {
        "content": "<p>indeed that would be a great idea</p>",
        "id": 153976309,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532003302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, <span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span>, a couple responses:</p>\n<p><strong>Regarding TestScripts and FHIRPath</strong> – FHIRPath support already exists in the TestScript in the following elements:</p>\n<ul>\n<li><em>TestScript.variable.expression</em> - the FHIRpath expression to evaluate against the source fixture contents that determines the value of this variable</li>\n<li><em>TestScript.setup.action.assert.compareToSourceExpression</em> - the FHIRpath expression to evaluate against the source fixture contents that determines the comparison value</li>\n<li><em>TestScript.setup.action.assert.expression</em> - the FHIRPath expression to be evaluated against the operation request or response fixture context either as a standalone boolean expression or path to the comparison value</li>\n</ul>\n<p><strong>TestScript Rules and Rulesets</strong> - The TestScript.rule and TestScript.ruleset elements were introduced in STU3 as a means to provide access to more complex processing logic than could be provided with the basic assert definition. For Touchstone, this allowed us to introduce a Rules Engine to provide this capability where we implemented support for Groovy, XSLT and Schematron. Our main use cases for Rules and Rulesets are supporting conditional asserts based on the system’s CapabilityStatement and conditional aspects of the FHIR specification. All of AEGIS’s TestScripts, rules, and rulesets are open-source and easily accessible from the Touchstone UI by guest users.</p>\n<p>As Jason has explained, the rule and ruleset elements have caused an interoperability issue with Crucible. For quite some time I have been thinking about how to best resolve this and have come up with the following proposal for R4:</p>\n<p>1. Remove TestScript.rule, TestScript.ruleset, TestScript.setup.action.assert.rule and TestScript.setup.action.assert.ruleset<br>\n2. Add new, optional Touchstone-based TestScript extensions to replace the removed TestScript rule and ruleset elements. Proposed new Touchstone extension canonical urls:</p>\n<ul>\n<li><a href=\"http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-rule\" target=\"_blank\" title=\"http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-rule\">http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-rule</a></li>\n<li><a href=\"http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-ruleset\" target=\"_blank\" title=\"http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-ruleset\">http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-ruleset</a></li>\n<li><a href=\"http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-assert-rule\" target=\"_blank\" title=\"http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-assert-rule\">http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-assert-rule</a></li>\n<li><a href=\"http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-assert-ruleset\" target=\"_blank\" title=\"http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-assert-ruleset\">http://touchstone.aegis.net/touchstone/fhir/StructureDefinition/testscript-assert-ruleset</a><br>\nAs Touchstone-based extensions, other FHIR test engines could then safely ignore them if present in any TestScript instances.</li>\n</ul>\n<p>Thanks</p>",
        "id": 153976390,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1532019636
    },
    {
        "content": "<p>Rather than have them be touchstone specific extensions, they could be HL7 standard extensions.  The notion of wanting to embed Groovy or XSLT tests would presumably be generic.</p>",
        "id": 153976397,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1532022081
    },
    {
        "content": "<p>(Even if not part of the 80%)</p>",
        "id": 153976398,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1532022090
    },
    {
        "content": "<p>Regarding changing to extensions... I need to think about this. Are these assertions absolutely necessary for determining if a test passes or fails? If so, making them extensions... doesn't feel completely correct either. If not, then... maybe that's OK.</p>",
        "id": 153976412,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1532024401
    },
    {
        "content": "<p>Thanks for the thorough and thoughtful response <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span></p>",
        "id": 153976413,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1532024551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span>, the (current) definition of an assert is that if any assert fails then the test fails. I don't believe that logic will change if rules and rulesets move to extensions.  (Your welcome ;)</p>",
        "id": 153976415,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1532024782
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>, my thinking on making these extensions touchstone specific was not that they would be touchstone specific but rather part of an implementation guide for touchstone. I'm not sure if that makes a difference to whether or not they are HL7 standard extensions.</p>",
        "id": 153976416,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1532024958
    },
    {
        "content": "<p>If the extensions are general purpose and likely to be used by others, define them in HL7.  In your IG, you can declare which ones you support/require.</p>",
        "id": 153976428,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1532026217
    },
    {
        "content": "<p>My question isn't whether or not the test <em>would</em> pass or fail without the extensions (because you are right only the assert matters)... but whether or not the execution of the extension <em>should</em> cause it to pass or fail.</p>\n<p>So, in extension-speak, is the rule an <code>extension</code> or would it really be a <code>modifierExtension</code>? I think the answer is the latter. In which case, we're kind of back to square one...</p>",
        "id": 153976445,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1532029311
    },
    {
        "content": "<p>no it wouldn't be a modifier extension; they would be extra tests. <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> can you provide examples of what you are using these for?</p>",
        "id": 153976480,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532032716
    },
    {
        "content": "<p>Well, I would argue that if the rules are required for the test to pass in spirit... for example, the only meaningful and relevant assertion to a test is the rule... then it absolutely would be required, and then it probably ought to be a modifierExtension. Because without knowing that extension, the meaning of the test is different. I realize that is a theoretical argument, but without a lot of concrete examples of where Touchstone uses it, it is hard to eliminate that as a possibility.</p>",
        "id": 153976564,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1532038827
    },
    {
        "content": "<p>the definition of modifier extension is very precise now. It might be a modifier but it would also depend on the exact wording of the elements as well</p>",
        "id": 153976603,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532039911
    },
    {
        "content": "<p>A simple example would be verifying an HTTP Header was present if a system supported versioning on a specific resource type. This requires that the system's CapabilityStatement be parsed to determine their declared support for versioning of, say, the Patient resource type. Based on that evaluation, the actual test for, say, the presence of the ETag header can be done or not done (skipped). To simplify this logic we can first test if the ETag header was not present because if it is, then there is no need to test for versioning support.</p>\n<p>So, the resulting rule logic that would perform the above \"assert\" looks like this:</p>\n<div class=\"codehilite\"><pre><span></span>if (response.header(&#39;ETag&#39;).empty()) // only check capStmt if ETag not present\n{\n    boolean supports = supportsViaFhirPath(\n        &quot;rest.where(mode.value=&#39;server&#39;).resource.where(type.value=&#39;Patient&#39;).versioning&quot;,\n        &quot;versioned,versioned-update&quot;, &quot;in&quot;, &quot;Patient versioning&quot;, serverCapStmt);\n\n    assert !supports: &quot;ETag header expected but not found when Patient versioning is supported by server capability statement&quot;;\n}\n</pre></div>",
        "id": 153976617,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1532041478
    },
    {
        "content": "<p>so we could do all that with FHIRPath assertions</p>",
        "id": 153976619,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532041582
    },
    {
        "content": "<p>The FHIRPath expression would need access to both the system's CapabilityStatement and the executed operation context.</p>",
        "id": 153976620,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1532041682
    },
    {
        "content": "<p>yes, but that seems a pretty minimal thing to achieve. %capabilities and %operation, for exaple</p>",
        "id": 153976622,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532041736
    },
    {
        "content": "<p>Ok.  But FHIRPath today does not  have those.</p>",
        "id": 153976624,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1532041909
    },
    {
        "content": "<p>those are context variables defined where FHIRPath is used. So you just have to say 'these context variables are defined' in TestScript, and then you can use them</p>",
        "id": 153976625,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532041948
    },
    {
        "content": "<p>Ok. Assuming I get the context variables %capabilities and %operation defined such that our FHIR test engine undertand how to send them to our FHIRPath engine and get our FHIRPath engine to understand them, I can see the equivalent FHIRPath expression as something like this:</p>\n<div class=\"codehilite\"><pre><span></span>(%capabilities.rest.where(mode.value=&#39;server&#39;).resource.where(type.value=&#39;Patient&#39;).versioning in &#39;versioned,versioned-update&#39;) and (%operation.response.header(&#39;ETag&#39;).notEmpty())\n</pre></div>\n\n\n<p>Something to keep in mind with this approach is that in order to support interoperability between FHIR test engines the definition and use of these context variables, %capabilities and %operation, will need become part of the specification which forces all FHIR test engines to support them. That make this feel like the current issue we have with rule and ruleset.</p>",
        "id": 153976697,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1532045322
    },
    {
        "content": "<p>The issue is a little more problematic regarding the %capabilities context variable. The TestScript allows for multiple actors, both client and server, in the defined tests. We would need to support a %capabilities variable for each actor; e.g. %capablities1, %capabilities2, etc.</p>",
        "id": 153976700,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1532045929
    },
    {
        "content": "<p>well, more likely it's a collection you can use where with or something. but anyway, passing variables to the FHIR path engine is core FHIR Path functionality, so it should not require an update to the engine</p>",
        "id": 153976705,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532046846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span>  I've sent you the url :grin:</p>",
        "id": 153977180,
        "sender_full_name": "Adam",
        "timestamp": 1532327780
    }
]