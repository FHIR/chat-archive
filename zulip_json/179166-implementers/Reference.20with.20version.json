[
    {
        "content": "<p>Just a double check: could the Reference.reference include the target reference resource's version so the receiving system can perform a vread? </p>\n<p>So for example, would the below reference be valid?<br>\n&lt;reference value=\"Task/234234/_history/3be72cfc-267a-450e-bb74-275b9785298e\"/&gt;</p>",
        "id": 190495762,
        "sender_full_name": "Ardon Toonstra",
        "timestamp": 1584101640
    },
    {
        "content": "<p>yes though it's not widely supported well</p>",
        "id": 190497465,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1584103024
    },
    {
        "content": "<p>related to that, does it make sense for _include or Patient $everything to follow versioned refs and retrieve the specified version?</p>",
        "id": 190521204,
        "sender_full_name": "Paul Church",
        "timestamp": 1584115568
    },
    {
        "content": "<p>A specification I am working on has considered this. </p>\n<p>You want to be able to pull a set of resources that link to a historic version of a resource. Medicinal products definitions are made of several resources and we want to be able to get the whole set as it was at a given point. </p>\n<p>To allow it to work we wondered about storing the resources in the first place using references with specific history versions. Otherwise when you follow a reference you always get the newest version of the pointed at resource, not the one as it was at the time. </p>\n<p>Clinical data doesn't tend to update, or if it does you want the latest. But definitional things tend to go through versions, which are all useful.</p>",
        "id": 190527901,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1584118722
    },
    {
        "content": "<p>That case could also use canonical references, I think?</p>",
        "id": 190528393,
        "sender_full_name": "Paul Church",
        "timestamp": 1584118938
    },
    {
        "content": "<p>you mean by appending a \"|version\" to the url? That would work if the pieces were all versioned with numbers. Presumably the resolver needs to look into the resource.version attribute. Not sure if any servers can do that. And that would need the version attribute to exist and be populated of course. We don't have numbers on the parts currently, they just all come in together.</p>",
        "id": 190529526,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1584119445
    }
]