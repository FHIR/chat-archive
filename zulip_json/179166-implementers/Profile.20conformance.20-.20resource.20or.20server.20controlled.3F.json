[
    {
        "content": "<p>In the UK we are getting a lot of resistance to having many profiles. </p>\n<p>As a developer I'm guilty of this, I can easily get lost in profiles and what I want to do is build one resource and use it many times.<br>\nSo my resource conforms to a UK core profile but in reality its conformant to many more. </p>\n<p>When I worked on the uk sandbox (resftul), I followed this and endpoints validated against uk core profiles ignoring the profile stated in the resource.</p>\n<p>We also have a lot of message and document based specifications in the NHS in England. This is where I believe the anti-profile comments are coming from. The specs have a focus around profiles, in particular the message appears to be build this and this profile. <br>\nHere I feel we have made a mistake and we should be saying this is how you build a message or document (using GrapDefinition) and you resources should validate against these profiles. </p>\n<p>Profiles are rules not building instructions.<br>\n(building is done in practice using fhir site and uk sandbox)</p>\n<p>The last bit goes back to the restful pattern where the resource was validated against the servers requirements. In this latter pattern, the bundle is validated against the profiles listed in graphdefintions (the graphdefintion controls validation). <br>\nSo validation is not controlled by the resource (it can be, it's useful during early development).<br>\nIt's also key that a validation service is provided to check conformance to the rules (profiles). This is primarily how a developer discovers they are not following profiles (they are unlikely to trawl profiles, they will use them when they find an error).</p>",
        "id": 180806699,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1573799638
    },
    {
        "content": "<p>A resource could simply declare conformance to a GraphDefenition and be done with it. Having the server ignore a declared profile/GraphDefintion sounds bad practice to me, as there will surely be multiple version of (e.g. a message) GraphDefenition over time.  As such only the client can label the instance with the correct GraphDef url.</p>",
        "id": 180812538,
        "sender_full_name": "René Spronk",
        "timestamp": 1573807402
    },
    {
        "content": "<p>The server should be able to reject resources that it doesn't support. E.g. a resource may say it supports vital-signs, the server doesn't support LOINC and so enforces a profile that requires SNOMED code to be present.</p>",
        "id": 180812730,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1573807631
    },
    {
        "content": "<p>So the the vital-sign resource would be rejected.</p>",
        "id": 180812746,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1573807662
    },
    {
        "content": "<p>Sure, that's a business rule aspect. But the client is in control in declaring what its instance complies with. As you say that doesn't mean the server has to accept it, it has its own business rules.</p>",
        "id": 180812831,
        "sender_full_name": "René Spronk",
        "timestamp": 1573807746
    },
    {
        "content": "<p>On a practical level, if I'm building a document or a message. What I would like to do is assemble the bundle from restful servers (with minimal transform) so Patient and Encounter comes from the PAS, Observations from the Obs/EPR, Binaries from the EDMS, etc.<br>\nThe stated profile in these returned resources is not likely to match what the message/document wants but they should validate according to their conformance rules. Do I need to correct the stated profile in the resources?</p>",
        "id": 180813424,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1573808374
    },
    {
        "content": "<p>I feel not as the servers/project business rules take precedence (and will override the resources stated conformance)</p>",
        "id": 180813530,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1573808468
    },
    {
        "content": "<p><code>profile</code>:</p>\n<blockquote>\n<p>An assertion that the content conforms to a resource profile (a StructureDefinition). See Extending and Restricting Resources for further discussion. Can be changed as profiles and value sets change or the system rechecks conformance. The profile can be used to indicate which version(s) of FHIR a resource conforms to.<br>\nOn the RESTful API: On receiving a write operation, the server MAY elect to remove invalid claims, SHOULD retain claims that are correct or untested, and MAY add additional claims it believes are valid</p>\n</blockquote>",
        "id": 180813622,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1573808556
    },
    {
        "content": "<blockquote>\n<p>I feel not as the servers/project business rules take precedence (and will override the resources stated conformance)</p>\n</blockquote>\n<p>I think so too, and then the server could add the profiles it thinks the resource conforms to, like the spec says</p>",
        "id": 180813759,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1573808667
    },
    {
        "content": "<blockquote>\n<p>I can easily get lost in profiles and what I want to do is build one resource and use it many times.</p>\n</blockquote>\n<p>This is why one should not build overzealous profiles that 0..0 everything you don't want :)</p>",
        "id": 180813771,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1573808698
    },
    {
        "content": "<p>It causes developer pain (and pushback) like this.</p>",
        "id": 180813789,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1573808713
    },
    {
        "content": "<blockquote>\n<p>In the UK we are getting a lot of resistance to having many profiles</p>\n</blockquote>\n<p>I get that. Totally. And I get this too, as the actual goal:</p>\n<blockquote>\n<p>what I want to do is build one resource and use it many times.</p>\n</blockquote>\n<p>But hiding hard requirements and not using profiles... doesn't achieve your actual goal. Unless, that is, there's some confusion that because you have a profile, you have to use Resource.meta.profile. A lot of projects knee-jerk into this because of past experience, but I strongly advise against it. I am in favor of defining profiles for your requirements, but I'm very much in favor of using Resource.meta.profile as sparingly as possible. </p>\n<p>It tends to get used because lazy validator writers think it's easier for them, but it creates heaps of work downstream</p>",
        "id": 180827896,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1573821594
    },
    {
        "content": "<p>Thanks. That matches technical feedback in UK. Their is a push to make Resource.meta.profile mandatory for reasons you've mentioned.</p>",
        "id": 180830258,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1573823633
    },
    {
        "content": "<p>Why does it create heaps of work downstream? Any declared profiles can be ignored by a server, so what's the extra effort if it's there? One can choose to ignore, but if there are no declared profiles, one can't choose to use the client-specified profiles. And somehow you need to identify the version of the StrucDef or IG one is sending.</p>",
        "id": 180830585,
        "sender_full_name": "René Spronk",
        "timestamp": 1573823866
    },
    {
        "content": "<p>You're free to ignore declared profiles inbound, but if you spit them out outbound and they're wrong, your system is non-conformant.  More importantly, requiring that profiles be declared means that clients must customize their interfaces to declare all of the profiles for all of the downstream systems that expect that declaration.  So rather than just pointing at a new server and having things work, the client needs to change their code every time a new server comes along that wants a different profile (or different profile version) declaration - even though the data being provided hasn't changed and the meaning of the instance hasn't changed.  That's a tax on the client community for the convenience of the server and makes costs higher for the system overall.</p>",
        "id": 180830981,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1573824167
    },
    {
        "content": "<p>Wouldn't that be covered by the business when establishing the connections? They would establish something like a contract which says which profiles can be used by client and server?</p>",
        "id": 180835398,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1573827195
    },
    {
        "content": "<p>[del]</p>",
        "id": 180835567,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1573827315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  that statement (about being non conformant by returning possibly invalid profiles on a resources) doesn't agree with what the spec states about that: \"...SHOULD retain claims that are correct or <em>untested</em>, and MAY add additional claims it believes are valid\" (emphasis mine)</p>",
        "id": 180859340,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1573843159
    },
    {
        "content": "<p><a href=\"http://hl7.org/fhir/r4/resource.html#Meta\" target=\"_blank\" title=\"http://hl7.org/fhir/r4/resource.html#Meta\">http://hl7.org/fhir/r4/resource.html#Meta</a></p>",
        "id": 180859346,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1573843162
    },
    {
        "content": "<p>The documentation for the field even hints a bit that this is something that may slowly get stale over time/not be real time maintained: \"It is up to the server and/or other infrastructure of policy to determine whether/how these claims are verified and/or updated over time. The list of profile URLs is a set.\"</p>",
        "id": 180859435,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1573843219
    },
    {
        "content": "<p>This has always been my understanding of the profile field - it's not guaranteed to be accurate as it's pretty expensive to re-validate on all calls/keep these up to date in all cases</p>",
        "id": 180859478,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1573843263
    },
    {
        "content": "<p>typically, people write a profile that expresses their requirements, which is reasonable, and then say 'you have to tell me you meet my requirements' (use Resource.meta.profile). Which is the bit that stops re-use, since the requirements are compatible, but the explicit declaration is not. So you can't re-use your existing interface. And then you add the new profile declaration and some other interface suddenly blows up because it doesn't know this new profile you've declared.. and now we're back to one-off interfaces. </p>\n<p>yes, servers are allowed to rewrite profile ids.. but the kind of thinking that leads to the scenarios in the previous paragraph... those kind of IGs also prohibit servers changing profiles, etc. </p>\n<p>The lesson is that there's really 2 types of profiles (well, there's more sub-types): </p>\n<ul>\n<li>ones that express business rules for conformance purposes </li>\n<li>ones that describes inherent semantics in the resource (exp. Observation)<br>\n(yes I'm aware that this is not a clean division)</li>\n</ul>\n<p>It's the second ones that are candidates for Resource.meta.profile, and the only reason to do that is to make semantic usage <em>easy to find</em> (it's a denormalization). You should never put the first type of profile in Resource.meta.profile</p>\n<p><span class=\"user-mention\" data-user-id=\"191321\">@David Hay</span> btw, this is why it's important not to require Resource.meta.profile in order to validate</p>",
        "id": 180862906,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1573845505
    },
    {
        "content": "<p>so (how) can we say and inquire that a resource indicates \"this content is declared compatible with the constraints and requirements expresssed by xxx. May (or may not) be compatible with other requirements\"?</p>",
        "id": 180865897,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1573847620
    },
    {
        "content": "<p>Wouldn't it be more practical for the source/client to say its compatible with xxxx? Probably via documentation (which resembles a capability statement).</p>",
        "id": 180901693,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1573889828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span> You're free to strip profile claims.  But if you retain them and spit them out in subsequent query responses - and the instance is no longer (or never was) valid against those claims - then you're non-conformant.  If an instance declares a profile and isn't valid against that profile, the instance is non-conformant.</p>",
        "id": 180911026,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1573908585
    },
    {
        "content": "<p>So if you send something (perhaps as a result of a subscription or query, or trigger based) you'd better make sure that whatever profiles you include [if any] were validated by you as a sender ? If (as a server) I receive a profile on a resource, a profile that I don't know about nor care about, then I'd better strop it off as quickly as I can because it serves no purpose. Or at least; strip unknown profiles off incoming resources UNLESS (a) I still know who/what system send the profile to me in the first place [so at least I can send it back to them], (b) the resource hasn't been modified by any other system, and (c) my persistence layer allows me to fully reconstruct all data elements that were originally sent to me. That's a lot of ifs.</p>",
        "id": 180914130,
        "sender_full_name": "René Spronk",
        "timestamp": 1573914269
    },
    {
        "content": "<p>Yup.  Retaining profiles that you don't verify yourself - ideally on output - is a risky business</p>",
        "id": 180914151,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1573914351
    },
    {
        "content": "<p>Fair enough. So my little validator app should have an option to specify the profile to apply. I'll update the docs as well...</p>",
        "id": 180918834,
        "sender_full_name": "David Hay",
        "timestamp": 1573922121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  do you have links to where that is described in the spec? The doc I linked to doesn't seem to indicate that.</p>",
        "id": 181036539,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574098014
    },
    {
        "content": "<p>Also, to be transparent, my implementation doesn't currently support this (it would strip profiles sent in on write today). However, we've talked about the profile field in Meta over time and my understanding is that it shouldn't be considered perfectly reliable. I just want to make sure I understand it as this is something that comes up with many IG discussions.</p>",
        "id": 181036715,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574098122
    },
    {
        "content": "<p>As well as realities of use. IE: querying by a profile, many think they could do this and get only the data they want. But typically, they want data that logically meets a profile rather than strictly conforming. For example, If I query for the US Core vitals profile and it excludes vitals that my system knows about but that don't conform (freetext results, different units, etc), this is surprising to many apps.</p>",
        "id": 181036904,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574098224
    },
    {
        "content": "<blockquote>\n<p>it shouldn't be considered perfectly reliable</p>\n</blockquote>\n<p>It's a claim. It should be considered reliable in the sense that it reliably claims to conform. Whether the claim is reliable or not is testable.</p>",
        "id": 181037131,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574098344
    },
    {
        "content": "<p>as for querying, yes, that is a subtle point that we can't stop people being surprised about in either direction</p>",
        "id": 181037219,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574098416
    },
    {
        "content": "<blockquote>\n<p>excludes vitals that my system knows about but that don't conform</p>\n</blockquote>\n<p>But these should not exist...</p>",
        "id": 181037289,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574098452
    },
    {
        "content": "<p>I have seen heights recorded in something other than cm and inches, or fat fingered in with freetext units. I've seen weights in stones. We know they're height and weight, but spitting it out in a converted unit isn't an accurate representation of how it looks in the system</p>",
        "id": 181037670,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574098730
    },
    {
        "content": "<p>those are still vitals in our system, and would be shown in our vitals sections, but they don't strictly meet the international profile.</p>",
        "id": 181037721,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574098774
    },
    {
        "content": "<p>if you queried by the vitals category (not the profile), we would return them</p>",
        "id": 181037900,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574098890
    },
    {
        "content": "<p>The intent of the profile is that you <em>do</em> return them in a converted unit. If you are concerned with representation, you have the narrative and/or rendered value extension</p>",
        "id": 181040277,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574100606
    },
    {
        "content": "<p>if you think that statement is a problem, then you need to take that up with OO</p>",
        "id": 181040297,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574100620
    },
    {
        "content": "<p>Yeah, because if I had an app tell me to update it using the same unit, it would probably not make the system owner happy and there are precision issues as well</p>",
        "id": 181040764,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574100959
    },
    {
        "content": "<p>I thought that was why we had the conversion extensions - specifically for these types of issues/concerns</p>",
        "id": 181040832,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574100985
    },
    {
        "content": "<p>but now we're drifting :) It could be that it's not just the unit that we don't have/there are issues with</p>",
        "id": 181040850,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574101004
    },
    {
        "content": "<p>more common one is that we likely recognize it as a vital, may not recognize the underlying coding as weight or height, would return it by category query, and a human being would recognize that it was a weight :)</p>",
        "id": 181041042,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574101143
    },
    {
        "content": "<p>(but the computer didn't)</p>",
        "id": 181041050,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574101150
    },
    {
        "content": "<p>I'm more trying to understand how to be conformant if we do use the meta profile fields, because what I see in the spec is that we should try to make those accurate, but a system may choose to not automatically validate or update on every call</p>",
        "id": 181041176,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574101207
    },
    {
        "content": "<p>And Lloyd seems to be saying that would make the server non-conformant, but I'm not sure I can find the language for that field to back that/understand that</p>",
        "id": 181041214,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574101235
    },
    {
        "content": "<p>And I think what he is saying is what many people actually <em>expect</em> from that field - that it's supposed to be 100% accurate at all times, but the spec itself seems to not indicate that as a reality</p>",
        "id": 181041289,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574101296
    },
    {
        "content": "<p>I think that the text you are looking for is:</p>",
        "id": 181041687,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574101552
    },
    {
        "content": "<blockquote>\n<p>On the RESTful API: On receiving a write operation, the server MAY elect to remove invalid claims, SHOULD retain claims that are correct or untested, and MAY add additional claims it believes are valid</p>\n</blockquote>",
        "id": 181041692,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574101555
    },
    {
        "content": "<p>Profile declaration is irrelevant in terms of vital signs profiles.  If your system recognizes that an Observation is a height, weight or one of the other core-standardized vital signs profiles, you SHALL comply with the relevant profile (Including converting code or units).  You don't have to declare the profile, but you <em>must</em> comply with it.</p>",
        "id": 181043182,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1574102412
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  then that makes it look like that it's ok to be untested/unvalidated. It doesn't look like a <em>must</em> to validate that</p>",
        "id": 181045641,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574104033
    },
    {
        "content": "<p>And that is the statement I found earlier</p>",
        "id": 181045656,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1574104041
    },
    {
        "content": "<p>I don't know where you found that. Perhaps in some narrower context where an additional rules was being applied?</p>",
        "id": 181048744,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574106095
    },
    {
        "content": "<p>Revisiting this issue: profile seems to be mainly something we need at the communications layer, not at the persistence layer. Therefore, a server should probably use declared profiles [on an inbound resource] in any way it sees fit (validation, optimized processing), but strip it off before actually persisting the resource. Profiles could be retained as part of a Provenance resource if one so chooses. <br>\nBefore sending a resource, a server could attempt to detect which profiles a resource conforms to, and include any profiles in the meta tag. This could be a forced process if the context of the implementation has implicit rules around the use of profiles. Don't include any profiles in profiles that one hasn't validated as a server, for these may cause problems downstream.</p>",
        "id": 221201367,
        "sender_full_name": "René Spronk",
        "timestamp": 1609321425
    }
]