[
    {
        "content": "<p>There are various resources that can contain very long lists of elements (eg List, Group, ValueSet) - it can be unpractical to GET one  of those in one go. Is there any way to 'page' through their content that I missed? If not - should we define maybe operation(s) to page through those lists?</p>",
        "id": 164997621,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557161010
    },
    {
        "content": "<p>I guess an API could implement something like this in the transport layer. Not sure if it is wise to pull this into the FHIR spec. Note that resource fragments are not valid json/xml.</p>",
        "id": 165003695,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1557165512
    },
    {
        "content": "<p>ValueSet expansion has paging parameters in the $expand operation.</p>",
        "id": 165003783,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557165592
    },
    {
        "content": "<p>nothing general so far</p>",
        "id": 165004317,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557165913
    },
    {
        "content": "<p>so is the implication that we need something like <code>_elements=someProperty[0..10]</code> ?</p>",
        "id": 165004506,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557166065
    },
    {
        "content": "<p>Maybe ... but I was thinking more along the lines of the way the $expand operation works, specifying a range (and relying on the fact that there is only one element that needs the paging)</p>",
        "id": 165004897,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557166336
    },
    {
        "content": "<p>sounds like graphQL</p>",
        "id": 165005625,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557166891
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> yes, you can do things at the transport layer, but the problem I am thinking about is the client having to limit the elements it gets for display or processing reasons, and so it would need valid json/xml resources, that transport layer stuff does not get you</p>",
        "id": 165005750,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557166962
    },
    {
        "content": "<p>As Michel, I'm also not sure whether this should be covered in FHIR core.<br>\nIf I was in the need, I would probably put up a custom operation on Group/List.</p>\n<p>What is your use case? Especially: is it necessary to have a Group or List, or might a search give the same results (e.g. using tags on the resources) - since a searchset Bundle has all that stuff out of the box</p>",
        "id": 165006108,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1557167195
    },
    {
        "content": "<p>Our specific use case is List, and we did solve it with a custom operation that returns a subsetted List with only a range of items</p>",
        "id": 165006300,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557167348
    },
    {
        "content": "<p>But seems a fairly general case, hence my question here</p>",
        "id": 165006329,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557167384
    },
    {
        "content": "<p>(Group are in the proposed bulk data specs, so systems that implement that are going to have large Groups to deal with)</p>",
        "id": 165006621,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557167544
    },
    {
        "content": "<p>Huge resources maybe a bad idea. That's why for terminology in aidbox we  introduced Concept resource and sptit StructureDefinition into Element (Attribute) resource. Because after paging you will want sorting and filter, concurent update problems, hisory problems etc - you will duplicate half of api :(</p>",
        "id": 165040556,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557201889
    },
    {
        "content": "<p>We also need ndjson representation of bundle for efficient stream processing</p>",
        "id": 165040654,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557202027
    },
    {
        "content": "<blockquote>\n<p>Huge resources maybe a bad idea</p>\n</blockquote>\n<p>Maybe they are a bad idea, but it is what we have....</p>",
        "id": 165082965,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557243632
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> I don't understand how Concept resource could reduce the number of items in value set expansion.</p>",
        "id": 165083416,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557243908
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191764\">@Cooper Thompson</span> and I were talking about that following a discussion earlier today in PA.</p>",
        "id": 165083507,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557243955
    },
    {
        "content": "<p>FHIR already has an elegant solution for this for the Bundles returned by searches.  How directly can we leverage that?</p>",
        "id": 165083579,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557243982
    },
    {
        "content": "<p>List has the List.entry BackboneElement.  What if we had a new resource, ListEntry, that had the same elements as List.entry?</p>",
        "id": 165083649,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557244041
    },
    {
        "content": "<p>Following <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> 's comment, I think you first have to answer why graphql is not an appropriate solution.</p>",
        "id": 165083685,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557244072
    },
    {
        "content": "<p>Then the List could have a new element, List.entryBundle to point to a Bundle of ListEntry resources.</p>",
        "id": 165083693,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557244078
    },
    {
        "content": "<blockquote>\n<p>Following <span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> 's comment, I think you first have to answer why graphql is not an appropriate solution.</p>\n</blockquote>\n<p>I don't think it's unreasonable to consider multiple possible solutions and evaluate their relative merits.  (Except when one has already been adopted; in that case I agree that whoever wants to present an alternative first needs to explain why we should discard what we're already doing.)</p>",
        "id": 165083923,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557244231
    },
    {
        "content": "<p>When Bundle is used as search result, the client can indicating paging using _count parameter. Similarly for valueSet expansion, client can provide offset and count for paging. When client request List/Group resource, what is the parameter for client to ask server for paging?</p>",
        "id": 165084228,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557244493
    },
    {
        "content": "<p>For the ListEntry solution, a client would GET [base]/List/[id], find the url for the List.entryBundle, and GET the linked Bundle.  If the server didn't want to return the contents of the Bundle in a single page, it would provide a URL for the next page.  </p>\n<p>For <a href=\"https://www.hl7.org/fhir/graphql.html\" target=\"_blank\" title=\"https://www.hl7.org/fhir/graphql.html\">graphQL</a>, how does this work?  It looks like the client would POST to [base]/List/[id]/$graphql</p>",
        "id": 165084439,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557244636
    },
    {
        "content": "<p>What does the client POST there?</p>",
        "id": 165084459,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557244662
    },
    {
        "content": "<blockquote>\n<p>When Bundle is used as search result, the client can indicating paging using _count parameter. Similarly for valueSet expansion, client can provide offset and count for paging. When client request List/Group resource, what is the parameter for client to ask server for paging?</p>\n</blockquote>\n<p>It could use the same syntax as a search.  In fact, it could <strong>be</strong> a search.  If ListEntry has a List element that's a Reference to the parent list, the List.entryBundle element could be a uri to the search.  [base]/ListEntry?list=[the List's id]</p>",
        "id": 165084720,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557244822
    },
    {
        "content": "<p>If we have a separate ListEntry resource then we can do normal paged searches directly on that I guess?</p>",
        "id": 165084734,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557244838
    },
    {
        "content": "<blockquote>\n<p>If we have a separate ListEntry resource then we can do normal paged searches directly on that I guess?</p>\n</blockquote>\n<p>Yes!</p>",
        "id": 165084779,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557244870
    },
    {
        "content": "<p>(I typed it at the same time...)</p>",
        "id": 165084780,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557244870
    },
    {
        "content": "<p>I was using graphQL to get the list, I'd do Patches to update the list</p>",
        "id": 165084804,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557244891
    },
    {
        "content": "<p>A client could hit [base]/ListEntry?list=[the List's id]&amp;_count=100</p>",
        "id": 165084812,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557244898
    },
    {
        "content": "<p>graphQL is really neither here nor there for mutations</p>",
        "id": 165084823,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557244907
    },
    {
        "content": "<p>I assume Grahme was not proposing GraphQL as a solution - implementing a complete different API just to solve this does not seem very practical</p>",
        "id": 165084914,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557244945
    },
    {
        "content": "<p>I have to say, I really don't like the idea of ListEntry-  feels like cracking a nut with a bulldozer</p>",
        "id": 165084927,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557244956
    },
    {
        "content": "<p>That's fair.</p>",
        "id": 165084941,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557244968
    },
    {
        "content": "<p>How complex would graphQL be?  What would the body be?</p>",
        "id": 165084962,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557244981
    },
    {
        "content": "<p>I was reacting to the invention of a whole different API anyway that was like graphQL</p>",
        "id": 165084974,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557244985
    },
    {
        "content": "<p>I'm not following then; is there a solution you recommend for paging through a List?</p>",
        "id": 165085007,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245014
    },
    {
        "content": "<p>we've never really resolved the problem of a list getting too big. But i would say that the obvious solution is to add $subList $add $remove operations, and anything more sophisticated --&gt; graphQL</p>",
        "id": 165085259,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557245164
    },
    {
        "content": "<p>I suppose you could look at List fragments in the style of CodeSystem fragments</p>",
        "id": 165085293,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557245196
    },
    {
        "content": "<p>(not that it gets much use in CodeSystem implementations AFAIK)</p>",
        "id": 165085312,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557245213
    },
    {
        "content": "<p>of course, that would only work if Lists were defined with and referenced by something like a canonical</p>",
        "id": 165085364,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557245256
    },
    {
        "content": "<p>I don't disagree with Grahame's bulldozer point.  That said, every FHIR server has a bulldozer already, and every FHIR client knows how to drive one.</p>",
        "id": 165085510,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245350
    },
    {
        "content": "<p>I am a little bit lost in this discussion. So <span class=\"user-mention\" data-user-id=\"191936\">@Michael Donnelly</span> What is the proposed ListEntry resource and what is the difference from List?</p>",
        "id": 165085527,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557245362
    },
    {
        "content": "<p>yes we all know how to drive the big bulldozer (brrrrrrrm) but I don't think we always want to have to start it up just to get down the end of the driveway</p>",
        "id": 165085689,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557245454
    },
    {
        "content": "<p>My idea (just noodling, not a proposal yet) is to have a ListEntry resource that has the same elements as the List.entry (List-dot-entry) BackboneElement.  Then a client can search for the ListEntry resources that are on a List.</p>",
        "id": 165085735,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245491
    },
    {
        "content": "<p>And then the client, like Michele said, can page through those results because it would be a normal search.</p>",
        "id": 165085769,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245516
    },
    {
        "content": "<p>As I wrote above we solved it in our case adding a <code>../List/$getPage?pageSize=N&amp;pageNumber=M </code> operation  (and we tag the returned partial list as SUBSETTED) - that seems to be Grahame's $subList</p>",
        "id": 165085776,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557245519
    },
    {
        "content": "<p>yes your $getPage is pretty much the same as $subList - doesn't matter what it's called</p>",
        "id": 165085875,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557245565
    },
    {
        "content": "<p>Michele, how easy did clients find implementing that?</p>",
        "id": 165085876,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245565
    },
    {
        "content": "<p>And Grahame or Michele, what happens if the server wants to enforce paging even if the client doesn't ask for it?</p>",
        "id": 165085951,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245607
    },
    {
        "content": "<p>Don't know! Do not have any doing that yet (but it does not seem difficult)</p>",
        "id": 165085953,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557245608
    },
    {
        "content": "<p>I agree, but I've been a bad judge of that sometimes in the past.</p>",
        "id": 165085978,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245629
    },
    {
        "content": "<p>If the list is too big we return a 422 'too expensive'</p>",
        "id": 165086034,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557245646
    },
    {
        "content": "<p>And then the client can come back and ask again with a pageSize (or a smaller one)?</p>",
        "id": 165086075,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245676
    },
    {
        "content": "<p>and maybe a header link see..aslo... if you really want to be thorough</p>",
        "id": 165086086,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557245684
    },
    {
        "content": "<p>Yes</p>",
        "id": 165086102,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557245694
    },
    {
        "content": "<p>Do you have an OperationOutcome that lets the client know how big a request is allowed?</p>",
        "id": 165086133,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245710
    },
    {
        "content": "<p>No, did not go that far</p>",
        "id": 165086149,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557245725
    },
    {
        "content": "<p>But it wouldn't be hard.</p>",
        "id": 165086174,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245742
    },
    {
        "content": "<p>Don't understand 'see also' ?</p>",
        "id": 165086177,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557245746
    },
    {
        "content": "<p>No, not hard</p>",
        "id": 165086187,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557245755
    },
    {
        "content": "<p>(and our lists are read-only, so no need for $add, $remove....)</p>",
        "id": 165086279,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557245794
    },
    {
        "content": "<p>I think that's a perfectly reasonable solution.  </p>\n<p>I still think breaking out ListEntry would be easier for implementers (if harder for the standard), since developers of clients and servers would already have code to handle search paging, so there wouldn't be incremental effort for this.  BUT I'm not going to die on that hill.</p>",
        "id": 165086432,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557245897
    },
    {
        "content": "<p>see also - you could add a related link in an http header to advise clients that if they want to access a list you have said is too big, they can go there. (that's HATEOS). Of course, they will only know how to use 'there' if they have the secret knowledge from this conversation somehow, so it's not that useful</p>",
        "id": 165086440,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557245903
    },
    {
        "content": "<p>breaking into listEntry would be better for searching for List, but really  bad for almost every other use of list - e.g. in documents, or just maintaining the list</p>",
        "id": 165086511,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557245946
    },
    {
        "content": "<p>Could an alternative be to have an operation that could generate/return a sublist, perhaps even in the form of a bundle if you want to use that paging mechanism? (not advocating for it, just spitballing)</p>",
        "id": 165086657,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557246040
    },
    {
        "content": "<p>Hmmm.</p>",
        "id": 165086699,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557246068
    },
    {
        "content": "<p>e.g. <code>List/[id]/$enumerate?_count=10</code></p>",
        "id": 165086736,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557246100
    },
    {
        "content": "<p>that's what Michele has done and I proposed</p>",
        "id": 165086800,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557246126
    },
    {
        "content": "<p>That's pretty much what <span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> did, I think .</p>",
        "id": 165086807,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557246129
    },
    {
        "content": "<p>oh, sorry. great minds, I guess</p>",
        "id": 165086816,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557246138
    },
    {
        "content": "<p>OK - so agreed that the operation is the 'right' solution...should that be in the specs? Or not worth is?</p>",
        "id": 165086884,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557246192
    },
    {
        "content": "<p>Should it be an operation or might it be just a link element (as in Bundle) plus search-like parameters?</p>",
        "id": 165087020,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1557246285
    },
    {
        "content": "<p>yes please create a task to add $getPage, $add $remove to the spec.</p>",
        "id": 165087080,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557246338
    },
    {
        "content": "<p>Is $add operation for adding item to the list?</p>",
        "id": 165087486,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557246604
    },
    {
        "content": "<p>Yes - so you do not have to POST or PUT the entire thing</p>",
        "id": 165087546,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557246654
    },
    {
        "content": "<p><a href=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=21650\" target=\"_blank\" title=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=21650\">GF#21650</a></p>",
        "id": 165092588,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557250352
    },
    {
        "content": "<p>I think count is a great idea, but I'm concerned about offset.  </p>\n<p>What if instead we had an equivalent to the next link in a Bundle?  As a server, if we have to support offset, we will need to iterate through the previous entries to count up to the offset.  If we return an opaque session parameter (like we do for a search), the client can pick up where it left off without an additional burden on the server.</p>",
        "id": 165094537,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557251659
    },
    {
        "content": "<p>see extensive discussion of this on the terminology stream with regard to expand. What I've learnt is that people feel very passionate about this but I can't figure out why</p>",
        "id": 165095815,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557252426
    },
    {
        "content": "<p>Copied that from $expand - for a List and Group the server should have the complete list of entries / members stored somewhere, so jumping to an offset does not seem that hard? (On searches is more complex because those are generated on the fly)</p>",
        "id": 165095919,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557252512
    },
    {
        "content": "<p>What should happen if the List resource changes between iterations?</p>",
        "id": 165096190,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557252703
    },
    {
        "content": "<p>offset problems should happen. Whatever the approach is</p>",
        "id": 165096484,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557252895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> Good point! since ValueSet expansion does not change that often.</p>",
        "id": 165096614,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557252967
    },
    {
        "content": "<blockquote>\n<p>What should happen if the List resource changes between iterations?</p>\n</blockquote>\n<p>mhh..nothing? If offset is beyond the end return no entries / members (that would be the same behavior even if the resource did not change)</p>",
        "id": 165096777,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557253119
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> For example, client got first 100 item, then a new item was inserted at index 50, then the client requested next 100, the client could get the same item (index 100 before insert and index 101 after insert) twice.</p>",
        "id": 165096986,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557253292
    },
    {
        "content": "<p>Yes - I'd be ok with that</p>",
        "id": 165097085,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557253362
    },
    {
        "content": "<blockquote>\n<p>What should happen if the List resource changes between iterations?</p>\n</blockquote>\n<p>It should work the same way as a typical relational database cursor. Although there is some variation between database products, the usual approach is to take a <strong>snapshot</strong> during the initial request. Then as long as the cursor is open the client can page back and forth through that snapshot and won't see any changes.</p>",
        "id": 165097215,
        "sender_full_name": "Nick Radov",
        "timestamp": 1557253467
    },
    {
        "content": "<p>It is possible for Server to inform client that the list is changed. Other than that I don't know what else the server could do.</p>",
        "id": 165097231,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557253487
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220686\">@Nick Radov</span> In theory this is good. I guess this put burden on server side complexity.</p>",
        "id": 165097418,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557253611
    },
    {
        "content": "<blockquote>\n<p>I guess this put burden on server side complexity.</p>\n</blockquote>\n<p>Not only on the server - the client should know / communicate which snapshot it is paging through, you'll need the same approach as a normal search - with next / previous links in the response etc. I would not go there</p>",
        "id": 165097545,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557253707
    },
    {
        "content": "<p>If you use the ETAG of the underlying Resource, then that should be usable to detect whether a change has happened; simple for client &amp; server</p>",
        "id": 165098113,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557254093
    },
    {
        "content": "<p>Not simple for the server.  If there's a list of 3500 entries and a client asks for 100 of them, the server would need to look at all 3500 to generate an etag.</p>",
        "id": 165100401,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557255652
    },
    {
        "content": "<p>There are problems not only with the size of huge resources but with concurrent updates and history as well.  ListEntry, GroupEntry, Element, Concept is an approach to efficiently reuse existing FHIR API and implementations</p>",
        "id": 165107827,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557260867
    },
    {
        "content": "<p>Otherwise, we have to add more and more irregularity and duplication into implementations.</p>",
        "id": 165108001,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557260961
    },
    {
        "content": "<p>I'm not sure why adding resource types would be any less disruptive than adding operations</p>",
        "id": 165108240,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557261115
    },
    {
        "content": "<p>Still don't understand how Concept could help paging  ValueSet expansion</p>",
        "id": 165108304,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557261132
    },
    {
        "content": "<p>... which already works</p>",
        "id": 165108333,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557261162
    },
    {
        "content": "<p>Because they  duplicate logic of  Search/ POST/PUT/PATCH</p>",
        "id": 165108340,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261167
    },
    {
        "content": "<p>Can you clarify?</p>",
        "id": 165108406,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557261217
    },
    {
        "content": "<blockquote>\n<p>Still don't understand how Concept could help paging  ValueSet expansion</p>\n</blockquote>\n<p>Concept resource turn expansion into FHIR Search</p>",
        "id": 165108408,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261220
    },
    {
        "content": "<p>expansion does a very different thing to FHIR Search</p>",
        "id": 165108477,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557261250
    },
    {
        "content": "<p>What is the difference?</p>",
        "id": 165108544,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261301
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> I guess your solution is that ValueSet.expansion contain [0..*] Concept and each Concept has a reference back to ValueSet so you search Concept?valueSet.id=12345. Is that correct?</p>",
        "id": 165108781,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1557261445
    },
    {
        "content": "<p>In 80% yes :)</p>",
        "id": 165108800,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261471
    },
    {
        "content": "<p>may be more</p>",
        "id": 165108809,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261476
    },
    {
        "content": "<p>In real apps probably 95%</p>",
        "id": 165108906,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261526
    },
    {
        "content": "<p>I'm pretty sure efficient terminology server do the same materialization internally?!</p>",
        "id": 165109129,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261676
    },
    {
        "content": "<p>Nope</p>",
        "id": 165109158,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557261711
    },
    {
        "content": "<p>Please, fix me if i'm wrong</p>",
        "id": 165109248,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261749
    },
    {
        "content": "<p>Our product doesn't do that. And we certainly consider it to be an efficient terminology server.</p>",
        "id": 165109322,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557261800
    },
    {
        "content": "<p>So you eval each expansion on every GET?</p>",
        "id": 165109347,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261824
    },
    {
        "content": "<p>I think ratio read to write for terminology server in production is about 1000 / 1</p>",
        "id": 165109447,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261875
    },
    {
        "content": "<p>Well, that's complicated, but we don't store mappings of codes to the ValueSets of which they are a member</p>",
        "id": 165109451,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557261882
    },
    {
        "content": "<p>Give me an example, where this approach will not work</p>",
        "id": 165109486,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261913
    },
    {
        "content": "<p>You can always supply a new ValueSet with your expand request. Either as an implicit ValueSet, or as a POST parameter to $expand</p>",
        "id": 165109493,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557261922
    },
    {
        "content": "<p>And this is a powerful thing to do, and something we do often</p>",
        "id": 165109504,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557261933
    },
    {
        "content": "<p>That's good for authoring - not for expluatation</p>",
        "id": 165109514,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557261941
    },
    {
        "content": "<p>Ours is not primarily an authoring product</p>",
        "id": 165109525,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557261954
    },
    {
        "content": "<p>I think we're well off topic. ValueSet is different from List and Group, in that it already has a Normative mechanism for paging content</p>",
        "id": 165109647,
        "sender_full_name": "Jim Steel",
        "timestamp": 1557262062
    },
    {
        "content": "<p>Ok. But for me, it's a similar technical problem/anti-pattern.</p>",
        "id": 165109740,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557262127
    },
    {
        "content": "<p>We've already got a request to support List with millions of references :(</p>",
        "id": 165109794,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557262180
    },
    {
        "content": "<p>I'm a little bit scared - guys want to search by reference on these resources, probably next step is _revinlcude=* :).</p>",
        "id": 165109893,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557262236
    },
    {
        "content": "<p>Yes, we can hack it and apply a different  strategy for storing and manipulating Lists - but that's will bring duplication</p>",
        "id": 165110041,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557262342
    },
    {
        "content": "<p>And yeah - internally we will do ListEntry for that :)</p>",
        "id": 165110443,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557262673
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191936\">@Michael Donnelly</span> I don't follow.  If I have a List resource with 100000 members and you ask for 100..200, the ETAG for the List containing the subset is the ETAG for the original List, i.e., based on the technical version.  No need to inspect anything.</p>",
        "id": 165152855,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557313501
    },
    {
        "content": "<p>That depends on how the List is represented in the server.  If it's a native FHIR server, and there's a List record with all those lines in it, you're great.  But if the list is a virtual thing in a façade server, it's a horse of an entirely different color.</p>",
        "id": 165213976,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362339
    },
    {
        "content": "<p>For us, functionally speaking, returning entries if a List would be basically the same as returning entries in a search.</p>",
        "id": 165214085,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362517
    },
    {
        "content": "<p>In both cases, we (usually) use iterator functions.  So each time we do a search, we call the \"get the next result\" function until we've hit the _count limit.</p>",
        "id": 165214138,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362549
    },
    {
        "content": "<p>When we hit that limit for a search, we set a bookmark, generate a session token associated with it, and return the session token with the results.</p>",
        "id": 165214158,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362589
    },
    {
        "content": "<p>When a client hits the next url, it includes the session token, and we can find the bookmark and keep searching.</p>",
        "id": 165214163,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362607
    },
    {
        "content": "<p>If we had to do an offset instead of a bookmark, we'd start at the beginning and count the entries over which we iterated.</p>",
        "id": 165214170,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362636
    },
    {
        "content": "<p>And we hit the offset, we would start getting results.</p>",
        "id": 165214216,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362646
    },
    {
        "content": "<p>So we'd have to loop over a bunch of entries - more each page - even though the client didn't need them.</p>",
        "id": 165214225,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362677
    },
    {
        "content": "<p>An ETAG for what's basically a search would be even worse.  We'd need to iterate over the entire list, <strong>store it somewhere as an entire list</strong>, and take a checksum of it.</p>",
        "id": 165214248,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362712
    },
    {
        "content": "<p>We wouldn't be able to count on keeping that in memory, so we'd have to write the list to disk, checksum it, and then discard that storage.</p>",
        "id": 165214303,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362777
    },
    {
        "content": "<p>Not excellent from a performance standpoint.</p>",
        "id": 165214306,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557362789
    },
    {
        "content": "<p>Right...so your List is really a view of a search result / a dynamically generated thing; you don't have an internal list of references that are pro-actively maintained?</p>",
        "id": 165214377,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557362903
    },
    {
        "content": "<p>Correct.</p>",
        "id": 165214454,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557363010
    },
    {
        "content": "<p>So I think we have a three by two array of options (if we're using operations instead of new resource and a search):<br>\n1. The client specifies an offset. <br>\n2. The client specifies a bookmark (basically, the last entry it got last time).<br>\n3. The server specifies a session token /  a next link.</p>",
        "id": 165214473,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557363054
    },
    {
        "content": "<p>The other axis is with or without ETAGs.</p>",
        "id": 165214479,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557363062
    },
    {
        "content": "<p>Option 2 or option 3 would be equally good for us.</p>",
        "id": 165214495,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557363088
    },
    {
        "content": "<p>Would option 2 be as good for you as option 1?</p>",
        "id": 165214505,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557363103
    },
    {
        "content": "<p>But if a client wants items 200..220 then they still need to iterate through with the next links and thus all the round-trip requests, rather than doing that server-side</p>",
        "id": 165214559,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557363144
    },
    {
        "content": "<p>Instead of \"give me 100 entries starting with entry 201\" the client would say \"give me 100 entries starting after f2e65bf5-ea34-4430-88ff-faa8a9fb816f\" where f2e65bf5-ea34-4430-88ff-faa8a9fb816f is the 200th entry.</p>",
        "id": 165214566,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557363165
    },
    {
        "content": "<p>Would the client need 200..220 if it hadn't already gotten 1..199?</p>",
        "id": 165214581,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557363197
    },
    {
        "content": "<p>how does the client know about f2e65bf5-ea34-4430-88ff-faa8a9fb816f? Is it reasonable to assume that a client will only be interested in entries from 201 if she has previously looked at/retrieved up to item 200?</p>",
        "id": 165214633,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557363263
    },
    {
        "content": "<p>The client would only know that if she had retrieved the list through entry 200.</p>",
        "id": 165216385,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557365486
    },
    {
        "content": "<p>I <strong>think</strong> a client would only care about 201 having seen 1..200, but I'm definitely interested in hearing about other use cases.</p>",
        "id": 165216440,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557365557
    },
    {
        "content": "<p>this is the same discussion as for ValueSet.expand - state based or offset based. <br>\n<span class=\"user-mention\" data-user-id=\"191936\">@Michael Donnelly</span> I expect that the statement \"your List is really a view of a search result / a dynamically generated thing\" will not necessarily be true for all lists you deal with (in fact, it's likely that most legacy systems will have a mix of literal and inferred lists like this)</p>",
        "id": 165239981,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557397306
    },
    {
        "content": "<p>Similar, yes, although I expect that there's a lot more literal Lists than there are literal ValueSet expansions.</p>",
        "id": 165240283,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557397581
    },
    {
        "content": "<p>not in USA where the habitual practice is distributing expansions</p>",
        "id": 165240528,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557397838
    },
    {
        "content": "<p>as I have only recently begun to recognize</p>",
        "id": 165240943,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557398287
    },
    {
        "content": "<p>\"not in USA where the habitual practice is distributing expansions\" is a habitual practice in and around VSAC and quality measures, but I don't think it's really the established practice in general outside of that</p>",
        "id": 165241146,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1557398550
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"191936\">Michael Donnelly</span> I expect that the statement \"your List is really a view of a search result / a dynamically generated thing\" will not necessarily be true for all lists you deal with (in fact, it's likely that most legacy systems will have a mix of literal and inferred lists like this)</p>\n</blockquote>\n<p>True.</p>",
        "id": 165248018,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557405454
    },
    {
        "content": "<p>Likely, though, the larger the list the higher the odds that it isn't a single composed entity.</p>",
        "id": 165248037,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557405481
    },
    {
        "content": "<p>As for state-based vs offset-based, how do you feel about the middle ground where the client specifies the entry after which it wants new entries?  I believe this gives both sides what they want.  <span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span>?  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>?</p>",
        "id": 165248198,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557405583
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191936\">@Michael Donnelly</span> : what are your list? From what you write I assume they cannot be created / modified via FHIR</p>",
        "id": 165249646,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557406788
    },
    {
        "content": "<p>What we've done so far is a List of Patients.  It's the same patient list that clinicians and administrative staff use in the hospital.  This includes:</p>\n<ul>\n<li>A physician's \"My List\" of patients he or she is attending</li>\n<li>A list of all the patients roomed in a specific unit</li>\n<li>A census of all the patients in the hospital</li>\n</ul>\n<p>These are actually two kinds of list.  One is built in the system with rule-based criteria (e.g. \"patients in the ICU\").  The other is a manually managed list to which a user adds and removes patients.</p>",
        "id": 165251359,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557408076
    },
    {
        "content": "<p>The system list will never be modifiable with FHIR.  The user-managed list can't be updated with FHIR <em>yet</em>, but we could add that in the future.</p>",
        "id": 165251442,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557408127
    },
    {
        "content": "<p>We haven't gotten requests for it, but if someone in the App Orchard was interested, we would look into it.</p>",
        "id": 165251458,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557408149
    },
    {
        "content": "<p>I haven't done a lot of work in that space, but my gut says that managing it with FHIR would be straightforward. (But don't quote me on that. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> )</p>",
        "id": 165251525,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557408208
    },
    {
        "content": "<p>So the big one can be the patient in the hospital - some 1000s' ? Just do not implement $getPage - and do not worry about it</p>",
        "id": 165251583,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557408243
    },
    {
        "content": "<p>I think the concept of bookmark-based paging through a list would also apply to valueset expansion.</p>",
        "id": 165251612,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557408247
    },
    {
        "content": "<blockquote>\n<p>So the big one can be the patient in the hospital - some 1000s' ? Just do not implement $getPage - and do not worry about it</p>\n</blockquote>\n<p>Not a bad point.</p>",
        "id": 165251652,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557408274
    },
    {
        "content": "<p>No client yet has a use case where they need to fetch a list with more than 1,000 entries.  I <em>believe</em> today that if a List will contain more than 1,000 entries, we return an error instead of the List.</p>",
        "id": 165251756,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557408333
    },
    {
        "content": "<p>I'm always wary of things like that, though.  Too often when I've said, \"but nobody would ever need to...\" I've later been proven wrong.</p>",
        "id": 165251845,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557408377
    },
    {
        "content": "<p>So in your case, <span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span>, how well would it work to request an offset by referring to the last entry you got rather than a number of entries?</p>",
        "id": 165251906,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557408437
    },
    {
        "content": "<p>We will have to search for that entry every time - not great, not too bad - but: that assumes that the same resource appears only once in a List (or Group) - and that is not in the specs</p>",
        "id": 165252150,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1557408594
    },
    {
        "content": "<p>here's a thought - if the server has a \"next token\", then the server can keep an association between this token and the corresponding offset-based link, then recognises this in the next request from the client and substitutes the token to avoid re-performing the search.<br>\nSpecifically:<br>\n1. client asks for /List/icu-patients?count=10<br>\n2. server performs search, iterates to construct List of Patients 0..9<br>\n3. server sets bookmark &amp; generates session token then associates it with /List/icu-patients?offset=10<br>\n4. client gets List, does whatever, and then asks for /List/icu-patients?count=10&amp;offset=10<br>\n5. server looks up url /List/icu-patients?offset=10 and finds a session token, continues iterating to build List of next 10 Patients, and continues as per step 3<br>\nIf client instead asks for /List/icu-patients?count=10&amp;offset=11, then server needs to re-perform search, skip over first 11, etc  But, use cases suggest this is not a likely case.</p>",
        "id": 165252573,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557408883
    },
    {
        "content": "<p>That would probably work.  I'd worry about edge cases it might introduce.</p>",
        "id": 165252661,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557408953
    },
    {
        "content": "<blockquote>\n<p>We will have to search for that entry every time - not great, not too bad - but: that assumes that the same resource appears only once in a List (or Group) - and that is not in the specs</p>\n</blockquote>\n<p>That's a major flaw in my idea, then. <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span></p>",
        "id": 165252748,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557409001
    },
    {
        "content": "<p>Has there been discussion about why a List can include duplicate entries?</p>",
        "id": 165252812,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557409051
    },
    {
        "content": "<p>This is just your option 3, but with implicit next links.  The main thing to be concerned about is that the client could re-issue its query with the offset in any place (and in fact reorder all parameters arbitrarily), so you need to do some URL normalisation process as part of the session token lookup</p>",
        "id": 165254567,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557410372
    },
    {
        "content": "<p>Totally.</p>",
        "id": 165275089,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557425101
    },
    {
        "content": "<p>I know we've taken that into account for search, so presumably we'd use the same logic.</p>",
        "id": 165275118,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557425121
    },
    {
        "content": "<p>In theory an ordered List could indicate who you're seeing that day - and the same patient might appear more than once.  Though you could fix that problem by making it a List of Appointments instead...</p>",
        "id": 165277789,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1557427004
    },
    {
        "content": "<p>Let me try a different angle: what need do clients have that would not be met by an opaque bookmark?  Note that nothing would stop a server from returning an opaque bookmark that happened to be a numeric offset.</p>",
        "id": 165285720,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1557433253
    },
    {
        "content": "<p>This thread sort of just stopped. <br>\nOne of the benefits of the next links used in the searching is that if the server doesn't like the page size provided, it can adjust it and continue, whereas the explicit use of count/page pairs just has to error out that the page size it too big.</p>",
        "id": 169839520,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1562559455
    }
]