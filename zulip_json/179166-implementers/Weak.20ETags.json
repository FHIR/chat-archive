[
    {
        "content": "<p><a href=\"http://community.fhir.org/t/weak-etags-and-the-if-match-header/1420\" target=\"_blank\" title=\"http://community.fhir.org/t/weak-etags-and-the-if-match-header/1420\">http://community.fhir.org/t/weak-etags-and-the-if-match-header/1420</a></p>",
        "id": 170670806,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1562877869
    },
    {
        "content": "<p>The relevant words are </p>\n<blockquote>\n<p>An origin server MUST use the strong comparison function when comparing entity-tags for If-Match</p>\n</blockquote>",
        "id": 170670985,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1562877991
    },
    {
        "content": "<p>I'm not sure what to think about this; if-match can't work for RESTful interfaces that use mime types properly....</p>",
        "id": 170671023,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1562878029
    },
    {
        "content": "<p>we discussed the use of weak and strong e-tags with IETF HTTP Wg, but did not discuss the use of if-match and I think we missed the sentence i quoted above</p>",
        "id": 170671071,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1562878067
    },
    {
        "content": "<blockquote>\n<p>I'm not sure what to think about this; if-match can't work for RESTful interfaces that use mime types properly....</p>\n</blockquote>\n<p>I don't see why If-Match shouldn't work with RESTful interfaces that use MIME types (content negotiation). One important thing to remember is, that ETags are about the representations and not only about the resource state. </p>\n<p>I'm quite new to FHIR but I have a strong background in REST. As I approached FHIR, I always wondered why the term representation isn't used in the spec. The wording is always about exchanging resources, but REST is about exchanging representations of resources. Thats why REST is called REpresentational State Transfer.</p>\n<p>So in REST the resource state isn't observable directly. The resource state is only observable through representations. In <a href=\"https://www.hl7.org/fhir/http.html#concurrency\" target=\"_blank\" title=\"https://www.hl7.org/fhir/http.html#concurrency\">HTTP - Managing Resource Contention</a> the wording is:</p>\n<blockquote>\n<p>If provided, the value of the ETag SHALL match the value of the version id for the resource.</p>\n</blockquote>\n<p>The version id however only changes with the resource state, not with different representations. In FHIR representations can vary not only by MIME type (JSON, XML, RDF), they can also vary by subsetting through <code>_summary</code> or <code>_elements</code>. At least I would see subsetting as a variance in the representation and not as a different resource. So in my opinion, the version id isn't sufficient for an ETag. We have to put all the variables in the ETag which could lead to different representations.</p>\n<p>Also using a weak ETag with only the version id in it isn't very inline with the HTTP spec. In <a href=\"https://tools.ietf.org/html/rfc7232#section-2.1\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc7232#section-2.1\">RFC 7232 - Weak versus Strong</a>, the following paragraph can be found:</p>\n<blockquote>\n<p>[...] or a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data.  An origin server SHOULD change a weak entity-tag whenever it considers prior representations to be unacceptable as a substitute for the current representation.  In other words, a weak entity-tag ought to change whenever the origin server wants caches to invalidate old responses.</p>\n</blockquote>\n<p>Reading this carefully, a XML representation can never be a substitute for say a JSON representation. So weak ETags should used for somehow grouping equivalent representations. Also the example with the weather report in the next paragraph shows this very good. On the other hand, strong ETags are required to change with every representation change.</p>\n<p>At the end, the only way I see, that conditional updates using the If-Match header could be implemented inline with REST and the HTTP spec, is to move to strong ETags. </p>\n<p>I'm also curious about, what was the reason behind not using the term representation in FHIR?</p>",
        "id": 170884047,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1563190047
    },
    {
        "content": "<p>The expectation is that the information conveyed is identical for all representations and it should be possible to read using JSON and then write using XML.  That's what creates ETag issues</p>",
        "id": 170900075,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1563202266
    },
    {
        "content": "<p>But if you consider caching, a cache could return a XML representation when a client really asked for a JSON one. Because the ETag would be the same and the cache can’t tell the difference between XML and JSON.</p>",
        "id": 170901472,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1563203228
    },
    {
        "content": "<p>For writes, it’s still possible to use both XML and JSON, because a resource can have multiple ETags, one for each representation.</p>",
        "id": 170902248,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1563203703
    },
    {
        "content": "<p>We're treating ETag as being representation-independent.  It equates to the 'version' of the resource.  A given version can be represented using multiple syntaxes.  The syntax doesn't change the meaning of the content.</p>",
        "id": 170902356,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1563203771
    },
    {
        "content": "<p>You are right, that all available representations (syntax as you say) should, or in FHIR even must, convey the same content or let's say state of a resource. And it's also right that the identifier of such a state, the version id, should be sufficient to prevent loosing edits (conditional update). </p>\n<p>But, maybe sadly, HTTP doesn't work this way. HTTP considers resources as black boxes and doesn't allow to observe their state directly. Instead HTTP defines <a href=\"https://tools.ietf.org/html/rfc7231#section-3\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc7231#section-3\">Representations</a> that reflect the state of the resource but aren't the state itself. So HTTP has no concept of an internal version id.</p>\n<p>Instead the headers ETag and Last-Modified, also called the <a href=\"https://tools.ietf.org/html/rfc7231#section-7.2\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc7231#section-7.2\">Validator Header Fields</a> are about the selected representation:</p>\n<blockquote>\n<p>Validator header fields convey metadata about the selected representation.</p>\n</blockquote>\n<p>So according the HTTP spec, the ETag header can't be representation independent. If FHIR want's to use such version id with applied semantics, custom header fields would be the right way to do it. Using the ETag, If-None-Match and If-Match with a resource-independent ETag would break intermediates like caches.</p>\n<p>And now the funny part: I just discovered that an old HTTP RFC the <a href=\"https://tools.ietf.org/html/rfc2068\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc2068\">RFC 2068</a> had a <a href=\"https://tools.ietf.org/html/rfc2068#section-19.6.2.2\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc2068#section-19.6.2.2\">Content-Version</a> and a Derived-From header with exactly the semantics FHIR likes to use. But they weren't taken over to <a href=\"https://tools.ietf.org/html/rfc2616\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc2616\">RFC 2016</a> because they <a href=\"https://tools.ietf.org/html/rfc2616#section-19.6.3\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc2616#section-19.6.3\">weren't widely implemented</a>.</p>",
        "id": 170909174,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1563208250
    },
    {
        "content": "<p>We deal with caching and the MIME (and other similar) issues where representation varies outside of URL changes through the Vary header.</p>",
        "id": 170926568,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1563220882
    },
    {
        "content": "<blockquote>\n<p>I'm also curious about, what was the reason behind not using the term representation in FHIR?</p>\n</blockquote>\n<p>Because it never become a useful way to talk about the issues we have faced in practice. It's certainly true that you only deal with representations, and we don't have any disagreement with that</p>",
        "id": 170937786,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1563230053
    },
    {
        "content": "<p>I didn't follow all you said because you weren't differentiating between week and strong etags. I think that most of your claims were about strong ETags and that's why we don't use them. I did run the logic on this by <span class=\"user-mention\" data-user-id=\"192267\">@Eric Prud'hommeaux</span> and MNot when we were first working on it. We wanted to use strong etags but can't. But I don't see (then or now) why weak etags are wrong</p>",
        "id": 170937919,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1563230193
    },
    {
        "content": "<blockquote>\n<p>We deal with caching and the MIME (and other similar) issues where representation varies outside of URL changes through the Vary header.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> Ok that works according to <a href=\"https://tools.ietf.org/html/rfc7234#section-4.1\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc7234#section-4.1\">Calculating Secondary Keys with Vary</a>. I have also tested this with nginx as caching reverse proxy.</p>",
        "id": 170982366,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1563281604
    },
    {
        "content": "<blockquote>\n<p>I didn't follow all you said because you weren't differentiating between week and strong etags. I think that most of your claims were about strong ETags and that's why we don't use them. I did run the logic on this by <span class=\"user-mention silent\" data-user-id=\"192267\">Eric Prud'hommeaux</span> and MNot when we were first working on it. We wanted to use strong etags but can't. But I don't see (then or now) why weak etags are wrong</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Ok with Mark Nottingham and Eric Prud'hommeaux, the right people already looked at the issue and I have to admit, the FHIR API is one of the best REST API's I saw.</p>\n<p>I was referring to strong and weak ETags. With weak ETags the origin server claims that representations with the same weak ETag can be considered the same regarding caching:</p>\n<blockquote>\n<p>In other words, a weak entity-tag ought to change whenever the origin server wants caches to invalidate old responses.</p>\n</blockquote>\n<p>I tested the caching with the following nginx config: <a href=\"https://gist.github.com/alexanderkiel/fbcebc83dfb337929d0420adab726f13\" target=\"_blank\" title=\"https://gist.github.com/alexanderkiel/fbcebc83dfb337929d0420adab726f13\">https://gist.github.com/alexanderkiel/fbcebc83dfb337929d0420adab726f13</a></p>\n<p>I used Postman with the Accept header <code>application/fhir+json</code> to access a Patient through <a href=\"http://localhost:8081/baseR4/Patient/22783\" target=\"_blank\" title=\"http://localhost:8081/baseR4/Patient/22783\">http://localhost:8081/baseR4/Patient/22783</a>. After that I repeated the request with the Accept header <code>application/fhir+xml</code> and got the JSON representation from the cache, while the cache was revalidating using <code>If-None-Match</code> with the weak ETag and the HAPI server was responding with a 304.</p>\n<p>As <span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> noted, it is right that one can solve the caching problem using the Vary header. In the Gist, I have the configuration of the Vary header commented. So if the origin server sends a vary header of at least <code>accept</code>, the cache can't use the representation with a different Vary header in the first place. So it is not revalidating. Instead it makes a normal GET request to the origin server.</p>\n<p>So maybe, if I'm right here, we should recommend that FHIR servers should use the Vary header if they support multiple representations.</p>\n<p>Regarding conditional updates (the root issue of this thread) using <a href=\"https://tools.ietf.org/html/rfc7232#section-3.1\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc7232#section-3.1\">If-Match</a>. HTTP if very clear about the comparison function:</p>\n<blockquote>\n<p>An origin server MUST use the strong comparison function when comparing entity-tags for If-Match (Section 2.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.</p>\n</blockquote>\n<p>The strong comparison function never matches on weak ETags. So I really don't see how <a href=\"https://www.hl7.org/fhir/http.html#concurrency\" target=\"_blank\" title=\"https://www.hl7.org/fhir/http.html#concurrency\">Managing Resource Contention</a> can work inline with the HTTP spec. But maybe I'm wrong here.</p>",
        "id": 170985638,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1563283884
    },
    {
        "content": "<p>I'll add investigating this to my todo list</p>",
        "id": 171808888,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1564174155
    },
    {
        "content": "<p>12 months later - any results of the investigation?<br>\nI <em>really</em> want to implement this (<code>If-Match</code> with weak etags), but if there's a better approach I'm all ears (eyes?)</p>",
        "id": 205096251,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1595842254
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span></p>",
        "id": 205096279,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1595842280
    },
    {
        "content": "<p>I didn't make any progress with this. I don't know how tot resolve it and be conformant with the HTTP spec; we can't use strong tags but we can't use weak tags either</p>",
        "id": 205168403,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1595884079
    },
    {
        "content": "<p>Which, I think, pushes us down the path of custom headers?<br>\nI'm not sure what that really buys us other than to-the-letter compliance with the HTTP spec.  I think the real question is whether breaking this part of the spec is likely to have consequences when interacting with other pieces of common web infrastructure like proxies, caches, and API gateways.</p>",
        "id": 205181747,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1595893370
    },
    {
        "content": "<p><a href=\"https://jira.hl7.org/browse/FHIR-31925\">https://jira.hl7.org/browse/FHIR-31925</a></p>",
        "id": 235229625,
        "sender_full_name": "Joe Lamy",
        "timestamp": 1618858184
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> <span class=\"user-mention\" data-user-id=\"241501\">@Caitlin Voegele</span> <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> <span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span>  <span class=\"user-mention\" data-user-id=\"191676\">@Lee Surprenant</span>  i wonder if you could comment on how your servers support If-Match on updates to guard against clobbering content that a client is unaware of. Do you support this use case with weak ETags, and would you prefer FHIR to change to a custom header (for purity of compliance with RFC7233) or leave things as they stand?</p>",
        "id": 235663930,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619093071
    },
    {
        "content": "<p>Hi Josh. The IBM FHIR Server supports If-Match with weak ETags set to the resource versionId as outlined in the spec. We’d prefer not to change this, but could possibly be convinced otherwise.</p>",
        "id": 235678932,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1619098874
    },
    {
        "content": "<p>(late to the party) What are the issues with strong and week ETag conformance?</p>",
        "id": 235681599,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1619099796
    },
    {
        "content": "<p><a href=\"http://jira.hl7.org/browse/FHIR-31925\">FHIR-31925</a> has a succinct distillation thanks to <span class=\"user-mention\" data-user-id=\"192274\">@Joe Lamy</span>; quoting here:</p>\n<blockquote>\n<p>The current specification defines usage of the HTTP If-Match header to manage resource contention on updates. However, as noted in this chat, this usage is in conflict with the underlying <a href=\"https://tools.ietf.org/html/rfc7232#section-3.1\">RFC 7232, section 3.1</a>. Simply stated, if servers obey the RFC, then conditional update using an ETag and If-Match should never work because it is a weak ETag.</p>\n</blockquote>\n<blockquote>\n<p>If servers are successfully making use of If-Match, and we are ok with a processing model that violates the RFC, then section 3.1.0.5 should call out the issue explicitly and specify the modified processing model.</p>\n</blockquote>",
        "id": 235689487,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619102339
    },
    {
        "content": "<p>Google supports If-Match with weak ETags as per the spec. This functionality is very useful and I'd like to expand it to PATCH/DELETE, and also <code>If-Match: *</code> and <code>If-None-Match: *</code> on methods where those make sense.</p>\n<p>Because there is no obvious way to change it to align with the RFC, and it is useful, I think we should keep it. Strict conformance with the HTTP spec would be purity at the expense of functionality.</p>\n<p>Maybe we should ask the IETF to create \"medium ETags\" and migrate to those.</p>",
        "id": 235719498,
        "sender_full_name": "Paul Church",
        "timestamp": 1619113603
    },
    {
        "content": "<p>Adding <span class=\"user-mention\" data-user-id=\"195075\">@Brendan Kowitz</span> </p>\n<p>We do support it. Every time you create, update or get a resource it returns an e-tag. After this if the client wanted to perform an update and ensure the update will only apply to the current state of the database they can pass back the If-Match header with the etag they have when fetching. If someone else has already updated the resource the etag will be different and the second update will return a conflict.</p>",
        "id": 235748848,
        "sender_full_name": "Caitlin Voegele",
        "timestamp": 1619125740
    },
    {
        "content": "<p>Agree, I think this is meeting the use-cases I've seen and looks to have consistent behavior across servers. I could also be convinced to change if there was a more compelling solution, but I don't see it as urgent either</p>",
        "id": 235760795,
        "sender_full_name": "Brendan Kowitz",
        "timestamp": 1619132034
    },
    {
        "content": "<p>I agree with the comments above: We support it in Firely Server as specified in the FHIR Spec. Changing the behaviour would not be a priority to us.</p>",
        "id": 236154948,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1619435345
    },
    {
        "content": "<p>Perhaps the appropriate outcome then is to explicitly document in the standard our awareness that \"yes, we're not technically conformant with the w3c spec, but we don't care because the functionality needed can't be achieved using a technically conformant mechanism\".</p>",
        "id": 236212139,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1619457911
    },
    {
        "content": "<p>I spoke with Yves Lafon and we came to the conclusion that FHIR can <em>appear to</em> use strong ETags.</p>",
        "id": 241131112,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622630037
    },
    {
        "content": "<p>specifically, FHIR can define a structured ETag (reminiscent of <a href=\"https://datatracker.ietf.org/doc/html/draft-ietf-http-negotiation-00#section-9.2\">https://datatracker.ietf.org/doc/html/draft-ietf-http-negotiation-00#section-9.2</a>) which captures the version number and the specific representation.</p>",
        "id": 241131225,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622630102
    },
    {
        "content": "<p>GET /Obs/obs1 Accept: application/json -&gt; ETag: \"v123;json\"<br>\nPUT /Obs/obs1 C-Type: text/turtle, If-Match: \"v123;json\" -&gt; 204 ETag: \"v124;ttl\"<br>\nPUT /Obs/obs1 C-Type: application/json, If-Match: \"v123;json\" -&gt;  412</p>",
        "id": 241131463,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622630269
    },
    {
        "content": "<p>That 1st PUT worked because the server split the ETag on the ';', got the version number, and saw that it was current, and updated the Resource.<br>\nThe 2nd failed 'cause the version number was no-longer current.</p>",
        "id": 241131809,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622630464
    },
    {
        "content": "<p>From the perspective of caches, the ETag looks like any opaque, strong ETag (I like my ETags strong and opaque)</p>",
        "id": 241131867,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622630514
    },
    {
        "content": "<p>Adding a Vary header on ETag will allow a proxy to honor byte-range requests because \"v123;json\" and \"v1234;ttl\" both map to individual cache entries (i.e. docs that it's seen go by and has indexed by URL and ETag).</p>",
        "id": 241132399,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622630877
    },
    {
        "content": "<p>with this structure ETag, any cache will see the Vary on ETag and the opaque value of the ETag and consider it a cache miss (i.e. distinct resource).</p>",
        "id": 241145141,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622639077
    },
    {
        "content": "<p>Can you expand on byte-range requests?  There's no expectation that the expressed XML and JSON are canonicalized.  Is there a risk if the serialization changes at all even if formally the data in the resource is identical?  E.g. if someone sets a pretty-print flag on a query, but asks for a byte range on a read?</p>",
        "id": 241149958,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1622641220
    },
    {
        "content": "<p>any change to the data would give you a new ETag.</p>",
        "id": 241151404,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622641852
    },
    {
        "content": "<p>GET /Obs/obs1 Accept: application/json -&gt; 200 ETag: \"v123;json\" Payload<br>\nGET /Obs/obs1 Accept: application/json, If-None-Match: \"v123;json\" -&gt; 304<br>\nPUT /Obs/obs1 C-Type: text/turtle, If-Match: \"v123;json\" -&gt; 204 ETag: \"v124;ttl\"<br>\nGET /Obs/obs1 Accept: application/json, If-None-Match: \"v123;json\" -&gt; 200 ETag: \"v124;ttl\" Payload</p>",
        "id": 241152255,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622642220
    },
    {
        "content": "<p>In Lloyd's example he's pointing out that</p>\n<div class=\"codehilite\"><pre><span></span><code>GET /Patient/1?pretty=true&amp;_format=json\nGET /Patient/1&amp;format=json\n</code></pre></div>\n\n<p>Needs to return different strong ETags. Which seems fine. All query parameters or headers that impact serialization need to be represented if you want strong ETags. (The details would be implementation specific and we wouldn't need to standardize them, as long as they worked functionally.)</p>",
        "id": 241154153,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1622643053
    },
    {
        "content": "<p>good point, but i think that just informs what goes into the second part of our structured ETag</p>",
        "id": 241161312,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622645931
    },
    {
        "content": "<p>basically, the 2nd part (not that the order matters, but i'm inheriting the assumption of the semantic segment being the first part from that ref'd RFC) can be exactly what we'd use for an ETag today; we just preface it with a \"version\" identifier (and throw \"\"s around it to not mislead the header parser)</p>",
        "id": 241161887,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622646146
    },
    {
        "content": "<p>Just so.</p>",
        "id": 241173878,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1622651245
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> - is this something we can get away with this far into normative?</p>",
        "id": 241181569,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1622654837
    },
    {
        "content": "<p>I think the main question is what it would buy us; it adds complexity to make clients understand different classes of ETags that a server might return, vs today <a href=\"http://build.fhir.org/http.html#versioning\">saying</a> \"The Version Id is represented in the ETag header\".</p>",
        "id": 241296341,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1622657085
    },
    {
        "content": "<p>I think the primary benefit would be that systems could make caching choices based on strong ETags.  I also thought there was an issue that we weren't strictly conformant with our use of weak e-tags.</p>",
        "id": 241320995,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1622668656
    },
    {
        "content": "<p>I think that this is a case of missed the boat. The real concern for me is the behavior of proxies and caches. I don't mind if we're diverging on the server (would prefer not to, but we're there now). But if w're breaking middleware, that's a bigger deal. I don't think we are...</p>",
        "id": 241337882,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1622681742
    },
    {
        "content": "<p>given that ETags are opaque, proxies and caches should never notice that you have useful structure in there. the only party that needs to look into the structure is the server.</p>",
        "id": 241418574,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622738976
    },
    {
        "content": "<p>Even the client doens't care. It gets an ETag and uses that ETag in an If-Match. It's just the server that knows that it can equate \"v123;json;pretty\" with \"v123;ttl;fugly\" without losing updates.</p>",
        "id": 241418943,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622739141
    },
    {
        "content": "<p>even byte-ranges work if the representation of \"v123;json;pretty\" is consistent</p>",
        "id": 241419054,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622739187
    },
    {
        "content": "<p>I also don't know how you can safely enable cross-format updates without some sort of semantic (component in the) ETag.</p>",
        "id": 241419349,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622739318
    },
    {
        "content": "<p>Right now we say we use weak etags  Are intermediaries going to cache or take any other action based on those?</p>",
        "id": 241429247,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1622743211
    },
    {
        "content": "<p>i think the question is what client/proxy behavior will change if we formalize the ETags (include version and representation flags) and remove the \"W/\" from them?</p>",
        "id": 241505325,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622795496
    },
    {
        "content": "<p><a href=\"https://recruiting.paylocity.com/recruiting/jobs/Details/572675/DEXCARE-INC/Sr-Developer-Epic-Integration-Engineer\">https://recruiting.paylocity.com/recruiting/jobs/Details/572675/DEXCARE-INC/Sr-Developer-Epic-Integration-Engineer</a></p>",
        "id": 241506244,
        "sender_full_name": "Brittney Wolf",
        "timestamp": 1622796074
    },
    {
        "content": "<p>the answer should lie in <a href=\"https://datatracker.ietf.org/doc/html/rfc7232#section-2.1\">https://datatracker.ietf.org/doc/html/rfc7232#section-2.1</a></p>\n<blockquote>\n<p>Strong validators are usable for all conditional requests, including<br>\ncache validation, partial content ranges, and \"lost update\"<br>\navoidance.  Weak validators are only usable when the client does not<br>\nrequire exact equality with previously obtained representation data,<br>\nsuch as when validating a cache entry or limiting a web traversal to<br>\nrecent changes.</p>\n</blockquote>",
        "id": 241507133,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622796715
    },
    {
        "content": "<p>so both are good for cache validation (I imagine the anthropomorphized cache saying \"I hope you know what you're doing\" when working with weak ETags). Strong validation adds byte range and If-Match.</p>",
        "id": 241507979,
        "sender_full_name": "Eric Prud'hommeaux",
        "timestamp": 1622797284
    },
    {
        "content": "<p>We're \"getting\" lost update avoidance (If-Match) with weak ETags today, in a fashion that perhaps is just cheating but appears to be working ;-)</p>",
        "id": 241536230,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1622814119
    },
    {
        "content": "<p>I think Eric is showing us what the straight and narrow path looks like.</p>",
        "id": 241536684,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1622814330
    }
]