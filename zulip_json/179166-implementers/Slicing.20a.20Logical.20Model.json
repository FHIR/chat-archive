[
    {
        "content": "<p>I was reading back on change requests I filed and found <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12063\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12063\">GF#12063</a>. How does the vote apply to Logical Models? Not all of the things we take for granted in profiling apply to Logical Models. I would not apply slicing to any base logical model. I *may* apply slicing to a logical model that profiles another logical model.</p>",
        "id": 153854022,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477346026
    },
    {
        "content": "<p>In a base logical model, I'm very likely giving options for certain value elements (e.g. Observation.value[x]). <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12063\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=12063\">GF#12063</a> outlines why that will sometimes fail, and thus why the current StructureDefinition will not work for Logical Models.</p>\n<p>So if StructureDefinition is not the right carrier, are we then in need for a different resource for LogicalModels?</p>",
        "id": 153854023,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477346259
    },
    {
        "content": "<p>That *could* also provide a way out of the multiple bindings discussion, and *could* relieve us of the required min/max/conformance attributes that I do not need in logical models of definitional nature.</p>",
        "id": 153854024,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477346376
    },
    {
        "content": "<p>It would also mean that you can have a logical model with the same <code>id</code> as a structure definition.  This may seem a small thing, but it is proving a <strong>_real_</strong> pain for us.</p>",
        "id": 153854034,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1477354387
    },
    {
        "content": "<p>we've talked about min/max before. I believe you're wrong: you always need to indicate whether something can repeat or not when you are defining it; it fundemantally alters it's nature and interpretation</p>",
        "id": 153854078,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387302
    },
    {
        "content": "<p>min, not so much. but it doesn't hurt you to say min=0</p>",
        "id": 153854079,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387316
    },
    {
        "content": "<p>conformance - which one? </p>",
        "id": 153854080,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387324
    },
    {
        "content": "<p>you always have extensions if you want to do things like specific examples for specific types. </p>",
        "id": 153854081,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387360
    },
    {
        "content": "<p>agree that you wouldn't slice a base logical model</p>",
        "id": 153854082,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387388
    },
    {
        "content": "<p>Binding conformance mostly I guess. Extensions for examples will not make them render anywhere by default</p>",
        "id": 153854083,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477387394
    },
    {
        "content": "<p>somewhere but not everywhere, perhaps. </p>",
        "id": 153854084,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387417
    },
    {
        "content": "<p>we're not comfortable with adding seemingly unlimited complexity because you have it in your model. No one else is using it</p>",
        "id": 153854085,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387452
    },
    {
        "content": "<p>your example included more complexity again than you described. </p>",
        "id": 153854086,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387493
    },
    {
        "content": "<p>what circumstances could you have more than one default value, and how would that make sense? I cannot think of any. </p>",
        "id": 153854087,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387519
    },
    {
        "content": "<p>same for minValue / maxValue - how can that make sense?</p>",
        "id": 153854088,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387533
    },
    {
        "content": "<p>same for fixed. </p>",
        "id": 153854089,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387559
    },
    {
        "content": "<p>My default value for a string based value could be \"30 meters\", while my default value for quantity based values could be \"value=\"30\" and unit=\"m\"\".</p>\n<p>When counting in meters the minInclude/maxInclude are different from when counting in centimeters.</p>",
        "id": 153854091,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477387688
    },
    {
        "content": "<p>so, firstly, you're way past type specific behavjour here.  You want unit specific behavior. </p>",
        "id": 153854092,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387781
    },
    {
        "content": "<p>also, if you provide 2 default values, which one applies? no one can resolve that </p>",
        "id": 153854093,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387796
    },
    {
        "content": "<p>So in general: the way I express my concept affects certain properties. This is not possible with the way StructureDefinitions are set up. My feeling is increasingly that StructureDefinition is better at profiling than it is at LogicalModeling</p>",
        "id": 153854094,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477387796
    },
    {
        "content": "<p>I must admit that defaultValue/fixedValue are not the best of examples for my point.</p>",
        "id": 153854095,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477387843
    },
    {
        "content": "<p>no, I think examples are. </p>",
        "id": 153854097,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477387954
    },
    {
        "content": "<p>what is also something we could say is that we have not provided machinery to assert control over units, and the impact of units on values, and on reference ranges. That's something that's come up occasionally, but is deferred to R4</p>",
        "id": 153854098,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477388027
    },
    {
        "content": "<p>So long as deferring is not the same as \"not doing it\", I'm fine with that statement</p>",
        "id": 153854100,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477388091
    },
    {
        "content": "<p>the course of several different threads of work makes me sure that we'll have to get to it for R4</p>",
        "id": 153854102,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477388148
    },
    {
        "content": "<blockquote>\n<p>we've talked about min/max before. I believe you're wrong: you always need to indicate whether something can repeat or not when you are defining it; it fundemantally alters it's nature and interpretation</p>\n</blockquote>\n<p>Definitions do not have cardinality. Look at any dictionary. It does not matter to a definition of a person whether or not he can have 0..1 or 0..* SSNs.</p>\n<p>The context of use is what determines cardinality. If a person has had faulty SSNs registered to his person that were subsequently replaced by the correct one, he might have multiple, where only one of which is active.</p>",
        "id": 153854103,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477388268
    },
    {
        "content": "<blockquote>\n<p>the course of several different threads of work makes me sure that we'll have to get to it for R4</p>\n</blockquote>\n<p>I'll try to be there for the discussion</p>",
        "id": 153854104,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477388313
    },
    {
        "content": "<p>structure definitions/ element definitions are not concept definitions. If you look at ConceptDefinition in codeSystem, you'll see that it doesn't have cardinality</p>",
        "id": 153854106,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477388353
    },
    {
        "content": "<p>So LogicalModels should have actually been a series of pointers to ConceptDefinition then?</p>",
        "id": 153854107,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477388391
    },
    {
        "content": "<p>no. they're different things</p>",
        "id": 153854112,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477388511
    },
    {
        "content": "<p>language dictionaries are defining concepts, not data elemetns</p>",
        "id": 153854113,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477388537
    },
    {
        "content": "<p>LogicalModels are called datasets from where I stand, so in fact a data dictionary where concepts and concept groups live. Each concept and each concept group has definitional properties and may have 0..* code/valueSet bindings. valueSet cannot be a applied to concept groups.</p>",
        "id": 153854116,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477388642
    },
    {
        "content": "<p>then your comparison to a language dictionary was not relevant</p>",
        "id": 153854117,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477388689
    },
    {
        "content": "<p>The only thing that makes a dataset different from a dictionary is the grouping. Otherwise it is the same</p>",
        "id": 153854118,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477388734
    },
    {
        "content": "<p>The second layer is where LogicalModels match more to what you are used to. We call them transactions. In a transaction you cherry pick what you need from the dataset for a given context. The context determines min/max/conformance/conditions and could make a choice from the bindings that the dataset has to offer.</p>",
        "id": 153854119,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477388861
    },
    {
        "content": "<p>So in FHIR speak it means my datasets are base Logical models (no cardinality/conformance), and transactions are profiled Logical Models (adding cardinality/conformance)</p>\n<p>I have yet to find out what to do about the fact that dataset concept( group)s can refer to concept( group)s from other datasets. I haven't found how to represent that using StructureDefinition</p>",
        "id": 153854120,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477389092
    },
    {
        "content": "<blockquote>\n<p>The only thing that makes a dataset different from a dictionary is the grouping. Otherwise it is the same</p>\n</blockquote>\n<p>Not really, the grouping introduces the need for min/max. You cannot have:<br>\nPerson.gender 0..*<br>\nIt never makes sense for a single Person to have multiple genders at the same time. Same for Person.birthDate. Multiple genders or birthDates only make sense when some administrative period is added; otherwise, like in Person, there can be only one <strong>within the group</strong>. That's just the way the world is.<br>\nSo I'd agree with Grahame that you need max values (and maybe a lot will be *), and that min values are usually 0 in base models.</p>",
        "id": 153854153,
        "sender_full_name": "Marc de Graauw",
        "timestamp": 1477406074
    },
    {
        "content": "<blockquote>\n<p>I have yet to find out what to do about the fact that dataset concept( group)s can refer to concept( group)s from other datasets. I haven't found how to represent that using StructureDefinition</p>\n</blockquote>\n<p>Aren't those simply references to separate resources? </p>",
        "id": 153854154,
        "sender_full_name": "Marc de Graauw",
        "timestamp": 1477406232
    },
    {
        "content": "<blockquote>\n<p>Aren't those simply references to separate resources?</p>\n</blockquote>\n<p>That is one of the solution I'm considering. Logical Models referring to Logical Models, that in turn could be referring to Logical models, etc. </p>",
        "id": 153854339,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477472286
    },
    {
        "content": "<blockquote>\n<p>So I'd agree with Grahame that you need max values (and maybe a lot will be *), and that min values are usually 0 in base models.</p>\n</blockquote>\n<p>Since you originate from the ART-DECOR setup too, I'm amazed here. Datasets do not have cardinality. Period. If Logical Models SHALL have cardinality, then I'll substitute 0..* in every single instance. There is no way to distinguish between concept X or Y at that level. The world doesn't care about cardinality at definition time. At least my world doesn't.</p>\n<p>I then need a transaction to tell me what my cardinality is going to be in the given context.</p>\n<p>The other option is the statement that Logical Models are conceptually transactions and that FHIR does not have something on the level of datasets. In that case we should just skip mapping of datasets altogether, but that sounds like a lackluster as you'd miss correlation between Logical Models.</p>",
        "id": 153854340,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477472562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span> I don't understand the purpose of grouping elements if you're not going to talk about cardinality.  Grouping creates a context and with context, cardinality usually applies.  Logical models definitely create a context.  Saying Patient can have a birth date without saying that they can't have more than one doesn't make any sense.  If you're just looking to aggregate \"data elements I defined this month\", then you want List, not StructureDefinition to group them (you might have a single StructureDefinition for each element - one for birthDate, one for gender, etc.  (And even then we still indicate on a data element whether, when used, it can repeat based on the intended use of the data element.  If your context is sufficiently wide, then making the root elements 0..* could work.)</p>",
        "id": 153854356,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1477502484
    },
    {
        "content": "<p>I can and will go for 0..* for anything when doing datasets &gt; Logical Model. But let's go back to the tracker item. What if I want to say that a given element may be expressed like:</p>\n<p>&lt;choice&gt;<br>\n    &lt;quantity in meters, valid range 0-3, fraction digits max 2, example \"2.10 m\"/&gt;<br>\n    &lt;quantity in centimeters, valid range 0-300, no fraction digits, example \"210 cm\"/&gt;<br>\n    &lt;quantity in millimeters, valid range 0-3000, no fraction digits, example \"2100 mm\"/&gt;<br>\n&lt;/choice&gt;</p>\n<p>Does that always mean that I will be slicing in my Logical model?</p>",
        "id": 153854367,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1477507112
    },
    {
        "content": "<p>no that's not slicing. it's just - at the moment - something that you can't say without extensions</p>",
        "id": 153854442,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477516326
    },
    {
        "content": "<p>From a data dictionary perspective, statements like \"Saying Patient can have a birth date without saying that they can't have more than one\" is common practice.  It's utility tends to be shorter term, but ISO 11179 observes this practice  (<code>Data Element Concepts</code> don't have cardinality).  What you would normally do then, is create a implementation-specific logical model -- i.e. a logical model peculiar to the particular domain that your implementation is addressing -- which then refers to the concepts in the data dictionary and applies the cardinality required by the domain.  The theory is that you cannot assume that, using your example, a Patient can never have more than one birth date; there may be (admittedly extremely obscure) edge cases where more than one birth date is required.</p>",
        "id": 153854480,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1477526470
    },
    {
        "content": "<p>You can say it without extensions - you could enforce it with FluentPath.</p>",
        "id": 153854482,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1477526923
    },
    {
        "content": "<blockquote>\n<p>Patient can never have more than one birth date; there may be (admittedly extremely obscure) edge cases where more than one birth date is required</p>\n</blockquote>\n<p>I'd like to see an example, then. I can come up with (not so edge) cases where the registered birthDate may change, so a Person can have multiple ones registered over time, like:<br>\nbirthDateRegistrationPeriod 0..*<br>\n  - startDateRegistration 1..1<br>\n  - endDateRegistration 0..1<br>\n  - birthDate 1..1<br>\nNote that while birthDateRegistrationPeriod repeats, birthDate still does not. I cannot think of one solid example where a Person could conceivably have multiple birthDates without contextual information regarding validity (in which case, as shown, the actual birthDate will still have max=1, not *).</p>",
        "id": 153854515,
        "sender_full_name": "Marc de Graauw",
        "timestamp": 1477566243
    },
    {
        "content": "<p>I agree with Marc; assertions regarding cardinality are quite often meaningful in that they inter-related with the definition of the element. A status with cardinality of &gt;1 is inherently different to a status with a cardinality of 1. But cardinality is - here I agree with Alexander - often only meaningful in a particular context; it makes inherent assumptions about containment. So here is my real point: many data elements only have meaning in the context of their containment. While others are independent of their containment.... because they carry their own context. </p>",
        "id": 153854519,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477567194
    },
    {
        "content": "<p>we haven't really ever properly differentiated them - in spite of having both DataElement and LogicalModel. And my experience is that very often a 'DataElement' is a small LogicalModel with a clear focal element - and we agree with Alexander that logical models or resources which are entry points do not have meaningful cardinalities</p>",
        "id": 153854520,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1477567303
    },
    {
        "content": "<p>For atomic items in a data element repository, cardinality indeed does not make sense. (One can have a list of birthDates in a non-person context). Seems everybody agrees there. For non-atomic items (like adresses etc.) it can indeed be more blurry. The non-atomic item itself would not have cardinalities; for its children, possibly (there are no adresses with multiple postal codes in Holland).</p>",
        "id": 153854523,
        "sender_full_name": "Marc de Graauw",
        "timestamp": 1477570161
    },
    {
        "content": "<p>The point is not whether or not any edge cases exist where a Patient can have more than one birth date, the point is that in a data dictionary, you have <strong>_no_</strong> context and so it is actually rare where you can assert a cardinality that will <strong>_always_</strong> be true in <strong>_all_</strong> contexts. (Patient birth date is probably such an exception, but in reality, if you think you can apply a cardinality, you probably already subconsciously have a context in mind.)  Since this is rare, data dictionaries do not capture cardinality even though there may be a small number of cases where they could.  The cardinality is only applied once the context is determined; this is done in a context-specific logical model that refers to, but sits outside of, the data dictionary.</p>",
        "id": 153854579,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1477618157
    },
    {
        "content": "<p>My question is why you would use a StructureDefinition to group elements in a data dictionary.  I would expect a data dictionary to be a List where each element would be its own StructureDefinition.</p>",
        "id": 153854580,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1477623927
    },
    {
        "content": "<p>At the moment we're just creating a collection of <code>DataElement</code> resources.</p>",
        "id": 153854581,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1477634883
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191366\">@Stephen Royce</span> , I absolutely agree that there'd be no cardinality when there is no context - such as data dictionaries with atomic data elements. We're working here with that, and I probably will make those available as DataElements, w/o cardinalities. I was speaking only about cases when there is a context, such as gender within a Person or postalCode within an address. Like Lloyd says, I'll share my data dictionary in a List or similar.</p>",
        "id": 153854597,
        "sender_full_name": "Marc de Graauw",
        "timestamp": 1477654901
    }
]