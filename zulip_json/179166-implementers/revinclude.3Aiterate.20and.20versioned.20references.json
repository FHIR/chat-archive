[
    {
        "content": "<p>The search spec says that _include SHOULD follow versioned references and provide the specified version. So the searchset may contain entries that are not the current version of the resource.</p>\n<p>It's pretty clear what _include:iterate would do from that point - follow outgoing references from that version. But what does _revinclude:iterate do?</p>\n<p>If the _include'd result is Patient/123/_history/456, it seems clear we want incoming versioned references to Patient/123/_history/456, if there are any. Should we also find incoming references to Patient/123? They might not be relevant to a past state of the resource.</p>",
        "id": 236246066,
        "sender_full_name": "Paul Church",
        "timestamp": 1619471890
    },
    {
        "content": "<p>Good question! Any existing behavior from servers we can review as a starting point?</p>",
        "id": 236246295,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619471968
    },
    {
        "content": "<p>Currently the Google implementation doesn't do either. I'm fixing revinclude to at least find the version-specific incoming references so it can catch <a href=\"http://Provenance.target\">Provenance.target</a>.</p>\n<p>Not aware of any other examples at the moment.</p>",
        "id": 236246929,
        "sender_full_name": "Paul Church",
        "timestamp": 1619472136
    },
    {
        "content": "<p>I think I lean toward <em>not</em> finding incoming non-versioned references. It's hard to come up with a use case where that's definitely desirable.</p>",
        "id": 236247496,
        "sender_full_name": "Paul Church",
        "timestamp": 1619472307
    },
    {
        "content": "<p>The problem is that the version might be current, in which case we should.</p>",
        "id": 236247609,
        "sender_full_name": "Paul Church",
        "timestamp": 1619472340
    },
    {
        "content": "<p>very tricky questions; I've ignored them in my implementation, and I don't even know what would happen</p>",
        "id": 236272143,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1619488094
    },
    {
        "content": "<p>seems this should be directable, rather than a default unchangeable behavior. Provenance use likely does want version specific followed, as that is an important part of the mechanism that is provenance.  Where else is version specific references used, are they intended to be soft (FYI, this was the version), or hard (this is the instance).</p>",
        "id": 236317917,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619521840
    },
    {
        "content": "<p>The issue is that 'search' doesn't allow for multiple versions of a resource in the Bundle, so Provenance with includes is tricky.</p>",
        "id": 236341197,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1619531896
    },
    {
        "content": "<p>Doesn't it? What if I have two results for my primary search, each of which has a versioned reference to different versions of the same resource, and I have an _include that follows that reference?</p>",
        "id": 236341637,
        "sender_full_name": "Paul Church",
        "timestamp": 1619532055
    },
    {
        "content": "<p>Only 'history' Bundles are currently allowed to have multiple versions of the same resource.</p>",
        "id": 236342155,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1619532235
    },
    {
        "content": "<p>That's an interesting conflict. I think there will be legitimate use cases for _include on versioned references that will collide with that constraint.</p>",
        "id": 236346681,
        "sender_full_name": "Paul Church",
        "timestamp": 1619533773
    },
    {
        "content": "<p>Isn't the idea that Lloyd describing that generally a reference that is versioned is most of the time treated as the resource id (current)? Thus outside of a history bundle, you would always get the current?</p>",
        "id": 236354399,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619535995
    },
    {
        "content": "<p>This is why a _revinclude on Provenance will find all historic Provenance based on the current Observation. And doesn't conflict because each of the Provenance are instances, not revisions.</p>",
        "id": 236354631,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619536057
    },
    {
        "content": "<p>What is a use-case, <span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> , that you are thinking of where _include really wants version specific targets?</p>",
        "id": 236354806,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619536093
    },
    {
        "content": "<p>This came up in CARIN BB where they want an ExplanationOfBenefit and related resources to be a \"point in time\" record that aligns with what the patient would have seen on a paper claim. For example, a Practitioner should be represented with the affiliation and address that they had at the time of the claim to avoid confusion, e.g. \"wait a minute, I didn't see a doctor at hospital X\" if the practitioner has since moved.</p>\n<p>One way of accomplishing this is through versioned references (rather than creating a bunch of Practitioner resources for the same individual), so the IG called for that. It was already allowed by the spec as a \"should\" so it didn't seem like a big deal.</p>",
        "id": 236357121,
        "sender_full_name": "Paul Church",
        "timestamp": 1619536765
    },
    {
        "content": "<p>that is versioned references... but what about multiple historic versions of the same resource?</p>",
        "id": 236357397,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619536874
    },
    {
        "content": "<p>your use-case sounds like a Composition. Often Compositions are a document of an instance in time.</p>",
        "id": 236357465,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619536904
    },
    {
        "content": "<p>If the patient searched for their ExplanationOfBenefit resources with an _include on Practitioner, you can imagine that two claims over time might have references to different versions of the same Practitioner, and those might occur in the same search.</p>",
        "id": 236357553,
        "sender_full_name": "Paul Church",
        "timestamp": 1619536929
    },
    {
        "content": "<p>I think in that case you get the current Practitioner, not the historic (version). Thus you get one Practitioner for each individual practitioner involved. It might be referenced multiple times in the search set.</p>",
        "id": 236357966,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619537090
    },
    {
        "content": "<p>But in this case, it makes sense for the application to show multiple versions of the same Practitioner when displaying the various claims. It would be confusing if sometimes you saw the referenced version and sometimes saw the current version depending on what search results were present.</p>",
        "id": 236368042,
        "sender_full_name": "Paul Church",
        "timestamp": 1619540730
    },
    {
        "content": "<p>Agreed, Paul's use case is pretty clear; I don't know why we'd intentionally rule this out.</p>",
        "id": 236374914,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619543530
    },
    {
        "content": "<p>I don't know either.</p>",
        "id": 236379640,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1619545625
    }
]