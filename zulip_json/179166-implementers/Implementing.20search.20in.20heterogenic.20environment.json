[
    {
        "content": "<p>I find generic search pretty difficult to implement. Behind my FHIR server I have a REST API that lets me query for objects based on certain filters. My general plan for dealing with an incoming query has been to parse it into an expression tree to represent the query, then find subqueries in the tree that I can make requests for from the REST API. For anything that can't be handled in the REST API, I perform the final joins / filtering in memory. But here's where it gets messy. A chained parameter is essentially a join that imposes a restriction on what referenced objects will be used. So, the global expression has an effect on how the local part of the expression should be executed.<br>\nThere's probably a lot written about this stuff in database theory but it's not something I ever deep dived into. Does anyone know some good reading material to help me out here? Or is there code / libraries that will help me perform this?</p>",
        "id": 153927164,
        "sender_full_name": "Mattias Flodin",
        "timestamp": 1514479624
    },
    {
        "content": "<p>This is a problem we aim to help solving with Vonk FHIR Facade. It breaks down the search into the elementary units, where you get to fill in the details of actually filtering and retrieving your own data (of which you know the structure / API). Breaking down the search and then combining the results is indeed hard, especially if you also want to validate it (valid search parameters for the resourcetype(s) currently in focus, valid (type) modifiers, comparators and values for the type of search parameter etc.) and want to return meaningful OperationOutcomes if something is not correct. <br>\nWhile this can help to make the search <em>work</em> you need more to make it <em>efficient</em>. I don't know of any existing reading on this, but from my experience I can come up with two broad ways of dealing with this:<br>\n1. Gain knowledge / statistics about which filters are the most discriminating. Perform those first and use the results for a 'join' on the next REST call. This way you minimize the amount of data you have to retrieve through each call. (This is actually what a relational database does when computing the 'query plan'.)<br>\n2. Create a cache of the data 'behind' the REST API, and query that. But cache means cache-invalidation and the complexity of that depends on the data turnover in the source system and the delay that is allowed on the FHIR interface.<br>\nRegardless of the approach I think there is no really easy solution to this problem.</p>",
        "id": 153927178,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1514489157
    },
    {
        "content": "<p>Hm, <code>a[b eq C1].c eq C2</code> should be equivalent to <code>a.b eq C1 and a.c eq C2</code> right? Is there any situation when a filter in the parameter path can't be factored out to remove all filters from the path?</p>",
        "id": 153927306,
        "sender_full_name": "Mattias Flodin",
        "timestamp": 1514539269
    },
    {
        "content": "<p>Seems that if you just use the surrounding path prefix to qualify each parameter path within the nested filter, then you can move it out of the path. So <code>(PREFIX[expr])</code> becomes <code>(PREFIX and expr2)</code>, where expr2 is expr with every parameter path prefixed by PREFIX.</p>",
        "id": 153927310,
        "sender_full_name": "Mattias Flodin",
        "timestamp": 1514542409
    },
    {
        "content": "<p>No time to analyze now, but I'd especially check the validity of your assumption on composite searchparameters and searchparameters that can have multiple values (like <a href=\"http://Patient.name\" target=\"_blank\" title=\"http://Patient.name\">Patient.name</a>).</p>",
        "id": 153927317,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1514553334
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> Hi Christiaan, would you like to participate in FHIR storage track? We want to try it in Germany</p>",
        "id": 153949664,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1522646961
    },
    {
        "content": "<p>what exactly is the track?</p>",
        "id": 153949665,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1522647169
    },
    {
        "content": "<p>I mean, what do you do to partcipate?</p>",
        "id": 153949667,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1522647182
    },
    {
        "content": "<p>Just preparing it - hope we are not too late - <a href=\"https://github.com/fhir-fuel/fhir-storage-and-analytics-track\" target=\"_blank\" title=\"https://github.com/fhir-fuel/fhir-storage-and-analytics-track\">https://github.com/fhir-fuel/fhir-storage-and-analytics-track</a></p>",
        "id": 153949668,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1522647236
    },
    {
        "content": "<p>so saw that but it doesn't tell me what i have to do to be part of it</p>",
        "id": 153949669,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1522647265
    },
    {
        "content": "<p>i am working on it. Should i use template?</p>",
        "id": 153949671,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1522647328
    },
    {
        "content": "<p>I want to find somebody, who help me to do it in a right way :)</p>",
        "id": 153949672,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1522647368
    },
    {
        "content": "<p>well, we can get to the template part later. What isn't clear is how it's about 'connecting'... at the moment it looks sort of like an unconference presentation</p>",
        "id": 153949675,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1522647526
    },
    {
        "content": "<p>Yes, that's true. Do you think this is not a track? I like discussions during the tracks and missing such about storage implementation - how to organise it?</p>",
        "id": 153949677,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1522647760
    },
    {
        "content": "<p>I think, the result can be  the report or guidelines for implementers</p>",
        "id": 153949679,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1522647808
    },
    {
        "content": "<p>we've had tracks like this before.. but most people come to make something work ('to connect'). So If you get interest we can do it. But it does need to be clear what your anticipated outcomes are</p>",
        "id": 153949681,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1522648171
    },
    {
        "content": "<p>Can you point me to similar tracks in order to use them as inspiration?</p>",
        "id": 153949682,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1522648349
    },
    {
        "content": "<p>Can Outcome  be working prototype of database  schema and FHIR search implementation? Or experience with existing approaches to do it?</p>",
        "id": 153949683,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1522648682
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> Certainly interesting, thanks. Only depends on the other tracks - cannot participate in three at the same time. Is there already any outline for the track or do you want me to think about that as well?</p>",
        "id": 153950121,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1522742563
    },
    {
        "content": "<p>so back to this... I don't know whether there's enough interest in a standard database schema that would both support the API, and also enable interoperable queries. I don't know if this is something that could be part of this, and would be the interoperability bit</p>",
        "id": 153950387,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1522798076
    }
]