[
    {
        "content": "<p>We are looking for a way to reference resources accross services in a distributed system. The current reference element provides two mechanisms: </p>\n<ul>\n<li>a literal reference, containing (in our case) a full url to the resource, or </li>\n<li>a logical reference by providing an identifier by which the resource is known. </li>\n</ul>\n<p>Given the varying network infrastructures in which we deploy our system, the literal references may not always be accessible (as it needs to pass through address translation frameworks, proxies, etc.) As such, we don't see those as a viable option. This leaves us with logical references, but those introduce the problem that it provides no hints where to resolve the resource. For example, several patient records may exist (at several servers, with potential conflicting information) that have the same SSN as identifier. In the reference we would like to be able to point to specific instance of those resources, but without using a literal url.</p>\n<p>One way to resolve this is to add an extension (or preferably field) to the reference element, named source. This field (similar to the source field in the resource meta element) could provide a hint on where to resolve the identifier. How to map the source to an actual endpoint would be out of scope for its definition. In our use-case the source field would point to a service identifier, which would be resolvable through service discovery to a base-path at which the patient resource can be retrieved. The benefit of this approach is that the sender of the reference does not need to know how the resource can be reached from various networks, that is left to an external system.</p>\n<p>Would this be something that is worthwhile adding to the standard? How are others dealing with this issue?</p>\n<p>Any comments or suggestions are welcome...</p>",
        "id": 175431570,
        "sender_full_name": "Joost Reuzel",
        "timestamp": 1568208785
    },
    {
        "content": "<p>The general expectation is that only URLs are expected to be resolvable.  Resolving identifiers will require a shared business context that allows determining the process for resolution.  You <em>do</em> have the identifier.system - which corresponds to the identifier namespace.  That should give you a pretty good idea of the source - particularly if you just look at the root of that system</p>",
        "id": 175436722,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1568211722
    },
    {
        "content": "<p>You are making the assumption that the authorities of identities (codified in the identifier.system) can be mapped to the services that actually hold the data. That may not always hold. For example, the example  in which patient resources are identified  using SSNs (or another 'global' patient id) is a case where multiple patient resources (across services) may have the same identifier. In that case I still would like to refer to a specific instance at a specific source...</p>",
        "id": 175438864,
        "sender_full_name": "Joost Reuzel",
        "timestamp": 1568213048
    },
    {
        "content": "<p>Any API client will expect the resource references to resolve - so if you break that you'll break most / all clients</p>",
        "id": 175439086,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1568213184
    },
    {
        "content": "<p>I don't know about 'break', but you certainly won't be able to do chained queries</p>",
        "id": 175439926,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1568213636
    },
    {
        "content": "<p>Indeed most API clients expect literal urls to be resolvable. However, we are facing a complex deployment scenarios that span several clouds and on-premise applications. In this complex world, a service would not even know how to formulate a literal url that is resolvable accross all these networks, as it would not have knowledge of local proxies, etc. Given that we are forced to look for alternatives...</p>",
        "id": 175440109,
        "sender_full_name": "Joost Reuzel",
        "timestamp": 1568213754
    },
    {
        "content": "<p>sounds like fun ;-)</p>",
        "id": 175440260,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568213856
    },
    {
        "content": "<p>We thought about the chained queries. These indeed would not work, but given the distributed nature that is ok. These aren't supported for logical references anyway. </p>\n<p>A specific scenario would be a ServiceRequest that is send from system A to B, with a reference to a patient resource at system C. System A could put his literal url to the patient resource at system C in the request, but that url may not be resolvable by system B. Instead we are thinking of refering to the resource by its identifier, and adding as a source extension/field the name of system C. B would (based on its local service discovery) need to resolve the system C name to a locally resolvable endpoint to fetch the resource...</p>",
        "id": 175440840,
        "sender_full_name": "Joost Reuzel",
        "timestamp": 1568214183
    },
    {
        "content": "<p>One way to do this is to use redirection services....</p>",
        "id": 175440971,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568214269
    },
    {
        "content": "<p>I don't know if Identifier.assigner helps?</p>",
        "id": 175441256,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568214444
    },
    {
        "content": "<p>Would this not be a re-interpretation of the assigner field? Moreover, wouldn't it be cleaner to have a source/server indication external to the identifier itself?</p>",
        "id": 175441727,
        "sender_full_name": "Joost Reuzel",
        "timestamp": 1568214699
    },
    {
        "content": "<p>probably.... I wasn't sure</p>",
        "id": 175442142,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568214896
    },
    {
        "content": "<p>Basically we are looking for a reference that allows you to say \"resource of type X known under the identifier Y at system Z\". X and Y have fields in the reference element (type and identifier respectively). Z is missing in our view...</p>",
        "id": 175442147,
        "sender_full_name": "Joost Reuzel",
        "timestamp": 1568214900
    },
    {
        "content": "<p>but if you know Z then you can fill out the URL</p>",
        "id": 175442220,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568214931
    },
    {
        "content": "<p>Indeed, but we would like to have an external \"context specific\" mechanism to find the url related to Z, instead of making it part of the reference itself.</p>",
        "id": 175442386,
        "sender_full_name": "Joost Reuzel",
        "timestamp": 1568214995
    }
]