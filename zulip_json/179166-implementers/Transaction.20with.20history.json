[
    {
        "content": "<p>Is there a way to indicate the history of resources in a transaction? For example, can I have a transaction that has three versions of the same resource? And if so, is the server supposed to respect the meta properties, such as the .meta.lastUpdated and .meta.versionId properties?</p>",
        "id": 157238797,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548897994
    },
    {
        "content": "<p>You can use a transaction to update something 3 times, but the meta will reflect what happened on the server the data's being created on, not where it came from.</p>",
        "id": 157238848,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1548898069
    },
    {
        "content": "<p>so there's no way to get the three different versions to have the correct \"lastUpdated\" property?</p>",
        "id": 157238902,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548898087
    },
    {
        "content": "<p>or to ensure that the three different versions are processed in the correct order?</p>",
        "id": 157238918,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548898106
    },
    {
        "content": "<p>Seems to me that this should be possible so that systems could backup a FHIR server using a Bundle</p>",
        "id": 157238964,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548898161
    },
    {
        "content": "<p>backup AND restore</p>",
        "id": 157238978,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548898186
    },
    {
        "content": "<p>I think entries are processed in order unless there's a reason they can't be.  But certainly there's no way to set lastUpdated to a historical value.</p>",
        "id": 157238980,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1548898189
    },
    {
        "content": "<p>If we want that, it'd need to be a distinct operation.</p>",
        "id": 157238988,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1548898200
    },
    {
        "content": "<p>ok... so you think I should submit a change request to create a \"$restore\" operation?</p>",
        "id": 157239055,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548898228
    },
    {
        "content": "<p>Sure, why not :)</p>",
        "id": 157239063,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1548898244
    },
    {
        "content": "<p>that $restore operation could be either a Bundle transaction OR a specific resource, I suppose</p>",
        "id": 157239071,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548898253
    },
    {
        "content": "<p>/$restore<br>\nAND<br>\n/Composition/1/$restore</p>",
        "id": 157239101,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548898277
    },
    {
        "content": "<p><a href=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20332\" target=\"_blank\" title=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20332\">https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20332</a></p>",
        "id": 157239658,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548898914
    },
    {
        "content": "<p>would this wipe the internal history? why would you do this across the API? It just seems like an internal thing to me</p>",
        "id": 157245149,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1548906989
    },
    {
        "content": "<p>This certainly brings up concerns with integrity of the history, if history can e re-written without a trace. Clearly this operation would need to be privileged, and it should clearly have strong authorization and audit logging behavioral requirements. behavioral requirements that can be fulfilled by a security layer such as SMART-on-FHIR, or other. behavioral logging requirements that could utilize AuditEvent or other.</p>\n<p>Would there be a Provenance impact? Seems these historic versions of a resource could have original Provenance restored as well; but one might ask if the $restore operation should create one new Provenance indicating the $restore activity and pointing (.target) of the version specific resources impacted (restored).</p>",
        "id": 157277887,
        "sender_full_name": "John Moehrke",
        "timestamp": 1548947160
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> , because as far as I can tell, none of the existing FHIR servers implement a form of backup/restore short of what's allowed by the supporting database. If this existed in the spec, it might be more likely to be supported by FHIR servers. Standardizing a more-thorough export/import format/process for a FHIR server doesn't seem like a bad thing to me.</p>",
        "id": 157278656,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548947667
    },
    {
        "content": "<blockquote>\n<p>Standardizing a more-thorough export/import format/process for a FHIR server doesn't seem like a bad thing to me.</p>\n</blockquote>\n<p>But overwriting history seems like a step further than that</p>",
        "id": 157293944,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1548959782
    },
    {
        "content": "<p>then let's adjust the $restore operation so that it only ADDS to the history</p>",
        "id": 157307014,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548969276
    },
    {
        "content": "<p>so, if a resource already has history, the existing history is preserved, and added to</p>",
        "id": 157307021,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548969286
    },
    {
        "content": "<p>maybe...</p>",
        "id": 157307047,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548969308
    },
    {
        "content": "<p>dunno, might have to think about that more</p>",
        "id": 157307051,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548969313
    },
    {
        "content": "<p>nah, I don't like that... I take it back</p>",
        "id": 157307064,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548969329
    },
    {
        "content": "<p>let's suggest that the $restore operation be secured with role-based authorization</p>",
        "id": 157307077,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548969351
    },
    {
        "content": "<p>and call it good :)</p>",
        "id": 157307132,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548969376
    },
    {
        "content": "<p>then, if the server implementer wants to allowing anonymous users to overwrite history, that's up to them</p>",
        "id": 157307148,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548969399
    },
    {
        "content": "<p>We implemented this in the Google Cloud FHIR server - our (non-spec) bulk import operation will accept history bundles and synthesize the corresponding history. It's quite useful for integration testing and a few niche use cases but creates complex issues for anything other than populating an empty store to a known state.</p>\n<p>If the resource already exists, the imported history will get interleaved with the existing history - and that could easily represent an inconsistent sequence of mutations. Any client holding on to an etag may get confused, because the history can be mutated without touching the current version. Doing a backup/restore of data that includes versioned references is even more difficult. We have audit logs outside of the FHIR store itself so we can potentially maintain the integrity of the audit trail but it's always going to look more confusing than \"normal\" operations.</p>\n<p>It's a nice implementation-specific feature but is there actually a use case where users want interoperability between servers of backup/restore including resource history?</p>",
        "id": 157308284,
        "sender_full_name": "Paul Church",
        "timestamp": 1548970272
    },
    {
        "content": "<p>wow that's head hurting territory</p>",
        "id": 157308408,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1548970341
    },
    {
        "content": "<p>It's just one of those early ideas that needs some iteration. If the operation couldn't touch resources that already exist or existed in the history, it would be a lot better behaved.</p>",
        "id": 157309306,
        "sender_full_name": "Paul Church",
        "timestamp": 1548970952
    },
    {
        "content": "<p>or if you just reset the repository completely</p>",
        "id": 157309916,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1548971389
    },
    {
        "content": "<p>actually, that's kinda the scenario I want to accommodate</p>",
        "id": 157310074,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548971514
    },
    {
        "content": "<p>completely wiping out the repository</p>",
        "id": 157310079,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548971521
    },
    {
        "content": "<p>and getting everything that was in the repository that was there before the wipe</p>",
        "id": 157310128,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1548971531
    },
    {
        "content": "<p>If you are doing incremental backups, I would expect you need to do incremental restores.</p>",
        "id": 157310133,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1548971534
    },
    {
        "content": "<p>I know - that's what we need - a healthcare specific standard for doing incremental backup restores across a RESTful API</p>",
        "id": 157310187,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1548971592
    },
    {
        "content": "<p>OK, so is there a need to do any of this in an interoperable way?</p>",
        "id": 157310308,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1548971695
    },
    {
        "content": "<p>I think there is a case for interoperable import including history - bulk data $export is trying to give the client everything the server knows about some patients. But what if the application logic on the receiving end uses the resource history? How do you capture and transfer that? It's not a big stretch to say it's an ndjson file containing history bundles. (Alternately, the answer could be \"bad application, don't do that\".)</p>",
        "id": 157313250,
        "sender_full_name": "Paul Church",
        "timestamp": 1548973984
    },
    {
        "content": "<p>or the answer could be... that's ok, but we don't believe it deserves formal standardization</p>",
        "id": 157313505,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1548974205
    },
    {
        "content": "<p>Having the ability so that one can fill a demo server, seems like a function of a reference implementation that has a feature of being easy to use as a demo server..... Even as a reference server this capability should be OFF by default, and it should take extraordanary effort by the sysadmin to enable it....   I don't think it is strange to have features like this... but they are system features, they don't need to be defined in a standard.</p>",
        "id": 157354657,
        "sender_full_name": "John Moehrke",
        "timestamp": 1549029888
    },
    {
        "content": "<p>Where ever it is defined, it should be defined as a highly privileged interface, and the use of that interface should be highly logged. Thus if it 'accidentally' got enabled on a medical-records dataset, it could be detected as to being enabled and all uses of the interface determined so they could be rolled back. This doesn't help the patient-safety risks that may have happened during the time that bad data was in the system, but it does make it detectable.</p>",
        "id": 157354864,
        "sender_full_name": "John Moehrke",
        "timestamp": 1549030107
    },
    {
        "content": "<p>By concluding that, you're concluding that no FHIR server will ever want to (in a standardized way) transfer data <em>with</em> history between FHIR servers.</p>",
        "id": 157363872,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1549037556
    },
    {
        "content": "<p>The issue is that \"history\" means two things:<br>\n1. What happened to this business record over time<br>\n2. What did the data on this particular server look like at a particular point in the past?</p>\n<p>FHIR's _history is <em>only</em> trying to represent #2.  #1 is handled with Provenance</p>",
        "id": 157364026,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1549037697
    },
    {
        "content": "<p>Reloading history thus only makes sense when you're doing a restore or when you're simulating a single server with multiple boxes</p>",
        "id": 157364085,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1549037744
    }
]