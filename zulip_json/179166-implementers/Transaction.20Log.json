[
    {
        "content": "<p>We were discussing subscriptions and streams and came to well known in databases design idea - transaction log: Any creating/deleting or changing resources operations (including transaction) could be expressed as transactions, server could provide stream/ log  of all transactions. This could be used for FHIR server *replication* - external (downstream) server just connect to upstream server transaction log , listen and apply all (or filtered) transactions. This is quite generic, but looks powerful. Also filtered by some criteria transaction log could be used to create simplest and natural subscriptions, which are easy to implement ( In general, it's not trivial (if possible) to make arbitrary search reactive - i mean current subscriptions). </p>",
        "id": 153855460,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1478239901
    },
    {
        "content": "<p>*history-all* operation is similar, but has different granularity  - transaction boundaries are missed.</p>",
        "id": 153855464,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1478240268
    },
    {
        "content": "<p>yes transaction boundaries are missed. that's explicitly documented. Is it a problem? why?</p>",
        "id": 153855466,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1478240491
    },
    {
        "content": "<p>May be not :) but that's integrity concern - usually replication has transaction granularity guaranties.</p>",
        "id": 153855467,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1478240670
    },
    {
        "content": "<p>Transaction log is an implementation and deployment detail. FHIR is an interoperability standard, it doesn't cover many implementation and deployment details. FHIR does have a Provenance resource and when used with Resource versioning, will provide a version granularity.</p>",
        "id": 153855488,
        "sender_full_name": "John Moehrke",
        "timestamp": 1478261429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  Replication of FHIR server  - isn't it interop?</p>",
        "id": 153855490,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1478261507
    },
    {
        "content": "<p>so your use-case is a replication of a FHIR server... okay... so what is the failure-mode you are looking to protect against? I ask because at the Interoperability layer, we have integrity through the http(s). So both sides can confirm communication. A good recipient will not return success indication until it has committed the transaction (to storage, to transaction queue, etc). A 'bad' recipient won't... so this 'risk' is an implementation detail. What is your identified 'risk'?</p>",
        "id": 153855495,
        "sender_full_name": "John Moehrke",
        "timestamp": 1478262011
    },
    {
        "content": "<p>You could use replication not only for failover, but to localize data on another server</p>",
        "id": 153855496,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1478262147
    },
    {
        "content": "<p>Note, FHIR also has AuditEvent that can be recorded on both sides (sender records the sending of an identified set of records, recipient records the reception of a set of records, recipient records commitment of a set of records, etc)</p>",
        "id": 153855497,
        "sender_full_name": "John Moehrke",
        "timestamp": 1478262213
    },
    {
        "content": "<p>This is a powerful thought, and potentially more useful than a typical FHIR subscription. One of my integration partners recently told me that an approach like this would be far easier for them to implement than the last-updated approach with polling.</p>",
        "id": 153855530,
        "sender_full_name": "John Calvin Young",
        "timestamp": 1478283171
    },
    {
        "content": "<p>what's the difference?</p>",
        "id": 153855539,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1478285631
    },
    {
        "content": "<p>The difference is \"state\". In a typical REST subscription it is the client that remembers what it has seen. In a case like SOAP (e.g. XDS Document Subscription) the server must remember the state, that is the server is told that the client is interested in notification on a specific set of filters (query), the server looks at the set of subscriptions everytime something changes, and notifies the client when something happens. The second problem is directionality, but that can be resolved with tricks of connection state management.</p>",
        "id": 153855560,
        "sender_full_name": "John Moehrke",
        "timestamp": 1478287862
    },
    {
        "content": "<p>I don't follow. there's push vs pull, and then there's transaction boundaries that might be missing. but I don't know what the difference between 'transaction log' and last-updated is</p>",
        "id": 153855561,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1478287966
    },
    {
        "content": "<p>Sorry, your question is then not for me... I too am confused as to the transaction log risk.</p>",
        "id": 153855562,
        "sender_full_name": "John Moehrke",
        "timestamp": 1478288157
    }
]