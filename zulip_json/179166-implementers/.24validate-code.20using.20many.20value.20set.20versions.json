[
    {
        "content": "<p>Can you easily validate if a code is/was a member of a value set at any point in time?</p>\n<p>The Value Set resource doesn’t provide a way to view the history of its members by looking at a single version. If you perform $validate-code and supply the url parameter, the default seems to check the latest version of the value set. If a historical member is not in the latest version of the value set, it returns false. You can perform $validate-code on a specific value set instance, so to determine if a member is valid for a particular url you could perform the operation on all value set instances (if versions are represented as individual value set instances) with that url.</p>\n<p>I used to think this wasn’t a problem for SNOMED reference sets because reference sets can have history in RF2, however, after trying to validate an inactive member of a refset (using implicit value set uri) it returned false. So similarly to determine if a code was a valid member you would need to perform $validate-code using the versioned implicit value set uri for every version of snomed.</p>",
        "id": 153959884,
        "sender_full_name": "Liam Barnes",
        "timestamp": 1526255767
    },
    {
        "content": "<p>that requires the terminology server to keep a record of all the past versions</p>",
        "id": 153959906,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526277042
    },
    {
        "content": "<p>And if it did, would it then be required to do something like batch $validate-code including each version?</p>",
        "id": 153962911,
        "sender_full_name": "Liam Barnes",
        "timestamp": 1526524750
    },
    {
        "content": "<p>You can provide date as input parameter of $validate-code operation. Server, if supports that parameter, would check if the code is valid on that date.</p>",
        "id": 153963710,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1526655294
    },
    {
        "content": "<p>Not really - dates do not clearly identify a single version; you need to actually specify a version</p>",
        "id": 153964722,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527201426
    },
    {
        "content": "<p>Being able to query a SNOMED Reference Set for members (active and inactive) is probably in scope for the forthcoming SNOMED Query Language.  That doesn't provide a general solution for FHIR ValueSets, though.</p>",
        "id": 153964729,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527201873
    },
    {
        "content": "<p>According the <a href=\"http://hl7.org/fhir/2018May/valueset-operation-validate-code.html\" target=\"_blank\" title=\"http://hl7.org/fhir/2018May/valueset-operation-validate-code.html\">http://hl7.org/fhir/2018May/valueset-operation-validate-code.html</a>:<br>\nThe date input parameter is: \"The date for which the validation should be checked.\" and \"A typical example of this would be where code selection is constrained to the set of codes that were available when the patient was treated, not when the record is being edited. Note that which date is appropriate is a matter for implementation policy.\"</p>",
        "id": 153964784,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1527217663
    },
    {
        "content": "<p>When we say version, is it the version of value set or the version of value set expansion?</p>",
        "id": 153964785,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1527217705
    },
    {
        "content": "<p>Yes, that is what the spec says.  It works when you have linear versions of thing and you can say that there is a unique most-recent (ValueSet/CodeSystem) instance with respect to a given date.  However, with SNOMED this is not the case due to the presence of Editions.</p>\n<p>The advantage of using date is that a single value can select versions for multiple entities, but it breaks down if you want versions valid at different points in time (e.g., the Jan 1st version of a ValueSet wrt the Dec 1st version of the CodeSystem, because you know that, in your specific context, the CodeSystem was late in getting added but the ValueSet was not, so on Jan 1st the available set of codes was actually from the Dec 1st release, not the Jan 1st release).  So, when going to a version-based selection you need to be able to do it on a per-entity basis.</p>",
        "id": 153964786,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527218534
    },
    {
        "content": "<p>actually, date can work for snomed too.</p>",
        "id": 153964787,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527218581
    },
    {
        "content": "<p>and it may not work for linear cases as well.</p>",
        "id": 153964788,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527218589
    },
    {
        "content": "<p>using date assumes that the terminology server has specific knowledge of the past state of affairs. Generic terminology servers won't, so date is not that useful for them. It's really intended for where an EHR (or similar) have an integrated configuration history that knows what value sets and code systems are relevant for that time in history</p>",
        "id": 153964789,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527218668
    },
    {
        "content": "<p>Thanks for the replies. I don't see how a date can determine a version. The author could be using any number of versions and that isn't known to a receiver and this is independent of a date. If the receiver validates a code, the result may be true or false. If it is true you can be sure it is an active member of the value set in the version tested. If it is false all can really say is it is not an active member of the value set in the version tested but is it a dodgy code or is it just not active in the version the server is using? </p>\n<p>This sounds like whenever a new version of a snomed reference set is published and members have been inactivated, it is breaking change. As you say Michael, it is being able to determine inactive and active members that offers much more information.</p>",
        "id": 153965150,
        "sender_full_name": "Liam Barnes",
        "timestamp": 1527550437
    },
    {
        "content": "<p>As I see it, the problem you're facing is that you want to ask \"was this code ever a valid member of this ValueSet\" but <code>$validate-code</code> only operates at a point-in-time and not over an interval. At present, if you are able to enumerate the set of versions, then you could issue a batch of validate-code requests, one-per-version.</p>",
        "id": 153965151,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527551284
    },
    {
        "content": "<p>Thanks Michael, sounds right. What could be helpful in the future is an element in the value set resource to describe a member of the value set as inactive. $validate-code could then use this as a parameter when determining results. But perhaps this isn't an issue for others.</p>",
        "id": 153965152,
        "sender_full_name": "Liam Barnes",
        "timestamp": 1527551935
    },
    {
        "content": "<p>I was going to suggest that it might be okay to use <code>contains.abstract = true</code> to represent SNOMED ReferenceSet members that had an active status of false. It feels like a hack and also opens up the issue in this thread: <a href=\"#narrow/stream/4-implementers/subject/.24validate-code.20for.20abstract.20ValueSet.20members\" title=\"#narrow/stream/4-implementers/subject/.24validate-code.20for.20abstract.20ValueSet.20members\">https://chat.fhir.org/#narrow/stream/4-implementers/subject/.24validate-code.20for.20abstract.20ValueSet.20members</a></p>",
        "id": 153965158,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527553835
    },
    {
        "content": "<p>Am I right in thinking that abstract is a concept property? If so and the concept is a member of multiple refsets with different active statuses would this method fall over?</p>",
        "id": 153965159,
        "sender_full_name": "Liam Barnes",
        "timestamp": 1527555060
    },
    {
        "content": "<p>abstract here is a property on the <code>ValueSet.expansion.contains</code> objects.  It's not a property of the concept per se</p>",
        "id": 153965180,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527574101
    },
    {
        "content": "<p>there are no codes in snomed that are abstract, so it would be a terrible hack. And abstract is a bad idea altogether</p>",
        "id": 153965279,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527624179
    },
    {
        "content": "<p>the right solution to this is in another thread somewhere else, about how to have a value set that includes codes from all versions of a code system</p>",
        "id": 153965280,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527624213
    },
    {
        "content": "<p>I'm not sure I follow - Liam is wanting all (implicit) ValueSet versions.  They happen to be in sync with CodeSystem versions, but I'm not sure that is relevant (in this case).</p>",
        "id": 153965285,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527624442
    },
    {
        "content": "<p>is it not? when would it not be?</p>",
        "id": 153965286,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527624521
    },
    {
        "content": "<p>The need to validate against a range of expansions is something I've been noodling for quite some time. Yes, this is complicated and yes I'm using the word expansion because that is really what we are talking about. But this comes up when you start thinking about the issues <span class=\"user-mention\" data-user-id=\"192027\">@Liam Barnes</span> mentioned: it's hard to know what versions of something are \"correct.\" And also that a single date is only at best useful in closed systems as Graham noted and even then a single date will not properly resolve to the correct value set definition version <strong>and</strong> the proper code system version to create the expansion you want, let alone a series of them (except for implicit ones.) <span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span>, while I suppose you are right when you say implicit valueset versions are in synch with code system versions =&gt; they generate a series of expansions that are \"correct\" for the code system version. But that is not the case with non-implicit valuesets. We need to spend some time thinking about how to support valueset validate-code when multiple expansions could be appropriate, such as when a data query needs to retrieve patients over a long period that experienced changes in allowed expansions.</p>",
        "id": 153965427,
        "sender_full_name": "Robert McClure",
        "timestamp": 1527638645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  A reference set may have its membership change from one SNOMED release to another without any changes happening to the referenced codes.  My comment was in relation to your <em>how to have a value set that includes codes from all versions of a code system</em>.  The contents of such a reference set are not necessarily dependent on the active status of the underlying codes.</p>\n<p>Are you suggesting that it should be the <strong>union</strong> of the expansions across all versions?</p>",
        "id": 153965429,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527639770
    },
    {
        "content": "<p>Agreed <span class=\"user-mention\" data-user-id=\"191503\">@Robert McClure</span> . Perhaps we should start by enumerating the use-cases.  I can imagine some where you want to be broadly inclusive (a code was ever a member of any version of the ValueSet expansion wrt any version of the CodeSystem(s)), but others where you (think you) want to be quite strict (ie constraining to the version of the ValueSet &amp; CodeSystem that matches the version specified in the Coding, and this is where dates rather than versions become attractive because the ValueSet version is not tracked by Coding)</p>",
        "id": 153965431,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1527640215
    }
]