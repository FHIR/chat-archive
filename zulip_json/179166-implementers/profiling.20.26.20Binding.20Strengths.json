[
    {
        "content": "<p>Hi,<br>\nReading the documentation here <a href=\"https://www.hl7.org/fhir/terminologies.html#strength\" target=\"_blank\" title=\"https://www.hl7.org/fhir/terminologies.html#strength\">https://www.hl7.org/fhir/terminologies.html#strength</a></p>\n<blockquote>\n<p>Irrespective of the binding strength, when a StructureDefinition is used to describe local usage, it can bind the element to a different value set in order to be much more precise about exactly which coded values can be used for these elements, and/or increase the strength of the binding.</p>\n</blockquote>\n<p>Does it mean that this situation would be conformant :<br>\n1) Defining a profiled Encounter, where class valueSet would be distinct from <a href=\"https://www.hl7.org/fhir/v3/ActEncounterCode/vs.html\" target=\"_blank\" title=\"https://www.hl7.org/fhir/v3/ActEncounterCode/vs.html\">https://www.hl7.org/fhir/v3/ActEncounterCode/vs.html</a> while Encounter.class is defined as \"Extensible\"<br>\n2) Defining a profiled Patient, where gender would have code in \"alien_female\" while Patient.gender is \"required\"</p>\n<p>Thanks by advance</p>",
        "id": 153890481,
        "sender_full_name": "natus",
        "timestamp": 1495142096
    },
    {
        "content": "<p>If the binding was extensible, you can bind to a value set that constrains codes out from the base value set and/or which adds new codes that aren't covered by any of the concepts in the original value set.  You can also tighten the binding to 'required'.  If the binding was required, you can bind to a value set that constrains out codes from the original value set, but can't introduce any new codes.</p>",
        "id": 153890493,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1495164769
    },
    {
        "content": "<p>I haven't found anything in the spec that clearly indicates _how_ an extensible binding should be extended in a profile.  Is the proper approach to create a new value set that contains the codes from the original VS and the new (non-overlapping) codes?  Or is there some specific way you're supposed to indicate you are extending the original value set (and original codes are somehow inherited)?</p>",
        "id": 153891790,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1496241623
    },
    {
        "content": "<p>Also... is it possible to add level 2 codes to an existing code in a value set with an extensible binding?  In other words... if I wanted to extend ActEncounterCode and put more specific virtual codes (audio, video, async), is it possible to make them level 2 codes under the existing VR (Virtual) code?</p>",
        "id": 153891791,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1496241734
    },
    {
        "content": "<p>You just define a new valueset.  There isn't a formal way of linking or establishing the relationship of the value sets.  Adding child codes wouldn't be allowed in an extensible value set.  That would have to be a separate binding (e.g. by slicing coding).  </p>",
        "id": 153891798,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496243030
    },
    {
        "content": "<p>\"Adding child codes wouldn't be allowed in an extensible value set.\"  Why?  It seems this would be a very appropriate way to extend a value set. Many code systems define hierarchies.</p>",
        "id": 153891800,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1496243305
    },
    {
        "content": "<p>Extensible means that if there's a code in the original value set that covers your concept, you <em>must</em> use that code.  So if the original value set contains a code for \"blue\", it's not acceptable for me to send an instance with a code that says \"navy blue\" or \"pale blue\" unless I also send the code from the original value set that just says \"blue\".  Thus the only way to introduce the notions of \"navy blue\" or \"pale blue\" is with a separate binding - ensuring that the expectation to send the code \"blue\" is still reflected.</p>",
        "id": 153891802,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496243554
    },
    {
        "content": "<p>I don't understand how sliding Coding gets you there. There is nothing to slice in Coding (no arrays). But you could send both \"blue\" and \"navy blue\" in a CodeableConcept. </p>",
        "id": 153891803,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1496243703
    },
    {
        "content": "<p>I meant slice CodeableConcept.coding so you can specify additional bindings</p>",
        "id": 153891804,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496243886
    },
    {
        "content": "<p>Unfortunately, Encounter.class is a 0..1 Coding, not a CodeableConcept, so there is no way to apply slicing to allow us to identify more specific types of virtual encounters.</p>",
        "id": 153891813,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1496252356
    },
    {
        "content": "<p>Then you'll have to use an extension if you want to convey more nuance than the original value set - or argue to have the binding relaxed in a future version.</p>",
        "id": 153891819,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496260923
    },
    {
        "content": "<p>and ask why it is not a CodeableConcept - unusual....</p>",
        "id": 153891860,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496273676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> I want to confirm a couple of items regarding your thinking on this: <br>\n1) Extensible means you can can not use a different code that is \"a kind of\" one of the current codes.<br>\n2) Any change from the originally defined value set must be identiffied by a new identifier - a url in the case of FHIR.<br>\n3) If you want to send \"navy blue\" when \"blue\" is in the original value set with extensible binding, I must create \"a new binding.\" Can you explain what that would mean and how it's different than if you change the value set 'in an extensible-conformant' way - for example, remove two codes and add two new one that are \"not a kind of\". Again, I assume this 'extensible-conformant' new value set would have a new url but would not \"have a new binding.\"</p>\n<p>What I'm not exactly following is the technical details used to identify that these different changes are occurring. This is the sort of thing we need to capture for our binding semantics work (and why you need to attend!)</p>\n<p>NB: I want to understand the technical approach for all this before we get into how a computer, or a person can determine when a desired concept \"is a kind of\" something in the value set already so that to use this new concept they need to follow approach A versus approach B.</p>",
        "id": 153892231,
        "sender_full_name": "Robert McClure",
        "timestamp": 1496591194
    },
    {
        "content": "<p>1. More specifically, it means you can't satisfy the binding with a code from outside the value set that has an \"is-a\" relationship with one of the codes inside the value set.  It doesn't mean such a code can't be present, only that it can't satisfy the binding<br>\n2. Not sure what you mean here.  Codings are identified with a combination of system (url) and code.  If you send a code outside valueset in an extensible binding, those might be codes from systems already found in the value set or from other code systems.<br>\n3. More specifically, if you're dealing with a CodeableConcept - which allows you to send multiple codings, you can define an <em>additional</em> binding by slicing CodeableConcept.coding.  If you're dealing with Coding or code, you're up the creek as you can only send one code with those.  With CodeableConcept, you can send one coding that complies with the original binding and additional codings that comply with other bindings.</p>",
        "id": 153892232,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496597776
    },
    {
        "content": "<p>with regard to (3) - you create a new value set with a new URL (per (2)) - and now you have to change the binding to point to your replacement value set. I'm not sure what you mean by 'new value set but not a new binding' </p>",
        "id": 153892233,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496605895
    },
    {
        "content": "<p>often, in this case, as well as changing the value set in the binding, you up the binding strength to required</p>",
        "id": 153892234,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496605929
    },
    {
        "content": "<p>In 3, if you want a value set that includes \"navy blue\", then you're going to have to have a binding to the original value set (which must be satisfied in the instance) and a binding to a second value set - which also must be satisfied by the instance.  It wouldn't be possible to have an instance that only contained the code \"navy blue\" and was valid.</p>",
        "id": 153892255,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496618700
    },
    {
        "content": "<p>Encounter.class is an extensible binding, so you can include additional more refined values in the set.</p>",
        "id": 153892268,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1496632277
    },
    {
        "content": "<p>Extensible doesn't allow for more refined values, only for concepts that don't fit within the valueset at all.  If a concept is expressible using the value set at any granularity, the code from the original value set must be used - you can't introduce a narrower one and satisfy the binding.</p>",
        "id": 153892269,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496634053
    },
    {
        "content": "<p>(If that rule weren't in place, 'extensible' would be no different than 'recommended')</p>",
        "id": 153892271,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496634100
    },
    {
        "content": "<p>it would be a little different</p>",
        "id": 153892275,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496634284
    },
    {
        "content": "<p>Not much.  You'd have to argue that the code meant <em>exactly</em> the same thing - which is near-impossible to do across code systems.</p>",
        "id": 153892277,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496635214
    },
    {
        "content": "<p>One way to follow Lloyd's suggestion for a nuanced value, navy-blue rather than blue, is to add an new data element, say colorDetail, with a value set that includes values like navy-blue and sky-blue. Then a resource instance could have <code>color=\"blue\" colorRefined=\"navy-blue\"</code></p>",
        "id": 153892282,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1496642337
    },
    {
        "content": "<p>If the data type isn't a CodeableConcept, then adding an extension is indeed pretty much your ownly choice.</p>",
        "id": 153892284,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496645373
    }
]