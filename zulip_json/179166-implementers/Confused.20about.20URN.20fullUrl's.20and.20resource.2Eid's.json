[
    {
        "content": "<p>Going back to this thread: <a href=\"#narrow/stream/179166-implementers/topic/Resource.2Eid.20requirements\" title=\"#narrow/stream/179166-implementers/topic/Resource.2Eid.20requirements\">https://chat.fhir.org/#narrow/stream/179166-implementers/topic/Resource.2Eid.20requirements</a>. It talks about servers that support search but not read.</p>\n<p>Let's sidestep for a moment the question of how desirable/likely this situation is, and just suppose I have a Bundle with resources that can't be queried individually. To make it possible for resources within the Bundle to reference each other, they all have a UUID based URN as entry.fullUrl (a similar situation might occur when using messaging for example). These UUID's are ephemeral, they are generated when creating the Bundle and not used for anything else.</p>\n<p>We now have to take the following three rules into account:</p>\n<ul>\n<li>entry.fullUrl may not disagree with <a href=\"http://Bundle.resource.id\" target=\"_blank\" title=\"http://Bundle.resource.id\">Bundle.resource.id</a></li>\n<li><a href=\"http://entry.resource.id\" target=\"_blank\" title=\"http://entry.resource.id\">entry.resource.id</a> may not be absent</li>\n<li><a href=\"http://entry.resource.id\" target=\"_blank\" title=\"http://entry.resource.id\">entry.resource.id</a> may not be a UUID based URN. It may be an unprefixed UUID though.</li>\n</ul>\n<p>We're confused about these rules, as they seem to be in conflict. So what should be the proper way to treat <a href=\"http://entry.resource.id\" target=\"_blank\" title=\"http://entry.resource.id\">entry.resource.id</a> when the Bundle.fullUrl is a UUID based URN:</p>\n<ol>\n<li><a href=\"http://entry.resource.id\" target=\"_blank\" title=\"http://entry.resource.id\">entry.resource.id</a> should be the unprefixed version of the URN?</li>\n<li><a href=\"http://entry.resource.id\" target=\"_blank\" title=\"http://entry.resource.id\">entry.resource.id</a> should be absent?</li>\n<li>something else?</li>\n</ol>\n<p>In my opinion, there is an implicit assumption that <a href=\"http://resource.id\" target=\"_blank\" title=\"http://resource.id\">resource.id</a> is something that has a meaning in a RESTful context, and it should be able to construct an URL from it. If that's not possible, then it should be absent. Also, an unprefixed ephemeral UUID is not the same as a <a href=\"http://resource.id\" target=\"_blank\" title=\"http://resource.id\">resource.id</a>. So 2 is the way to go. But maybe this assumption is wrong.</p>\n<p>Bonus question: in practice we see systems POSTing Bundles, using (ephemeral) UUID based URN's as fullUrl but also including a <a href=\"http://resource.id\" target=\"_blank\" title=\"http://resource.id\">resource.id</a>. Sometimes they use the UUID part of the URN, sometimes they use something else. These id's don't have a meaning, but is this allowed?</p>",
        "id": 185107800,
        "sender_full_name": "Pieter Edelman",
        "timestamp": 1578488910
    },
    {
        "content": "<p><a href=\"http://entry.resource.id\" target=\"_blank\" title=\"http://entry.resource.id\">entry.resource.id</a> should be the unprefixed version of the URN.  Within the scope of the Bundle, the UUID acts as the resource id.  In theory, you could have multiple versions of the same resource in the same Bundle sharing the same id but with different versions (even though there's no ability to subsequently query/read them due to no proper base URL).</p>\n<p>In answer to the second, it depends on the type of Bundle.  If it's a transaction and you're doing 'create' actions, there shouldn't be ids.  For other types of bundles (e.g. messages, documents), I'd expect the ids to be present.</p>",
        "id": 185127790,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1578499672
    },
    {
        "content": "<p>..and expect them to be uuids.<br>\nI've seen some facades that allow search but not read. The server is simply unwilling to commit to using any 'solid IDs', so it's search + uuids in response bundles. Rather annoying if one has a FHIR mindset, but from the viewpoint of that legacy system I guess it makes sense.</p>",
        "id": 185184403,
        "sender_full_name": "René Spronk",
        "timestamp": 1578547167
    },
    {
        "content": "<p>Ok, thanks for the clarification!</p>",
        "id": 185189145,
        "sender_full_name": "Pieter Edelman",
        "timestamp": 1578554958
    },
    {
        "content": "<p>So if you have a fullUri why do you need an Id to resolve references within the bundle?</p>",
        "id": 185217399,
        "sender_full_name": "Eric Haas",
        "timestamp": 1578580963
    },
    {
        "content": "<p>In other words can you only have the fullUri and not the I’d in a message bundle?</p>",
        "id": 185217476,
        "sender_full_name": "Eric Haas",
        "timestamp": 1578581011
    },
    {
        "content": "<p>Because it seems easier to omit them</p>",
        "id": 185217624,
        "sender_full_name": "Eric Haas",
        "timestamp": 1578581064
    },
    {
        "content": "<p>The spec currently says \"The only time that a resource does not have an id is when it is being submitted to the server using a create operation.\"  In practice, if you're using a UUID the expectation is that if you send a subsequent message, document, etc. where a resource is identified by the <em>same</em> UUID, then it <em>must</em> be the same resource.  So it's possible to use UUIDs when you have a persistent identity and no REST interface.  Ensuring there's always an id present means that resources function the same way regardless of where they're from.</p>",
        "id": 185218948,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1578581839
    },
    {
        "content": "<p>OK the validator didn't error me when sending message bundles without ids, I assumed that they and transaction integrity since they resolved based on the FullUri... so a $process-message is not a create but an operation so there is some ambiguity in the spec...</p>",
        "id": 185243854,
        "sender_full_name": "Eric Haas",
        "timestamp": 1578596469
    },
    {
        "content": "<p>or the validation</p>",
        "id": 185243903,
        "sender_full_name": "Eric Haas",
        "timestamp": 1578596496
    },
    {
        "content": "<p>Care to submit a change request to get expectations clarified? :)</p>",
        "id": 185243942,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1578596512
    },
    {
        "content": "<p>I will after a little more testing and review</p>",
        "id": 185244009,
        "sender_full_name": "Eric Haas",
        "timestamp": 1578596544
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> there is a follow up <a href=\"#narrow/stream/179263-fhir-messages/topic/Absence.20of.20Reliable.20Messaging.20Documentation\" title=\"#narrow/stream/179263-fhir-messages/topic/Absence.20of.20Reliable.20Messaging.20Documentation\">issue</a> on the messaging channel after looking into id.s vis a vis bundles and messaging... I am trying to understand how to know if the Bundle is truly the same instance when is resent.</p>\n<p>I see where the spec states in the resource profile...   </p>\n<blockquote>\n<p>The only time that a resource does not have an id is when it is being submitted to the server using a create operation.</p>\n</blockquote>\n<p>sounds like an invariant like statement, but probably not processable.  Besides many resources are created on the fly and are only referenced by identifiers since I guess that they never touched a fhir server (yet).  So an operation <em>may</em> result in the creation of a resource on a server or the resource may never persist beyond the transaction.   so is kind of like a lemma to the above statement.   I frankly think adding any more text will only muddy the waters and concede that the best practice is to just add ids (uuid's or whatever) to the Bundles....  I think that the ref servers are pretty generous on this point which led to my laziness in constructing bundles sans ids and may clear up some of my more esoteric validation errors.</p>",
        "id": 185457547,
        "sender_full_name": "Eric Haas",
        "timestamp": 1578876395
    },
    {
        "content": "<p>I'd like to think that <a href=\"http://Resource.id\">Resource.id</a> has relevance only when it actually means you may retrieve this exact resource (albeit versioned) for eternity at the given base until deletion. A server SHALL NOT reuse any <a href=\"http://Resource.id\">Resource.id</a>. Any other use of <a href=\"http://Resource.id\">Resource.id</a>, e.g. populate with random uuid or a make-belief string, is ambiguous and undesirable.</p>\n<p>So the relationship between fullUrl and <a href=\"http://Resource.id\">Resource.id</a> in my mind is like this:</p>\n<ul>\n<li>If <a href=\"http://Resource.id\">Resource.id</a> than SHALL have fullUrl of type absolute URL. <ul>\n<li><a href=\"http://Resource.id\">Resource.id</a> MAY be an unprefixed OID (system/root and value/extension or system/root only if no value/extension)</li>\n</ul>\n</li>\n<li>If Resource.identifier of type OID than MAY have fullUrl of type urn:oid: because OID SHALL be stable and persistent</li>\n<li>If all else fails then SHALL have fullUrl of type urn:uuid:</li>\n</ul>",
        "id": 197913447,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1589796510
    },
    {
        "content": "<p>I don't understand preferring OIDs to GUIDs.  I'd much rather have GUIDs than OIDs because there's no need (or temptation) to try to extract meaning and they're a lot harder to get wrong.</p>",
        "id": 197949841,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1589815143
    },
    {
        "content": "<p>Preferring OIDs over UUIDs is besides the point on <a href=\"http://Resource.id\">Resource.id</a>, but since you asked: the patient ssn, a national identifier for a doctor, a national identifier for an organization are all very common use cases for OIDs in v3. Most of our FHIR data starts its life a v3 data.</p>\n<p>The V3 <a href=\"http://Class.id\">Class.id</a> is the FHIR Resource.identifier, but serves the same purpose as the <a href=\"http://Resource.id\">Resource.id</a>. It uniquely and persistently identifies the Class instance (Act, Role, Entity, ...). So:</p>\n<ul>\n<li>if you have V3 data identified using an oid based <a href=\"http://Class.id\">Class.id</a> (normally root + extension for us) and</li>\n<li>if that <a href=\"http://Class.id\">Class.id</a> root+extension does not violate the FHIR <a href=\"http://Resource.id\">Resource.id</a> limitations of 64 characters and</li>\n<li>if you intend to serve that Class RESTfully based on the <a href=\"http://Class.id\">Class.id</a>, then</li>\n<li>you MAY use the V3 <a href=\"http://Class.id\">Class.id</a> as FHIR <a href=\"http://Resource.id\">Resource.id</a></li>\n</ul>\n<p>UUID may also be <a href=\"http://Resource.id\">Resource.id</a> if you intend to support read on it. An ad hoc UUID could not serve that purpose.</p>",
        "id": 197956791,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1589817993
    },
    {
        "content": "<p>I understand that much of your data might start as OIDs, but you <em>should</em> be converting as many of them as possible to URIs when you port to FHIR (and you MUST convert any of those where FHIR has defined a URI).</p>",
        "id": 197964706,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1589821300
    },
    {
        "content": "<p>For internal identifiers we don't have system URI's. For a limited number of national ones we do. That leads to a system URI in the Resource.identifier.system, but the <a href=\"http://Resource.id\">Resource.id</a> could still be the original OID, hence:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"nt\">&lt;entry&gt;</span>\n  <span class=\"nt\">&lt;fullUrl</span> <span class=\"na\">value=</span><span class=\"s\">&quot;urn:oid:2.16.528.1.1007.3.3.2727&quot;</span><span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;resource&gt;</span>\n     <span class=\"nt\">&lt;Organization&gt;</span>\n        <span class=\"nt\">&lt;identifier&gt;</span>\n           <span class=\"nt\">&lt;system</span> <span class=\"na\">value=</span><span class=\"s\">&quot;http://fhir.nl/fhir/NamingSystem/ura&quot;</span><span class=\"nt\">/&gt;</span>\n           <span class=\"nt\">&lt;value</span> <span class=\"na\">value=</span><span class=\"s\">&quot;00002727&quot;</span><span class=\"nt\">/&gt;</span>\n        <span class=\"nt\">&lt;/identifier&gt;</span>\n         ...\n     <span class=\"nt\">&lt;/Organization&gt;</span>\n  <span class=\"nt\">&lt;/resource&gt;</span>\n<span class=\"nt\">&lt;/entry&gt;</span>\n</code></pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"nt\">&lt;entry&gt;</span>\n  <span class=\"nt\">&lt;fullUrl</span> <span class=\"na\">value=</span><span class=\"s\">&quot;https://example.org/fhir/Organization/2.16.528.1.1007.3.3.2727&quot;</span><span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;resource&gt;</span>\n     <span class=\"nt\">&lt;Organization&gt;</span>\n        <span class=\"nt\">&lt;id</span> <span class=\"na\">value=</span><span class=\"s\">&quot;2.16.528.1.1007.3.3.2727&quot;</span><span class=\"nt\">/&gt;</span>\n        <span class=\"nt\">&lt;identifier&gt;</span>\n           <span class=\"nt\">&lt;system</span> <span class=\"na\">value=</span><span class=\"s\">&quot;http://fhir.nl/fhir/NamingSystem/ura&quot;</span><span class=\"nt\">/&gt;</span>\n           <span class=\"nt\">&lt;value</span> <span class=\"na\">value=</span><span class=\"s\">&quot;00002727&quot;</span><span class=\"nt\">/&gt;</span>\n        <span class=\"nt\">&lt;/identifier&gt;</span>\n         ...\n     <span class=\"nt\">&lt;/Organization&gt;</span>\n  <span class=\"nt\">&lt;/resource&gt;</span>\n<span class=\"nt\">&lt;/entry&gt;</span>\n</code></pre></div>",
        "id": 198030180,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1589873417
    },
    {
        "content": "<p>We keep running into problems with the <a href=\"http://Resource.id\">Resource.id</a> for stateless facade situations. The current FHIR spec (+ tickets that have yet to be applied) thinks there SHALL be a <a href=\"http://Resource.id\">Resource.id</a> except for create / conditional updates. But for stateless facades serving for a non-FHIR system, there may or may not be an id.</p>\n<p>For those systems it is not impossible to generate an ad hoc id, but normally the <a href=\"http://Resource.id\">Resource.id</a> is also the static RESTful id. Ad hoc conflicts with static.</p>\n<p>So my question is: should a system infer RESTful availability from the presence of a <a href=\"http://Resource.id\">Resource.id</a>? If the answer is no we would feel free to follow the FHIR Core spec, and facades would insert an ad hoc id. If the answer is no then we have to infer that stateless FHIR facades cannot exist unless the backend supports RESTful ids. <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span></p>",
        "id": 207230497,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597735748
    },
    {
        "content": "<p>I certainly don't understand all of this question. You have 2 'if the answer is no' but I don't understand other bits like inferring restful availability</p>",
        "id": 207230957,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736155
    },
    {
        "content": "<p>If a resource carries a <a href=\"http://Resource.id\">Resource.id</a>: does that <a href=\"http://Resource.id\">Resource.id</a> have a to be stable?</p>",
        "id": 207231050,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736212
    },
    {
        "content": "<p>If a resource carries a <a href=\"http://Resource.id\">Resource.id</a>: does that mean that I can RESTfull read on Resource/id?</p>",
        "id": 207231118,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736269
    },
    {
        "content": "<p>it's hard to answer that question without more context. If a resource has a different id, it's a different resource</p>",
        "id": 207231120,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736270
    },
    {
        "content": "<blockquote>\n<p>does that mean that I can RESTfull read on Resource/id</p>\n</blockquote>\n<p>I don't think so, but it's not clear what your assumptions are that lead to that question. I certainly don't think that there's a general answer to the question. For a start, what restful server would you decide you could read from with that id safely?</p>",
        "id": 207231242,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736381
    },
    {
        "content": "<p>When you query for data, you get a response Bundle. For a stateless FHIR facade it is not possible to generate stable <a href=\"http://Resource.id\">Resource.id</a> values. Hence it will generate new ids every time you query.</p>",
        "id": 207231287,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736402
    },
    {
        "content": "<p>so this is the result of a search on a restful interface?</p>",
        "id": 207231363,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736441
    },
    {
        "content": "<p>Yes. It supports query, but not read based on id</p>",
        "id": 207231394,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736463
    },
    {
        "content": "<p>well, the first thing to say is that the id in that bundle can never be re-used to identify a different resource.</p>",
        "id": 207231434,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736500
    },
    {
        "content": "<p>but we never state anywhere that you have to be able to read a resource that you got in a search response</p>",
        "id": 207231452,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736517
    },
    {
        "content": "<p>I think it's a really unstable design but it's not non-conformant</p>",
        "id": 207231511,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736535
    },
    {
        "content": "<p>Ok, so that means we cannot populate <a href=\"http://Resource.id\">Resource.id</a> as we cannot guarantee the same id every time you request the same resource</p>",
        "id": 207231530,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736548
    },
    {
        "content": "<p>that's not what i said.</p>",
        "id": 207231561,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736575
    },
    {
        "content": "<p>I said you can't re use the ids. You can give the resources different ids each time. Bad design, and would break lots of clients. But not non-conformant</p>",
        "id": 207231619,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736631
    },
    {
        "content": "<p>Then I don't understand. We can guarantee uniqueness of <a href=\"http://Resource.id\">Resource.id</a> in the Bundle entries, but we cannot guarantee the same <a href=\"http://Resource.id\">Resource.id</a>, upon serving the next query that yields the same resource</p>",
        "id": 207231623,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736634
    },
    {
        "content": "<p>you need to guarantee not to re-use the same id for a different resource. That's not the same thing</p>",
        "id": 207231702,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736678
    },
    {
        "content": "<p>Since generated ids are not stored anywhere on the facade, you could unknowingly regenerate the same id, could you not?</p>",
        "id": 207231724,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736702
    },
    {
        "content": "<p>If the ids are as meaningless as they get in this case: would not populating them not be more safe?</p>",
        "id": 207231865,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736792
    },
    {
        "content": "<p>well, that depends on how you generate them. a UUID is sufficient. or a serial number.</p>",
        "id": 207231868,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736793
    },
    {
        "content": "<p>I'm assuming that you have to populate them for internal references in the bundle, and I'm also thinking that a search bundle needs ids, though I'm not sure we've specifically said that</p>",
        "id": 207231926,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736838
    },
    {
        "content": "<p>The Bundle consistency works fine with fullUrl references without a need for <a href=\"http://Resource.id\">Resource.id</a>.</p>",
        "id": 207231985,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736881
    },
    {
        "content": "<p>if you say so. I'm not sure.</p>",
        "id": 207232069,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736914
    },
    {
        "content": "<p>fullUrl is a UUID in these cases. The beauty about fullUrls is that they are not expected to be unique across different Bundles</p>",
        "id": 207232100,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736933
    },
    {
        "content": "<p>really? I'm not sure about that on search results. But why are UUIDs any different in a fullurl as opposed to a <a href=\"http://resource.id\">resource.id</a>?</p>",
        "id": 207232150,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597736976
    },
    {
        "content": "<p><a href=\"http://Resource.id\">Resource.id</a> on the contrary is expected to be persisted and guaranteed across resources over time.</p>",
        "id": 207232151,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597736976
    },
    {
        "content": "<p>After processing of a response Bundle, the fullUrls have served their purpose and may be forgotten. The Resource.ids live on 'forever'.</p>",
        "id": 207232378,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597737129
    },
    {
        "content": "<p>if we say that, maybe we need to review that in regard to search results, but I'm not aware of us saying that</p>",
        "id": 207232413,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597737162
    },
    {
        "content": "<p>What's the best place to have a proper discussion on the topic? We really need closure on the expectations and boundaries of <a href=\"http://Resource.id\">Resource.id</a>.</p>",
        "id": 207232590,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597737291
    },
    {
        "content": "<p>here and then resolution by FHIR-I</p>",
        "id": 207232726,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597737384
    },
    {
        "content": "<p>Alright, I'm in meetings for the next couple of hours. We've been discussing this issue in various ways before on Zulip and somehow this has not yet gotten to a solution. That must mean we/I have not explained ourselves right. So I'll try to craft something with everything we think we know, maybe as Google doc, and post that here as the basis for further discussion. Would that work or do you have a different proposal?</p>",
        "id": 207233293,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597737853
    },
    {
        "content": "<p>I don't have a better proposal</p>",
        "id": 207233434,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597737974
    },
    {
        "content": "<p>In general there should not be the expectation that a) if one posts a new resource, that somehow the <a href=\"http://resource.id\">resource.id</a> listed in it would be persisted/used by the receiving server, nor b) that resource.ids listed in a search result would be persisted by a client. The scope of use for a <a href=\"http://resource.id\">resource.id</a> value, when talking about persistence, is limited to one single server.</p>",
        "id": 207234342,
        "sender_full_name": "René Spronk",
        "timestamp": 1597738710
    },
    {
        "content": "<p>Where does it say that a server, once it has communicated a resource with a certain <a href=\"http://resource.id\">resource.id</a>, that it SHALL support reads based on that same <a href=\"http://resource.id\">resource.id</a> ? It won't be able to guarantee that anyway, as the resource may be deleted at some future point in time.</p>",
        "id": 207234416,
        "sender_full_name": "René Spronk",
        "timestamp": 1597738778
    },
    {
        "content": "<p>At the very least you would expect, if you get data, that the data corresponds with the same resource every time. If you generate ids without keeping track of what you generated, say 2 months ago, it is possible that it generates the same id twice.</p>",
        "id": 207234734,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597738972
    },
    {
        "content": "<p>With UUIDs or the inclusion of a time-stamp as part of the id that's not very likely. But yes, one should not re-use one and the same <a href=\"http://resource.id\">resource.id</a> for two semantically different resources. That's a fairly low bar for a facade.</p>",
        "id": 207234896,
        "sender_full_name": "René Spronk",
        "timestamp": 1597739085
    },
    {
        "content": "<p>But more importantly: the facades I'm talking about do <em>not</em> support read at all based on [type]/[id]. Why would you even need a <a href=\"http://Resource.id\">Resource.id</a> if not for RESTful read? The Resource.identifier is a different matter.</p>",
        "id": 207234935,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597739115
    },
    {
        "content": "<p>The Facade use case is not the 80%. Just populate <a href=\"http://resource.id\">resource.id</a> with the fullURL minus its initial part.  fullURL and id (=leafURL) are tightly related anyway.</p>",
        "id": 207235096,
        "sender_full_name": "René Spronk",
        "timestamp": 1597739247
    },
    {
        "content": "<p>The <a href=\"http://Resource.id\">Resource.id</a>, as generated by a face, should have added value to a receiver. I'm arguing there is no value. It is an ad hoc, fire and forget, value with no relationship to the backend system. Why does a facade have to populate data that has no value?</p>",
        "id": 207235184,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597739294
    },
    {
        "content": "<p>Because it's useful in most situations. The alternative, which is to make <a href=\"http://resource.id\">resource.id</a> optional, would cause a lot more issues than the one faced by facades like yours.</p>",
        "id": 207235740,
        "sender_full_name": "René Spronk",
        "timestamp": 1597739671
    },
    {
        "content": "<p>Useful how? Only if RESTful read is possible? Or also in other cases?</p>",
        "id": 207235806,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597739729
    },
    {
        "content": "<p>In most FHIR implementations there is consistency in the use of <a href=\"http://resource.id\">resource.id</a> as long lived identifier of a particular resource instance. If you start to question that, then you're questioning one of the basic principles of REST. You can, but this is hardly the forum to discuss the merits of one of the key REST principles.</p>",
        "id": 207235969,
        "sender_full_name": "René Spronk",
        "timestamp": 1597739880
    },
    {
        "content": "<p>I'm arguing that if you do RESTful read, you SHALL have persistent/unique <a href=\"http://Resource.id\">Resource.id</a>. I'm also arguing that if you cannot support RESTful read/persistent/unique Resource.ids you SHALL NOT populate them</p>",
        "id": 207236119,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597739989
    },
    {
        "content": "<p>The current spec requires me to populate Resource.ids regardless of my situation.</p>",
        "id": 207236178,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597740026
    },
    {
        "content": "<p>Note that <a href=\"http://Resource.id\">Resource.id</a> already is optional. It's the text around it that tries to convey the conditions on when you should/shall use it. (currently just POST and conditional update)</p>",
        "id": 207236333,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597740179
    },
    {
        "content": "<p>I can see your position, but the price we'd pay would be way to high IMHO to make such a change, whereas the price of the Facade generating some dummy ids is very very low.  Feel free to create an issue with your detailed arguments ;-)</p>",
        "id": 207236400,
        "sender_full_name": "René Spronk",
        "timestamp": 1597740240
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191372\">@René Spronk</span>, I don't really understand what the price to pay is.</p>\n<p>At first glance, it may seem like a nice consistent rule to state that all resources in a searchset Bundle should have .id populated. However, its value in this context can never be interpreted in isolation since there is no indication of the _kind_ of id you're using. It might be an actual logical id that is persistent on the server, or it might be something temporary for the Bundle only. You will always need to inspect the corresponding fullUrl to figure this out.</p>\n<p>So there's no actual _need_ for .id in searchset Bundles, and IMO it only leads to confusion if you allowing different kinds of id's in the .id field. It also breaks the expectation that the .id is \"The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.\" I think it would make much more sense to say that you only populate the .id field IF you have a logical, persistent id. Otherwise, you just use fullUrl for inter-Bundle references and forget about the whole .id field.</p>",
        "id": 207240542,
        "sender_full_name": "Pieter Edelman",
        "timestamp": 1597743697
    },
    {
        "content": "<p>\"you only populate the .id field IF you have a logical, persistent id\" - but that condition is not testable. As such a client won't have a clue (ever) whether or not they'll receive an id. Lazy servers will omit the id by default. Inconsistency rules. That's the price I'm talking about.</p>",
        "id": 207241623,
        "sender_full_name": "René Spronk",
        "timestamp": 1597744589
    },
    {
        "content": "<p>Yes, but the a client will never need to look at .id anyway (in searchset Bundle's), because it can only be interpreted in the context of .fullUrl. And .fullUrl doesn't need .id because it already contains all the information needed.<br>\nIf the server always includes .id's, a lazy client might make the naïve assumption that they can simple be used as logical ids for RESTful reads, without bothering with .fullUrl's.</p>",
        "id": 207243047,
        "sender_full_name": "Pieter Edelman",
        "timestamp": 1597745870
    },
    {
        "content": "<p>And don't forget that servers do not enter the network without vetting. At vetting time we inspect how they operate. Not having a <a href=\"http://Resource.id\">Resource.id</a> because of laziness will be detected and is not allowed. We firmly steer towards having <a href=\"http://Resource.id\">Resource.id</a> that is meaningful, but if a facade is unable to populate it, and we have no use case for 'read' we don't expect the facade to fake a <a href=\"http://Resource.id\">Resource.id</a> on the resources.</p>\n<ol>\n<li>The client would otherwise never know what the value of the <a href=\"http://Resource.id\">Resource.id</a> is (if it truly identifies the object on the origin server or not)</li>\n<li>The server may inadvertently be guilty of the biggest sin of all, which is to issue the same <a href=\"http://Resource.id\">Resource.id</a> twice on different resources (of the same type)</li>\n</ol>",
        "id": 207248550,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597750425
    },
    {
        "content": "<p>All in all the condition on <a href=\"http://Resource.id\">Resource.id</a> is testable, just not in an automated way. The upside for clients is that if they encounter a <a href=\"http://Resource.id\">Resource.id</a>, they know what it stands for and trust it.</p>",
        "id": 207248795,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597750631
    },
    {
        "content": "<p>This is really good discussion, and I look forward to seeing Alexander's proposal. I agree with premise here that populating <a href=\"http://resource.id\">resource.id</a> sometimes provides no value, and can be hard for servers to do properly.</p>\n<p>That said, <span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span>, if you can share some more details about your facade architecture I would find that quite helpful. Often a facade sits in front of some other database or interface where data objects have some kind of internal identifier like a primary key -- which the facade can combine with some representation of the source system and hash to create a unique + stable fhir <a href=\"http://Resource.id\">Resource.id</a>. It would be great if you can share a few details about your system/constraints, because I bet it is quite different from what I described here :-)</p>",
        "id": 207259278,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1597757532
    },
    {
        "content": "<p>One thing that is not clear to me, is whether the facade that only supports search, but not read, does not implement search using _id (i.e. <code>GET [base]/resource?_id=33adne5528340</code>)</p>",
        "id": 207262776,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1597759396
    },
    {
        "content": "<p>I think if it is able to support stable ids, then it could choose to support this search parameter. But in Alexander's example, by definition the server could not and so would not support the search parameter.</p>",
        "id": 207264167,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1597760071
    },
    {
        "content": "<p>It could support it, but there would (by definition) never be a match :-)</p>",
        "id": 207265411,
        "sender_full_name": "René Spronk",
        "timestamp": 1597760646
    },
    {
        "content": "<p>The Dutch use case (which Alexander refers to) is an aggregator, which by law isn't allowed to store any data itself. Receives a query from a client, sends queries (potentially using standards other than FHIR) to multiple applications (a selection of all Dutch national infrastructure enabled applications), aggregates the responses in a FHIR response bundle. The aggregator has no knowledge of the storage layer of the responding systems.</p>",
        "id": 207265950,
        "sender_full_name": "René Spronk",
        "timestamp": 1597760909
    },
    {
        "content": "<p>Don't see how things would work without ids - it is central to references, how you access data, pretty much everything in FHIR</p>",
        "id": 207282006,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1597768183
    },
    {
        "content": "<p>Exposing the read operation is not the same as storing any data. Going though the effort to enable search and the ability to return search bundles, but not exposing a simple read sounds strange to me. Assuming that there are identifiers in the resources returned, the id can be a hash based on system and value.</p>",
        "id": 207287958,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1597771116
    },
    {
        "content": "<p>The backends for these types of facades are V3. In V3 you have identifiers, but not ids. The aggregation that Rene refers to, could happen but doesn't at present: data comes from exactly 1 system. The facade is bridging a V3 messaging infrastructure that support some queries but not every type that FHIR theoretically could support. Some objects may be queried by identifier, but a V3 identifier may or may not be compatible with the special <a href=\"http://Resource.id\">Resource.id</a> requirements especially in STU3. A valid V3 identifier could look like this:</p>\n<p>&lt;id root=\"2.16.528.1.1007.3.3.112233445.1\" extension=\"235\"/&gt;</p>\n<p>This could be turned into a <a href=\"http://Resource.id\">Resource.id</a> by concatenation: 2.16.528.1.1007.3.3.112233445.1.235 carrying the same semantics in terms of persistency and uniqueness. A V3 identifier could also look like this:</p>\n<p>&lt;id root=\"2.16.528.1.1007.3.3.112233445.1\" extension=\"b615a4a2-5fe1-4d6f-9411-81139ef7f2a6\"/&gt;<br>\nor this:<br>\n&lt;id root=\"2.16.528.1.1007.3.3.112233445.1\" extension=\"202009_abcd\"/&gt;</p>\n<p>This could not be turned into a <a href=\"http://Resource.id\">Resource.id</a> because it exceeds 64 characters or the allowed character set respectively. But even more importantly in all three cases: how do I map a <a href=\"http://Resource.id\">Resource.id</a> back into a meaningful V3 query?</p>\n<p>Suppose FHIR read of [base]/Observation/[id] ... how do I ever know whether I should issue a POOB_IN990001NL message with [id] split back into @root and @extension, or into a POLB_IN354001NL03 message? The first yields generic observations like length/height, the second yields lab observations.</p>\n<p>Based on a read of Observation there could be 10-20 applicable different V3 queries. So even if I was able to construct a valid FHIR <a href=\"http://Resource.id\">Resource.id</a> from a V3 identifier... I would still be left in the dark. Should I just fire them all in V3 and hope one yields data?</p>",
        "id": 207320249,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597787078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192685\">@Vassil Peytchev</span> Similar to read we cannot support _id in these situations. We never specify use of _id anyway and only talk about a subset of query parameters that FHIR supports. While systems are allowed to support more (within the use case boundaries), they are only tested for the specified set. We specify for use cases, not for general purpose FHIR servers.</p>",
        "id": 207346634,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597787342
    },
    {
        "content": "<p>How are you going to handle references between resource if there are no ids? eg how does a DiagnosticReport references its Observation, or an Observation its Patient or Encounter?</p>",
        "id": 207355041,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1597793433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span>  Within a bundle this is done using a resolution rules based on bundle entry full URL. Like <a href=\"https://github.com/microsoft-healthcare-madison/health-wallet-demo/blob/master/src/fixtures/vc-jwt-payload.json#L58\">this example</a>; spec at <a href=\"http://build.fhir.org/bundle.html#references\">http://build.fhir.org/bundle.html#references</a>. For Alexander's use case there is no need to create references that go beyond the boundaries of a bundle.</p>",
        "id": 207362820,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1597802099
    },
    {
        "content": "<p>this is not an unusual situation when you are putting a pseudo-restful facade in front of a service orientated architecture that has no place for consistent identification. All the facade can do is pass the problem on downstream to the client, which can't consistently identify data between calls, for the same reason the facade can't. (such efforts start out looking each but always turn into  a sisyphean task - <a href=\"https://www.cartoonstock.com/cartoonview.asp?catref=CX903792\">https://www.cartoonstock.com/cartoonview.asp?catref=CX903792</a>)</p>",
        "id": 207370452,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597812978
    },
    {
        "content": "<p>Well, maybe. The example seems to be wrong, because Reference.reference is defined as a URL, yet in at least one instance, it contains a URN.</p>\n<p>Here is the short description of Reference.reference:</p>\n<blockquote>\n<p>Literal reference, Relative, internal or absolute URL</p>\n</blockquote>\n<p>Everything directly describing and defining Reference.reference insists that the string must be a URL.</p>\n<p>Here is the definition of Bundle.entry.fullURL</p>\n<blockquote>\n<p>URI for resource (Absolute URL server address or URN for UUID/OID)</p>\n</blockquote>\n<p>Further explanation on fullURL</p>\n<blockquote>\n<p>[...] each entry in a Bundle must have a fullUrl which is the identity of the resource in the entry. Note that this is not a versioned reference to the resource, but its identity. Where a resource is not assigned a persistent identity that can be used in the Bundle, a UUID should be used (urn:uuid:...).</p>\n</blockquote>\n<p>Only then come the <a href=\"http://build.fhir.org/bundle.html#references\">resolution rules for resources within a Bundle</a>, and here we have a discrepancy, as there is an implication that Reference.reference can be a URI that is not a URL, and the example that shows reference containing a URN. Since this seems to contradict the definition of Reference.reference, I think the implication needs a technical correction, and the example needs to be fixed.</p>\n<p>The way the normative content is written, to me it seems that the following should be true:<br>\nIf the fullUrl is a URN, it can't be used in Reference.reference, only reference.identifier can be used.</p>\n<p>For Alexander's case, using reference.identifier will allow for proper resolution. I think, however, that there is also value to provide <a href=\"http://Resource.id\">Resource.id</a> for the resources, by simply calculating the SHA1 or SHA256 of the root+extension, as that will be a consistent .id. This way you are not completely designing yourself into a dead end...</p>",
        "id": 207372462,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1597815859
    },
    {
        "content": "<p>I don't think that this interpretation is correct, actually. One of the problems here is that the definitions that W3C have provided are incomplete, inconsistent, and vague. </p>\n<p>My working definition is:<br>\nuri: A sequence of characters that identifies an abstract or physical resource<br>\nurl: a URI that can be resolved to a physical resource<br>\nurn: a URI that is globally unique and persistent even when the resource ceases to exist or becomes unavailable</p>\n<p>From this I draw 2 conclusions:</p>\n<ul>\n<li>FHIR RESTful URLs are very definitely URLs and they are also URNs</li>\n<li>A URI can be a URL if it is well understand how it resolves to a physical resource. Whether it starts with urn: or not is not the point.</li>\n</ul>\n<p>Hence: Reference.reference does need to be a URL, not a URI. It is intended to resolve. But it can be, in <em>and only in</em> the context of a bundle, a URL that starts with urn:</p>",
        "id": 207378419,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597822743
    },
    {
        "content": "<p>It took me a little more time than anticipated, but I've drafted a document with the issue at hand. It should be world writable:</p>\n<p><a href=\"https://docs.google.com/document/d/1RKuvZ5ttRnpaTOG4JntcpRz7BJFiHRTIRyOTwZlo0PY/edit?usp=sharing\">https://docs.google.com/document/d/1RKuvZ5ttRnpaTOG4JntcpRz7BJFiHRTIRyOTwZlo0PY/edit?usp=sharing</a></p>\n<p>Let me know if it is missing arguments. What I hope we land at, is an update in FHIR Core for <a href=\"http://Resource.id\">Resource.id</a> that either:</p>\n<ul>\n<li>Sets unambiguous, realistic rules for when a <a href=\"http://Resource.id\">Resource.id</a> SHALL be present and acknowledges that this may mean that are also cases where <a href=\"http://Resource.id\">Resource.id</a> is _not_ present, other than post/conditional update (preferred)</li>\n</ul>\n<p>or</p>\n<ul>\n<li>Requires <a href=\"http://Resource.id\">Resource.id</a> to be present as it currently does, and acknowledges that <a href=\"http://Resource.id\">Resource.id</a> in this case may or may not have RESTful value (not preferred)</li>\n</ul>",
        "id": 207400830,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597840296
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> I do not understand. If a client search for Observation it gets back a bundle of observations - in-bundle resource references are not going to help to get to the encounters that those observation references, they are not in that bundle (or even if they are, the client would not expect them to be there - it asked for observations)</p>",
        "id": 207401159,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1597840550
    },
    {
        "content": "<p>A server may include whenever it feels it needs to, regardless of client query. We normally anticipate clients having to request _include though</p>",
        "id": 207401278,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597840615
    },
    {
        "content": "<p>But yes... in certain corner cases the reference.identifier is being used (logical reference) which leaves systems with no other option than to marry Encounter.identifier in a different query to the logical reference.</p>",
        "id": 207401348,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597840681
    },
    {
        "content": "<p>.Yes, so it needs to be a client written specifically for that server behavior, a generic FHIR client won't work, that was Grahme point I think</p>",
        "id": 207401707,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1597840895
    },
    {
        "content": "<p>I thing the specs should forbid that if they don't already do that</p>",
        "id": 207401818,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1597840951
    },
    {
        "content": "<p>Logical references in general are always a dead end, but that was just the design I believe. A regular FHIR client would not know what to do there</p>",
        "id": 207401918,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597841023
    },
    {
        "content": "<p>But note: logical references are not the highlight of the topic. I'm talking mostly about Bundle with Observation that references an Encounter that is present in that same Bundle and referred to by means of its fullUrl. Any regular FHIR client would get that today. However as long as the <a href=\"http://Encounter.id\">Encounter.id</a> is not present: it is considered non conformant</p>",
        "id": 207402340,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597841253
    },
    {
        "content": "<p>This is more urgent in healthcare than it is in the general REST community due to the fact that healthcare is made up of thousands and thousands of servers, with data on any one patient split across hundreds. So we MUST be better able to deal with this. logical id is fine in a monolithic environment, but fails in healthcare.  This is not to say that I want to eliminate logical id, I love it... but we must recognize that we are dealing with patients that are getting coordinated care (eg. carePlan) that is NOT on a monolithic REST server.</p>",
        "id": 207402818,
        "sender_full_name": "John Moehrke",
        "timestamp": 1597841496
    },
    {
        "content": "<p>Understood. Logical reference has purpose, but should be avoided if possible because it suggests custom resolving.</p>",
        "id": 207402973,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597841568
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span> i totally follow and forsee that i have the same needs as you</p>",
        "id": 207404698,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597842473
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  I am having trouble finding references that support your conclusion that a fhir restful URL can be considered a \"URN\". <a href=\"https://www.w3.org/TR/uri-clarification/\">https://www.w3.org/TR/uri-clarification/</a> provide some context, but as far as I can tell, a necessary condition for something to be a URN is starting with the <code>urn</code> prefix.</p>",
        "id": 207405552,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1597842945
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> I agree with your point that clients would not be able to follow normal references to get more data than they had originally queried for. There are probably circumstances where this is a reasonable trade-off. But it would be a big problem if <em>any</em> fhir server could choose to inflict this pain on clients -- like in the scope of patient API access in the US, if it suddenly became okay for a server to just break all links by omitting resource IDs, that would be a total fai</p>",
        "id": 207406227,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1597843264
    },
    {
        "content": "<p>well, I feel as though that document doesn't help, in that what you are referring to is \"URN Namespaces\" which is not quite the same as \"a URN\".</p>",
        "id": 207406320,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597843317
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> I agree with your point that clients would not be able to follow normal references to get more data than they had originally queried for. There are probably circumstances where this is a reasonable trade-off. But it would be a big problem if <em>any</em> fhir server could choose to inflict this pain on clients -- like in the scope of patient API access in the US, if it suddenly became okay for a server to just break all links by omitting resource IDs, that would be a total failure. Getting the conformance language right here is critical, and if we relax it in the base specification then many implementation guides and they need to make updates to tighten it downstream.</p>",
        "id": 207406502,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1597843423
    },
    {
        "content": "<p>In practice it gets pretty painful to manage!</p>",
        "id": 207406575,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1597843443
    },
    {
        "content": "<p>the earlier RFC says that it's a name if it is reliably unique.</p>",
        "id": 207406886,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597843585
    },
    {
        "content": "<p>Here is <a href=\"https://tools.ietf.org/html/rfc8141\">RFC 8141</a> that defines URNs</p>\n<p>The W3C link Josh shared, while not clarifying everything about URIs, seems to confirm my understanding that basically, URI is the union of URL and URN, and URLs and URNs are disjoint sets.</p>",
        "id": 207407655,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1597843968
    },
    {
        "content": "<p>Correct me if I'm wrong - but it is absolutely crucial to the spread of FHIR that it is usable as a façade layer in front of existing legacy infrastructure as <span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span> describes</p>",
        "id": 207408139,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597844167
    },
    {
        "content": "<p>which means that there are many situations where the <a href=\"http://Resource.id\">Resource.id</a> has little / no value</p>",
        "id": 207408256,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597844218
    },
    {
        "content": "<p>that doesn't mean that it will always be possible to do it without pain</p>",
        "id": 207408273,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597844224
    },
    {
        "content": "<p>when used as an API as a facade... I think it is important that <a href=\"http://Resource.id\">Resource.id</a> management is an expectation. It might not be easy, but it is necessary.</p>",
        "id": 207408441,
        "sender_full_name": "John Moehrke",
        "timestamp": 1597844299
    },
    {
        "content": "<p>That makes very little sense</p>",
        "id": 207408770,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597844442
    },
    {
        "content": "<p>We've had similar discussions about this before with eg. how terminology services sort of differ from how clinical servers work</p>",
        "id": 207408965,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597844525
    },
    {
        "content": "<p>And now there is a case for facades as well</p>",
        "id": 207409012,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597844545
    },
    {
        "content": "<p>For what it's worth: I actually think it is a specific (small?) subset of facade servers that have this problem; most facade servers I have come across at least are wrappers around existing structured data stores that just happen happen not to use fhir; they are perfectly capable of generating stable IDs and resolving references.</p>",
        "id": 207409989,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1597845008
    },
    {
        "content": "<p>Imaging an on-demand service behind a FHIR facade</p>",
        "id": 207410294,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597845143
    },
    {
        "content": "<p>Or a service from which you only get sensitive business identifiers which may not be part of an URL in a request as it will be  logged across all kind of different passing proxies. That is a real concern and a real problem of mine</p>",
        "id": 207411616,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597845730
    },
    {
        "content": "<p>At the bottom of the <a href=\"http://build.fhir.org/resource.html#id\">Logical ID</a> section, we find the following (key phrase is in bold):</p>\n<blockquote>\n<p>In some contexts, resources are not associated with location on a RESTful server, either because they are only created transiently for transfer between systems, or the systems are not using RESTful servers. In these cases, resources may be assigned some kind of location anyway, for purposes of consistency, or <strong>they might not have an assigned logical id</strong>, and they are identified based on other kinds of identifiers. See Resolving references in Bundles for one method of using resources not associated with RESTful servers.</p>\n</blockquote>\n<p>We definitely need to clarify the language, even if we agree on the intent...</p>",
        "id": 207415151,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1597847423
    },
    {
        "content": "<p>Just for the record: I agree with everybody who says we should push FHIR Servers to do what they can to arrange for Resource.ids. In fact that is what we already do. However: in a facade situation where the backend is not the system itself, but some form of messaging like V3 where there is no reasonable expectation that a <a href=\"http://Resource.id\">Resource.id</a> is persistent and unique for that Resource ... we currently allow the <a href=\"http://Resource.id\">Resource.id</a> to be omitted, and never expect a system to generate ad hoc Recource.ids just to comply with having one.</p>",
        "id": 207493791,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597906392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191427\">Jens Villadsen</span> <a href=\"#narrow/stream/179166-implementers/topic/Confused.20about.20URN.20fullUrl's.20and.20resource.2Eid's/near/207411616\">said</a>:</p>\n<blockquote>\n<p>Or a service from which you only get sensitive business identifiers which may not be part of an URL in a request as it will be  logged across all kind of different passing proxies. That is a real concern and a real problem of mine</p>\n</blockquote>\n<ul>\n<li>and in that case, issuing GET on the Resource/[id] is not an option. For the same reasons, the searches are conducted using the POST method with application/x-www-form-urlencoded parameters</li>\n</ul>",
        "id": 207493976,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597906596
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"191315\">Josh Mandel</span> / <span class=\"user-mention silent\" data-user-id=\"191912\">Michele Mottini</span> I agree with your point that clients would not be able to follow normal references to get more data than they had originally queried for.</p>\n</blockquote>\n<p>I also agree with that. We require that servers that cannot support read actions on essential data attached to the focal resources, SHALL include this data with the response Bundle, thus eliminating the need for read actions. Inclusion of data is server discretion for as far as the FHIR spec goes, so a client does not have to ask for it.</p>",
        "id": 207493982,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597906607
    },
    {
        "content": "<p>In such cases, is it useful to pretend there is a RESTful search interface? Why not have these as operations?</p>",
        "id": 207521267,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1597929797
    },
    {
        "content": "<p>Or just present it as what it is, a messaging interface.</p>",
        "id": 207522187,
        "sender_full_name": "John Moehrke",
        "timestamp": 1597930300
    },
    {
        "content": "<p>Its not messaging as it aint async</p>",
        "id": 207524876,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597931934
    },
    {
        "content": "<blockquote>\n<p>In such cases, is it useful to pretend there is a RESTful search interface? Why not have these as operations?</p>\n</blockquote>\n<p>I fail to see how that would help. Operations require far more work on the server side than simple queries. Nothing on the network would compare to anything in the outside world. It would do nothing for <a href=\"http://Resource.id\">Resource.id</a>. Why do you think it helps?</p>",
        "id": 207530689,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597934969
    },
    {
        "content": "<p>It makes clear to the client that they are not really dealing  with a REST interface and that they are expected to do things in a different way</p>",
        "id": 207530886,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1597935049
    },
    {
        "content": "<p>Sorry but no. We support RESTful query here, just not (always) RESTful read. It makes no sense at all do ditch RESTful just because we have a few limitations for some systems. The system works fine. It works fine with out-of-the-box reference frameworks. What you are asking here is to make it a proprietary network (messaging/operations). No can do</p>",
        "id": 207531116,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597935168
    },
    {
        "content": "<p>REST is more about the resource id, than it is about query / search models. I think you are confusing REST with http GET</p>",
        "id": 207533717,
        "sender_full_name": "John Moehrke",
        "timestamp": 1597936373
    },
    {
        "content": "<p>My thinking (and <span class=\"user-mention\" data-user-id=\"192685\">@Vassil Peytchev</span> ?)  is that it does things so differently from 'normal' FHIR server that is already proprietary - so better be upfront about it</p>",
        "id": 207534320,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1597936660
    },
    {
        "content": "<p>we tend to push complexity to servers... so either accept the need for <a href=\"http://resource.id\">resource.id</a> and do extra work to de-duplicate and track things on the server for the benefit of clients not needing to do something different (meaning clients can query and retrieve). OR make it clearly different using an operation with more of a messaging pattern.</p>",
        "id": 207534986,
        "sender_full_name": "John Moehrke",
        "timestamp": 1597936973
    },
    {
        "content": "<p>Ok, if you put it like that: could FHIR Core please remove the requirement for <a href=\"http://Resource.id\">Resource.id</a> based on the fact that there are more uses for FHIR than RESTful?</p>",
        "id": 207549256,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597944034
    },
    {
        "content": "<p>That's an interesting suggestion. Note that 'Bundles' (even if transported via HTTP) are strictly taken not RESTful ..</p>",
        "id": 207549752,
        "sender_full_name": "René Spronk",
        "timestamp": 1597944291
    },
    {
        "content": "<p>So does search even count as RESTful then? Every query yields a Bundle.</p>",
        "id": 207551269,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597945011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191375\">Alexander Henket</span> <a href=\"#narrow/stream/179166-implementers/topic/Confused.20about.20URN.20fullUrl's.20and.20resource.2Eid's/near/207549256\">said</a>:</p>\n<blockquote>\n<p>Ok, if you put it like that: could FHIR Core please remove the requirement for <a href=\"http://Resource.id\">Resource.id</a> based on the fact that there are more uses for FHIR than RESTful?</p>\n</blockquote>\n<p>quite possibly the right question. The model so far has been dominated by REST. It is possible some requirements that should be limited to REST have leaked in as absolutes.</p>",
        "id": 207555686,
        "sender_full_name": "John Moehrke",
        "timestamp": 1597947303
    },
    {
        "content": "<p>I am repeating myself, but here it is:</p>\n<p>At the bottom of the <a href=\"http://build.fhir.org/resource.html#id\">Logical ID</a> section, we find the following (key phrase is in bold):</p>\n<blockquote>\n<p>In some contexts, resources are not associated with location on a RESTful server, either because they are only created transiently for transfer between systems, or the systems are not using RESTful servers. In these cases, resources may be assigned some kind of location anyway, for purposes of consistency, or <strong>they might not have an assigned logical id</strong>, and they are identified based on other kinds of identifiers. See Resolving references in Bundles for one method of using resources not associated with RESTful servers.</p>\n</blockquote>",
        "id": 207569144,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1597954393
    },
    {
        "content": "<p>Well  - the description on logical Id's as <span class=\"user-mention\" data-user-id=\"192685\">@Vassil Peytchev</span> pointed out allows it</p>",
        "id": 207569158,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597954405
    },
    {
        "content": "<p>oh snap ... double post!</p>",
        "id": 207569172,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597954413
    },
    {
        "content": "<p>catching up on this thread:</p>\n<p><span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span> I don't think that changing to an operation from a search is a big a deal as you made it out to be; it would effectively be changing from <code>[base]/[type]?params</code> to <code>[base]/[type]/$query?params</code>, but everything would otherwise be the same. </p>\n<p>Michele's proposal to do this would make sense because:</p>\n<ul>\n<li>it makes clear that you are not dealing with the search obligations</li>\n<li>Clients won't accidentally get themselves in trouble; if they get in trouble with this approach (they will anyway!) you can at least be clear that they should've paid attention</li>\n</ul>\n<p>OTOH, there's several reasons I can think of why it wouldn't be a good idea to do it.</p>",
        "id": 207574952,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597957822
    },
    {
        "content": "<blockquote>\n<p>could FHIR Core please remove the requirement for <a href=\"http://Resource.id\">Resource.id</a> based on the fact that there are more uses for FHIR than RESTful</p>\n</blockquote>\n<p>I'm not familiar with this requirement you are referring to here.</p>",
        "id": 207574980,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597957850
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span> Whilst quite a few REST APIs use some sort of bundle principle for search results, most other bundles in FHIR are effectively an attempt to do non-RESTful things in a HTTP-transport context (messaging, documents, collections, transactions, .. - in all of those bundles it's easy to see that one may not have resource.ids, and that fullURLs are sufficient to establish linkages). </p>\n<p>Note that resources in bundles <em>could</em> have a <a href=\"http://resource.id\">resource.id</a>, which means that a receiving application can use that id to fetch additional (related) resources or that it could subscribe to updates. </p>\n<p>The text cited by Vassil already allows for resource.ids to be omitted. If that wording is limited to bundles (of any kind) then certainly I'd agree with the wording.</p>",
        "id": 207605579,
        "sender_full_name": "René Spronk",
        "timestamp": 1597993739
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> / <span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> I don't think operations make sense because it does not change anything for the FHIR resources you retrieve. They are still required to have the Resource.id's that we can't provide ... in some cases.</p>\n<p>Also it means that the majority of systems that behave RESTfully, serve the exact same use cases, need different ways of accessing that information. So if I want my patient summary from system A I need to jump through hoop A and if want that very same patient summary from system B I need to jump through hoop B.</p>\n<p>And finally: we have had the hardest time getting all systems to implement the few operations we have (like MedicationOverview). Not one reference framework has ever had any trouble implementing standard query behavior. From an economical perspective it does not make sense to do operations at scale. We do operations if it cannot be done otherwise.</p>\n<p>There are really only two ways out of this is, imo:</p>\n<ul>\n<li>to lift the RESTful bias from the <a href=\"http://Resource.id\">Resource.id</a>, or</li>\n<li>to accept that <a href=\"http://Resource.id\">Resource.id</a> is not a guaranteed access key to a RESTful endpoint</li>\n</ul>\n<p>I know what I would choose: reliability of what <a href=\"http://Resource.id\">Resource.id</a> means. If it exists, it SHALL be clear. If it does not: that's clear too.</p>",
        "id": 207606146,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597994430
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191372\">@René Spronk</span> </p>\n<blockquote>\n<p>Note that resources in bundles <em>could</em> have a <a href=\"http://resource.id\">resource.id</a>, ...</p>\n</blockquote>\n<p>No that is not correct. FHIR spec says <a href=\"http://Resource.id\">Resource.id</a> SHALL be present except for POST and there is an accepted but not yet applied ticket from Ewout that argues \"conditional updates\". Any other Resource regardless it being retrieved by operation or query, sent in a Bundle, SOAP, messaging  or contained SHALL have a <a href=\"http://Reource.id\">Reource.id</a>.</p>",
        "id": 207606635,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1597995026
    },
    {
        "content": "<p>Contrary to my initial position I'm now suggesting to add such wording: that <a href=\"http://resource.id\">resource.id</a> in Bundles (of any type) may not be present.</p>",
        "id": 207607058,
        "sender_full_name": "René Spronk",
        "timestamp": 1597995447
    },
    {
        "content": "<p>In addition to support <span class=\"user-mention\" data-user-id=\"191372\">@René Spronk</span> and <span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span>  a HL7 standardized extension to the CapabilityStatement resource could be to flag the behavioural pattern eg. and extension that clearly states that <a href=\"http://Resource.id\">Resource.id</a> is not to be expected in the bundles or alike (a hierarchy of extensions could also be suitable if eg. certain behaviour can be established - eg. an extension saying this service acts as a façade (whatever fixed behaviour that means) ).</p>",
        "id": 207608373,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1597996578
    },
    {
        "content": "<blockquote>\n<p>FHIR spec says <a href=\"http://Resource.id\">Resource.id</a> SHALL be present except for POST and there is an accepted but not yet applied ticket from Ewout that argues \"conditional updates\".</p>\n</blockquote>\n<p>I am confused. Where does it say that?</p>",
        "id": 207634684,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1598017090
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span> I've had a chance to read your document. In that document, you write:</p>\n<blockquote>\n<p>We also think that if a <a href=\"http://Resource.id\">Resource.id</a> is present, and the origin server is a RESTful server at all, it SHALL be capable of serving the resource by means of its <a href=\"http://Resource.id\">Resource.id</a></p>\n</blockquote>\n<p>This is ambiguous. Are you saying that this is a rule that you want to make? Well, you can, but I want to be clear that this is not something that the core spec says, not will it ever say this.</p>\n<p>What is still not clear to me is how much your whole argument is based on this position</p>",
        "id": 207742651,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598131134
    },
    {
        "content": "<p>There's been several references in this thread to an unapplied task from Ewout about this, but I'm not sure which task this is. <a href=\"http://jira.hl7.org/browse/FHIR-20390\">J#20390</a> ?</p>",
        "id": 207742893,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598131585
    },
    {
        "content": "<p>ah no it's <a href=\"http://jira.hl7.org/browse/FHIR-20651\">J#20651</a>. The resolution hardly helps us here</p>",
        "id": 207742902,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598131671
    },
    {
        "content": "<blockquote>\n<p>I don't think operations make sense because it does not change anything for the FHIR resources you retrieve</p>\n</blockquote>\n<p>well, specifically, the spec says that 'results from operations may include resources that are not identified'. Just so you know that</p>",
        "id": 207742954,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598131771
    },
    {
        "content": "<p>I also want to point that out since the definition of fullUrl says:</p>\n<blockquote>\n<p>The Absolute URL for the resource. The fullUrl SHALL NOT disagree with the id in the resource</p>\n</blockquote>\n<p>I think for this reason that the uniqueness requirements for fullUrl are not less than for <a href=\"http://Resource.id\">Resource.id</a>.</p>",
        "id": 207743056,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598131940
    },
    {
        "content": "<p>final comment: yes, there's some theoretical prospect that if your systems run for several million years, a duplicate UUID might occur. But generating a UUID is sufficient for conformance.</p>",
        "id": 207743069,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598132001
    },
    {
        "content": "<p>However, none of that deals with your core issue. And it's tricky. See, if we accept that that the normative specification does say that a <a href=\"http://resource.id\">resource.id</a> must be populated in a search result, we also accept that this isn't something we can fix, because it's a normative requirement. </p>\n<p>If, on the other hand, we accept that it's ambiguous, then we accept that (a) it can be clarified but (b) you can leave it out without being conformant (so we don't need to fix it)</p>",
        "id": 207743129,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598132117
    },
    {
        "content": "<p>I don't understand the desire to leave out the id given that you have to have the fullUrl and the fullUrl and id are expected to align.  Having/not having the id in no way implies whether you can/can't do things you'd expect to do with the id - whether that's read it, update it, retrieve a history for it or reference it in resources created elsewhere.  Whether you can do most of those things (read, history, update, etc.) are governed by the CapabilityStatement of the server from which you retrieved the results.  If it's a facade, it's fine for it to support search but none of the other operations.  Where things get dicey is when you retrieve a resource in a search and then create an instance somewhere that references a resource you saw in a search.  Nothing stops anyone from doing that.  However, a reference to a resource that isn't retrievable via a 'read' isn't terribly useful, so it might be worth making a statement that it <em>should</em> not be done.</p>\n<p>In essence, a facade that's incapable of maintaining a persistent id or a resource is generating a new transient resource instance on the fly every time it executes the query.  That resource <em>has</em> an id - the same as in the fullUrl.  It's redundant, yes, as the id and fullUrl are always intended to be redundant.  However, that redundancy is there for expediency of processing.  There are times when you want to process using the fullUrl and there are times you want to process using the id and the pain of getting from one to the other is sufficient that having both present was deemed appropriate and necessary.</p>\n<p>I agree there should be absolute clarity about whether the id can be expected to be present (I argue for 'yes' because it makes life easier for processors - and is why we have both it and fullUrl there in the first place).  But I <em>don't</em> think we should be ascribing any meaning to the presence of a fullUrl and absence of an id.  The fact a resource can't be 'read' is conveyed by the CapabilityStatement, not any characteristic of the resource itself.</p>",
        "id": 207794321,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1598221906
    },
    {
        "content": "<p>The position is this:</p>\n<p>FHIR Core requires <a href=\"http://Resource.id\">Resource.id</a> except for a few cases. The few cases do not match circumstances for some or our systems. <a href=\"http://Resource.id\">Resource.id</a> does not have purpose outside being an endpoint for RESTful calls or when a resource is contained.</p>\n<p>As long as long FHIR keeps <a href=\"http://Resource.id\">Resource.id</a> required, we have no alternative but to generate the <a href=\"http://Resource.id\">Resource.id</a>. So apparently generating a meaningless <a href=\"http://Resource.id\">Resource.id</a> is better than omitting it. I don't like it, but I'm not sure how to break the RESTful bias here.</p>\n<blockquote>\n<p>Having/not having the id in no way implies whether you can/can't do things you'd expect to do with the id - whether that's read it, update it, retrieve a history for it or reference it in resources created elsewhere.</p>\n</blockquote>\n<p>If RESTful read/update/delete and search by _id is governed by <a href=\"http://Resource.id\">Resource.id</a> and just about any client is taught to work with <a href=\"http://Resource.id\">Resource.id</a> that way: does it not become the de facto purpose of the <a href=\"http://Resource.id\">Resource.id</a>? Why would I have a <a href=\"http://Resource.id\">Resource.id</a> I cannot support, and mitigate/hide that fact by means of a CapabilityStatement?</p>",
        "id": 207808326,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1598246378
    },
    {
        "content": "<blockquote>\n<p>I don't like it, but I'm not sure how to break the RESTful bias here</p>\n</blockquote>\n<p>I'd feel bad about that, except that you're actually implementing the RESTful API here. If, for instance, you were doing some service thing that was using bundles in some other context, and complaining about RESTful orientation, then I'd be inclined to give it a little more weight</p>",
        "id": 207811327,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598251027
    },
    {
        "content": "<p>Hmm. Transactions aren't REST, yet we require <a href=\"http://resource.id\">resource.id</a> in such bundles (whether transported using HTTP or not).  Messages aren't REST, yet we require <a href=\"http://resource.id\">resource.id</a> in such bundles (whether transported using HTTP or not). Documents aren't REST, yet we require <a href=\"http://resource.id\">resource.id</a> in such bundles (whether transported using HTTP or not). <br>\nIn many of these paradigms resource.ids don't make a lot of sense - e.g. most messaging systems won't expose a RESTful endpoint, so resource.ids in messaging are useless (we'll need fullURL though for referencing).</p>",
        "id": 207812150,
        "sender_full_name": "René Spronk",
        "timestamp": 1598252040
    },
    {
        "content": "<p>I think that transactions are indeed RESTful - they are completely defined in terms of the REST Api.</p>",
        "id": 207812209,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598252089
    },
    {
        "content": "<p>Do we require <a href=\"http://Resource.id\">Resource.id</a> in a message? where does it say that?</p>",
        "id": 207812213,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598252102
    },
    {
        "content": "<p><a href=\"http://build.fhir.org/resource.html#id\">http://build.fhir.org/resource.html#id</a> (we only have the high level requirement) - there is no special wording about messaging and resource.ids AFAIK.</p>",
        "id": 207812482,
        "sender_full_name": "René Spronk",
        "timestamp": 1598252415
    },
    {
        "content": "<p>I'm pretty sure that we have a task to clarify that those words about <a href=\"http://Resource.id\">Resource.id</a> are applicable in the context of the RESTful api, and other rules apply outside that</p>",
        "id": 207812539,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598252507
    },
    {
        "content": "<p>As for transactions being restful - what we have seems like  a patch to me. What % of APIs have some sort of transaction functionality ? Does the highrise API support transactions ?</p>",
        "id": 207812606,
        "sender_full_name": "René Spronk",
        "timestamp": 1598252564
    },
    {
        "content": "<p>I haven't seen transactions elsewhere.</p>",
        "id": 207812818,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598252834
    },
    {
        "content": "<p>I have seen batches elsewhere</p>",
        "id": 207812828,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598252852
    },
    {
        "content": "<p>Transaction feels like an operation to me. Operations (services) aren't REST. As such \"other rules may apply to that\". Anyways, I hope there already is a workitem to clarify the current wording.</p>",
        "id": 207813041,
        "sender_full_name": "René Spronk",
        "timestamp": 1598253064
    },
    {
        "content": "<p>right, indeed other rules might apply to an operation. but since the details of transaction are defined by the RESTful API, the rules around whether a <a href=\"http://resource.id\">resource.id</a> must be present or not are defined by the RESTful API. e.g. there are conditions where <a href=\"http://Resource.id\">Resource.id</a> must not be present</p>",
        "id": 207813130,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598253147
    },
    {
        "content": "<p><a href=\"http://Resource.id\">Resource.id</a> is defined here: <a href=\"http://build.fhir.org/resource-definitions.html#Resource.id\">http://build.fhir.org/resource-definitions.html#Resource.id</a></p>\n<p>it says:</p>\n<blockquote>\n<p>Definition:  The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.<br>\nCardinality   0..1<br>\nType  id<br>\nSummary   true<br>\nComments:  The only time that a resource does not have an id is when it is being submitted to the server using a create operation.</p>\n</blockquote>\n<p>This does not list any other exception than create. It does not list operations, messages, conditional updates (yet) or anything else.</p>\n<p>On this page <a href=\"http://build.fhir.org/operations.html#response\">http://build.fhir.org/operations.html#response</a> I read the exception you are referring to</p>\n<blockquote>\n<p>The resources that are returned by the operation may be retained and made available in the resource repository on the operation server. In that case, the server will provide the identity of the resource in the returned resources. When resources that are not persisted are returned in the response, they will have no id property.</p>\n</blockquote>\n<p>This is most interesting as it goes directly against the comment on resource-definitions.html. At the very least there is a consistency problem here. I would argue to move/copy the operations exception to the main definition for <a href=\"http://Resource.id\">Resource.id</a> as a single of truth.</p>\n<p>But coming back to:</p>\n<blockquote>\n<p>If, for instance, you were doing some service thing that was using bundles in some other context, and complaining about RESTful orientation, then I'd be inclined to give it a little more weight</p>\n</blockquote>\n<p>I don't see how this position holds unless you feel that search always is a RESTful action. I'd say search <em>can</em> be RESTful. RESTful search and not-so-RESTful search could coexist perfectly, and <a href=\"http://Resource.id\">Resource.id</a> is the key to that.</p>",
        "id": 207834784,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1598270674
    },
    {
        "content": "<p>I don't see how the Comment on <a href=\"http://Resource.id\">Resource.id</a> has some overall normative hold that overrides the <a href=\"http://build.fhir.org/resource.html#id\">whole section</a> in the content.</p>\n<p>Search is a RESTful interaction by definition, since it is defined as <a href=\"http://build.fhir.org/http.html#search\">part of the RESTful API</a></p>",
        "id": 207840517,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1598274573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192685\">@Vassil Peytchev</span> from your Logical Id link</p>\n<blockquote>\n<p>In some contexts, resources are not associated with location on a RESTful server, either because they are only created transiently for transfer between systems, or the systems are not using RESTful servers. In these cases, resources may be assigned some kind of location anyway, for purposes of consistency, <strong>or they might not have an assigned logical id, and they are identified based on other kinds of identifiers</strong></p>\n</blockquote>\n<p>Emphasis applied by me. Do I read what I want when I say this supports what we do?</p>",
        "id": 207846656,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1598277817
    },
    {
        "content": "<p>I think I can also read in this fragment that <a href=\"http://Resource.id\">Resource.id</a> and RESTful are explicitly interlinked.</p>",
        "id": 207846804,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1598277884
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 208155756,
        "sender_full_name": "Richard Braman",
        "timestamp": 1598479958
    },
    {
        "content": "<p>Okay, say a server generates <a href=\"http://Resource.id\">Resource.id</a> based on UUID and I request data twice. Different <a href=\"http://MedicationRequest.id\">MedicationRequest.id</a> (because of generated nature), same MedicationRequest.identifier (because in V3 this is the unique identifier for it)</p>\n<p>What would you expect from a receiver? I'm fully expecting loads of virtual duplicates because they distinguish based on <a href=\"http://Resource.id\">Resource.id</a> which is generated and does not reflect something on the source server.</p>",
        "id": 210740806,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600695067
    },
    {
        "content": "<p>When a server generates a new uuid each time it serves a resource: does that not constitute a change in the <a href=\"http://resource.id\">resource.id</a> and as such a direct violation of this part of the spec:</p>\n<blockquote>\n<p>Once assigned by the server, the id is never changed.</p>\n</blockquote>",
        "id": 210745923,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600697206
    },
    {
        "content": "<p>I see two points here:</p>\n<ul>\n<li>How to generate <a href=\"http://Resource.id\">Resource.id</a>: If you have a unique identifier, is it not possible to \"generate\" <a href=\"http://Resource.id\">Resource.id</a> based of Resource.identifier?</li>\n<li>What is expected from the receiver: The whole premise is that the resources don't exist at the expected REST endpoints. The receivers need to treat the resources as business objects, and not FHIR resources. Yes, this breaks down several premises that make FHIR so compelling, but that is due to the decision that the facade in front of the existing system is not going to be sophisticated enough to provide the expected RESTful API .</li>\n</ul>",
        "id": 210746496,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1600697454
    },
    {
        "content": "<p>I've filed <a href=\"http://jira.hl7.org/browse/FHIR-28587\">FHIR#28587</a></p>",
        "id": 210749314,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600698647
    },
    {
        "content": "<blockquote>\n<p>How to generate <a href=\"http://Resource.id\">Resource.id</a>: If you have a unique identifier, is it not possible to \"generate\" <a href=\"http://Resource.id\">Resource.id</a> based of Resource.identifier?</p>\n</blockquote>\n<p>Sometimes, but that is not guaranteed. <a href=\"http://Resource.id\">Resource.id</a> is really short and disallows most characters ([A-Za-z0-9\\-\\.]{1,64})</p>",
        "id": 210749600,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600698794
    },
    {
        "content": "<p>Whenever possible we will definitely encourage servers to generate a relevant <a href=\"http://Resource.id\">Resource.id</a>. We even development mappings for V3 ourselves for production use that go to great lengths to guarantee stable/unique Resource.ids. That being said: it turns out it is just not feasible in all cases</p>",
        "id": 210749872,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600698908
    },
    {
        "content": "<p>A SHA-1 or SHA-256 hash on a v3 II data type, or on the Resource.identifier content fits the restrictions of <a href=\"http://Resource.id\">Resource.id</a> - isn't that trivial to generate at run time?</p>",
        "id": 210750186,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1600699050
    },
    {
        "content": "<p>If you don't have a reliable id, FHIR REST isn't going to work well.  That's just the reality of REST.  It relies on resources have a fixed identity.</p>",
        "id": 210750946,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600699371
    },
    {
        "content": "<p>Sure, but the current requirements talk about requirements for \"Resources\". You are saying \"if you are using them in a RESTful way\". That is not the same</p>",
        "id": 210751109,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600699439
    },
    {
        "content": "<p>We fully acknowledge that without a <a href=\"http://Resource.id\">Resource.id</a> these resources will not play nice in a RESTful read/update/delete/patch, but... they work excellently in search and create.</p>",
        "id": 210751251,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600699495
    },
    {
        "content": "<p>Something you search for that has its id change each time you search or something that you create that isn't at the same place you look isn't \"excellent\" in my opinion...</p>",
        "id": 210751466,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600699568
    },
    {
        "content": "<p>It has the very same Resource.identifier every time.</p>",
        "id": 210751513,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600699595
    },
    {
        "content": "<p>Resource.identifier doesn't matter for most use</p>",
        "id": 210751653,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600699669
    },
    {
        "content": "<p>It has done so for the last 15 years of V3.</p>",
        "id": 210751737,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600699690
    },
    {
        "content": "<p>If the 'id' isn't reliable, then I don't think you can say that search or create with REST are behaving 'well'.</p>",
        "id": 210751767,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600699708
    },
    {
        "content": "<p><a href=\"http://Observation.id\">Observation.id</a> in V3 SHALL be unique, persistent and SHALL NOT be changed once assigned.</p>",
        "id": 210751798,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600699720
    },
    {
        "content": "<p>V3 was doing documents and messaging</p>",
        "id": 210751808,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600699724
    },
    {
        "content": "<p>We do both.</p>",
        "id": 210751837,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600699739
    },
    {
        "content": "<p>If you run a search multiple times and you get different ids each time, then that's essentially \"changing\" the id</p>",
        "id": 210751894,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600699759
    },
    {
        "content": "<p>Ok, so ad hoc generated ids are out of the question then.</p>",
        "id": 210751944,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600699782
    },
    {
        "content": "<p>Systems doing RESTful search would not expect to have to de-dup using identifier</p>",
        "id": 210751950,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600699784
    },
    {
        "content": "<p>They have no choice. It is not possible to do so based on id</p>",
        "id": 210752062,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600699808
    },
    {
        "content": "<p>Not out of the question, but be aware that they're going to cause issues, so all client systems need to be aware of the limitations.</p>",
        "id": 210752067,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600699810
    },
    {
        "content": "<p>A standard RESTful client isn't going to have a great experience if it's not prepared.</p>",
        "id": 210752129,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600699836
    },
    {
        "content": "<p>A standard RESTful client is too limited for use then. In a MedicationOverview any system will include everything it knows, wherever it came from even if not from its own system. So: two systems will potentially respond with the same object. This object, say MedicationRequest, would have the same identifier, but a different id.</p>",
        "id": 210752352,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600699919
    },
    {
        "content": "<p>RESTful solves a technical communication issue on getting/sending objects, but it does not solve all business requirements</p>",
        "id": 210752509,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600699969
    },
    {
        "content": "<p>All I'm asking is: make FHIR useful outside RESTful use.</p>",
        "id": 210752722,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600700043
    },
    {
        "content": "<p>You can't make REST do something it isn't designed to do.  Certainly it's possible for a system to expose 30 AllergyIntolerance instances reflecting different views of a patient's penicillin allergy - that's one of the reasons we have List - to provide a filtered view.  However List isn't going to work if the AllergyIntolerance ids aren't constant</p>",
        "id": 210752977,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600700144
    },
    {
        "content": "<p>If you've got a 'stable' .identifier, your best solution is to have the infrastructure map that to a stable .id</p>",
        "id": 210753085,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600700179
    },
    {
        "content": "<blockquote>\n<p>All I'm asking is: make FHIR useful outside RESTful use.</p>\n</blockquote>\n<p>Isn't that what operations are for? I don't understand how using RESTful search is outside RESTful use...</p>",
        "id": 210753277,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1600700264
    },
    {
        "content": "<p>I'm not making REST do anything. I'm trying to use FHIR resources but the RESTful bias prohibits it.</p>\n<blockquote>\n<p>If you've got a 'stable' .identifier, your best solution is to have the infrastructure map that to a stable .id</p>\n</blockquote>\n<p>Would you like me to open a ticket for lifting the extreme limitations on <a href=\"http://Resource.id\">Resource.id</a> in that case? I would need 128 + 64 characters and no restrictions on characters</p>",
        "id": 210753285,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600700267
    },
    {
        "content": "<p>Operations don't help: they are about the SAME resources that REQUIRE id</p>",
        "id": 210753379,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600700295
    },
    {
        "content": "<p>And: if 90% of the network is perfectly fine with <a href=\"http://Resource.id\">Resource.id</a> and we could have a way to have RESTful systems and non-RESTful systems coexist and all it needs is to lift the SHALL on <a href=\"http://Resource.id\">Resource.id</a>.... why would I architect two different networks?</p>",
        "id": 210753547,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600700378
    },
    {
        "content": "<p>Its a bad value proposition.</p>",
        "id": 210753641,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600700406
    },
    {
        "content": "<p>You can use FHIR resources for messaging and documents.  But if you want to use them with REST, then you need to make them behave in a RESTful way.</p>",
        "id": 210753728,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600700452
    },
    {
        "content": "<p><a href=\"http://Resource.id\">Resource.id</a> syntax is normative and isn't going to change</p>",
        "id": 210753760,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600700467
    },
    {
        "content": "<p>We already established that search is not REST (I think). Nonetheless the FHIR spec requires <a href=\"http://Resource.id\">Resource.id</a>.</p>",
        "id": 210753838,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600700504
    },
    {
        "content": "<p>If you want to take a messaging/document system and expose it via a RESTful interface, then you have to add additional logic and infrastructure that handles mapping to a reliable id</p>",
        "id": 210753896,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600700522
    },
    {
        "content": "<p>OK, simple question - why is sha256(Resource.identifier) not possible? What are the issues that prevent this from working?</p>",
        "id": 210754036,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1600700564
    },
    {
        "content": "<p>Generated ids don't resolve to anything and are thus generated solely for the satisfaction of a RESTful requirement we don't have. It also weakens the experience for RESTful systems as they never know if the <a href=\"http://Resource.id\">Resource.id</a> actually means anything.</p>",
        "id": 210754335,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600700683
    },
    {
        "content": "<p>I am missing something. How will the following work:</p>\n<blockquote>\n<p>I would need 128 + 64 characters and no restrictions on characters</p>\n</blockquote>\n<p>yet sha256(string[128]+string[64]) will not?</p>",
        "id": 210755728,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1600701300
    },
    {
        "content": "<blockquote>\n<p>OK, simple question - why is sha256(Resource.identifier) not possible? What are the issues that prevent this from working?</p>\n</blockquote>\n<p>The most elementary answer there is: there is no XSLT2 solution for sha256 and lots of the mappings are written in XSLT2 without any expectation of Saxon-EE that may include sha256 support as extension. The second part is tat FHIR Resources slice the world differently than V3 does. Hence not all FHIR Resources will get a V3 id. The third part is that in number of cases certain V3 objects never needed an id hence there is no data to base the sha256 hash on.</p>",
        "id": 210755751,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600701307
    },
    {
        "content": "<p>So to summarize: we might be able to generate stable Resource.ids in more cases than currently possible, based on sha256 hashing. It will not be a 100% solution</p>",
        "id": 210755923,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600701387
    },
    {
        "content": "<p>But still: what you have is stable yet meaningless ids that would not serve any read/update/delete/patch purpose. Why? Because RESTful says so? But what if I don't need that functionality? What if all I need is search?</p>",
        "id": 210756233,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600701495
    },
    {
        "content": "<p>If a RESTful client executes search, they're going to treat the 'id' as the reliable identifier - because in REST, that is <em>always</em> the primary and reliable identifier.  If it searches again, it's going to presume everything with a new 'id' is a new resource instance - because that's what a new 'id' means in REST.  'id' isn't meaningless - it's essentially the primary key of the record.  Trying to use REST without a reliable id is like trying to use SQL when you don't have a primary key.  It's not going to go well...</p>",
        "id": 210757853,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600702134
    },
    {
        "content": "<p>If you have limitations on what you can create reliable ids for, then at least produce them everywhere possible.  \"Most\" is better than \"None\".  If XSLT can't do what you need, then seriously consider going beyond XSLT.  The importance of reliable ids is (or ought to be) higher than the importance of not changing the mapping technology.</p>",
        "id": 210758043,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600702206
    },
    {
        "content": "<p>I thought we landed on search not being RESTful? As said we will definitively strive for the best possible coverage of Resource.ids but as long as the requirement to have one stays and as long we can't fully comply, we will always be \"FHIR-like\".</p>",
        "id": 210758683,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600702498
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191375\">@Alexander Henket</span> this discussion is getting tiresome. This stuff is normative. Use RESTful, RESTfullty. Or don't. SEARCH is part of the restful interface, and we wouldn't make it non-restful if we could.</p>",
        "id": 210759328,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600702787
    },
    {
        "content": "<p>There's a serious misconception is what you write above:</p>",
        "id": 210759357,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600702801
    },
    {
        "content": "<blockquote>\n<p>When a server generates a new uuid each time it serves a resource: does that not constitute a change in the <a href=\"http://resource.id\">resource.id</a> and as such a direct violation of this part of the spec:</p>\n<blockquote>\n<p>Once assigned by the server, the id is never changed.</p>\n</blockquote>\n</blockquote>",
        "id": 210759450,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600702825
    },
    {
        "content": "<p>There answer is: yes, you cannot change the <a href=\"http://Resource.id\">Resource.id</a>. But the fact that you cannot change the <a href=\"http://Resource.id\">Resource.id</a> means that you have phrased the question wrongly.</p>",
        "id": 210759555,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600702873
    },
    {
        "content": "<p>the correct phrasing is \"Does FHIR require that a system can only have one resource for a given business concept\", and the answer is: no, we never said that</p>",
        "id": 210759627,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600702907
    },
    {
        "content": "<p>That last bit means that as a receiver you have to assume discrete copies where the source system has 1 object.</p>\n<p>I'm tired about it too, but that does not resolve the issue. So if you feel you don't want to discuss it anymore I'll have to talk to leadership here that in certain places we can never be FHIR compliant. I don't know where that ends.</p>",
        "id": 210759867,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600703017
    },
    {
        "content": "<p>I don't know, from what you've said, where what you have done is not FHIR complaint, unless you insist on wording it wrongly.</p>",
        "id": 210759974,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600703061
    },
    {
        "content": "<p>I agree about consequence. it's ugly, but not non-conformant</p>",
        "id": 210760029,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600703085
    },
    {
        "content": "<p>Don't know what to say. Please formally close <a href=\"http://jira.hl7.org/browse/FHIR-28587\">FHIR#28587</a> and we'll see from there. I cannot break iron with my bare hands (Dutch expression). </p>\n<p>I 'really' don't know what not solving this will do. In any case I'm really disappointed about all this.</p>",
        "id": 210761220,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600703641
    },
    {
        "content": "<p>well, I can't close it personally, but the committee can not do anything but close it as out of scope because it's normative. The tiresome part for me is that after all your explanations, I still don't understand why this is a problem</p>",
        "id": 210761457,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600703740
    },
    {
        "content": "<p>I asked for in-person discussion, but I'm not sure what new thing I can say if all the above doesn't help.</p>",
        "id": 210761662,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600703804
    },
    {
        "content": "<p>what you have established clearly is that </p>\n<ol>\n<li>the standard requires you to populate <a href=\"http://Resource.id\">Resource.id</a></li>\n<li>you choose not to populate with an id that will be persistent (to avoid re-engineering your backends or an onerous solution on the facade)</li>\n<li>under these conditions, the <a href=\"http://Resource.id\">Resource.id</a> brings no value</li>\n</ol>\n<p>What you have not showed is that something about this is non-conformant</p>",
        "id": 210762083,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600703963
    },
    {
        "content": "<p>According to FHIR <code>Resource.id</code> must be unique, but it does not say there can only ever be a single id.  So, if you generate a new id every time a resource is returned, that is conformant (but ugly*).  The issue is that you must ensure they are unique - a client <em>will</em> assume it is the same resource if the same id is seen twice.  Alexander, it seems this is what you would like changed (e.g., have this use some combination of identifiers).  Without getting into a discussion about pros and cons, that concept is normative and it cannot realistically be changed (it would, for example, require every single FHIR implementer to agree - as one step).</p>\n<p>*Years ago there was a large commercial DICOM implementation that did this (responded to every query with newly-generated ids).  It worked, but everyone else had to do extra work to interact with their system (e.g., manually checking MRNs in addition to the IDs).  This sounds like the same case: if you do the mapping to create a stable id, then nobody else has to.  If you don't, everyone else will need to.</p>",
        "id": 210763425,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600704512
    },
    {
        "content": "<p>Ok.... that is a different unclarity than I thought you were on. To avoid adding large texts again: what we do in some cases (I keep stressing this), i.e. not giving back a <a href=\"http://Resource.id\">Resource.id</a>, is \"ugly but conformant.\" </p>\n<p>If that is shared opinion then I'll take it, because that is a fair statement. The notion that what we do is \"non conformant\" was fuelled by what I kept getting back here from people and the FHIR spec. If all that is a big misunderstanding, then I'm glad we cleared that up.</p>",
        "id": 210763450,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600704524
    },
    {
        "content": "<p>I think that's the case: it's ugly but conformant. </p>\n<p>It will invite people to think it's non-conformant if you keep using the langauge 'changing the id' since you can't. Instead, use the language 'creating a new resource which doesn't persist'</p>",
        "id": 210763663,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600704626
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> I'm not advocating generation of a new id every time. In cases where that is the only option, there would not be <a href=\"http://Resource.id\">Resource.id</a> at all to avoid people thinking it is that stable id that <a href=\"http://Resource.id\">Resource.id</a> is supposed to be. The net effect is that a RESTful client is not misled.</p>\n<blockquote>\n<p>It will invite people to think it's non-conformant if you keep using the langauge 'changing the id' since you can't. Instead, use the language 'creating a new resource which doesn't persist'</p>\n</blockquote>\n<p>Point taken.</p>",
        "id": 210764196,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600704906
    },
    {
        "content": "<p>That is fine - the result is functionally equivalent (where <code>Resource.id</code> is optional).</p>\n<p>I will note though, that while the field is optional, many clients assume <code>Resource.id</code> will be present.  Excluding it means that you (or someone on your staff) will likely have this discussion with many implementors, many times.  You may want to document this behavior thoroughly  =).</p>",
        "id": 210765315,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600705408
    },
    {
        "content": "<p>And that's only where discussions are possible.  For third-party tools, there won't be opportunity for discussion.  They just won't work.</p>",
        "id": 210765705,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1600705593
    },
    {
        "content": "<blockquote>\n<p>You may want to document this behavior thoroughly<br>\nAnd that's only where discussions are possible. For third-party tools, there won't be opportunity for discussion. They just won't work.</p>\n</blockquote>\n<p>Evidence so far shows no issues other than deduplication questions. We will have to beef up there on our documentation no doubt, but that we can do. Thanks to you all for sticking with me on this.</p>",
        "id": 210776435,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600710732
    },
    {
        "content": "<p>I think that it won't be so much a matter of 'they don't work' as 'their efficiency mechanisms will not work'. At least, a well designed client should continue to work, since resource ids still have meaning.</p>",
        "id": 210777967,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600711379
    },
    {
        "content": "<p>... and we can help those implementers on how to work with the data they will get on the network. Make them aware of <a href=\"http://Resource.id\">Resource.id</a> behavior, duplicate detection strategies and maybe more.</p>",
        "id": 210785234,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600714879
    },
    {
        "content": "<p>Even with <a href=\"http://Resource.id\">Resource.id</a> in place they might still find the 'same' MedicationRequest coming from two different sources (different <a href=\"http://Resource.id\">Resource.id</a>) with MedicationRequest.identifier as linking pin. This is because MedicationOverview includes what you have, even if that is obtained from a third party.</p>",
        "id": 210785616,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1600715042
    },
    {
        "content": "<p>right.</p>",
        "id": 210787554,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1600715969
    },
    {
        "content": "<p>Most non-trivial implementations will require a de-duplication strategy. Is there any cross-industry guidance on such strategies?</p>",
        "id": 210833699,
        "sender_full_name": "René Spronk",
        "timestamp": 1600757953
    }
]