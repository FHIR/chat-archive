[
    {
        "content": "<p>Dear FIR Community,</p>\n<p>We recently defined a profile to capure clinical data based on the Observation profile. How it works is that on a workflow trigger our backend creates a new resource with some pre-filled elements. A client application reads that resource and presents it to a clinical user who fills in some additional data and the application persists that to our backend by updating the resource. Our FHIR service is only a facade so we don't support every element in the Observation resource. At first we naively defined our own MyObservation profile which modifies types, constraints and cardinality of the Observation profile to exactly match our backend. Inspired by talks on the Amsterdam DevDays, we started thinking about making our profiles more permissive and using the mustSupport flag. Our current interpretation is that when reading a resource, we can include all the elements that our backend supports. Elements that are not supported can be left out as long as the profile does not mark them as required. For all operations that modify the resource, we set mustSupport=true and if needed restrict the profile to indicate what we allow to be persisted.</p>\n<p>Some concrete examples on our MyObservation profile, which is based on the Observation profile:</p>\n<ul>\n<li>Observation.code: This element is pre-filled by the backend. We do NOT set mustSupport to true, because that would indicate that the client application can change the code and update the resource, which we do not allow. If a client would change the code and update the resource, we ignore that element.</li>\n<li>Observation.subject: We always link an observation 1-1 to a patient automatically on the backend. That is compliant so we don't need to modify cardinality to 1..1 and restrict the Subject type to Patient. Again mustSupport=false since we don't allow clients to relink the resource to another patient.</li>\n<li>Observation.bodySite: This element is to be filled in by the client, so we set mustSupport=true and we persist on update.</li>\n<li>Observation.hasMember: This element is to be filled in by the client, so we set mustSupport=true. The members are resources of a proprietary 'Foo' profile, so we need to modify our MyObservation profile to set the allowed target to a single value, being our Foo profile.</li>\n</ul>\n<p>Is this the correct interpretation of permissive profiles and the mustSupport flag?</p>\n<p>Thanks!</p>",
        "id": 182347164,
        "sender_full_name": "Yoni De Witte",
        "timestamp": 1575294995
    },
    {
        "content": "<p>On the first two I'd reject the instance sent by the client, 'not allowed to change', the client is breaking a business rule. Ignoring that may lead to patient safety issues.<br>\nObs.hasMember: do ALL referenced resources have to conform to Foo, or is it OK to have a Bar, as long as there is at least one Foo ?</p>",
        "id": 182348224,
        "sender_full_name": "René Spronk",
        "timestamp": 1575295691
    },
    {
        "content": "<p>To me .code and .subject sounds like they're mustSupport. However, given that definition of 'mustSupport' is up to you (as a project), what do YOU defined mustSupport to be?</p>",
        "id": 182348315,
        "sender_full_name": "René Spronk",
        "timestamp": 1575295770
    },
    {
        "content": "<p>Yes, all referenced resources have to conform to Foo. If there is a Bar, we can ignore it or return an error.</p>\n<p>We don't yet have mustSupport defined in our project. So we're open to suggestions from the community what that definition should be. I would say that there are 3 categories of elements in our application:<br>\n1) read-only elements which are populated and persisted by the backend<br>\n2) elements which MAY(not SHALL) be populated by a client and are persisted by the backend<br>\n3) elements which are not persisted by the backend</p>\n<p>In the current proposal, we would use the mustSupport-flag to distinguish elements of category 2. The difference between elements of category 1 and 3 is simply that category 3 elements are missing when the resource is read, as they are not persisted.</p>",
        "id": 182353234,
        "sender_full_name": "Yoni De Witte",
        "timestamp": 1575298950
    },
    {
        "content": "<p>Ignoring an element and throwing it away is a bit different than ignoring an element and holding onto something else.  I'd certainly recommend at least including a warning about elements that you ignore but store something else.</p>",
        "id": 182359025,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575302119
    },
    {
        "content": "<p>mustSupport = true does not imply that the client has the right to change the value. Only that you think it's not safe if a client ignores the element.</p>",
        "id": 182369114,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575308050
    },
    {
        "content": "<p>We've not really had much discussion about specifying rules in a computable form over what can changed or not by the client</p>",
        "id": 182369153,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575308071
    },
    {
        "content": "<p>mustSupport isn't about what's \"safe\", it's about what a system is expected to do/pay attention to.  So if you want to say \"I will pay attention to elements A, B and C, but not to anything else\", then marking A, B and C as \"mustSupport\" is appropriate.  And if you're going to ignore submitted data, not marking it as mustSupport is the appropriate way to designate that.  What's a bit unique here is that you're ignoring submitted data - but then asserting your own value for it.  That's not typical/expected behavior, so throwing out a warning message would be good practice.</p>",
        "id": 182373376,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1575310745
    }
]