[
    {
        "content": "<p>Hi,<br>\nI am using HAPI Fhir Server and I'm testing sending FHIR messages to it.<br>\nI've sent the same Patient FHIR Resource to the server and it created 2 different Patient resources.<br>\nShould it not have detected they are the same patient?<br>\nOr are there some settings I have to set?</p>",
        "id": 169651271,
        "sender_full_name": "Quintonn",
        "timestamp": 1562249412
    },
    {
        "content": "<p>In REST, the burden is (mostly) upon the client to ensure it doesn't create duplicates. <br>\nHAPI doesn't truly support FHIR messaging unless you wrote your own operation (e.g. $process-message) to define how a message should be processed. If you're posting a FHIR message to the root endpont the server will ignore the fact that it's a message and process it like any other bundle, and it will POST all of the resources contained in the message. If you send the same message twice, it will create all resources twice.</p>",
        "id": 169651790,
        "sender_full_name": "René Spronk",
        "timestamp": 1562249888
    },
    {
        "content": "<p>thank you for that.<br>\nAnd if I do a search on the identifier i should see the same patient twice?</p>",
        "id": 169651856,
        "sender_full_name": "Quintonn",
        "timestamp": 1562249968
    },
    {
        "content": "<p>actuall i can confirm that is indeed the case.<br>\nSo there is no setting or anything that control this?<br>\nOr maybe I can add some java code somewhere?</p>",
        "id": 169652108,
        "sender_full_name": "Quintonn",
        "timestamp": 1562250145
    },
    {
        "content": "<p>I would suggest writing your own code to handle this. You could do as Rene suggested or create a facade on top of the server that implements your business rules and logic. <br>\nI've tended to use the facade pattern as I can change the FHIR server behind it without too much hassle.</p>",
        "id": 169652702,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1562250721
    },
    {
        "content": "<p>is there any documentation anywhere that can give me some ideas where to start?</p>",
        "id": 169652833,
        "sender_full_name": "Quintonn",
        "timestamp": 1562250832
    },
    {
        "content": "<p>Using If-None-Exist http header worked. It prevents further duplication</p>",
        "id": 169653414,
        "sender_full_name": "Quintonn",
        "timestamp": 1562251290
    },
    {
        "content": "<p>Prevention of duplicates is a business rule.  The server has to decide what constitutes a duplicate and act to prevent them.  For example, is it prohibited for multiple patient records to exist with the same social insurance number?  In some systems yes, in others no.  Our public test servers don't enforce any business rules so they'll allow duplicates of anything.</p>",
        "id": 169654232,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1562252039
    },
    {
        "content": "<blockquote>\n<p>Using If-None-Exist http header worked. It prevents further duplication</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"229067\">@Quintonn</span> I also use the conditional create to prevent data duplication However, that is an expensive transaction for the server. So I create a duplicate detection filter. Since I am only uploading Patient, Device and Observation resources, I can prevent re-uploading the Patient and Device resources by linking the if-none-exist parameter to the logical id in the server's response. When my if-none-exist parameter has a logical id associated with it, I dont re-upload it. For Observations from the same Patient and Device use time stamping to filter. It works quite well and saves bandwidth.</p>",
        "id": 169677083,
        "sender_full_name": "Brian Reinhold",
        "timestamp": 1562286037
    },
    {
        "content": "<p>I'll chime in that for our server implementation of Patient.create, we will always perform a duplicate check before creating.  If we find a single high threshold match, we will return that patient as if it were the one you created (i.e. we will \"lie\" and say we created a new patient for you, when in fact we didn't).    </p>\n<p>Related to René's comment above about the burden being on the client for preventing duplicates, that can sometimes be true for data within a patient context, but often a client is not permitted to see patients beyond the one they are authorized for, so for Patient specifically, often a client cannot determine if the patient they want to create exists already or not.</p>",
        "id": 169735412,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1562360099
    },
    {
        "content": "<p>Also, Conditional Create / If-None-Exist may work for some servers, but some servers may want to control the conditions for creating a patient, and not allow clients that control.</p>",
        "id": 169735488,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1562360216
    },
    {
        "content": "<p>I fully agree that server will need to do some stuff to avoid duplicates, but to me that adds a layer above and beyond \"pure REST\" (or rather: pure CRUD). You used the wording \"the server will 'lie' to you\" to indicate that you also consider this behavior (while necessary) not to be entirely in the spirit of REST :-) .. but it'll work just fine.  Question will then be how to expose this server behaviour in a FHIR conformance statement or implementation guide.</p>",
        "id": 169753478,
        "sender_full_name": "René Spronk",
        "timestamp": 1562391937
    },
    {
        "content": "<p>Are there any servers which implement the Patient $match operation?</p>",
        "id": 170449911,
        "sender_full_name": "Kirt Schaper",
        "timestamp": 1562676792
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191372\">@René Spronk</span> I agree - this is beyond \"pure REST\".  However I think basically every FHIR interaction we have implemented goes beyond pure REST, since for reads we only return the part of the resource that the requester has access to, and for writes (of all sorts) we will always perform some sort of matching / validation.  I think anything other than a toy server has to deviate somewhat from pure REST, otherwise you'd end up with a tangled mess of duplicate data (not just patients, but pretty much any other data type as well).</p>",
        "id": 170468662,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1562689927
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192901\">@Kirt Schaper</span> The AEGIS WildFHIR server supports the Patient $match operation.<br>\nFHIR STU3 (v3.0.1): <a href=\"http://wildfhir3.aegis.net/fhir3-0-1\" target=\"_blank\" title=\"http://wildfhir3.aegis.net/fhir3-0-1\">http://wildfhir3.aegis.net/fhir3-0-1</a><br>\nFHIR R4 (v4.0.0): <a href=\"http://wildfhir4.aegis.net/fhir4-0-0\" target=\"_blank\" title=\"http://wildfhir4.aegis.net/fhir4-0-0\">http://wildfhir4.aegis.net/fhir4-0-0</a></p>",
        "id": 170471771,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1562692447
    },
    {
        "content": "<p><a href=\"http://tx.fhir.org\" target=\"_blank\" title=\"http://tx.fhir.org\">tx.fhir.org</a> also supports $match (though the algorithm is not overly intelligent)</p>",
        "id": 170586473,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1562799031
    }
]