[
    {
        "content": "<p>I am wondering if there any known problems with using the same Observation.code for both numeric (or quantity) and CodeableConcept values.</p>\n<p>A group we are working with has data which, for the same code, will have values which are usually numeric, but sometimes will have things like \"N/A\".   It might be theoretically possible (not sure) to map these values into dataAbsentReason, but given the amount of data they do not have the time to do that.</p>",
        "id": 241950036,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1623170862
    },
    {
        "content": "<p>From what you've written, it sounds like you want to use Obs.code for the same things you used Obs.value.  Can you clarify what situations would have a non LOINC(-ish) code for the type of observation?</p>",
        "id": 241950493,
        "sender_full_name": "David Pyke",
        "timestamp": 1623171028
    },
    {
        "content": "<blockquote>\n<p>but sometimes will have things like \"N/A\". It might be theoretically possible (not sure) to map these values into dataAbsentReason, but given the amount of data they do not have the time to do that.</p>\n</blockquote>\n<p>That was the intent of <code>Observation.dataAbsentReason</code>.  Whether or not your system can filter results and map is a different matter.  Nothing in FHIR prohibiting  value[x] from changing datatypes, but I think it will shift the burden to the client side of things.</p>",
        "id": 241952826,
        "sender_full_name": "Eric Haas",
        "timestamp": 1623171943
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192587\">@David Pyke</span>   I am not sure what you're saying.  As an example, for a given code that represents heart rate, one will usually have numeric values, but sometimes will have a string value, e.g. \"Unable to measure\".</p>\n<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span>   Yes, it does shift the burden to the client.  I also don't know whether dataAbsentReason would semantically cover all such cases, though my guess it is that would cover most.  My question here is whether having value[x] changing datatypes, as you put it, would cause other problems, but i am glad to hear you say FHIR is okay with it.</p>",
        "id": 241958532,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1623174191
    },
    {
        "content": "<p>In the case you're describing, Obs.code will have the LOINC code for heart rate measurement and the result would be in Obs.value[x] which can hold many different types .  Obs.code declares what the measurement is measuring.  The actual measurement goes on Obs.value[x] which can have various datatypes values</p>",
        "id": 241959784,
        "sender_full_name": "David Pyke",
        "timestamp": 1623174767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"195344\">Paul Lynch</span> <a href=\"#narrow/stream/179166-implementers/topic/Multiple.20data.20types.20for.20same.20Observation.2Ecode/near/241958532\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"191401\">Eric Haas</span>   Yes, it does shift the burden to the client.  I also don't know whether dataAbsentReason would semantically cover all such cases, though my guess it is that would cover most.  My question here is whether having value[x] changing datatypes, as you put it, would cause other problems, but i am glad to hear you say FHIR is okay with it.</p>\n</blockquote>\n<p>I am wondering whether the \"note\" field might be the better place to put such human-readable, non-numerical info? dataAbsentReason does have a few subcategories for \"unknown\", but I guess one could simply always set it to the generic \"unknown\" code and put the reason into the \"note\" free-text.<br>\nI think pushing the spec to the limit with fancy handling of valueX might surprise clients and HL7v2 middle-boxes, and statistics packages, and ETL tools, and data scientists who years later want to curate the data, ...</p>",
        "id": 241962007,
        "sender_full_name": "Tilo Christ",
        "timestamp": 1623175729
    },
    {
        "content": "<p>The base issue is that for a system converting data with no understanding, the result is that whatever's in the value element is going to get stuck in Observation.value - even if it might better live in dataAbsentReason, interpretation, comment or somewhere else.  If you <em>can</em> migrate the value received to a more appropriate element, certainly that's better.</p>\n<p>The only issue I can foresee would be if the Observation.code strongly indicated what data type the value should have and the values received don't always meet that expectation.  In those cases, a recipient might complain (perhaps with justification).  Certainly there's no rule that says that a single observation code must always have values of a single data type.  ObservationDefinition.permittedDatatype is 0..*.</p>",
        "id": 241973119,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1623180513
    }
]