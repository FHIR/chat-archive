[
    {
        "content": "<p>It looks like the \"correct\" sort order according to FHIR when requesting results with <code>_sort:asc=given</code> is not exactly intuitive.  The behavior if you search would be to map each patient to her alphabetically-earliest given name. So a patient with:</p>\n<div class=\"codehilite\"><pre>{\n  &quot;name&quot;: [{\n    &quot;given&quot;: [&quot;c&quot;, &quot;f&quot;,&quot;d&quot;]\n  }, {\n    &quot;given&quot;: [&quot;b, &quot;a&quot;]\n  }]\n}\n</pre></div>\n\n\n<p>would be sorted by <code>a</code> (in <code>asc</code> context) or <code>f</code> (in <code>desc</code> context).</p>\n<p>Wouldn’t it make sense to have a mechanism for requesting a sort order that would be “natural” to human beings (i.e. sorted by <code>b a</code> in <code>asc</code> and <code>c f d</code> in <code>desc</code>)?</p>",
        "id": 153824559,
        "sender_full_name": "Nikolai Schwertner",
        "timestamp": 1462385320
    },
    {
        "content": "<p>interesting. we've never talked about this </p>",
        "id": 153824563,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462387076
    },
    {
        "content": "<p>Wow, that is interesting.. I've never thought about this, but you're right, the way we do this would produce surprising results.</p>\n<p>Doing this the \"right way\" would be hard though, at least for me.</p>",
        "id": 153824586,
        "sender_full_name": "James Agnew",
        "timestamp": 1462391961
    },
    {
        "content": "<p>Could we assume that the first name in a list of names is the preferred one and takes precedence when sorting(that would need to be in the spec however)? In the prior example applying this rule would mean sorting by <code>c f d b a</code>. Does this make any sense at all?</p>",
        "id": 153824595,
        "sender_full_name": "Nikolai Schwertner",
        "timestamp": 1462396014
    },
    {
        "content": "<p>(FYI, this came up for us in designing a pretty straightforward FHIR-based patient selector widget -- and we realized it was hard to support with the standard API.)</p>",
        "id": 153824596,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462397598
    },
    {
        "content": "<p>Hmm... Does <code>c f d b a</code> make more sense, or <code>b c a f d</code>?</p>\n<p>Is there any reason that the first repetition of the <code>name</code> (as opposed to the first repetition of <code>given</code>) carries more weight?</p>",
        "id": 153824599,
        "sender_full_name": "James Agnew",
        "timestamp": 1462400005
    },
    {
        "content": "<p>Shouldn't be :) </p>",
        "id": 153824600,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462401023
    },
    {
        "content": "<p>Should there be some consideration as to what use properties should be used?<br>\nas described for what you should use in the display segment that I described for practitioner.<br>\n<a href=\"http://hl7-fhir.github.io/practitioner-definitions.html#Practitioner.name\" target=\"_blank\" title=\"http://hl7-fhir.github.io/practitioner-definitions.html#Practitioner.name\">http://hl7-fhir.github.io/practitioner-definitions.html#Practitioner.name</a><br>\nThis probably applies to patient also, and therefore maybe to the sort order.</p>",
        "id": 153824602,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1462401428
    },
    {
        "content": "<p>It's an interesting point. But of course here, we're distinguishing between multiple instances of the same field (given, or family) even  within the same name. I hate the idea is special cases but they current behavior prevents the creation of a simple FHIR-powered  patient picker. </p>",
        "id": 153824603,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462409960
    },
    {
        "content": "<p>well, the most likely solutions seems like defining a new search parameter that only searches the first of the given names </p>",
        "id": 153824606,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462423773
    },
    {
        "content": "<p>but that fails when a patient actually uses their second given name</p>",
        "id": 153824607,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462423787
    },
    {
        "content": "<p>Would it make sense to say that when you're sorting by an element that's a collection, you're actually sorting by the string concatenation of those elements?</p>",
        "id": 153824730,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1462481843
    },
    {
        "content": "<p>When you're sorting by a <strong>string</strong> element? Maybe, but I know in our server at least the sort code is tied into our indexing code, so we'd want consistent rules.</p>",
        "id": 153824737,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462484951
    },
    {
        "content": "<p>I'd like to see us define type equivalence/comparison rules for each of the types.  Similar issue applies when sorting by (or slicing by) CodeableConcepts...I'm unclear if/where this is defined?</p>",
        "id": 153824970,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1462626509
    },
    {
        "content": "<p>sigh. we haven't</p>",
        "id": 153824972,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462626537
    },
    {
        "content": "<p>ok...that's one of my goals for this week mainly in the context of slicing.</p>",
        "id": 153824973,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1462626584
    },
    {
        "content": "<p>well, slicing, it's narrower - the fixed value has to match</p>",
        "id": 153824974,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462626654
    },
    {
        "content": "<p>or the concept has to match</p>",
        "id": 153824975,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462626660
    },
    {
        "content": "<p>Anonymous slices....</p>",
        "id": 153824977,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1462626689
    },
    {
        "content": "<p>what's an anonymous slice?</p>",
        "id": 153824978,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462626715
    },
    {
        "content": "<p>A bit in left field here...  There are times when we want to be able to dis-aggregate a list by some criteria but don't need to name or constrain any slice in particular.  We use this then to compare resources.  So I slice Encounter.participant by type.  We then know that type is the \"primary key\" for participants when moving them into a relational system or when merging instances (PATCH).</p>",
        "id": 153824989,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1462626891
    },
    {
        "content": "<p>Finally, another use case is defining a constraint to dis-allow redundant CodeableConcepts (e.g. Encounter.type).  What's a duplicate?</p>",
        "id": 153824993,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1462627023
    }
]