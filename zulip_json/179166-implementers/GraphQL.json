[
    {
        "content": "<p>Just to fire discussion:</p>\n<p><a href=\"https://github.com/facebook/graphql\" target=\"_blank\" title=\"https://github.com/facebook/graphql\">https://github.com/facebook/graphql</a><br>\n<a href=\"https://github.com/Netflix/falcor\" target=\"_blank\" title=\"https://github.com/Netflix/falcor\">https://github.com/Netflix/falcor</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=ByNs9TG30E8\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=ByNs9TG30E8\">https://www.youtube.com/watch?v=ByNs9TG30E8</a></p>\n<div class=\"message_inline_image\"><a href=\"https://www.youtube.com/watch?v=ByNs9TG30E8\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=ByNs9TG30E8\"><img src=\"https://i.ytimg.com/vi/ByNs9TG30E8/default.jpg\"></a></div>",
        "id": 153811305,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1448833101
    },
    {
        "content": "<p>Hi, I am wondering if the use of GraphQL - <a href=\"http://graphql.org\" target=\"_blank\" title=\"http://graphql.org\">http://graphql.org</a>  is something that has been discussed in the past (in the context of FHIR), if not, who can  I contact to start a discussion about it?  (some part of the tech industry is moving wards this type of API)</p>",
        "id": 153852165,
        "sender_full_name": "Martin Chavez Aguilar",
        "timestamp": 1475773087
    },
    {
        "content": "<p>Hi, I am wondering if the use of GraphQL - <a href=\"http://graphql.org\" target=\"_blank\" title=\"http://graphql.org\">http://graphql.org</a>  is something that has been discussed in the past (in the context of FHIR), if not, who can  I contact to start a discussion about it?  (some part of the tech industry is moving wards this type of API)</p>",
        "id": 153852167,
        "sender_full_name": "Martin Chavez Aguilar",
        "timestamp": 1475773195
    },
    {
        "content": "<p>looks interesting. this would be the place to ask</p>",
        "id": 153852173,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1475779392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> did a prototype around this a while back<br>\n<a href=\"https://github.com/FHIR-CN/gra-fhir-ql\" target=\"_blank\" title=\"https://github.com/FHIR-CN/gra-fhir-ql\">https://github.com/FHIR-CN/gra-fhir-ql</a></p>",
        "id": 153852437,
        "sender_full_name": "Rowan Foster",
        "timestamp": 1476058476
    },
    {
        "content": "<p>+1. Looks like it solves real world problems (we are analyzed couple of our current projects on FHIR). We are going to support GraphQL in aidbox (after swagger:). In some way GraphQL is related to Compartments topic.</p>",
        "id": 153852679,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1476265133
    },
    {
        "content": "<p><img alt=\":heart:\" class=\"emoji\" src=\"/static/third/gemoji/images/emoji/heart.png\" title=\":heart:\"> swagger</p>",
        "id": 153852729,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1476303281
    },
    {
        "content": "<p>Meteor is currently supporting GraphQL integration in Meteor apps via the Apollo database proxy; so Clinical Meteor currently has partial support for it.  We're waiting for GraphQL support in the Mongo shell before migrating the entire Clinical Meteor framework over to Apollo; but it's on the long term roadmap.  </p>",
        "id": 153852765,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1476331368
    },
    {
        "content": "<p>I've started working on a graphql processor in my server, with the aim of clarifying what we need to say in the FHIR spec about a standard way of using graphql with FHIR</p>",
        "id": 153890434,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495133605
    },
    {
        "content": "<p>I'm creating this thread to discuss things as I go along. <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> at least is interested in this. </p>",
        "id": 153890435,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495133637
    },
    {
        "content": "<p>let's start by how to invoke graphql... I think that it goes something like this:</p>",
        "id": 153890436,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495133663
    },
    {
        "content": "<p>POST [base]/$graphql<br>\nPOST [base]/[Type]/$graphql<br>\nPOST [base]/[Type]/[id]/$graphql</p>",
        "id": 153890437,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495133776
    },
    {
        "content": "<p>the nature of the queries/mutations supported depends on the scope at which it is implemented. e.g. if you invoke the graphql on an instance of a resource, the query has a known context and you don't specify a selection, where as if you invoke at a higher level, you have to provide a selection </p>",
        "id": 153890438,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495133853
    },
    {
        "content": "<p>e.g. invoking at /Patient/example:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  active, name, address, dateOfBirth\n}\n</pre></div>",
        "id": 153890441,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495133907
    },
    {
        "content": "<p>but invoking at /Patient:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  Patient[id: example] { \n    active, name, aaddress, dateOfBirth\n  }\n}\n</pre></div>",
        "id": 153890442,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495133964
    },
    {
        "content": "<p>also, let's, for now,  restrict ourselves only to queries, and get to talk about mutations later</p>",
        "id": 153890443,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495134010
    },
    {
        "content": "<p><span class=\"emoji emoji-1f44d\" title=\"+1\">:+1:</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> how do you deal with polymorphic elements and primitive extensions?</p>",
        "id": 153890471,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1495137978
    },
    {
        "content": "<p>don't know. that's one of many questions to be resolved</p>",
        "id": 153890474,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495138071
    },
    {
        "content": "<p>For polymorphic elements I'd consider just using the specified property names, like <code>valueString</code> or <code>valueCode</code> for <code>Observation.value[x]</code>. For references that can use &gt;1 type, I think we'd use object spreads like <code>... on Patient</code> or <code>... on Practitioner</code> to account for multiple possible types at a spot.</p>",
        "id": 153890483,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495143528
    },
    {
        "content": "<p>So for example I could query <code>/Patient/123/Procedure</code> with:</p>\n<div class=\"codehilite\"><pre><span></span>   Procedure {\n        type {\n          text\n        }\n        performer {\n          actor {\n            ... on Practitioner {\n              name {\n                given\n              }\n              identifier {\n                system\n                value\n              }\n            }\n          }\n        } \n      }\n    }\n</pre></div>",
        "id": 153890484,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495143586
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 153890485,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495143736
    },
    {
        "content": "<p>note that Josh's example here autimatically walks across references. It's not clear that this is good for me - what does a server do with references that it can't resolve?</p>",
        "id": 153890488,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495151999
    },
    {
        "content": "<p>also, there's the question of whether it is good to support compartment queries like this, given that most servers are not supporting them</p>",
        "id": 153890490,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495154561
    },
    {
        "content": "<p>So let's see if we can get consensus on something simple. Say I perform the following query: </p>\n<div class=\"codehilite\"><pre><span></span>POST [base]/Patient/example/$graphql\n\n{\n  identifier active name\n}\n</pre></div>",
        "id": 153890508,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495187426
    },
    {
        "content": "<p>then the correct response is </p>\n<div class=\"codehilite\"><pre><span></span>{\n  &quot;identifier&quot;: [\n    {\n      &quot;use&quot;: &quot;usual&quot;,\n      &quot;type&quot;: {\n        &quot;coding&quot;: [\n          {\n            &quot;system&quot;: &quot;http://hl7.org/fhir/v2/0203&quot;,\n            &quot;code&quot;: &quot;MR&quot;\n          }\n        ]\n      },\n      &quot;system&quot;: &quot;urn:oid:1.2.36.146.595.217.0.1&quot;,\n      &quot;value&quot;: &quot;12345&quot;,\n      &quot;period&quot;: {\n        &quot;start&quot;: &quot;2001-05-06&quot;\n      },\n      &quot;assigner&quot;: {\n        &quot;display&quot;: &quot;Acme Healthcare&quot;\n      }\n    }\n  ],\n  &quot;active&quot;: true,\n  &quot;name&quot;: [\n    {\n      &quot;use&quot;: &quot;official&quot;,\n      &quot;family&quot;: &quot;Chalmers&quot;,\n      &quot;given&quot;: [\n        &quot;Peter&quot;,\n        &quot;James&quot;\n      ]\n    },\n    {\n      &quot;use&quot;: &quot;usual&quot;,\n      &quot;given&quot;: [\n        &quot;Jim&quot;\n      ]\n    },\n    {\n      &quot;use&quot;: &quot;maiden&quot;,\n      &quot;family&quot;: &quot;Windsor&quot;,\n      &quot;given&quot;: [\n        &quot;Peter&quot;,\n        &quot;James&quot;\n      ],\n      &quot;period&quot;: {\n        &quot;end&quot;: &quot;2002&quot;\n      }\n    }\n  ]\n}\n</pre></div>",
        "id": 153890509,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495187474
    },
    {
        "content": "<p>anyone disagree with that?</p>",
        "id": 153890510,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495187481
    },
    {
        "content": "<p>less obvious question: is it relevant to talk about xml or turtle responses to graphQL?</p>",
        "id": 153890511,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495188432
    },
    {
        "content": "<p>hmm no. fields must represent primitive values...</p>",
        "id": 153890512,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495194860
    },
    {
        "content": "<p>does anyone know what this, in the GraphQL spec means?</p>\n<div class=\"codehilite\"><pre><span></span>Serialization formats which can only represent unordered maps should retain this order grammatically (such as JSON).\n</pre></div>",
        "id": 153890513,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495195635
    },
    {
        "content": "<p>Might this be a good solution for more complex Privacy Consent rules? That is to support cases where the patient wants to blind a specific type of clinical condition, or specific episode, etc? I would like if the Consent resource could be more simple, and leverage a construct that is designed to do complex selection for more complex privacy needs.</p>",
        "id": 153890519,
        "sender_full_name": "John Moehrke",
        "timestamp": 1495199818
    },
    {
        "content": "<p>I'm not sure how a query format would solve consent problems. I'm looking forward to it making things worse :-(</p>",
        "id": 153890544,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495215246
    },
    {
        "content": "<p>Have you all taken a look at Mostafa Sholkamy's gql-fhir tool?  It uses the Apollo graphQL libraries, which I can attest are getting very good attention and work on.  <br>\n<a href=\"https://github.com/shalkam/gql-fhir/tree/master\" target=\"_blank\" title=\"https://github.com/shalkam/gql-fhir/tree/master\">https://github.com/shalkam/gql-fhir/tree/master</a></p>",
        "id": 153890549,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1495218732
    },
    {
        "content": "<p>hadn't seen it before. <span class=\"user-mention\" data-user-id=\"193512\">@Mostafa Sholkamy</span> are you tracking this topic?</p>",
        "id": 153890551,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495220449
    },
    {
        "content": "<p>In the bigger picture context?  Could this replace parts of the FHIR API (  specifically _query  ) in R4 or is it a supplementary piece that is outside of the FHIR specification.</p>",
        "id": 153890575,
        "sender_full_name": "Eric Haas",
        "timestamp": 1495233454
    },
    {
        "content": "<p>_query is designed to provide more expressive ways of matching resources in a query; graphql is more focused on describing what properties to return and what links to follow from the resources that match (though there is certainly some overlap). </p>",
        "id": 153890579,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495241223
    },
    {
        "content": "<p>Hi,<br>\nFirst let's talk about GraphQL for little.<br>\nNow for developers building new APIs,  using REST style API - I can say - is no longer a thing<br>\n<a href=\"http://nordicapis.com/is-graphql-the-end-of-rest-style-apis/\" target=\"_blank\" title=\"http://nordicapis.com/is-graphql-the-end-of-rest-style-apis/\">http://nordicapis.com/is-graphql-the-end-of-rest-style-apis/</a> </p>\n<p>Currently to develop a FHIR app using GraphQL will make it automatically non compliant with the FHIR specs.<br>\nFHIR is adopting RESTful style API with a HTTP endpoint for each resource because it was a standard way in the industry to APIs back then.<br>\nOf course that was before GraphQL come into the play, as oppose to REST; GraphQL is all about having a single HTTP endpoint for all your requests to save user having multiple round trips to get the data he wants.<br>\nYou can imagine it like writing a MYSQL query against a database except that it is using GraphQL query language and it sends the query string over HTTP.<br>\nSo doing something like this :<br>\nPOST [base]/$graphql<br>\nPOST [base]/[Type]/$graphql<br>\nPOST [base]/[Type]/[id]/$graphql</p>\n<p>is not okay or necessary according to GraphQL standards ( it's all about a single HTTP endpoint )</p>\n<p>Now I will talk about my project a little bit, how I am implementing GraphQL for FHIR.<br>\nI am using my own JSON <a href=\"https://github.com/shalkam/gql-fhir/blob/master/src/data/fhir/helpers/gql-schema/index.js\" target=\"_blank\" title=\"https://github.com/shalkam/gql-fhir/blob/master/src/data/fhir/helpers/gql-schema/index.js\">parser</a> - not complete yet -to convert Structure definitions into a GraphQL <a href=\"https://github.com/shalkam/gql-fhir/blob/master/src/data/schema.graphql\" target=\"_blank\" title=\"https://github.com/shalkam/gql-fhir/blob/master/src/data/schema.graphql\">schema</a>.</p>\n<p>What my project does:<br>\n- It can handle all the CRUD operations for the supported resouces.</p>\n<p>What my project does not:<br>\n- Because of my lack of understanding for FHIR - especially the infrastructure part - it doesn't handle searches, bundles and conformance stuff I can say the whole infrastructure part is yet to be done.</p>\n<p>Looking forward to knowing your thoughts about this.</p>\n<p>Regards,<br>\nMostafa</p>",
        "id": 153890580,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495244051
    },
    {
        "content": "<p>I thought that Graphql returns only properties from resources and not the entire resources and is a shortcut for _revinclude or _include or a _query.  E.g.,  I could get all the practitioner names for a patient A using something like this...</p>",
        "id": 153890581,
        "sender_full_name": "Eric Haas",
        "timestamp": 1495245255
    },
    {
        "content": "<p>{<br>\n        Patient {<br>\n          name<br>\n          Practitioner{<br>\n          name<br>\n          }<br>\n        }<br>\n      }</p>\n<div class=\"codehilite\"><pre><span></span>    &quot;data&quot;: {\n      &quot;Patient&quot;: {\n        &quot;name&quot;: &quot;A&quot;,\n        &quot;Practitioner&quot;: [\n          {\n            &quot;name&quot;: Dr X&quot;\n          },\n          {\n           &quot;name&quot;: Dr Y&quot;\n          },\n          {\n            &quot;name&quot;: &quot;Dr Z&quot;\n          }\n        ]\n      }\n    }\n  }\n</pre></div>",
        "id": 153890582,
        "sender_full_name": "Eric Haas",
        "timestamp": 1495245260
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> GraphQL is all about getting the exact result a defined in the query string, it does not care about how we do it or what's going under the hood in the server</p>",
        "id": 153890583,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495246190
    },
    {
        "content": "<p>But the semantics of graphql require that you can define your \"entry points\" for a query and can start from the there, right <span class=\"user-mention\" data-user-id=\"193512\">@Mostafa Sholkamy</span>? For example, if I wanted to get a list of blood pressures and conditions for a given patient, this is readily expressed with graphql (well, if we assume what FHIR would call \"reverse\" relationships from Patient to Condition, and from Patient to Observation -- note that natively FHIR defines these relationships in the other direction, and we'll probably want to define both directions in a graphql mapping). But I can't use graphql to say \"find me list of patients who have had an elevated blood pressure reading and also have a diagnosis of hypertension\". In other words, it's not a graph search paradigm so much as filtered subgraph retrievable. Is that fair?</p>",
        "id": 153890584,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495247299
    },
    {
        "content": "<p>I think that there's 2 things at play here - one is using graphQL, and the other is changing your patterns. </p>",
        "id": 153890586,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495248389
    },
    {
        "content": "<p>These:</p>\n<div class=\"codehilite\"><pre><span></span>GET base/Patient/example/$graphql?q={name link active}\n</pre></div>",
        "id": 153890587,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495248447
    },
    {
        "content": "<p>and</p>\n<div class=\"codehilite\"><pre><span></span>GET base/$graphql?q={Patient[id:example] {name link active}}\n</pre></div>",
        "id": 153890588,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495248481
    },
    {
        "content": "<p>are synonymous. That doesn't mean that the first has no use, or that the second is going to replace RESTful URLs and make them redundant</p>",
        "id": 153890589,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495248533
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> you can use graphQL to say what you said, if we define it accordingly. But it's not inherent in graphql - it would be for us to define how that kind of search functionality is made available</p>",
        "id": 153890590,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495248609
    },
    {
        "content": "<p>Do you mean by defining some clever set of arguments, in something akin to chained search? Like <code>Patient(\"_has:Procedure:patient.code\":\"123\"){}</code>Sure, but I guess my point is is then it's not some new or newly-expressive graph-based model for query, it's just packing dots into a string argument. (Also graphql is nicely typed, which is awesome but I don't know if you can get this much flexibility without explicitly naming every allowed argument.)</p>",
        "id": 153890592,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495251524
    },
    {
        "content": "<p>Arguments within inner blocks don't change the behavior of the outer blocks, so you can't achieve this kind of query with nested graphql blocks.</p>",
        "id": 153890593,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495251710
    },
    {
        "content": "<p>well, I was more thinking Patient(search: \"[_filter string]\") { fields..} where search is as specified here: <a href=\"http://hl7.org/fhir/search_filter.html\" target=\"_blank\" title=\"http://hl7.org/fhir/search_filter.html\">http://hl7.org/fhir/search_filter.html</a></p>",
        "id": 153890594,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495262177
    },
    {
        "content": "<p>for those tracking this discussion - I just created a first test case on this, in subversion - \\build\\tests\\graphql.</p>",
        "id": 153890604,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495289000
    },
    {
        "content": "<p>it says that if you execute this qraphql</p>\n<div class=\"codehilite\"><pre><span></span>{\n  identifier { system value }\n  active \n  name { text given family } \n}\n</pre></div>",
        "id": 153890605,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495289022
    },
    {
        "content": "<p>against the resource context Patient/example (e.g. [base]/Patient/example/$graphql)</p>",
        "id": 153890606,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495289033
    },
    {
        "content": "<p>then the correct output is</p>\n<div class=\"codehilite\"><pre><span></span>{\n  &quot;identifier&quot;: [{\n      &quot;system&quot;: &quot;urn:oid:1.2.36.146.595.217.0.1&quot;,\n      &quot;value&quot;: &quot;12345&quot;\n  }],\n  &quot;active&quot;: true,\n  &quot;name&quot;: [{\n    &quot;given&quot;: [&quot;Peter&quot;,&quot;James&quot;],\n    &quot;family&quot;: &quot;Chalmers&quot;\n  },{\n    &quot;given&quot;: [&quot;Jim&quot;]\n  },{\n    &quot;given&quot;: [&quot;Peter&quot;,&quot;James&quot;],\n    &quot;family&quot;: &quot;Windsor&quot;\n  }]\n}\n</pre></div>",
        "id": 153890607,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495289084
    },
    {
        "content": "<p>btw. I think that there's a pretty simple answer to the question of omitting mandatory attributes: the output of graphql is not expected to be resources, it's a view on them </p>",
        "id": 153890608,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495289133
    },
    {
        "content": "<p>can we all agree that if you execute this graphql against that resource, that's the correct outcome?</p>",
        "id": 153890609,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495289185
    },
    {
        "content": "<p>if we can all agree to that, then the next things to work on are:<br>\n- polymorphic fields <br>\n- field filters and directives <br>\n- extensions in primitive fields / schema reconciliation<br>\n- forward reference resolution<br>\n- searching resources (.e.g context [base]/$graphql)<br>\n- backwards reference resolution<br>\n- mutations<br>\n(in that approximate order)</p>",
        "id": 153890610,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495289478
    },
    {
        "content": "<blockquote>\n<p>well, I was more thinking Patient(search: \"[_filter string]\") { fields..} where search is as specified here: <a href=\"http://hl7.org/fhir/search_filter.html\" target=\"_blank\" title=\"http://hl7.org/fhir/search_filter.html\">http://hl7.org/fhir/search_filter.html</a></p>\n</blockquote>\n<p>Sure. Again, just emphasizing that graphql doesn't provide a new model for graph <em>search</em>. It lets us use our existing models. </p>",
        "id": 153890612,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495291376
    },
    {
        "content": "<p>For forward reference resolution, I'd like to suggest that we just use a \"resource\" field within any reference, like <code>MedicationRequest { patient { resource {active} } }</code> -- this preserves access to the reference's display and value fields.</p>",
        "id": 153890613,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495291774
    },
    {
        "content": "<p>For reverse references, one option to consider is constructing names from \"Source type\" + underscore + \"search parameter name\". Like, to get conditions pointing to a patient, you might say <code>Patient { Condition_patient { id} }</code>. This feels a bit clumsy, but it's at least simple.</p>",
        "id": 153890614,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495292486
    },
    {
        "content": "<p>If it were possible to refer to fields in a parent result, we could do something a bit cleaner like <code>Patient { Condition(patient: \"$parent.id\") { severity {text} }}</code>... but I don't think graphql defines something like this.</p>",
        "id": 153890615,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495292989
    },
    {
        "content": "<p>I guess we could just define things as working this way, with a magic \"parent\" variable or something like it (ideally, you'd be able to more precisely state which parent, with assigned variable names and stuff). But this kind of magic makes it hard to reuse existing graphql server support libraries...</p>",
        "id": 153890616,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495293194
    },
    {
        "content": "<p>My preference would be the Condition_patient approach, which avoids blurring the boundary between references and arguments.</p>",
        "id": 153890617,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495293621
    },
    {
        "content": "<p>I don't understand anything from after you start talking about parent, but I agree with resource. This lets us do:</p>",
        "id": 153890621,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495306905
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>MedicationRequest { patient { resource(policy : error) {active} } }\n</pre></div>",
        "id": 153890622,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495306935
    },
    {
        "content": "<p>or</p>\n<div class=\"codehilite\"><pre><span></span>MedicationRequest { patient { resource(policy : optional) {active} } }\n</pre></div>",
        "id": 153890623,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495306964
    },
    {
        "content": "<p>ok. so this graphQL:</p>\n<div class=\"codehilite\"><pre><span></span>{ \n  id\n  subject { reference, resource {active} } \n  code {coding {system code} }\n}\n</pre></div>",
        "id": 153890624,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495309048
    },
    {
        "content": "<p>run in the context of Observation/example, gives this:</p>",
        "id": 153890625,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495309063
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>{\n  &quot;id&quot; : &quot;example&quot;,\n  &quot;subject&quot; : {\n    &quot;reference&quot; : &quot;Patient/example&quot;,\n    &quot;resource&quot; : {\n      &quot;active&quot;: true\n    }\n  },\n  &quot;code&quot;: {\n    &quot;coding&quot;: [{\n        &quot;system&quot;: &quot;http://loinc.org&quot;,\n        &quot;code&quot;: &quot;29463-7&quot;\n      },{\n        &quot;system&quot;: &quot;http://loinc.org&quot;,\n        &quot;code&quot;: &quot;3141-9&quot;\n      },{\n        &quot;system&quot;: &quot;http://snomed.info/sct&quot;,\n        &quot;code&quot;: &quot;27113001&quot;\n      },{\n        &quot;system&quot;: &quot;http://acme.org/devices/clinical-codes&quot;,\n        &quot;code&quot;: &quot;body-weight&quot;\n      }]\n  }\n}\n</pre></div>",
        "id": 153890626,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495309072
    },
    {
        "content": "<p>ok, static notes extracted from this thread: <a href=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL\">http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL</a></p>",
        "id": 153890633,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495316723
    },
    {
        "content": "<blockquote>\n<p>I don't understand anything from after you start talking about parent</p>\n</blockquote>\n<p>Okay, how about before the stuff about \"parent\"? Thoughts on the <code>Condition_patient</code> notation?</p>",
        "id": 153890635,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495321688
    },
    {
        "content": "<p>I don't know what it's supposed to do. I think that the requirement is:<br>\n- at this point in the graph, insert the list of resources that refer to this resource in property [x]</p>",
        "id": 153890636,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495337470
    },
    {
        "content": "<p>That's close to how I'd describe the requirement, too. Only tweak I'd make is \"insert the list of resources of type Y that refer to this resource via property X\". So in my example, Y was \"Condition\" and X was the Condition's \"patient\" element acting as the source of the reference. I was suggesting we define a graphql field called \"Condition_patient\" to capture this relationship (would have preferred \"Condition.patient\", but <code>.</code> isn't valid) . Possibly we can further restrict X to \"elements implicated by standard reference-type search parameters\", which means we could use those search parameter names instead of having to point to arbitrary element paths.</p>",
        "id": 153890637,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495338175
    },
    {
        "content": "<p>Also we should capture as an explicit goal: publishing a graphql schema for FHIR. This will make our design decisions explicit and easy to use from code. </p>",
        "id": 153890638,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495338287
    },
    {
        "content": "<p>I think search parameter names is correct. </p>",
        "id": 153890639,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495338882
    },
    {
        "content": "<p>but I would have gone for something like this:</p>\n<div class=\"codehilite\"><pre><span></span>references(resource: Condition, parameter: patient) {\n}\n</pre></div>",
        "id": 153890640,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495338936
    },
    {
        "content": "<p>instead of </p>\n<div class=\"codehilite\"><pre><span></span>Condition_patient {\n}\n</pre></div>",
        "id": 153890641,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495338952
    },
    {
        "content": "<p>with regard to polymorphic types - there's kind of 2 ways to do it. Say we're dealing with Observation, and we want the value:</p>\n<p>{<br>\n  valueQuantity, valueCodeableConcept, valueString, valueBoolean, valueRange, valueRatio, valueSampledData, valueAttachment, valueTime, valueDateTime, valuePeriod<br>\n}</p>",
        "id": 153890643,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495339434
    },
    {
        "content": "<p>or we could go for <br>\n{ <br>\n  value<br>\n}</p>",
        "id": 153890644,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495339444
    },
    {
        "content": "<p>actually, you can't. unless the types are all primitives - and I don't think that actually happens anywhere</p>",
        "id": 153890645,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495339548
    },
    {
        "content": "<p>you'd have to blow them out and specify their primitives, courtesy of GraphQL's rule about all leafs be scalars</p>",
        "id": 153890646,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495339614
    },
    {
        "content": "<p>so</p>\n<div class=\"codehilite\"><pre><span></span>{\n  subject{reference}\n  valueQuantity {value unit}\n}\n</pre></div>",
        "id": 153890647,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495340587
    },
    {
        "content": "<p>on Observation/example gives this:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  &quot;subject&quot; : {\n    &quot;reference&quot; : &quot;Patient/example&quot;\n  },\n  &quot;valueQuantity&quot;: {\n    &quot;value&quot;: 185,\n    &quot;unit&quot;: &quot;lbs&quot;\n  }\n}\n</pre></div>",
        "id": 153890648,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495340608
    },
    {
        "content": "<blockquote>\n<p>can we all agree that if you execute this graphql against that resource, that's the correct outcome?</p>\n</blockquote>\n<p>Yes That is correct</p>",
        "id": 153890649,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495347652
    },
    {
        "content": "<ul>\n<li>searching resources <br>\nI think we should create a filter type for each resource that uses search as defined here : <a href=\"http://hl7.org/fhir/search_filter.html\" target=\"_blank\" title=\"http://hl7.org/fhir/search_filter.html\">http://hl7.org/fhir/search_filter.html</a><br>\nand we can also create a resourceFilter interface that implements the common things when searching a resource.</li>\n</ul>",
        "id": 153890650,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495348562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> <br>\n- references<br>\nFirst thing I want to confirm that we all agree that we should add a <code>resource</code> field to the <code>Reference</code> element as that doesn't exist in FHIR specs<br>\n<a href=\"http://hl7.org/fhir/references.html\" target=\"_blank\" title=\"http://hl7.org/fhir/references.html\">http://hl7.org/fhir/references.html</a></p>\n<p>Now that we have the <code>resource</code> field in hand it's pretty easy to resolve it.<br>\nGraphQL has an interface type <a href=\"http://graphql.org/learn/schema/#interfaces\" target=\"_blank\" title=\"http://graphql.org/learn/schema/#interfaces\">http://graphql.org/learn/schema/#interfaces</a> , So we can create a resource interface that has all the common fields for all resources then we can do something like this:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  id\n  subject {\nreference\nresource {\n    ...on Patient {\n         birthDate\n    }\n    ...on Practioner {\n           practitionerRole {  speciality }\n   }\n }\n  code {coding {system code} }\n}\n</pre></div>",
        "id": 153890652,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495349308
    },
    {
        "content": "<ul>\n<li>extensions in primitive fields / schema reconciliation</li>\n</ul>\n<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  Could you explain more what do you mean by schema reconciliation?</p>\n<p>I think there is no problem with extensions for primitive fields,the <code>_</code> prefix works just fine,  here is how I do it:<br>\nfirst I define an element type </p>\n<div class=\"codehilite\"><pre><span></span># Base for all elements\ntype Element {\n  id: ID\n  extension: [Extension]\n}\n</pre></div>\n\n\n<p>then use the element for the primitive field extension in <code>Address</code> type for example:</p>\n<div class=\"codehilite\"><pre><span></span># A postal address\ntype Address {\n  id: ID\n  extension: [Extension]\n  use: String\n  _use: Element\n  type: String\n  _type: Element\n  text: String\n  _text: Element\n  line: [String]\n  _line: Element\n  city: String\n  _city: Element\n  district: String\n  _district: Element\n  state: String\n  _state: Element\n  postalCode: String\n  _postalCode: Element\n  country: String\n  _country: Element\n  period: Period\n}\n</pre></div>",
        "id": 153890654,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495349759
    },
    {
        "content": "<p>so the question with extensions is whether graphql is specific to json, or more general. so far, all the discussion has been that it's a json only thing. that would make being explicit about the json representatation of extensions the right thing - which is what you've done</p>",
        "id": 153890655,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495351916
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> that is correct GraphQL is for JSON only APIs</p>",
        "id": 153890656,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495353201
    },
    {
        "content": "<p>that's not quite what the graphql spec says</p>",
        "id": 153890658,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495359807
    },
    {
        "content": "<p>the response is always json</p>",
        "id": 153890659,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495361557
    },
    {
        "content": "<p>section 7.1: GraphQL does not require a specific serialization format. However, clients should use a serialization format that supports the major primitives in the GraphQL response</p>",
        "id": 153890660,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495365409
    },
    {
        "content": "<p>JSON is the preferred serialization format for GraphQL, though as noted above, GraphQL does not require a specific serialization format.</p>",
        "id": 153890661,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495365434
    },
    {
        "content": "<p>it's the first time I see the this, but again I searched for any GraphQL server that supports anything other than JSON but I've found nothing</p>",
        "id": 153890663,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495371875
    },
    {
        "content": "<p>yes that is certainly true</p>",
        "id": 153890664,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495382881
    },
    {
        "content": "<p>I could be first ;-)</p>",
        "id": 153890665,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495382892
    },
    {
        "content": "<p>back to extensions. Running this:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  subject { resource { birthDate } }\n  subject { resource { _birthDate { extension {valueDateTime} } } }\n}\n</pre></div>",
        "id": 153890671,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495393774
    },
    {
        "content": "<p>against Observation/20minute-apgar-score results in this output:</p>",
        "id": 153890672,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495393798
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>{\n  &quot;subject&quot;: [{\n    &quot;resource&quot;: {\n      &quot;birthDate&quot;: &quot;2016-05-18&quot;\n    }\n  },{\n    &quot;resource&quot;: {\n      &quot;_birthDate&quot;: {\n        &quot;extension&quot;:[{\n            &quot;valueDateTime&quot;: &quot;2016-05-18T10:28:45Z&quot;\n        }]\n      }\n    }\n  }]\n}\n</pre></div>",
        "id": 153890673,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495393807
    },
    {
        "content": "<p>Well if I don't see a reason you should duplicate a fragment of the query twice, I think you would get an error with that.<br>\nthe correct one would look like that:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  subject { \n    resource { \n        birthDate\n        _birthDate { \n            extension {\n                valueDateTime\n            }\n         } \n    } \n   }\n}\n</pre></div>",
        "id": 153890675,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495394246
    },
    {
        "content": "<p>oh -I was also testing that my processor handled that properly - as far as I can tell, the graphQL spec allows that. But I agree that the way you did it would be more natural</p>",
        "id": 153890676,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495394660
    },
    {
        "content": "<p>anyway, I've just set this live at <a href=\"http://test.fhir.org/r3\" target=\"_blank\" title=\"http://test.fhir.org/r3\">http://test.fhir.org/r3</a> - so people can test it. Note that the server doesn't yet support root level query (only on resource instance) and it doesn't yet support anything on the todo list here: <a href=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL\">http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL</a></p>",
        "id": 153890677,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495394783
    },
    {
        "content": "<p>one thing I haven't found in the graphql spec yet is how the client gets the schema... is it inline, or just doco?</p>",
        "id": 153890678,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495394842
    },
    {
        "content": "<p>e.g. <a href=\"http://test.fhir.org/r3/Observation/example/$graphql?query={%20id%20subject%20{%20reference,%20resource%20{active}%20}%20code%20{coding%20{system%20code}%20}}\" target=\"_blank\" title=\"http://test.fhir.org/r3/Observation/example/$graphql?query={%20id%20subject%20{%20reference,%20resource%20{active}%20}%20code%20{coding%20{system%20code}%20}}\">http://test.fhir.org/r3/Observation/example/$graphql?query={%20id%20subject%20{%20reference,%20resource%20{active}%20}%20code%20{coding%20{system%20code}%20}}</a> btw</p>",
        "id": 153890679,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495394960
    },
    {
        "content": "<blockquote>\n<p>one thing I haven't found in the graphql spec yet is how the client gets the schema... is it inline, or just doco?</p>\n</blockquote>\n<p>Could you explain more what do you mean by that?</p>",
        "id": 153890681,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495395622
    },
    {
        "content": "<p>can the client actually ask the server for the schema? or does the server just have to publish it somewhere?</p>",
        "id": 153890682,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495396491
    },
    {
        "content": "<p>hah - just found it - Schema Introspection.</p>",
        "id": 153890683,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495396730
    },
    {
        "content": "<p>yes, that is correct, this can also work as a sort of conformance statement if I understand it correctly</p>",
        "id": 153890685,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495397490
    },
    {
        "content": "<p>Good job with <a href=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL\">http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL</a> <br>\nI will go through it and I will give you my feedback on it</p>",
        "id": 153890686,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495397583
    },
    {
        "content": "<p>As regard <strong> Data type mappings </strong> for primitive types<br>\nIn GraphQL you can create custom scalar types <a href=\"http://graphql.org/learn/schema/#scalar-types\" target=\"_blank\" title=\"http://graphql.org/learn/schema/#scalar-types\">http://graphql.org/learn/schema/#scalar-types</a> <br>\nIn the GraphQL schema it's pretty easy you can just do something like:</p>\n<div class=\"codehilite\"><pre><span></span>scalar positiveInt\n</pre></div>\n\n\n<p>and the server determines how to deal with this scalar type, My project - it's using node.js -deals with it this way</p>\n<div class=\"codehilite\"><pre><span></span>import { GraphQLScalarType } from &#39;graphql&#39;;\nimport { GraphQLError } from &#39;graphql/error&#39;;\nimport { Kind } from &#39;graphql/language&#39;;\n\nexport default new GraphQLScalarType({\n  name: &#39;positiveInt&#39;,\n  description: &#39;an integer with value more than zero&#39;,\n  serialize: value =&gt; {\n    return value;\n  },\n  parseValue: value =&gt; {\n    return value;\n  },\n  parseLiteral: ast =&gt; {\n    if (ast.kind !== Kind.INT) {\n      throw new GraphQLError(&#39;Query error: Can only parse integers got a: &#39; + ast.kind, [ ast ]);\n    }\n    if (!(ast.value &gt; 0)) {\n      throw new GraphQLError(&#39;Query error: Not a valid positive integer&#39;, [ ast ]);\n    }\n\n    return ast.value;\n  }\n});\n</pre></div>\n\n\n<p>I've got my primitive types defined here<br>\n<a href=\"https://github.com/shalkam/gql-fhir/tree/master/src/data/fhir/types/primitive\" target=\"_blank\" title=\"https://github.com/shalkam/gql-fhir/tree/master/src/data/fhir/types/primitive\">https://github.com/shalkam/gql-fhir/tree/master/src/data/fhir/types/primitive</a></p>",
        "id": 153890687,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495398490
    },
    {
        "content": "<p>this can be also useful when profiling, an Array scalar type can be created for handling cardinality like this:</p>\n<div class=\"codehilite\"><pre><span></span>scalar ArrayMin1Max5\n</pre></div>",
        "id": 153890688,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495399319
    },
    {
        "content": "<p>hmm. that loses the mapping to the underlying scalar type. How do you know that unsignedInt is a number in json? I think that's just bizarre, and I'd rather avoid defining them then</p>",
        "id": 153890689,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495404625
    },
    {
        "content": "<p>so far, there's 2 things that strike as weird in graphql - that, and the fact that you have to do selection sets for objects</p>",
        "id": 153890690,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495404675
    },
    {
        "content": "<p>ok, back to reverse references (<span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span>). So after looking at the schema, let's do it this way:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  name {...}\n  Condition(_key: patient) {\n   .. fields from Condition ...\n  }\n}\n</pre></div>",
        "id": 153890691,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495407725
    },
    {
        "content": "<p>name the resource type that you are looking up - helpful for typing - and, provide which index you want to use for matching as the argument '_key'. You can provide other search parameters as arguments, to further filter</p>",
        "id": 153890692,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495407821
    },
    {
        "content": "<p>And <code>_key</code> is limited to search parameters? I like this! I might change <code>_key</code> to <code>reference</code> or <code>_reference</code> just to avoid introducing a new term for this idea. </p>",
        "id": 153890694,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495409750
    },
    {
        "content": "<p>yes. I don't mind changing to _reference. I will update the doco and my implementation</p>",
        "id": 153890696,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495409788
    },
    {
        "content": "<p>has to be _reference not reference because there are existing search parameters named reference and you might want to combine them</p>",
        "id": 153890697,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495409888
    },
    {
        "content": "<p>I will update <a href=\"http://test.fhir.org\" target=\"_blank\" title=\"http://test.fhir.org\">test.fhir.org</a> to support this later today</p>",
        "id": 153890698,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495409937
    },
    {
        "content": "<blockquote>\n<p>hmm. that loses the mapping to the underlying scalar type. How do you know that unsignedInt is a number in json? I think that's just bizarre, and I'd rather avoid defining them then</p>\n</blockquote>\n<p>No, that is just a standard in GraphQL and fulfills a requirement in FHIR specs;  I don't see a reason why we should avoid it. You have a GraphQL schema string and you have <code>resolver</code> function for each type in the schema.<br>\na <code>resolver</code> function is responsible for getting the data to deliver to the client, it doesn't matter how but most of the time it will be doing some database queries against a model.</p>\n<p>It's a GraphQL server responsibility to match those two together. <code>resolvers</code> can be written in any programming language according to your favorite language and according to that the server library you are using.</p>\n<p>It's not the responsibility of HL7 to define how <code>resolver</code> functions will look like, it is just enough to write a GraphQL schema and then anyone can figure out how to resolve that schema in his way using his own preferred programming language.</p>\n<p>Please take a look at this link and see if it makes more sense after : <a href=\"http://dev.apollodata.com/tools/graphql-tools/scalars.html\" target=\"_blank\" title=\"http://dev.apollodata.com/tools/graphql-tools/scalars.html\">http://dev.apollodata.com/tools/graphql-tools/scalars.html</a> </p>",
        "id": 153890705,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495414331
    },
    {
        "content": "<p>and here is another article about resolvers: <a href=\"http://dev.apollodata.com/tools/graphql-tools/resolvers.html\" target=\"_blank\" title=\"http://dev.apollodata.com/tools/graphql-tools/resolvers.html\">http://dev.apollodata.com/tools/graphql-tools/resolvers.html</a></p>",
        "id": 153890709,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495416485
    },
    {
        "content": "<p>Please note that most of the Links I am referencing are for Node.js libraries, of course other languages have their own corresponding libraries</p>",
        "id": 153890710,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495416541
    },
    {
        "content": "<p>right. resolvers are a private thing to the server. The question for the client is, what is scalar type xxx? a string? a number? something else?</p>",
        "id": 153890711,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495418439
    },
    {
        "content": "<p>on the subject of looking up reverse references, do we need to worry about there being too many of them?</p>",
        "id": 153890712,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495419779
    },
    {
        "content": "<p>and if we did worry about it, what would we do about it?</p>",
        "id": 153890713,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495419795
    },
    {
        "content": "<p>so there's another problem here - we define search parameter names with '-' in them. These make them non-valid argument names in graphQL</p>",
        "id": 153890716,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495425384
    },
    {
        "content": "<p>for now, I am replacing - with _</p>",
        "id": 153890717,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495427063
    },
    {
        "content": "<p>do we have any need for directives other than the mandatory ones?</p>",
        "id": 153890732,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495445782
    },
    {
        "content": "<blockquote>\n<p>The question for the client is, what is scalar type xxx? a string? a number? something else?</p>\n</blockquote>\n<p>There is always a schema introspection every scalar type has its own description in the schema, Most of the time the type name itself is self explanatory.<br>\nAnd also FHIR describes every scalar/primitive type</p>",
        "id": 153890766,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495465767
    },
    {
        "content": "<blockquote>\n<p>on the subject of looking up reverse references, do we need to worry about there being too many of them?<br>\nand if we did worry about it, what would we do about it?</p>\n</blockquote>\n<p>Do you mean like a some sort of pagination solution?</p>",
        "id": 153890767,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495465995
    },
    {
        "content": "<p>well, that's the question - do we need to?</p>",
        "id": 153890777,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495468297
    },
    {
        "content": "<p>Of course if it's too many we have to paginate</p>",
        "id": 153890785,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495469675
    },
    {
        "content": "<p>Could you take a look at this : <a href=\"https://facebook.github.io/relay/docs/graphql-relay-specification.html\" target=\"_blank\" title=\"https://facebook.github.io/relay/docs/graphql-relay-specification.html\">https://facebook.github.io/relay/docs/graphql-relay-specification.html</a> ?</p>",
        "id": 153890786,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495469692
    },
    {
        "content": "<p>it adds more specifications to take care of pagination and other stuff</p>",
        "id": 153890788,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495470383
    },
    {
        "content": "<p>so the way that works puts all the control on the part of the server,  yes? the client doesn't get to say anything about it? </p>",
        "id": 153890791,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495471172
    },
    {
        "content": "<p>I'm also not sure how you would make that work deep inside a graph</p>",
        "id": 153890792,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495471201
    },
    {
        "content": "<p>so looking at <a href=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL\">http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL</a><br>\n I am confused by the notation or syntax of ellipses. <br>\nof this:</p>\n<div class=\"codehilite\"><pre><span></span>      resource {\n        ...on Patient {\n</pre></div>\n\n\n<p>vs ellipses here:</p>\n<div class=\"codehilite\"><pre><span></span>   {\n   name {...}\n    Condition(_reference: patient) {\n    .. fields from Condition ...\n    }\n</pre></div>\n\n\n<p>I'm assuming the first case is actual GraphQL syntax and the second means 'some data here' ?</p>",
        "id": 153890793,
        "sender_full_name": "Eric Haas",
        "timestamp": 1495471203
    },
    {
        "content": "<p>ah yes. tricky. I'll make the second explicit</p>",
        "id": 153890794,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495471229
    },
    {
        "content": "<p>try that</p>",
        "id": 153890795,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495471303
    },
    {
        "content": "<p>that is clearer.  thanks</p>",
        "id": 153890796,
        "sender_full_name": "Eric Haas",
        "timestamp": 1495471409
    },
    {
        "content": "<blockquote>\n<p>so the way that works puts all the control on the part of the server, yes? the client doesn't get to say anything about it?</p>\n</blockquote>\n<p>could you explain more?</p>",
        "id": 153890799,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495474274
    },
    {
        "content": "<p>I couldn't find anywhere in that approach where the client said whether it wanted paging </p>",
        "id": 153890810,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495477373
    },
    {
        "content": "<p>the client can always state whether it wants paging  or not<br>\nso, using this example </p>\n<div class=\"codehilite\"><pre><span></span> {\n   name {...}\n    Condition(_reference: patient) {\n    .. fields from Condition ...\n    }\n</pre></div>\n\n\n<p>we can do something like this </p>\n<div class=\"codehilite\"><pre><span></span> {\n   name {...}\n    Condition(_reference: patient, start: 0, limit: 10) {\n    .. fields from Condition ...\n    }\n</pre></div>",
        "id": 153890812,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495478126
    },
    {
        "content": "<p>the arguments can always be changed per client query</p>",
        "id": 153890813,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495478154
    },
    {
        "content": "<p>I missed that bit. Should we make this standard?</p>",
        "id": 153890819,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495483576
    },
    {
        "content": "<p>I think we should, yes. But a more difficult question: order....</p>",
        "id": 153890829,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495487448
    },
    {
        "content": "<p>I think we probably want to align our paging approach with what we do in the search API, using opaque \"next page\" tokens and a client-suggested count. </p>",
        "id": 153890831,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495495975
    },
    {
        "content": "<p><a href=\"http://graphql.org/learn/pagination/\" target=\"_blank\" title=\"http://graphql.org/learn/pagination/\">http://graphql.org/learn/pagination/</a> describes relevant considerations </p>",
        "id": 153890832,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495495995
    },
    {
        "content": "<p>that makes sense at the root, but I'm quite unpersuaded that it makes sense deep inside a graph</p>",
        "id": 153890833,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495496027
    },
    {
        "content": "<p>It does imply we need a kind wrapper though around the list of paginated things. Like a ConditionList instead of Condition. </p>",
        "id": 153890834,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495496053
    },
    {
        "content": "<p>What I'm suggesting is essentially the best practice described on the \"learn\" site </p>",
        "id": 153890835,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495496192
    },
    {
        "content": "<p>What worries you about it? </p>",
        "id": 153890836,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495496212
    },
    {
        "content": "<p>it's one thing to say start/limit or something a the root, or have a cursor approach that matches what we do no</p>",
        "id": 153890837,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495496550
    },
    {
        "content": "<p>get me all the resources that match these conditions.... right. that's obvious. </p>",
        "id": 153890838,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495496570
    },
    {
        "content": "<p>Oh, yes deeply nested this kind of token would be hard to pass into a followup query. I was imaging the followup query would be targeted to just the nested piece (not containing/repeating all the outer stuff). </p>",
        "id": 153890839,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495496585
    },
    {
        "content": "<p>it get's especially hard when you have nested lists - the server is keeping a lot of speculative lists that the client will never follow </p>",
        "id": 153890840,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495496650
    },
    {
        "content": "<p>I'm not even sure how many servers would be able to retain an independent context in which the deep queries could be followed </p>",
        "id": 153890841,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495496690
    },
    {
        "content": "<p>But letting the client provide offsets doesn't quite work either: if I do a top level query for Patients and want to get first 5 Encounters for each and then independently page through the next 5 Encounters for just the first patient... I'd probably just issue a follow-up query for that on patient's next encounters, rather than repeat the whole outer query, right? (I can't see another way to express it, because the outer query is doesn't give me a way to use different offsets for different patients.)</p>",
        "id": 153890842,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495496818
    },
    {
        "content": "<p>The server doesn't need to maintain speculative lists -- it can instead just produce pagination tokens that internally just represent something like \"skip 15\". The point is just that the server gets to choose (between this and db cursors or whatever), and the client treats it as opaque.</p>",
        "id": 153890843,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495496964
    },
    {
        "content": "<p>I can't present </p>",
        "id": 153890845,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495501549
    },
    {
        "content": "<p>I can't present a token that means 'skip 15' unless I know what the server has to skip <em>from</em></p>",
        "id": 153890846,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495501572
    },
    {
        "content": "<p>I think that there's no place for pagination queries on anything but the root. For the nested stuff, just let the client specify a limit, and only on the root allow pagination and links for following the sequence (the stuff we already do)</p>",
        "id": 153890847,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495501667
    },
    {
        "content": "<p>And how does a client follow up beyond the initial fetch limit? A nicely designed pagination token embeds enough context to reproduce a query (e.g. The query parameters and an index of a last returned result.) </p>",
        "id": 153890849,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495508019
    },
    {
        "content": "<p>I'm just implementing it on the root. It's problematic. Here's my example, which should illustrate:</p>",
        "id": 153890850,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495508230
    },
    {
        "content": "<p>request:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  Patient(active : true) { \n   id \n}\n</pre></div>",
        "id": 153890851,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495508316
    },
    {
        "content": "<p>response:</p>",
        "id": 153890852,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495508322
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>{\n  &quot;Patient&quot;: [\n    {\n      &quot;type&quot;: &quot;paging&quot;,\n      &quot;first&quot;: &quot;search-id=e6686cc0-11cc-4266-a027-aef4c7f3fb&amp;&amp;active=true&amp;_sort=_id&amp;search-offset=0&amp;_count=50&quot;,\n      &quot;next&quot;: &quot;search-id=e6686cc0-11cc-4266-a027-aef4c7f3fb&amp;&amp;active=true&amp;_sort=_id&amp;search-offset=50&amp;_count=50&quot;,\n      &quot;last&quot;: &quot;search-id=e6686cc0-11cc-4266-a027-aef4c7f3fb&amp;&amp;active=true&amp;_sort=_id&amp;search-offset=200&amp;_count=50&quot;\n    },\n    {\n      &quot;type&quot;: &quot;resource&quot;,\n      &quot;id&quot;: &quot;1&quot;\n    },\n    {\n      &quot;type&quot;: &quot;resource&quot;,\n      &quot;id&quot;: &quot;100&quot;\n    },\n  .. etc...\n  ]\n}\n</pre></div>",
        "id": 153890853,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495508365
    },
    {
        "content": "<p>This is doest look quite right. Your Connection object should have next/prev links and then an array of patients </p>",
        "id": 153890854,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495508451
    },
    {
        "content": "<p>first of all, you need to find somewhere to inject the paging control data. I chose one of several different possible ways here; there are others I expect we'll argue over. But you have to do something, if you're going to enable this. I just don't see the value on reverse reference resolution, only on the root searches</p>",
        "id": 153890855,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495508456
    },
    {
        "content": "<p>well, you can show what you think it should look like, but I don't see how it can look like you describe, given the way that graphQL works</p>",
        "id": 153890856,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495508528
    },
    {
        "content": "<p>(yes, I'll be argue about this particular representation ;)) But when you say that you don't see me value... you're saying that there should be no way to get more than the first batch of things linked to from a top level result? Like, first 5 conditions in my example, and there's no value in every getting more? </p>",
        "id": 153890857,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495508613
    },
    {
        "content": "<p>and reading this <a href=\"http://graphql.org/learn/pagination/\" target=\"_blank\" title=\"http://graphql.org/learn/pagination/\">http://graphql.org/learn/pagination/</a> tells me nothing because I don't know whether those fragments are schema, request, or response</p>",
        "id": 153890858,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495508633
    },
    {
        "content": "<p>define 'top level result'</p>",
        "id": 153890859,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495508652
    },
    {
        "content": "<p>Looking at the example at the bottom of that page: the left hand side is a query, and the right hand side is a response.</p>",
        "id": 153890860,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495508685
    },
    {
        "content": "<p>When I said \"top level\" just now, I'm referring to the query that finds patients and then for each patient finds conditions. \"top level\" meant the patients.</p>",
        "id": 153890862,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495508729
    },
    {
        "content": "<p>ok. so I'm sceptical of the value in setting up paging for the conditions - it's work for both client and server. And those lists are inherently both shorter and more bounded than the general search. </p>",
        "id": 153890863,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495508805
    },
    {
        "content": "<p>but now I understand the link a little better... I really don't like their terms at all (connection, edge)... and I don't begin to understand how they intend the cursor to work</p>",
        "id": 153890864,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495509507
    },
    {
        "content": "<p>one option - more work for the server, but that's our usual choice - is to allow either. So </p>\n<div class=\"codehilite\"><pre><span></span>Condition(_reference : parameter, ... search parameters) {\n}\n</pre></div>",
        "id": 153890866,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495511262
    },
    {
        "content": "<p>or </p>\n<div class=\"codehilite\"><pre><span></span>ConditionConnection(_reference : parameter, ... search parameters, iteration parameters) {\n  link {type, ref}\n  totalCount offset pageSize\n  node {\n    ... fields....\n  }\n}\n</pre></div>",
        "id": 153890867,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495511316
    },
    {
        "content": "<p>but there'd have to be a rule that if you wanted to pursue the references on the nested queries, you'd have to iterate them directly, not in a nested fasion</p>",
        "id": 153890868,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495511410
    },
    {
        "content": "<p>I still have real problems with this though. In my server, I actually have to remember each result set specifically, so that you can iterate it with confidence. I'm going to be doing a lot of this for nothing...</p>",
        "id": 153890869,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495511462
    },
    {
        "content": "<p>I think all the paging stuff belongs inside the <code>Reference</code> data type</p>\n<div class=\"codehilite\"><pre><span></span># A reference from one resource to another\ntype Reference {\n  id: ID\n  extension: [Extension]\n  reference: String\n  _reference: Element\n  display: String\n  _display: Element\n  resources(filter: JSON, .. any other parameters): ResourceInterface\n}\n</pre></div>",
        "id": 153890924,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495532575
    },
    {
        "content": "<p>Then whenever a reference is called we use the <code>Reference</code> type, it should be limited to a resource specific reference field</p>",
        "id": 153890925,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495532658
    },
    {
        "content": "<p>Resource is 0..1 here, there's no paging to be done. It's only the reverse references that don't have a home that can be 0..*</p>",
        "id": 153890933,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495541522
    },
    {
        "content": "<p>ok, that is correct</p>",
        "id": 153890957,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495545809
    },
    {
        "content": "<blockquote>\n<p>there'd have to be a rule that if you wanted to pursue the references on the nested queries, you'd have to iterate them directly, not in a nested fasion</p>\n</blockquote>\n<p>I think spelling this out directly would be good. I'm not 100% sure I understand what you mean by \"iterate them directly\". (Of course, an alternative is to say: if you want to page over these, you just issue a new query for <code>Condition(patient: \"123\"){}</code>...)</p>",
        "id": 153890988,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495567571
    },
    {
        "content": "<p>In </p>\n<div class=\"codehilite\"><pre><span></span>ConditionConnection(_reference : parameter, ... search parameters, iteration parameters) {\n  link {type, ref}\n  totalCount offset pageSize\n</pre></div>\n\n\n<p>... what are the <code>link.ref</code> properties? Full URLs to a page of FHIR REST API search results? Or a token that can be inserted into a follow-up graphql query?</p>",
        "id": 153890989,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495567726
    },
    {
        "content": "<p>a token that can be used in a follow up query</p>",
        "id": 153890997,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495570271
    },
    {
        "content": "<p>ok so wrote up where I think we are here:</p>",
        "id": 153891000,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495572592
    },
    {
        "content": "<p><a href=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Searching_resources\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Searching_resources\">http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Searching_resources</a></p>",
        "id": 153891001,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495572593
    },
    {
        "content": "<p>I have not updated the reverse references section yet - I will when we have consensus about top level searching</p>",
        "id": 153891002,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495572616
    },
    {
        "content": "<p>This looks like a great approach for the top-level results.</p>",
        "id": 153891022,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1495574200
    },
    {
        "content": "<p>In the primitive type mapping, I think every type should be mapped to a scalar type in GraphQL, instead of</p>\n<blockquote>\n<p>String | everything else</p>\n</blockquote>",
        "id": 153891038,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495580421
    },
    {
        "content": "<p>if there is no corresponding one in the default scalar types in GraphQL, a custom scalar type should be declared and then it's the server issue to resolve it</p>",
        "id": 153891039,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495580496
    },
    {
        "content": "<p>Can we discuss the <code>generate schema</code> in the open questions section?</p>",
        "id": 153891040,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495580602
    },
    {
        "content": "<p>ok. updated the <a href=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Reverse_References\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Reverse_References\">http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Reverse_References</a> section now</p>",
        "id": 153891047,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495590269
    },
    {
        "content": "<p>why map to scalar instead of string?</p>",
        "id": 153891048,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495590306
    },
    {
        "content": "<p>as for generate schema - I intend to generate a full graphQL schema for the entire specification, as an examplar for people to copy from / or use as a template for generating their own responses from their server. I think that would be a useful thing. And now that we've agreed on all the queries - well, I <em>think we have</em> ;-) - it's about time to generate the schema. If that all makes sense</p>",
        "id": 153891049,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495590410
    },
    {
        "content": "<p>For, example GraphQL doesn't have a Date type we can easily create a Date scalar type, why use a string for that?<br>\nWe can also create a positiveInteger type to validate that a value is a positive integer. Or why did FHIR declare those primitive type at the first place?</p>",
        "id": 153891059,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495607912
    },
    {
        "content": "<p>How are we going handle extensions in graphql? </p>",
        "id": 153891060,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1495608191
    },
    {
        "content": "<p>just like any other content. there's no need to do anything special</p>",
        "id": 153891061,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495608208
    },
    {
        "content": "<p>with regard to positiveInteger etc - we expect FHIR processors to natively know what those things are. That seems a wrong assumption to make in graphQL - and the key question has to be, what are these things in json, right</p>",
        "id": 153891062,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495608252
    },
    {
        "content": "<p>I mean, if i have Patient with dozen of extensions and i want to get only <code>race</code> extension (specifying only what i need in graphql paradigm)?<br>\n<code>{extension( race filter) { ..........}</code>?</p>",
        "id": 153891064,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1495608514
    },
    {
        "content": "<p>{ extension( url : \"..\") { valueCode }  }</p>",
        "id": 153891065,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495608541
    },
    {
        "content": "<p>If i need couple of extensions - graphql aliasing?</p>",
        "id": 153891066,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1495608596
    },
    {
        "content": "<p>yes</p>",
        "id": 153891067,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495608617
    },
    {
        "content": "<p>scalar types in GraphQL also have their corresponding resolvers in the server too</p>",
        "id": 153891068,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495608766
    },
    {
        "content": "<blockquote>\n<p>the key question has to be, what are these things in json</p>\n</blockquote>\n<p>For example date time is of type Date in JSON but that doesn't exist in GraphQL</p>",
        "id": 153891069,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495608844
    },
    {
        "content": "<p>So, For now all the discussion has been around querying a list of patients, but there have to be a query that returns a single patient too</p>",
        "id": 153891071,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495613071
    },
    {
        "content": "<p>Taking my schema here : <a href=\"https://github.com/shalkam/gql-fhir/blob/master/src/data/schema.graphql\" target=\"_blank\" title=\"https://github.com/shalkam/gql-fhir/blob/master/src/data/schema.graphql\">https://github.com/shalkam/gql-fhir/blob/master/src/data/schema.graphql</a> as a guide<br>\nSo, if the root query type looks like this :</p>\n<div class=\"codehilite\"><pre><span></span>type Query {\n  Patient: PatientQuery\n}\ntype PatientQuery {\n  find(any filter goes here): [Patient]\n  findOne(id: ID!, ... plus any other filter ...): Patient\n}\n</pre></div>\n\n\n<p>So, we have <code>find</code> type that returns a list of patients and <code>findOne</code> that returns only one patient</p>",
        "id": 153891073,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495613422
    },
    {
        "content": "<p>Same goes for mutations</p>\n<div class=\"codehilite\"><pre><span></span>type Mutation {\n  Patient: PatientMutation\n}\ntype PatientMutation {\n  remove(_id: ID!): Patient\n  upsert(data: PatientInput!): Patient\n}\n</pre></div>\n\n\n<p>then a mutation will look like this:</p>\n<div class=\"codehilite\"><pre><span></span>mutation upsertPatient($data: PatientInput!)  {\n  patient { upsert(data: $data) { ...patient fields goes here... } }\n}\n</pre></div>\n\n\n<p>and a query </p>\n<div class=\"codehilite\"><pre><span></span> query find($filter: JSON){\n  patient { find(filter: $filter) { ...patient fields goes here... } }\n}\n</pre></div>",
        "id": 153891078,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495614362
    },
    {
        "content": "<p>I think we should all agree how we should name the different crud operations and arguments used for them inside the GraphQL schema</p>",
        "id": 153891080,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495614455
    },
    {
        "content": "<p>scalar types - chatting to graphQL guys - there's no solution for this. If the schema uses scalar types, then everyone in the picture just has to 'know' the scalar types magically</p>",
        "id": 153891204,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495656468
    },
    {
        "content": "<p>i mean, custom scalar types...</p>",
        "id": 153891205,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495656494
    },
    {
        "content": "<p>What about the reference here : <a href=\"http://hl7.org/fhir/datatypes.html\" target=\"_blank\" title=\"http://hl7.org/fhir/datatypes.html\">http://hl7.org/fhir/datatypes.html</a> it states what is needed for each primitive type this can be a reference</p>",
        "id": 153891212,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1495658331
    },
    {
        "content": "<p>well, indeed, that's the reference. </p>",
        "id": 153891242,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495665723
    },
    {
        "content": "<p>just not computable. </p>",
        "id": 153891243,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495665729
    },
    {
        "content": "<p>but that's a graphQL issue</p>",
        "id": 153891244,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495665739
    },
    {
        "content": "<p>ok, updated <a href=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Searching_resources\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Searching_resources\">http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Searching_resources</a></p>",
        "id": 153891334,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495765754
    },
    {
        "content": "<p>before we talk about mutations, can we talk about directives? </p>",
        "id": 153891335,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495765767
    },
    {
        "content": "<p>GraphQL says that you should support directives - \"GraphQL implementations should provide the @skip and @include directives.\"</p>",
        "id": 153891336,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495765943
    },
    {
        "content": "<p>we could say, 'yeah, but no', or we could say 'SHALL provide'. Or we could remain silent. Any opinions? And should we define any other directives? (I haven't seen any need)</p>",
        "id": 153891337,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495765990
    },
    {
        "content": "<p>updated <a href=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Searching_resources\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Searching_resources\">http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Searching_resources</a> again after actually implementing it </p>",
        "id": 153891414,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495834656
    },
    {
        "content": "<p>and added actual working links for examples</p>",
        "id": 153891416,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1495840264
    },
    {
        "content": "<p>ok, schema - I added to the build to generate scheme files. So far, I've only done the static schema. see<br>\n<a href=\"http://build.fhir.org/types.graphql\" target=\"_blank\" title=\"http://build.fhir.org/types.graphql\">http://build.fhir.org/types.graphql</a><br>\n<a href=\"http://build.fhir.org/patient.graphql\" target=\"_blank\" title=\"http://build.fhir.org/patient.graphql\">http://build.fhir.org/patient.graphql</a></p>\n<p>or <a href=\"http://build.fhir.org/[resource].graphql\" target=\"_blank\" title=\"http://build.fhir.org/[resource].graphql\">http://build.fhir.org/[resource].graphql</a> where resource name is all lowercase</p>",
        "id": 153891449,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496006086
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> and <span class=\"user-mention\" data-user-id=\"193512\">@Mostafa Sholkamy</span> please check the schema </p>",
        "id": 153891450,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496006127
    },
    {
        "content": "<p>I think this example <a href=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Additional_Selectors\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Additional_Selectors\">here</a>.....</p>\n<div class=\"codehilite\"><pre><span></span>     http://test.fhir.org/r3/Observation/example/$graphql?query={id,subject{reference,resource{...on%20Patient{birthDate}...on%20Practioner{practitionerRole{speciality}}}}code{coding{system,code}}}\n</pre></div>\n\n\n<p>should be this...</p>\n<div class=\"codehilite\"><pre><span></span>    http://test.fhir.org/r3/Observation/example/$graphql?query={id,subject{reference,resource{...on%20Patient{birthDate}}}code{coding{system,code}}}\n</pre></div>\n\n\n<p>(remove the practitiionerRole reference)</p>",
        "id": 153891455,
        "sender_full_name": "Eric Haas",
        "timestamp": 1496019297
    },
    {
        "content": "<p>The result is the same </p>",
        "id": 153891456,
        "sender_full_name": "Eric Haas",
        "timestamp": 1496019325
    },
    {
        "content": "<p>well, it's not wrong - it's just that the example doesn't use that type. <br>\nActually, the type is not legal, so I just updated to something that is</p>",
        "id": 153891457,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496020635
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> how come properties have <code>phrases_like_this</code> instead of <code>phrasesLikeThis</code>? </p>",
        "id": 153891541,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496089352
    },
    {
        "content": "<p>Oh, I see -- just for search parameters.</p>",
        "id": 153891543,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496089389
    },
    {
        "content": "<p>You're using the FHIR standard names with <code>_</code> --&gt; <code>-</code> to make them valid.</p>",
        "id": 153891544,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496089403
    },
    {
        "content": "<p>y. servers have to reverse the conversion</p>",
        "id": 153891545,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496089418
    },
    {
        "content": "<p>This schema proposes  two very similar ways to search patients, one returning <code>[Patient]</code> and the other returning <code>[PatientEdge]</code>.  It might be better just to do searches that include the count/score/pagination details (like FHIR's REST search does today).</p>",
        "id": 153891546,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496089645
    },
    {
        "content": "<p>What's the use case for having the other one, too?</p>",
        "id": 153891547,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496089655
    },
    {
        "content": "<p>Also, in any case, we should be sure to preserve search parameters that come from Resource (<code>_id</code>, <code>_lastUpdated</code>, etc)</p>",
        "id": 153891548,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496089759
    },
    {
        "content": "<p>I think it's more relevant in reverse reference searches. There's 3 differences:<br>\n- the returned graph is simpler <br>\n- in particular, the returned graph doesn't need to be considered with logic asking 'is there more pages to get'<br>\n- servers can fulfill the simpler search with much less resources, because they do not need to remember state about the searches</p>",
        "id": 153891549,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496089819
    },
    {
        "content": "<p>_id is irrelevant. I'll update the generator to handle the others</p>",
        "id": 153891550,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496089843
    },
    {
        "content": "<p><code>_id</code> is relevant because it lets you get a list of named patients without having to alias each, and it's just a nice analogy to our existing search behavior.</p>",
        "id": 153891551,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496089876
    },
    {
        "content": "<p>not following that</p>",
        "id": 153891552,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496089902
    },
    {
        "content": "<p>I want to get <code>PatientList(\"_id\": \"1, 2, 3\")</code></p>",
        "id": 153891553,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496089921
    },
    {
        "content": "<p>That way search parameters would work in a consistent fashion between our REST API and the grpahql API.</p>",
        "id": 153891554,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496089962
    },
    {
        "content": "<p>For the reverse search, even if a server doesn't want to implement support for pagination etc -- it's still important to communicate \"this is not a complete list\", which the Connection structure could/should let us say.</p>",
        "id": 153891555,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496089969
    },
    {
        "content": "<p>I think you mean PatientList(id: [1, 2,3]) but ok. </p>",
        "id": 153891556,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090001
    },
    {
        "content": "<p><code>[1,2,3]</code> isn't a valid string</p>",
        "id": 153891557,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090018
    },
    {
        "content": "<p>\"1, 2, 3\" is not a valid id</p>",
        "id": 153891558,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090049
    },
    {
        "content": "<p>No, but that's how <code>_id</code> and other search parms work in FHIR's REST API: they define a comma-separated list as a string.</p>",
        "id": 153891559,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090073
    },
    {
        "content": "<p>question is whether the composite syntax should apply or not. </p>",
        "id": 153891560,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090075
    },
    {
        "content": "<p>I mean, being able to say \"or\" somehow is helpful. Do we have a better way?</p>",
        "id": 153891561,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090102
    },
    {
        "content": "<p>If there is, I'd be happy to use that instead; I'm just missing it right now.</p>",
        "id": 153891562,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090122
    },
    {
        "content": "<p>yes we do. _filter. For syntactical reasons, most of the interesting FHIR search techniques are not possible in GraphQL, and I don't think we should bend over backwards to make them so - we should say, use _filter</p>",
        "id": 153891563,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090165
    },
    {
        "content": "<p>We could define params like <code>whatever</code> + <code>_in</code> for each search param, to provide an array form, like <code>_id_in: [\"1\",\"2\",\"3\"]</code></p>",
        "id": 153891564,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090187
    },
    {
        "content": "<p>The filter language is a bit obscure; it's a lot of baggage just to say \"or\".</p>",
        "id": 153891565,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090220
    },
    {
        "content": "<p>it's exactly the language used by other restful specifications, and it's not obscure to say _id eq 1 or Id eq 2</p>",
        "id": 153891566,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090300
    },
    {
        "content": "<p>the two letter ops are obscure to me.</p>",
        "id": 153891567,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090330
    },
    {
        "content": "<p>I haven't ever used another REST API with FHIR's filter syntax.</p>",
        "id": 153891568,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090339
    },
    {
        "content": "<p>pffft. </p>",
        "id": 153891569,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090343
    },
    {
        "content": "<p>But I understand the idea came from elsewhere (which is good).</p>",
        "id": 153891570,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090358
    },
    {
        "content": "<p>Anyway, overall I think this schema approach looks really nice. I'd try very hard to condense the <code>PatientListType</code> and <code>PatientConnectionType</code>.</p>",
        "id": 153891571,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090375
    },
    {
        "content": "<p>given that we have arrays in graphql, it's much cleaner to avoid the syntactical issues with ',' and escapes bu saying to use json arrays and escaping instead</p>",
        "id": 153891572,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090408
    },
    {
        "content": "<p>how you going to condense them? Force everyone to use the heavier weight Connection approach every time?</p>",
        "id": 153891573,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090435
    },
    {
        "content": "<p>Any time you do a query that returns a list, you need to know if you're getting a complete result or just the the \"first n matches\", right?</p>",
        "id": 153891574,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090501
    },
    {
        "content": "<p>I can't really think of a use case like \"just give me some of a patient's allergies, dealer's choice\"...</p>",
        "id": 153891575,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090521
    },
    {
        "content": "<p>if you say \"list\" you get everything or an error - that's what the wiki page says. </p>",
        "id": 153891576,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090534
    },
    {
        "content": "<p>I thought you reviewed all that and said you liked it...</p>",
        "id": 153891577,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090546
    },
    {
        "content": "<p>I think I didn't understand this implication.</p>",
        "id": 153891578,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090555
    },
    {
        "content": "<p>But that certainly helps!</p>",
        "id": 153891579,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090580
    },
    {
        "content": "<p>Have we addressed sort order?</p>",
        "id": 153891580,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090610
    },
    {
        "content": "<p>(for lists or connections?)</p>",
        "id": 153891581,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090620
    },
    {
        "content": "<p>works like the search for both</p>",
        "id": 153891582,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090627
    },
    {
        "content": "<p>Like, there are <code>_sort</code> params?</p>",
        "id": 153891583,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090639
    },
    {
        "content": "<p>I didn't generate that though did I?</p>",
        "id": 153891584,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090648
    },
    {
        "content": "<p>This isn't reflected in the Patient schema, no</p>",
        "id": 153891585,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090652
    },
    {
        "content": "<p>Or, not yet ;-)</p>",
        "id": 153891586,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090657
    },
    {
        "content": "<p>That'll work fine though.</p>",
        "id": 153891587,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090663
    },
    {
        "content": "<p>I'll generate the inherited search parameters and the sort parameters</p>",
        "id": 153891588,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090704
    },
    {
        "content": "<p>Super. graphql for FHIR will be massively convenient for a lot of folks, if it sees widespread support.</p>",
        "id": 153891589,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090724
    },
    {
        "content": "<p>(And I think it's still probably possible to do a reasonable job of implementing the graphql API on top of the REST API, as a proxy in from of servers that don't support it; I should review what it'll take to get there based on the current definitions.)</p>",
        "id": 153891590,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1496090785
    },
    {
        "content": "<p>I effectively did that in my server. The only alteration I made to my base server was to create a direct path for the *List search, that doesn't do paging/caching. That was for efficiency, not for functionality. (plus found and fixed some bugs on the way)</p>",
        "id": 153891591,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496090915
    },
    {
        "content": "<p>ah.. .and you need to know, in the proxy, how paging works on the server. To the client, it's opaque, but to correctly transfer between syntaxes, you need to know how to take the URL apart and reconstruct it </p>",
        "id": 153891593,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496091446
    },
    {
        "content": "<p>ok updated the generated graphQL according to our discussion</p>",
        "id": 153891608,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496113587
    },
    {
        "content": "<p>so. finally, time to talk about mutation. my preferred approach would be that you could update a resource directly, but: </p>",
        "id": 153891618,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496126837
    },
    {
        "content": "<p>but nothing. I read something wrong. So create/update/delete. </p>",
        "id": 153891619,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496127375
    },
    {
        "content": "<p>but so many questions - are a set of mutations a batch? a transaction? How can you create a set of related resources? </p>",
        "id": 153891623,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496127851
    },
    {
        "content": "<p>duh. no multiple mutations</p>",
        "id": 153891626,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496128799
    },
    {
        "content": "<p>I've been reading the graphQL spec about mutations, and am unclear on error handling. Here's questions I put on the graphQL chat:</p>",
        "id": 153891627,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496130626
    },
    {
        "content": "<ul>\n<li>if execution fails, should a server return 200 OK with { \"error\" : [\"...\"] }? or should it have a different response code?</li>\n<li>This forces a client have to handle HTTP errors (before you get to the graphQL processor), and also check for 200 OK + errors - why is that useful?</li>\n<li>under what conditions would your response include both data and errors, and what should a client do with that?</li>\n<li>the documentation helpfully says \"If no data is returned, according to the GraphQL spec, the \"data\" field should only be included if the error occurred during execution\" - I've read that several times, and I don't know what it means, either returning data if there is no data returned, or what the definition of 'during execution' is</li>\n</ul>",
        "id": 153891628,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496130637
    },
    {
        "content": "<p>I just upgraded my server to fix a mistake in every response.</p>",
        "id": 153891632,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496135841
    },
    {
        "content": "<p>and after dsicussion on the graphQL, chat, I've added a new section to the graphQL page:</p>",
        "id": 153891677,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496170833
    },
    {
        "content": "<p><a href=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Conformance\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Conformance\">http://wiki.hl7.org/index.php?title=FHIR_and_GraphQL#Conformance</a></p>",
        "id": 153891679,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496170842
    },
    {
        "content": "<p>I think it's time to move the wiki page to the spec itself. <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> <span class=\"user-mention\" data-user-id=\"193512\">@Mostafa Sholkamy</span> - do you agree? And is there enough interest for a connectathon stream? (Josh, I presume you see a cds-hooks interest here....)</p>",
        "id": 153891831,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496263038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I do not see in wiki how to query specific extension?</p>",
        "id": 153891950,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1496331749
    },
    {
        "content": "<p>added an example</p>",
        "id": 153891975,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496350413
    },
    {
        "content": "<p>Github are getting in on the act: <a href=\"https://githubengineering.com/the-github-graphql-api/\" target=\"_blank\" title=\"https://githubengineering.com/the-github-graphql-api/\">https://githubengineering.com/the-github-graphql-api/</a></p>",
        "id": 153893962,
        "sender_full_name": "David Hay",
        "timestamp": 1497501739
    },
    {
        "content": "<p>thx. </p>",
        "id": 153893963,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497502231
    },
    {
        "content": "<p>should we have a Connectathon stream on graphQL? </p>",
        "id": 153893964,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497502240
    },
    {
        "content": "<p>+1 on stream and can one do a LastN like search with it?  It was not clear to me whether this was possible?</p>",
        "id": 153894011,
        "sender_full_name": "Eric Haas",
        "timestamp": 1497541657
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-email=\"eric@montagesystems.com.au\" data-user-id=\"487\">@Eric Browne</span>  h</p>",
        "id": 153894072,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497563325
    },
    {
        "content": "<p>oops</p>",
        "id": 153894073,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497563336
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> yes - you can. Just add a _graphql parameter to the operation when you invoke it, and the graphql runs on the output. I've added an example to the wiki page, and my server will start supporting it next time I upgrade it </p>",
        "id": 153894074,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497563390
    },
    {
        "content": "<p>I think it's time to move the graphQL stuff into the specification itself</p>",
        "id": 153894076,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497563501
    },
    {
        "content": "<p>I agree.  Is there a GForge</p>",
        "id": 153894079,
        "sender_full_name": "Eric Haas",
        "timestamp": 1497564117
    },
    {
        "content": "<p>probably not</p>",
        "id": 153894080,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497564136
    },
    {
        "content": "<p><a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=13532\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=13532\">GF#13532</a></p>",
        "id": 153894083,
        "sender_full_name": "Eric Haas",
        "timestamp": 1497564308
    },
    {
        "content": "<p>is now. <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=13531\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=13531\">GF#13531</a></p>",
        "id": 153894084,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497564309
    },
    {
        "content": "<p>lol</p>",
        "id": 153894085,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497564318
    },
    {
        "content": "<p>NM withdrew mine</p>",
        "id": 153894086,
        "sender_full_name": "Eric Haas",
        "timestamp": 1497564346
    },
    {
        "content": "<p><a href=\"http://wiki.hl7.org/index.php?title=201709_GraphQL\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=201709_GraphQL\">http://wiki.hl7.org/index.php?title=201709_GraphQL</a></p>",
        "id": 153894499,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497938674
    },
    {
        "content": "<p>if you're interested in participating, please register your interest directly on the wiki, or mention it here. </p>",
        "id": 153894500,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497938701
    },
    {
        "content": "<p>I'm the track lead at the moment, but I'm looking for a volunteer to take this one on</p>",
        "id": 153894502,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497938717
    },
    {
        "content": "<p>I have migrated the GraphQL documentation to here: <a href=\"http://build.fhir.org/graphql.html\" target=\"_blank\" title=\"http://build.fhir.org/graphql.html\">http://build.fhir.org/graphql.html</a></p>",
        "id": 153894503,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1497938894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  Does <a href=\"http://build.fhir.org/types.graphql\" target=\"_blank\" title=\"http://build.fhir.org/types.graphql\">http://build.fhir.org/types.graphql</a> includes all datatypes in FHIR?<br>\nand each resource like the patient's file <a href=\"http://build.fhir.org/patient.graphql\" target=\"_blank\" title=\"http://build.fhir.org/patient.graphql\">http://build.fhir.org/patient.graphql</a> only includes types for backbone elements?</p>",
        "id": 153896578,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1499775392
    },
    {
        "content": "<p>yes that's right</p>",
        "id": 153896579,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1499776301
    },
    {
        "content": "<p>I've cleaned up those graphql files  <code>types.graphql</code> and <code>patient.graphql</code> they had some errors and changed some stuff too like the adding <code>PatientMutation</code> and <code>PatientQuery</code> types</p>",
        "id": 153896619,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1499800536
    },
    {
        "content": "<p>you can check it here <a href=\"https://gist.github.com/shalkam/5e68771783b941cc601d2a468589517e\" target=\"_blank\" title=\"https://gist.github.com/shalkam/5e68771783b941cc601d2a468589517e\">https://gist.github.com/shalkam/5e68771783b941cc601d2a468589517e</a></p>",
        "id": 153896620,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1499800548
    },
    {
        "content": "<p>I've set up a full stack example for a patient resource in node.js using graphql, mongoose and  express<br>\nFeel free to check it out <a href=\"https://github.com/shalkam/gql-fhir-patient-example\" target=\"_blank\" title=\"https://github.com/shalkam/gql-fhir-patient-example\">https://github.com/shalkam/gql-fhir-patient-example</a></p>",
        "id": 153898927,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1501205903
    },
    {
        "content": "<p>Hi, releasing a proposal for an Apollo on FHIR architecture.  Integrated database proxy with Meteor on FHIR backend that serves up GraphQL queries.  </p>\n<p><a href=\"https://medium.com/@awatson1978/apollo-on-fhir-architecture-3d5bf4d0fc97\" target=\"_blank\" title=\"https://medium.com/@awatson1978/apollo-on-fhir-architecture-3d5bf4d0fc97\">https://medium.com/@awatson1978/apollo-on-fhir-architecture-3d5bf4d0fc97</a></p>\n<p><a href=\"/user_uploads/10155/RzwM95w4zsPeebHi4ZBdlLeK/Apollo-on-FHIR-Architecture.png\" target=\"_blank\" title=\"Apollo-on-FHIR-Architecture.png\">Apollo-on-FHIR-Architecture.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/RzwM95w4zsPeebHi4ZBdlLeK/Apollo-on-FHIR-Architecture.png\" target=\"_blank\" title=\"Apollo-on-FHIR-Architecture.png\"><img src=\"/user_uploads/10155/RzwM95w4zsPeebHi4ZBdlLeK/Apollo-on-FHIR-Architecture.png\"></a></div>",
        "id": 153903989,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1504047154
    },
    {
        "content": "<p><a href=\"https://github.com/facebook/graphql/issues/351\" target=\"_blank\" title=\"https://github.com/facebook/graphql/issues/351\">https://github.com/facebook/graphql/issues/351</a> [GraphQL Patent Infringement Issues] just a heads up</p>",
        "id": 153910031,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1506147703
    },
    {
        "content": "<p>Follow up: <a href=\"http://www.healthintersections.com.au/?p=2740\" target=\"_blank\" title=\"http://www.healthintersections.com.au/?p=2740\">http://www.healthintersections.com.au/?p=2740</a></p>",
        "id": 153916382,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1509093374
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191678\">@Abigail Watson</span> I read the article you wrote and  found it helpful for my current project. What I found most interesting where the graphics. I wonder, what tool where used to create them?</p>",
        "id": 153929619,
        "sender_full_name": "Karlo Martinez",
        "timestamp": 1516374130
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193512\">@Mostafa Sholkamy</span> </p>\n<blockquote>\n<p>I've set up a full stack example for a patient resource in node.js using graphql, mongoose and  express<br>\nFeel free to check it out <a href=\"https://github.com/shalkam/gql-fhir-patient-example\" target=\"_blank\" title=\"https://github.com/shalkam/gql-fhir-patient-example\">https://github.com/shalkam/gql-fhir-patient-example</a></p>\n</blockquote>\n<p>Would it be possible that you forgot to push your commits to Github? I found the repository to be empty upon entering.</p>",
        "id": 153929620,
        "sender_full_name": "Karlo Martinez",
        "timestamp": 1516374438
    },
    {
        "content": "<p>Hi there, I am Karlo Martnez from Puerto Rico. I am looking to use FHIR in a GraphQL server implementation and am having trouble figuring out the spec and found, through reading the topic thread that there might already exists resources to make it happen. I have a couple of questions that will help me start in the right direction.</p>\n<p>Where can I find the GraphQL Type and Schema definitions for the resources?<br>\nis there a particular reason why the wiki describes the usage in a REST-like manner? Meaning that there are multiple endpoints each for the different resources.</p>",
        "id": 153929622,
        "sender_full_name": "Karlo Martinez",
        "timestamp": 1516375039
    },
    {
        "content": "<p>have you read <a href=\"http://build.fhir.org/graphql.html\" target=\"_blank\" title=\"http://build.fhir.org/graphql.html\">this</a></p>",
        "id": 153929754,
        "sender_full_name": "Eric Haas",
        "timestamp": 1516408234
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> . Yes, I have for the most part. I am familiar with GraphQL, contrary to FHIR which I just recently got involved due to my employment. I have read through the thread and found some answers. I have never seen a GraphQL API that has multiple endpoints such as it's described. And would have also expected to find url's to the schemas in the documentation from previous works.</p>",
        "id": 153929917,
        "sender_full_name": "Karlo Martinez",
        "timestamp": 1516620035
    },
    {
        "content": "<p>you don't need to make use of the multiple end-points - you can only use the base on if you want</p>",
        "id": 153929918,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1516625159
    },
    {
        "content": "<p>for the schema: <a href=\"http://build.fhir.org/patient.graphql\" target=\"_blank\" title=\"http://build.fhir.org/patient.graphql\">http://build.fhir.org/patient.graphql</a> , etc. I haven't got around to integrating all the schemas yet</p>",
        "id": 153929919,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1516625237
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> </p>\n<blockquote>\n<p>for the schema: <a href=\"http://build.fhir.org/patient.graphql\" target=\"_blank\" title=\"http://build.fhir.org/patient.graphql\">http://build.fhir.org/patient.graphql</a> , etc. I haven't got around to integrating all the schemas yet</p>\n</blockquote>\n<p>Thanks, I went and downloaded each one. Kind of troublesome to do by hand. Also rearranged them to be sorted by category, I'd be happy to share a zip file with all the schema's for convenience.</p>",
        "id": 153929930,
        "sender_full_name": "Karlo Martinez",
        "timestamp": 1516628863
    },
    {
        "content": "<blockquote>\n<p>you don't need to make use of the multiple end-points - you can only use the base on if you want</p>\n</blockquote>\n<p>Would this affect our chances of getting the FHIR public API to be HL7 certified, if there is such a thing?</p>",
        "id": 153929931,
        "sender_full_name": "Karlo Martinez",
        "timestamp": 1516628946
    },
    {
        "content": "<p>there is no such thing. but no, you choose what you want to implement - for now. We don't generally make rules like that - it's left to the implementation guides, and we haven't exploded implementation guides constraining graphql usage yet</p>",
        "id": 153930082,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1516647066
    },
    {
        "content": "<p>GraphQL now is foundation - <a href=\"https://medium.com/@leeb/introducing-the-graphql-foundation-3235d8186d6d\" target=\"_blank\" title=\"https://medium.com/@leeb/introducing-the-graphql-foundation-3235d8186d6d\">https://medium.com/@leeb/introducing-the-graphql-foundation-3235d8186d6d</a></p>",
        "id": 154016577,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1541657301
    },
    {
        "content": "<p>Hello, when we started our development on FHIR GraphQL, we found on github an interesting project from Asymmetrik. Their implementation give a complete GraphQL definition of FHIR resources.: <a href=\"https://github.com/Asymmetrik/graphql-fhir\" target=\"_blank\" title=\"https://github.com/Asymmetrik/graphql-fhir\">https://github.com/Asymmetrik/graphql-fhir</a>.</p>",
        "id": 154642977,
        "sender_full_name": "Michele Korell",
        "timestamp": 1546952940
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"198505\">@Michele Korell</span>, thanks for checking us out. Just wanted to let everyone know that we are planning on open sourcing GraphQL definitions for all of R4 very soon, and a re-release of 3.0.1 and 1.0.2 with some fixes involving union types (End of the week or early next week). Hope you all find these useful and if you have any feedback, please feel free to reach out to me or <span class=\"user-mention\" data-user-id=\"195693\">@Jon Lee</span> either here or via an issue on Github.</p>",
        "id": 154644362,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1546954228
    },
    {
        "content": "<p>Would this be something that would make sense to generate as a reference implementation alongside the Java, C#, Javascript and other reference implementations?</p>",
        "id": 154656278,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1546964948
    },
    {
        "content": "<p>Yea absolutely</p>",
        "id": 154663517,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1546970625
    },
    {
        "content": "<p>Anything we can do to help get that started?</p>",
        "id": 154664193,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1546971217
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, what would we need to be done (beyond an open license)?</p>",
        "id": 154665121,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1546971995
    },
    {
        "content": "<p>I'm not sure what this is. We already publish graphQL definitions of the resources.</p>",
        "id": 154671397,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1546976947
    },
    {
        "content": "<p>Please can you provide a link where definitions were published ?  I means *.graphql files.</p>",
        "id": 154730505,
        "sender_full_name": "Geoffrey BAUDIN",
        "timestamp": 1547046628
    },
    {
        "content": "<p>I found some definitions of FHIR resource as graphql file (Example: <a href=\"http://build.fhir.org/observation.graphql\" target=\"_blank\" title=\"http://build.fhir.org/observation.graphql\">http://build.fhir.org/observation.graphql</a>) but it is available an endpoint that expose the whole schema? To allow a server work with remote schema definition, like is explained on Apollo GraphQL tools (<a href=\"https://www.apollographql.com/docs/graphql-tools/schema-stitching.html#remote-schemas\" target=\"_blank\" title=\"https://www.apollographql.com/docs/graphql-tools/schema-stitching.html#remote-schemas\">https://www.apollographql.com/docs/graphql-tools/schema-stitching.html#remote-schemas</a>).</p>",
        "id": 154781606,
        "sender_full_name": "Michele Korell",
        "timestamp": 1547082143
    },
    {
        "content": "<p>I don't think I gathered them into a whole schema. What is required in it?</p>",
        "id": 154828869,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1547115267
    },
    {
        "content": "<p>Actually I'm looking for GraphQL endpoint (like the example [base]/$graphql defined at <a href=\"http://build.fhir.org/graphql.html#invoking\" target=\"_blank\" title=\"http://build.fhir.org/graphql.html#invoking\">http://build.fhir.org/graphql.html#invoking</a>) to execute an IntrospectionQuery and let me get the whole GraphQL schema. I try with <a href=\"http://test.fhir.org/r4/$graphql\" target=\"_blank\" title=\"http://test.fhir.org/r4/$graphql\">http://test.fhir.org/r4/$graphql</a> but i cannot execute any query. Only queries on selected resource are working, for example:  <a href=\"http://test.fhir.org/r4/Patient/8/$graphql?query={id%20name{text,given,family}}\" target=\"_blank\" title=\"http://test.fhir.org/r4/Patient/8/$graphql?query={id%20name{text,given,family}}\">http://test.fhir.org/r4/Patient/8/$graphql?query={id%20name{text,given,family}}</a></p>\n<p>The following http query doesn't work:<br>\nPOST /r4/$graphql HTTP/1.1<br>\nHost: <a href=\"http://test.fhir.org\" target=\"_blank\" title=\"http://test.fhir.org\">test.fhir.org</a><br>\nContent-Type: application/json<br>\n{\"query\":\"Patient(id:\\\"8\\\"){id name { text given family}}\"}</p>",
        "id": 154829389,
        "sender_full_name": "Michele Korell",
        "timestamp": 1547115873
    },
    {
        "content": "<p>If there is anything we can do to help with this, we would love to contribute where appropriate. Unfortunately (or fortunately if your a javascript developer), all of our schemas are written as JS files, not .graphql files so the files themselves are specific to the node.js ecosystem. You could start the server and  run an introspectionQuery against it to get the full schema in .graphql syntax though.  We could do this and include those GraphQL files on Github but they are pretty large for a full server.</p>\n<p>I did notice something in the observation.graphql and bundle.graphql files that <em>may</em> cause issues when used in GraphQL. The BundleEntry contains a resource property of type Resource. While this is what is defined in the spec, in GraphQL, this means you can only include the exact resource object, so you would not be able to return Patient and Observation or any other, just what is defined here, <a href=\"http://build.fhir.org/resource.html\" target=\"_blank\" title=\"http://build.fhir.org/resource.html\">http://build.fhir.org/resource.html</a>.</p>\n<p>Same thing with an Observation and any property of type Reference. We had to define them as strings on inputs when performing mutations, but on outputs, a.k.a. schemas, we define them as unions. For example, an Observation.subject can return with a resource of type patient, group, device, or location. So we have an inline union that checks the resource type and returns one of those four types to take advantage of result coercion.</p>",
        "id": 155340449,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1547736605
    },
    {
        "content": "<blockquote>\n<p>POST /r4/$graphql HTTP/1.1<br>\nHost: <a href=\"http://test.fhir.org\" target=\"_blank\" title=\"http://test.fhir.org\">test.fhir.org</a><br>\nContent-Type: application/json<br>\n{\"query\":\"Patient(id:\\\"8\\\"){id name { text given family}}\"}</p>\n</blockquote>\n<p>That's supposed to work</p>",
        "id": 155341863,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1547737633
    },
    {
        "content": "<p>apparently I overlooked implementing that. I will work on it</p>",
        "id": 155343248,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1547738531
    },
    {
        "content": "<p>no, this is actually a formatting issue. I'm expecting, from the graphql spec, to get this:</p>",
        "id": 155356363,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1547749133
    },
    {
        "content": "<p><code>{\"query\":\"{ Patient(id:\\\"8\\\"){id name { text given family}} }\"}</code></p>",
        "id": 155356376,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1547749151
    },
    {
        "content": "<ul>\n<li>note wrapping {}. My parser is not knowing how to parse with out the {}</li>\n</ul>",
        "id": 155356401,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1547749181
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 155356496,
        "sender_full_name": "Rick Geimer",
        "timestamp": 1547749247
    },
    {
        "content": "<p>yes that bit</p>",
        "id": 155356520,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1547749274
    },
    {
        "content": "<p>Hello, I've executed some test with  <a href=\"http://test.fhir.org/r4/$graphql\" target=\"_blank\" title=\"http://test.fhir.org/r4/$graphql\">http://test.fhir.org/r4/$graphql</a> endpoint and it is working as described in a previus post. But I've tried to introspect GraphQL schema against the same endpoint but without success. Normally it is suppose to return graphql schema of available queries and mutations, but actually i get an empty json with { \"data\" : { } }. They are a particular reason that introspection is not supported? <br>\nBy the way  there  is a new interesting project that contains all classes definitions  in typescript of fhir resources (<a href=\"https://github.com/Ahryman40k/typescript-fhir-types\" target=\"_blank\" title=\"https://github.com/Ahryman40k/typescript-fhir-types\">https://github.com/Ahryman40k/typescript-fhir-types</a>). It is generated by using official fhir json definition (the one that can be download here: <a href=\"https://www.hl7.org/fhir/downloads.html\" target=\"_blank\" title=\"https://www.hl7.org/fhir/downloads.html\">https://www.hl7.org/fhir/downloads.html</a>) and we use it to wrap GraphQL fhir queries responses.</p>",
        "id": 159665666,
        "sender_full_name": "Michele Korell",
        "timestamp": 1551398991
    },
    {
        "content": "<p>it looks like I haven't got around to doing introspection. I'll investigate</p>",
        "id": 159680516,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1551418644
    },
    {
        "content": "<p>I think that GraphQL schema introspection permit to get the CapabilityStatement of the server, but directly with server's integrated graphql-tools. In this way we doesn't have to write some logic that can retrieve capabilities of following endpoints. Micro services can be connected between each others trough schema stitching and introspection allow delegation of some operations. For example in a system that manage procedure, but doesn't has locally informations about Patients, it can directly delegate the resolution to right endpoint (only if it provide GraphQL interface).<br>\nInteresting links (we implemented our system like hasura example): </p>\n<ul>\n<li><a href=\"https://blog.hasura.io/the-ultimate-guide-to-schema-stitching-in-graphql-f30178ac0072/#0e66\" target=\"_blank\" title=\"https://blog.hasura.io/the-ultimate-guide-to-schema-stitching-in-graphql-f30178ac0072/#0e66\">https://blog.hasura.io/the-ultimate-guide-to-schema-stitching-in-graphql-f30178ac0072/#0e66</a></li>\n<li><a href=\"https://graphql.org/learn/introspection/\" target=\"_blank\" title=\"https://graphql.org/learn/introspection/\">https://graphql.org/learn/introspection/</a></li>\n<li><a href=\"https://www.apollographql.com/docs/graphql-tools/schema-stitching.html#mergeSchemas\" target=\"_blank\" title=\"https://www.apollographql.com/docs/graphql-tools/schema-stitching.html#mergeSchemas\">https://www.apollographql.com/docs/graphql-tools/schema-stitching.html#mergeSchemas</a></li>\n</ul>",
        "id": 159721216,
        "sender_full_name": "Michele Korell",
        "timestamp": 1551452909
    },
    {
        "content": "<p>I understand why it would be useful</p>",
        "id": 159738543,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1551466167
    },
    {
        "content": "<p>Hi , I am just about on the journey of setting a  hasura - fhirbase server for proof of concept... I have an  questions on a similar topic in the fhirbase stream. The missing feature for doing it, is on hasura's backlog already. In the meantime I am looking for alternatives such us <a href=\"http://prisma.io\" target=\"_blank\" title=\"http://prisma.io\">prisma.io</a>. For that, I am trying to generate the graphql.types from json schemas... Btw is there already graphQL types officially released? I am also new to this domain so any advise or experience could be helpful. Thank you</p>",
        "id": 159746262,
        "sender_full_name": "Zoltan Simon",
        "timestamp": 1551472111
    },
    {
        "content": "<p>you can get grapql definitions for the json representation of the resources at <a href=\"http://build.fhir.org/observation.graphql\" target=\"_blank\" title=\"http://build.fhir.org/observation.graphql\">http://build.fhir.org/observation.graphql</a> (or similar pattern)</p>",
        "id": 159753534,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1551477941
    },
    {
        "content": "<p>We get the actual schema from build fhir server, for example you can get the procedure schema at  <a href=\"http://build.fhir.org/procedure.graphql\" target=\"_blank\" title=\"http://build.fhir.org/procedure.graphql\">http://build.fhir.org/procedure.graphql</a> endpoint.  Or you can donfload the Asymmetrik implementation from git (<a href=\"https://github.com/Asymmetrik/graphql-fhir\" target=\"_blank\" title=\"https://github.com/Asymmetrik/graphql-fhir\">https://github.com/Asymmetrik/graphql-fhir</a>),  run the server and use graphql/utilities and use printSchema ( <a href=\"https://graphql.org/graphql-js/utilities/#printschema\" target=\"_blank\" title=\"https://graphql.org/graphql-js/utilities/#printschema\">https://graphql.org/graphql-js/utilities/#printschema</a>) to generate  the whole schema in a single file. The only inconvenient is that the output file has 127'473 lines.</p>",
        "id": 159753542,
        "sender_full_name": "Michele Korell",
        "timestamp": 1551477951
    },
    {
        "content": "<p>Thx, You saved me a lot of time :) Let's see what will work (or not) on this \"zero effort\" server experiment.</p>",
        "id": 159753786,
        "sender_full_name": "Zoltan Simon",
        "timestamp": 1551478179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198505\">@Michele Korell</span>  - Thx, I found the Asymmetrik stack too. It looks like an \"interpretation / implementation done\". Using the #printschema tool would be a reverse engineering  or kind of. I would go for a solution where I can have a \"golden source\" schema that I can load on the server. This way I would get better  <em>compliance</em>.  An option would be just go with the Asymmetrik stack and follow their way instead of building one. <em>I am on the first phase, learning &amp; understanding fhir, trying to convert magic to knowledge.</em> I might end up on the stack anyway..</p>",
        "id": 159754654,
        "sender_full_name": "Zoltan Simon",
        "timestamp": 1551478903
    },
    {
        "content": "<p>We used asymmetrik implementation as mock server between front-end and back-end. We put json resources examples of our implementation guide at resource resolvers. The graphql server example is also cool because it implements the OAuth2 SMART strategy (<a href=\"https://github.com/Asymmetrik/graphql-fhir/blob/master/FAQ.md#authentication\" target=\"_blank\" title=\"https://github.com/Asymmetrik/graphql-fhir/blob/master/FAQ.md#authentication\">https://github.com/Asymmetrik/graphql-fhir/blob/master/FAQ.md#authentication</a>).</p>",
        "id": 159755172,
        "sender_full_name": "Michele Korell",
        "timestamp": 1551479419
    },
    {
        "content": "<p>Yes asymmetrik stack looks solid. I am working in the Danish space (NemID auth) and I am also planning to build a React App on top of the stack. This  SMART <em>strategy</em>  is talking about jquery and plain html and iframes, not sure how much can be applied. (I might misunderstand it, lot to learn in this space...)</p>",
        "id": 159756279,
        "sender_full_name": "Zoltan Simon",
        "timestamp": 1551480386
    },
    {
        "content": "<p>Our setup are Angular and iOS app at front-end and using apollo graphql client. So at backend we decided to provide the SMART on FHIR auth strategy, GraphQL interface and optional RESTful endpoint if needed for external providers.</p>",
        "id": 159756761,
        "sender_full_name": "Michele Korell",
        "timestamp": 1551480897
    },
    {
        "content": "<p>Hello, i've tried to run the graphql schemas get from <a href=\"http://build.fhir.org\" target=\"_blank\" title=\"http://build.fhir.org\">build.fhir.org</a> site with an Apollo GraphQL server but they are some problems:</p>\n<ul>\n<li>At the type ElementBase, property extension :  [Extension] {  &lt;- this open bracket cause error.</li>\n<li>input type have the same name as type, this generate an error because it is a double generation. As is explained at <a href=\"https://graphql.org/learn/schema/#input-types\" target=\"_blank\" title=\"https://graphql.org/learn/schema/#input-types\">https://graphql.org/learn/schema/#input-types</a> for an input type we cannot mix with type, so when is a double declaration the system can't differentiate.</li>\n<li>Queries are defined as type. For example inside patient.graphql we can find:<br>\ntype PatientReadType {<br>\n  Patient(id : ID!) : Patient<br>\n}<br>\nBut for GraphQL they are two special types, Query and Mutation who are the only can have this kind of declarations, something like this:<br>\nextend type Query {<br>\n  Patient(id:ID!): Patient<br>\n}</li>\n</ul>\n<p>And just define an empty base type Query inside types.graphql:<br>\ntype Query {<br>\n    _empty: String<br>\n  }<br>\n(Has to be tested)</p>",
        "id": 159892714,
        "sender_full_name": "Michele Korell",
        "timestamp": 1551684621
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"198505\">@Michele Korell</span> and <span class=\"user-mention\" data-user-id=\"209208\">@Zoltan Simon</span>, I am the lead developer building the Asymmetrik GraphQL FHIR server example and would love to hear any feedback you guys have for us on how it's been working for you or if there is anything else we can add that would be helpful. I'll admit, the single schema is massive (I use Atom text editor and it frequently crashed trying to do syntax highlighting on that), would it be better if we offered a way to grab schemas for individual resources? We are generating a lot of code from structure definitions (everything in resources folder is 100% generated and everything else is more custom) so generating additional things would not be very difficult for us.</p>",
        "id": 159918879,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1551710802
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"196306\">@Robert Winterbottom</span> , I've a question about your generation, inside R4 release i see that you limit the resource extension for reference into a union, from which fhir definition you get these infos? Inside full JSON definition we didn't find that.</p>\n<p>For example from your R4 schema:<br>\n\"\"\"<br>\nThis observation is a group observation (e.g. a battery, a panel of tests, a set<br>\nof vital sign measurements) that includes the target as a member of the group.<br>\n\"\"\"<br>\nunion ObservationhasMember_hasMember_Union = Observation | QuestionnaireResponse | MolecularSequence</p>\n<p>We are just looking how to implement resources validation layer whit our internal FHIR implementation guide.</p>",
        "id": 159927079,
        "sender_full_name": "Michele Korell",
        "timestamp": 1551716646
    },
    {
        "content": "<p>Ahh yes, this was a recent update in our code generator. Our first pass on code generation used JSON schemas but we found more useful information when parsing structure definitions.  So in our V2, we download the JSON version of FHIR definitions from here, <a href=\"https://www.hl7.org/fhir/downloads.html\" target=\"_blank\" title=\"https://www.hl7.org/fhir/downloads.html\">https://www.hl7.org/fhir/downloads.html</a>, not the JSON schemas but the JSON representation of the structure definitions (for this case specifically profiles-resources.json and profiles-types.json). These include information specifying which types of references are allowed, which, in this case, you can see here, <a href=\"https://www.hl7.org/fhir/observation-definitions.html#Observation.hasMember\" target=\"_blank\" title=\"https://www.hl7.org/fhir/observation-definitions.html#Observation.hasMember\">https://www.hl7.org/fhir/observation-definitions.html#Observation.hasMember</a>. It specifies the type is reference, and specifically one of Observation, QuestionnaireResponse, or MolecularSequence.</p>",
        "id": 159932379,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1551720672
    },
    {
        "content": "<p>Validation was actually one of the reasons we started moving away from JSON schemas, we just found the structure definitions have much more info and actually worked a lot better in our code generator.  If you are going to be in Washington for DevDays at the Microsoft Campus, I believe my colleague Jon and myself are going to be giving a talk on code generation at a higher level and what problems we think it can solve.</p>",
        "id": 159934576,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1551722307
    },
    {
        "content": "<p>You did a very good job! I was thinking that you used the structure definition. Actually we are developing a lot of microservices and we rely on GraphQL schema stitching to distribute the types, queries and mutations. <br>\nFor the DevDays unfortunately our hospital is based in Switzerland and at the moment is not planned to go at kind of events. Maybe in the future...</p>",
        "id": 159942569,
        "sender_full_name": "Michele Korell",
        "timestamp": 1551727853
    },
    {
        "content": "<p>Nice, schema stitching is a very interesting concept.  We generated a massive schema for the open source version but our code generator does some more advanced things, such as generating code for custom profiles to make a much smaller/lighter server implementation.  I can add a note to look into exposing the files individually per resource for one of our upcoming sprints since it should be a light lift to add it.  We are trying to add features consistently while working on our enterprise version for either the June dev days or the November one in Amsterdam.</p>",
        "id": 159949761,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1551732882
    },
    {
        "content": "<p>Hello,  <br>\nI started to build an example server for Patient resource with Apollo GraphQL. I get the Patient GraphQL schema from <a href=\"http://build.fhir.org/patient.graphql\" target=\"_blank\" title=\"http://build.fhir.org/patient.graphql\">http://build.fhir.org/patient.graphql</a>. As reported before I had to correct a lot of error in the schema, add Patient to Query type to permit to execute patient query and spend a lot of time to correct base data types. Actually is just an example and it doesn't support full CRUD. I've published the result at <a href=\"https://github.com/michelekorell/patient-fhir-graphql\" target=\"_blank\" title=\"https://github.com/michelekorell/patient-fhir-graphql\">https://github.com/michelekorell/patient-fhir-graphql</a> and you can find the GraphQL schema at <a href=\"https://github.com/michelekorell/patient-fhir-graphql/blob/master/src/graphql/patient.ts\" target=\"_blank\" title=\"https://github.com/michelekorell/patient-fhir-graphql/blob/master/src/graphql/patient.ts\">https://github.com/michelekorell/patient-fhir-graphql/blob/master/src/graphql/patient.ts</a> <br>\nI think that it can be a good idea if we discuss about graphql specs and how define graphql to let working with common project like GraphCool, Prisma, Apollo, ... Actually the specs that can be found on <a href=\"http://build.fhir.org\" target=\"_blank\" title=\"http://build.fhir.org\">build.fhir.org</a> can't be used directly. I have the impression that schemas are automatically generated, so:</p>\n<ul>\n<li>there is a section in github that contain this code? </li>\n<li>We can participate to fix some problems?</li>\n</ul>\n<p>Bye!</p>",
        "id": 162091568,
        "sender_full_name": "Michele Korell",
        "timestamp": 1553901578
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I think you've done this generation for the spec?</p>",
        "id": 162147893,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1553994412
    },
    {
        "content": "<p>yes this is on my list to investigtae</p>",
        "id": 162150940,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1553999414
    },
    {
        "content": "<p>Actually we are looking how to generate the schema starting from resource sd. One of our colleague already developed a generator to create fhir resources from the json definitions, so I can look with him to add some templates to generate the graphql spec. This week I go to discuss with other implementers at our annual hl7 swiss meeting about graphql.</p>",
        "id": 162212678,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554099934
    },
    {
        "content": "<p>you have an annual swiss hl7 meeting about graphQL?</p>",
        "id": 162213173,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554100567
    },
    {
        "content": "<p>It is not about GraphQL, but Oliver Egger invite me to discuss about our work during the mini connectathon at morning session. How I wrote before it wasn't clear.</p>",
        "id": 162213205,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554100666
    },
    {
        "content": "<p>ok thx. I will look into this tonight</p>",
        "id": 162213584,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554101236
    },
    {
        "content": "<p>... and in types.graphql</p>",
        "id": 162220422,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554109201
    },
    {
        "content": "<p>ok. I can easy fix teh ElementBase declaration</p>",
        "id": 162220476,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554109218
    },
    {
        "content": "<blockquote>\n<p>input type have the same name as type,</p>\n</blockquote>\n<p>where exactly is this error?</p>",
        "id": 162220504,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554109259
    },
    {
        "content": "<p>This is a global problem, in GraphQL definition we cannot specify the same name for input and type because this create a circular reference. common implementations cannot handle this case. For example in my apollo graphql test implementation I removed all the input types to permit to use the schema. (see <a href=\"https://stackoverflow.com/a/41515879\" target=\"_blank\" title=\"https://stackoverflow.com/a/41515879\">https://stackoverflow.com/a/41515879</a> as explanation)</p>",
        "id": 162221291,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554110007
    },
    {
        "content": "<p>so what wasn't clear is where my schema actually does that</p>",
        "id": 162221364,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554110043
    },
    {
        "content": "<p>Actually for example at patient.graphql whe have:</p>\n<ul>\n<li>\n<p>type Patient { ... } at line 3<br>\nand after:</p>\n</li>\n<li>\n<p>input Patient {...} at line 61</p>\n</li>\n</ul>",
        "id": 162221562,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554110210
    },
    {
        "content": "<p>uh that's a generation error -they are identical, no?</p>",
        "id": 162221645,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554110283
    },
    {
        "content": "<p>no type vs input. so I need to namespace the input types?</p>",
        "id": 162221675,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554110336
    },
    {
        "content": "<p>The specification advice to put Input after the resource name (<a href=\"https://graphql.org/learn/schema/#input-types\" target=\"_blank\" title=\"https://graphql.org/learn/schema/#input-types\">https://graphql.org/learn/schema/#input-types</a>)</p>",
        "id": 162221712,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554110378
    },
    {
        "content": "<p>ok. I sorted that.</p>",
        "id": 162221838,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554110468
    },
    {
        "content": "<p>so I don't understand your 3rd issue either</p>",
        "id": 162221890,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554110514
    },
    {
        "content": "<p>I found other error at line 229 of patient.graphql: PatientUpdate(id: IDresource: Patient): PatientUpdate  -&gt; after ID type they is not comma before resource.</p>",
        "id": 162221974,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554110567
    },
    {
        "content": "<p>k. anything more?</p>",
        "id": 162222064,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554110655
    },
    {
        "content": "<p>I'm looking with a colleague</p>",
        "id": 162222071,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554110684
    },
    {
        "content": "<p>k. I'll send you a regenerated patient.graphQl shortly.</p>",
        "id": 162222181,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554110775
    },
    {
        "content": "<p>Maybe I miss understand how implements queries inside type definition.</p>",
        "id": 162222184,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554110776
    },
    {
        "content": "<p>but also, seems like you want a single fhir.graphql for all resources?</p>",
        "id": 162222191,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554110789
    },
    {
        "content": "<p>It can be useful to create a complete server with standard libs like apollo, but not required</p>",
        "id": 162222335,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554110934
    },
    {
        "content": "<p>with node package graphql-tools we can load all .graphql separately</p>",
        "id": 162222377,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554110980
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/X-FXtzE58UG2Cg2DBlD6S_ZT/patient.graphql\" target=\"_blank\" title=\"patient.graphql\">patient.graphql</a></p>",
        "id": 162222459,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554111009
    },
    {
        "content": "<p>Starting from line 124 for query PatientList is a space after each argument and before the ':'</p>",
        "id": 162222597,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554111145
    },
    {
        "content": "<p>there shouldn't be?</p>",
        "id": 162222631,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554111184
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/c_bSdBlAzcfR0N3NJKfdsZTG/patient.graphql\" target=\"_blank\" title=\"patient.graphql\">patient.graphql</a></p>",
        "id": 162222720,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554111276
    },
    {
        "content": "<p>Now I'm trying to modify my sample Patient server to use it</p>",
        "id": 162222753,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554111320
    },
    {
        "content": "<p>I feel as though it violates all specification logic that the space matters</p>",
        "id": 162222795,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554111360
    },
    {
        "content": "<p>still, it's not hard to remove them:</p>",
        "id": 162222888,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554111436
    },
    {
        "content": "<p>We have to ask to facebook they do like that</p>",
        "id": 162222898,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554111452
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/g538RbeVekeFknm3jHr_lFYb/patient.graphql\" target=\"_blank\" title=\"patient.graphql\">patient.graphql</a></p>",
        "id": 162222988,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554111537
    },
    {
        "content": "<p>the parser of vscode like it better! thanks a lot. Now I try to integrate it inside my test server</p>",
        "id": 162223167,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554111674
    },
    {
        "content": "<p>ok. let me know if there's more, and then we'll schedule this as an R4 technical correction</p>",
        "id": 162223315,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554111802
    },
    {
        "content": "<p>line 90 input PatientContact was not generated as PatientContactInput</p>",
        "id": 162223762,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554112314
    },
    {
        "content": "<p>same for input PatientCommunication and PatientLink</p>",
        "id": 162223858,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554112406
    },
    {
        "content": "<p>I think is more complicated, by i corrected it by hand and actually all resources specified inside PatientInput has to be as input type. So for type HumanName i have to wrote an HumanNameInput that is used by PatientInput</p>",
        "id": 162224200,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554112750
    },
    {
        "content": "<p>I have to fix by hand all data types before try to run my sample server</p>",
        "id": 162224291,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554112835
    },
    {
        "content": "<p>They are some log when i try to run the apollo-server with this schema:<br>\n  The type of PatientInput.generalPractitioner must be Input Type but got: [Reference].<br>\n  The type of PatientInput.managingOrganization must be Input Type but got: Reference.<br>\n  The type of PatientInput.link must be Input Type but got: [PatientLink].</p>",
        "id": 162224408,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554112975
    },
    {
        "content": "<p>Once the schema is ok, I can implement a server that permit introspection of official fhir-graphql schema definitions.</p>",
        "id": 162224502,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554113089
    },
    {
        "content": "<p>duh. I think I chased everything down here:</p>",
        "id": 162232354,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554120822
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/9gI0ctrD5BdVYhEky7D3ktFc/patient.graphql\" target=\"_blank\" title=\"patient.graphql\">patient.graphql</a></p>",
        "id": 162232418,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554120849
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/6rIFjAfgIM15dsqcxZrTRuRs/types.graphql\" target=\"_blank\" title=\"types.graphql\">types.graphql</a></p>",
        "id": 162232426,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1554120854
    },
    {
        "content": "<p>Hello thanks a lot!<br>\nThey are some small errors for the types.graphql:</p>\n<ul>\n<li>scalar is written starting with uppercase</li>\n<li>ElementBase there is no definition for ElementBaseInput</li>\n<li>at line 27 date scalar is defined a second time</li>\n<li>at line 33 the uri scalar is defined a second time</li>\n<li>at line 1072 url: null -&gt; url: uri!</li>\n<li>at line 1126 url: nullInput! -&gt; url: uri!</li>\n<li>at line 1183 given inside HumanName is not an array</li>\n<li>at line 1195 same for HumanNameInput</li>\n</ul>",
        "id": 162237473,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554124582
    },
    {
        "content": "<p>Hello, here is the file i create starting from patient.graphql and types.graphql to let my sample server work. I've committed the last modification of my sample server on github.<br>\n<a href=\"/user_uploads/10155/8semP-dfKbYfjJFBbn86MGtp/patient-sample-srv.graphql\" target=\"_blank\" title=\"patient-sample-srv.graphql\">patient-sample-srv.graphql</a></p>",
        "id": 162243310,
        "sender_full_name": "Michele Korell",
        "timestamp": 1554128519
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 165621689,
        "sender_full_name": "VP Herisse",
        "timestamp": 1557840331
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 165622050,
        "sender_full_name": "VP Herisse",
        "timestamp": 1557840527
    },
    {
        "content": "<blockquote>\n<p>Hello, I've executed some test with  <a href=\"http://test.fhir.org/r4/$graphql\" target=\"_blank\" title=\"http://test.fhir.org/r4/$graphql\">http://test.fhir.org/r4/$graphql</a> endpoint and it is working as described in a previus post. But I've tried to introspect GraphQL schema against the same endpoint but without success. Normally it is suppose to return graphql schema of available queries and mutations, but actually i get an empty json with { \"data\" : { } }. They are a particular reason that introspection is not supported? <br>\nBy the way  there  is a new interesting project that contains all classes definitions  in typescript of fhir resources (<a href=\"https://github.com/Ahryman40k/typescript-fhir-types\" target=\"_blank\" title=\"https://github.com/Ahryman40k/typescript-fhir-types\">https://github.com/Ahryman40k/typescript-fhir-types</a>). It is generated by using official fhir json definition (the one that can be download here: <a href=\"https://www.hl7.org/fhir/downloads.html\" target=\"_blank\" title=\"https://www.hl7.org/fhir/downloads.html\">https://www.hl7.org/fhir/downloads.html</a>) and we use it to wrap GraphQL fhir queries responses.</p>\n</blockquote>\n<p>Was looking for this all over google, Thank you Michele! :)</p>",
        "id": 165622127,
        "sender_full_name": "VP Herisse",
        "timestamp": 1557840595
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198505\">@Michele Korell</span> I am interested in your efforts for generating GraphQL types out of JSON ( it would equal structure definition resource I think ).<br>\nRight now I am working on stuff that may this process easier it's for node.js for now, this is still in a very early stage both not completely done.<br>\n- graphql-fhir-directives <a href=\"https://github.com/shalkam/graphql-fhir-directives\" target=\"_blank\" title=\"https://github.com/shalkam/graphql-fhir-directives\">https://github.com/shalkam/graphql-fhir-directives</a> with aim to include all profiling capabilities into graphql schema.<br>\nit now has <code>@card</code> which adds <code>min</code> and <code>max</code> for arrays and <code>@binding</code> directives which gets a code system json convert the field into enum type.</p>\n<ul>\n<li><a href=\"https://github.com/shalkam/graphql-fhir-primitive-types\" target=\"_blank\" title=\"https://github.com/shalkam/graphql-fhir-primitive-types\">https://github.com/shalkam/graphql-fhir-primitive-types</a> this one adds primitive fields as defined in FHIR specs along with their resolvers.</li>\n</ul>",
        "id": 167648794,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1559996147
    },
    {
        "content": "<p>We started the implementation of GraphQL in Aidbox - interested in this topic as well.</p>",
        "id": 167661984,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1560018394
    },
    {
        "content": "<p>Why are you generating the graphql types?</p>",
        "id": 167675786,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560041623
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Most of the primitive data type in FHIR doesn't have their corresponding types in GraphQL, for example:-<br>\n- We have different kinds of Integers values like <code>positiveInt</code>, <code>unsignedInt</code> and plain <code>integer</code><br>\n- Same goes for <code>string</code> type we have also many sub-types basically with some regex on top</p>\n<p>So, graphQL SDL (Schema definition language ) gives us the option to declare <code>scalar</code> ( = primitive )  types like this :-</p>\n<div class=\"codehilite\"><pre><span></span>scalar positiveInt\n</pre></div>\n\n\n<p>And a resolver for this type can be implemented for any graphQL server implementation in any language.<br>\nAnd example for node.js</p>\n<div class=\"codehilite\"><pre><span></span>import { GraphQLScalarType } from &#39;graphql&#39;\nimport { GraphQLError } from &#39;graphql/error&#39;\nimport { Kind } from &#39;graphql/language&#39;\n\nexport default new GraphQLScalarType({\n  name: &#39;positiveInt&#39;,\n  description: &#39;an integer with value more than zero&#39;,\n  serialize: value =&gt; {\n    return value\n  },\n  parseValue: value =&gt; {\n    return value\n  },\n  parseLiteral: ast =&gt; {\n    if (ast.kind !== Kind.INT) {\n      throw new GraphQLError(\n        &#39;Query error: Can only parse integers got a: &#39; + ast.kind,\n        [ast]\n      )\n    }\n    if (!(ast.value &gt; 0)) {\n      throw new GraphQLError(&#39;Query error: Not a valid positive integer&#39;, [ast])\n    }\n\n    return ast.value\n  }\n})\n</pre></div>\n\n\n<p>Notice we just add validation that it's an integer and the value is more zero.<br>\nSo, this is a declarative straight-forward way to represent FHIR data types and eventually resources using purely GraphQL SDL without any programming languages involved.<br>\nOnly later on developers will implement resolvers  for these based on FHIR specs and their favorite programming language</p>",
        "id": 167687491,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1560064063
    },
    {
        "content": "<p>that wasn't quite what I was asking - we already defined graphql schema - see <a href=\"http://build.fhir.org/patient.graphql\" target=\"_blank\" title=\"http://build.fhir.org/patient.graphql\">http://build.fhir.org/patient.graphql</a> - why not use those?</p>",
        "id": 167687554,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560064193
    },
    {
        "content": "<p>Most of primitive types doesn't exist in GraphQL like <code>positiveInt</code>, <code>code</code>, <code>oid</code> ... etc</p>",
        "id": 167687874,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1560064817
    },
    {
        "content": "<p>For me I may just use it even as a matter of naming to strictly follow FHIR specs, for example I may declare a scalar <code>id</code> in lower case, and just use GraphQL default <code>ID</code> scalar type for the resolver</p>\n<div class=\"codehilite\"><pre><span></span>SDL:\nscalar id\n\nResolver:\nconst { GraphQLID } = require(&#39;graphql&#39;)\n\nmodule.exports = GraphQLID\n</pre></div>",
        "id": 167687947,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1560065003
    },
    {
        "content": "<p>I'm not sure that's an answer to my question?</p>",
        "id": 167692238,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560073306
    },
    {
        "content": "<blockquote>\n<p>that wasn't quite what I was asking - we already defined graphql schema - see <a href=\"http://build.fhir.org/patient.graphql\" target=\"_blank\" title=\"http://build.fhir.org/patient.graphql\">http://build.fhir.org/patient.graphql</a> - why not use those?</p>\n</blockquote>\n<p>Not sure what do you mean by <code>those</code> here, is it scalar types like :-</p>\n<div class=\"codehilite\"><pre><span></span>deceasedDateTime: dateTime\nlanguage: code\n</pre></div>\n\n\n<p>or do you mean built-in GraphQL scalar types?</p>",
        "id": 167711882,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1560105754
    },
    {
        "content": "<p>why not use the graphQL definitions that are defined as part of the FHIR standard?</p>",
        "id": 167711901,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560105787
    },
    {
        "content": "<p>If we talk specifically about the <code>patient.graphql</code>, it's incorrect as regard GraphQL syntax.<br>\nFor these two fields for example:</p>\n<div class=\"codehilite\"><pre><span></span>deceasedDateTime: dateTime\nlanguage: code\n</pre></div>\n\n\n<p>we need to declare two scalar types: </p>\n<div class=\"codehilite\"><pre><span></span>scalar dateTime\nscalar code\n</pre></div>\n\n\n<p>Otherwise it will through an error if I put this schema as a part of the server configuration</p>",
        "id": 167715230,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1560111209
    },
    {
        "content": "<p>well, let's fix that. are there other issues?</p>",
        "id": 167715285,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560111256
    },
    {
        "content": "<p>I will double check</p>",
        "id": 167715922,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1560112399
    },
    {
        "content": "<p>does any one know what the right mime type for the graphql schema is ?</p>",
        "id": 167757099,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560171958
    },
    {
        "content": "<p>I looked around, but I don't see a mime type for graphql schemas, <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span></p>",
        "id": 167767856,
        "sender_full_name": "Dan Connolly",
        "timestamp": 1560179856
    },
    {
        "content": "<p>I'll ask on the graphql face book page</p>",
        "id": 167769507,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560181008
    },
    {
        "content": "<p>There is some information on that here, <a href=\"https://graphql.org/learn/serving-over-http/#post-request\" target=\"_blank\" title=\"https://graphql.org/learn/serving-over-http/#post-request\">https://graphql.org/learn/serving-over-http/#post-request</a>, in short, it mentions you should use application/json. However, another option available for post-requests is to use application/graphql. If using application/graphql then you should treat the post body as a graphql query string (however I do not think you can use variables with this approach so application/json is probably better for that reason)</p>",
        "id": 167772756,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560183359
    },
    {
        "content": "<p>the schema is not valid json</p>",
        "id": 167778077,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560187678
    },
    {
        "content": "<p>I am asking about the schema itself</p>",
        "id": 167778131,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560187689
    },
    {
        "content": "<p>ahh right, sorry, I misinterpreted that.  Unfortunately application/graphql is for query strings so that would not fit either.  In the javascript world, they are often treated as strings and then passed into parsers, so I'm not sure what the official mime type would/should be for a .graphql schema. Would be curious to hear what the facebook page says about that as well</p>",
        "id": 167783243,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560191139
    },
    {
        "content": "<p>there is no mime type</p>",
        "id": 167793296,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560198403
    },
    {
        "content": "<p>Hello,  actually the schema I put in my demo <a href=\"https://github.com/michelekorell/patient-fhir-graphql\" target=\"_blank\" title=\"https://github.com/michelekorell/patient-fhir-graphql\">https://github.com/michelekorell/patient-fhir-graphql</a> is a merge of the specifications that we can found on <a href=\"http://build.fhir.org\" target=\"_blank\" title=\"http://build.fhir.org\">build.fhir.org</a>. Some time ago <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  made some fix and actually it work. The only change I made is to add the Query type that contains resource query.   I think that in official FHIR graphql schemas are some little problem of specification with operation on a resource inside a type definition. But on my point of view the declaration of scalar type is normal. The types are the same specified inside FHIR definition and has to respect the FHIR regex and not to depend on facebook's base type definition. So we can guarantee the interoperability between GraphQL and RESTful interfaces.</p>\n<p>After small search for mime type at <a href=\"https://www.iana.org/assignments/media-types/media-types.xhtml#application\" target=\"_blank\" title=\"https://www.iana.org/assignments/media-types/media-types.xhtml#application\">official list</a> I didn't find any specification about graphql. After looking our services requests we can see that a graphql query execute with a POST is an application/json with following structure</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span>\n    <span class=\"nt\">&quot;operationName&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;GetSomeThings&quot;</span><span class=\"p\">,</span>\n    <span class=\"nt\">&quot;query&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;query getSome($var:type) {...}&quot;</span><span class=\"p\">,</span>\n    <span class=\"nt\">&quot;variables&quot;</span> <span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">&quot;var&quot;</span><span class=\"p\">:</span> <span class=\"mi\">123</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div>",
        "id": 167836009,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560247507
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198505\">@Michele Korell</span> <span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> <span class=\"user-mention\" data-user-id=\"196306\">@Robert Winterbottom</span> <span class=\"user-mention\" data-user-id=\"193512\">@Mostafa Sholkamy</span> Are we interested in creating a set of test cases based on the resources included in the specifications so that we can check that the graphQL implementations are consistent?</p>",
        "id": 168059685,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560442293
    },
    {
        "content": "<p>Yes, I'm really interested! We currently use a lot of graphql on our electronic patient record system!</p>",
        "id": 168061143,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560443350
    },
    {
        "content": "<p>Should we develop a test suit for that?</p>",
        "id": 168069152,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1560448741
    },
    {
        "content": "<p>The idea of the test is to provide multiples uses cases to submit to endpoint where where can perform simple resource crud operation and try to resolve more complex dependencies by using resource extension defined in Reference field? </p>\n<p>I have just a question about FHIR GraphQL specification at chapter <a href=\"http://build.fhir.org/graphql.html#mutations\" target=\"_blank\" title=\"http://build.fhir.org/graphql.html#mutations\"> 3.1.2.8 Mutations</a>, the create operation is intended to be used like:</p>\n<div class=\"codehilite\"><pre><span></span>type Mutation {\n  PatientCreate(res: PatientInput): Patient\n}\n</pre></div>\n\n\n<p>and inside <a href=\"http://build.fhir.org/patient.graphql\" target=\"_blank\" title=\"http://build.fhir.org/patient.graphql\">patient.graphql</a> is specified like field <a href=\"https://graphql.org/learn/schema/#arguments\" target=\"_blank\" title=\"https://graphql.org/learn/schema/#arguments\">argument</a></p>\n<div class=\"codehilite\"><pre><span></span>type PatientCreateType {\n  PatientCreate(resource: PatientInput): PatientCreation\n}\n</pre></div>\n\n\n<p>In this case to make <a href=\"https://github.com/michelekorell/patient-fhir-graphql\" target=\"_blank\" title=\"https://github.com/michelekorell/patient-fhir-graphql\">my demo</a> I made some modification on Patient.graphql file. By the way I made an error by putting the PatientCreate operation inside query type, oups...</p>",
        "id": 168085570,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560460262
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I think that would be a great idea. Are you thinking some mock queries/scenarios and just documenting the results on the spec page?</p>",
        "id": 168096368,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560471583
    },
    {
        "content": "<p>well, yes. I'm imagining a Json document with an array of objects each of which has a query (string) and either an error (String) or a json object that is the data output of the query. A client that knows how to follow the document could test any server</p>",
        "id": 168098344,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560474498
    },
    {
        "content": "<p>That sounds good to me. We have a test framework in place so something like that would be very useful for us in the CI process as well as for our end users.</p>",
        "id": 168132291,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560516909
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I've already done some tests on my own custom resources in node.js here: <a href=\"https://github.com/shalkam/gql-fhir-patient-example/blob/master/tests/patient/index.test.js\" target=\"_blank\" title=\"https://github.com/shalkam/gql-fhir-patient-example/blob/master/tests/patient/index.test.js\">https://github.com/shalkam/gql-fhir-patient-example/blob/master/tests/patient/index.test.js</a>.</p>\n<p>So, Where to find schemas to tests? I only have <a href=\"http://build.fhir.org/patient.graphql\" target=\"_blank\" title=\"http://build.fhir.org/patient.graphql\">http://build.fhir.org/patient.graphql</a> because of the discussions we had ... I can start with this one.<br>\nIf there are more please let me know</p>",
        "id": 168150319,
        "sender_full_name": "Mostafa Sholkamy",
        "timestamp": 1560529791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"196306\">@Robert Winterbottom</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Actually we already have some UI tests on cypress ti intercept graphql queries and return mock data. For the future we plan to do the same think with nodejs backend. It can be a shared project, something like a web hook that permits to execute a test on selected endpoint and resources. At end of the operation it can return a mocha report about the test (or other format)</p>",
        "id": 168153797,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560532329
    },
    {
        "content": "<p>so each of us will have different test frameworks, of course. What I want is to standardise the tests that they apply. With that in mind, I offer this as a starting position - can we agree to this format, and get this test passing on our servers?</p>",
        "id": 168220307,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560627095
    },
    {
        "content": "<p><a href=\"https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.r5/src/main/resources/graphql/server-tests.json\" target=\"_blank\" title=\"https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.r5/src/main/resources/graphql/server-tests.json\">https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.r5/src/main/resources/graphql/server-tests.json</a></p>",
        "id": 168220357,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560627158
    },
    {
        "content": "<p>I guess the first key question is - should the tests create the resources that they operate on? or should they assume a pre-configured read-only interface?</p>",
        "id": 168220476,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560627404
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198505\">@Michele Korell</span> I see that there are 2 different rules made here. What should we do? </p>\n<ul>\n<li>the specification calls for the return of a simple patient; the location header and operation outcome header would be lost</li>\n<li>the schema anticipates a wrapper object that carries those and the resource</li>\n</ul>\n<p>Definitely in conflict with each other; how to resolve?</p>",
        "id": 168220616,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560627642
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> your speaking about the test specification or the GraphQL query definition for resources?</p>",
        "id": 168221010,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560628419
    },
    {
        "content": "<p>that is in response to your question about the mutation in the schema above. I'm not talking about the tests right now</p>",
        "id": 168221058,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560628482
    },
    {
        "content": "<p>I'm looking at the issues with the generated schema - the scalar types and the complex types are all defined in types.graphql. The problem is that graphql doesn't define a way for one schema to reference another. (things like <a href=\"https://blog.apollographql.com/modularizing-your-graphql-schema-code-d7f71d5ed5f2\" target=\"_blank\" title=\"https://blog.apollographql.com/modularizing-your-graphql-schema-code-d7f71d5ed5f2\">https://blog.apollographql.com/modularizing-your-graphql-schema-code-d7f71d5ed5f2</a> are all about js pre-processing). </p>\n<p>So the options appear to be:</p>\n<ul>\n<li>add a documentation note to each resource schema noting the dependency on types.graphql</li>\n<li>duplicate types.graphql into every resource schema</li>\n<li>generate one single large combined schema</li>\n</ul>\n<p>Thoughts?</p>",
        "id": 168221107,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560628565
    },
    {
        "content": "<p>(note: there's a typo in <a href=\"http://build.fhir.org/types.graphql\" target=\"_blank\" title=\"http://build.fhir.org/types.graphql\">http://build.fhir.org/types.graphql</a> - Scalar not scalar - that will fixed once we resolve this question. Also, I'll add a download that includes all the graphql schema in a single zip as well)</p>",
        "id": 168221254,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560628836
    },
    {
        "content": "<p>They are another differents ways with apollographql tools. for example with <a href=\"https://www.apollographql.com/docs/graphql-tools/schema-transforms/\" target=\"_blank\" title=\"https://www.apollographql.com/docs/graphql-tools/schema-transforms/\">transform</a> you can load multiples files and manipulate queries. Or maybe have an official endpoint that provide each FHIR version and compatible for introspection, we can perform some schema federation ( <a href=\"https://www.apollographql.com/docs/apollo-server/federation/migrating-from-stitching/\" target=\"_blank\" title=\"https://www.apollographql.com/docs/apollo-server/federation/migrating-from-stitching/\">before was schema stitching</a> ) to build our endpoint schema.</p>",
        "id": 168221371,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560629090
    },
    {
        "content": "<p>... I think you mean, we should have a single schema</p>",
        "id": 168221381,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560629123
    },
    {
        "content": "<p>or maybe: generate all the fragments, and also publish a single combined schema</p>",
        "id": 168221514,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560629392
    },
    {
        "content": "<p>Have a big schema with all is simplier, but we lost the overview. In our hospital we made a service that only provide a big generated schema using introspection thecnics, but we found a lot of error and it is difficult to use. I like the idea to have Patient.graphql,  but in this case we must have at least Scalar and complex types in a base schema and for the other resources we can use extension operation to do something like:</p>\n<div class=\"codehilite\"><pre><span></span>extend type Query {\n    Patient(...) : Patient\n    PatientList(...) : Bundle\n    ....\n}\n</pre></div>",
        "id": 168221691,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560629715
    },
    {
        "content": "<p>I don't understand this. types.graphl is the base schema, but how does it get included? What does 'extend' have to do with that?</p>",
        "id": 168221737,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560629793
    },
    {
        "content": "<p>Actually, types.graphql contains only scalars and complex type?</p>",
        "id": 168221747,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560629867
    },
    {
        "content": "<p>right. it's your base schema</p>",
        "id": 168221749,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560629880
    },
    {
        "content": "<p>So, if I have understand right GraphQL, to merge two .graphql files we have to define somewhere the type Query {...} and in all other .graphql files we can use extend type Query</p>",
        "id": 168221850,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560630020
    },
    {
        "content": "<p>where is that documented?</p>",
        "id": 168221857,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560630049
    },
    {
        "content": "<p>And for me the best place to define base Query and Mutation is inside types.graphql because in any case we need Scalars and complex types.<br>\nWait a momen, i go search the doc</p>",
        "id": 168221866,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560630092
    },
    {
        "content": "<p>Here: <a href=\"https://www.apollographql.com/docs/graphql-tools/generate-schema/#extending-types\" target=\"_blank\" title=\"https://www.apollographql.com/docs/graphql-tools/generate-schema/#extending-types\">https://www.apollographql.com/docs/graphql-tools/generate-schema/#extending-types</a></p>",
        "id": 168221921,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560630232
    },
    {
        "content": "<p>so there's nothing there about schema modularity. It might be that we should actually do that, though I'm not sure where that would be useful, but it doesn't help with the current question</p>",
        "id": 168221964,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560630302
    },
    {
        "content": "<p>With apollo graphql-tools lib we can get multiples files in one executable schema. <br>\nMaybe <span class=\"user-mention\" data-user-id=\"196306\">@Robert Winterbottom</span> can help us resolve these question, because asymmetrik worked a lot  for their FHIR GraphQL server and have more experience than me.</p>",
        "id": 168222022,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560630467
    },
    {
        "content": "<p>the apollo tools do it by pre-processing. I presume that leads to one large schema...</p>",
        "id": 168222064,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560630499
    },
    {
        "content": "<p>In our implementation we use to load multiples schemas and merge with base types and scalars</p>",
        "id": 168222069,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560630547
    },
    {
        "content": "<p>The <a href=\"https://www.apollographql.com/docs/apollo-server/federation/federation-spec/\" target=\"_blank\" title=\"https://www.apollographql.com/docs/apollo-server/federation/federation-spec/\">GraphQL federation</a> is a concept that i didn't study until now, but it can be a way to see what it could be done in case we have a big schema or multiples definitions. Our experience with a big schema is that is difficult to handle and find errors.</p>",
        "id": 168222342,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560631123
    },
    {
        "content": "<p>I found an introduction chapter on apollographql federation: <a href=\"https://www.apollographql.com/docs/apollo-server/federation/introduction/\" target=\"_blank\" title=\"https://www.apollographql.com/docs/apollo-server/federation/introduction/\">https://www.apollographql.com/docs/apollo-server/federation/introduction/</a></p>",
        "id": 168222408,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560631281
    },
    {
        "content": "<p>But it is based on apollographql framework...</p>",
        "id": 168222623,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560631752
    },
    {
        "content": "<blockquote>\n<p>Note that the _service field is never exposed at the gateway. This is soley done to compose the schema</p>\n</blockquote>",
        "id": 168222673,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560631809
    },
    {
        "content": "<p>so, once again, private to Apollo</p>",
        "id": 168222677,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560631825
    },
    {
        "content": "<blockquote>\n<p>Our experience with a big schema is that is .. find errors.</p>\n</blockquote>\n<p>because it's big? or because there's errors to find?</p>",
        "id": 168222795,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560632085
    },
    {
        "content": "<p>The problem of big schema is handle personal's IG restrictions</p>",
        "id": 168256787,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560698903
    },
    {
        "content": "<p>Elsewhere our reference server work well with the big schema</p>",
        "id": 168256912,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560699014
    },
    {
        "content": "<blockquote>\n<p>handle personal's IG restrictions</p>\n</blockquote>\n<p>can you try this line again please</p>",
        "id": 168266941,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560717573
    },
    {
        "content": "<blockquote>\n<p>the apollo tools do it by pre-processing. I presume that leads to one large schema...</p>\n</blockquote>\n<p>Yes from what I have seen with apollo tools that is correct. It essentially forces you to wrap those types as strings so they can be stitched together into one big schema (for your root schema) and then you can also use them as smaller pieces for instance queries (e.g. Patient/&lt;patient-id&gt;/$graphql).</p>\n<p>I (or Asymmetrik currently) don't use Apollo tools because facebooks own JS library works really well for our case. We also autogenerate schemas individually so modularity is extremely simple. However, our schemas are not in the schema language so they are not portable to other languages, they are specific to <code>graphql-js</code>.</p>",
        "id": 168268652,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560720732
    },
    {
        "content": "<p>As far as loading the <code>types.graphql</code>, they need to be defined when they are used. In our case, we just require each module and all it's dependencies and they all work just fine, if you want to see what we did, here is an example of the patient resource, <a href=\"https://github.com/Asymmetrik/graphql-fhir/blob/master/src/resources/4_0_0/schemas/patient.schema.js\" target=\"_blank\" title=\"https://github.com/Asymmetrik/graphql-fhir/blob/master/src/resources/4_0_0/schemas/patient.schema.js\">https://github.com/Asymmetrik/graphql-fhir/blob/master/src/resources/4_0_0/schemas/patient.schema.js</a>. So if you are using Apollo, you may have to either load everything together with <code>makeExecutableSchema</code> or redefine them in each schema where they are used.</p>",
        "id": 168268715,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560720877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> As far as the tests go, that setup file would work fine for us and be very easy to integrate.  </p>\n<p>As for whether or not the tests should create the resources or assume they are present and the API is read only. I like the idea of supporting read only but does that mean we would need to have the example resources present at all times in our system (so end users can run the tests against our implementations themselves)?</p>",
        "id": 168268882,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560721214
    },
    {
        "content": "<p>so the upshot is: there is no support at the schema level for stitching. We should probably publish modular and stitched schema</p>",
        "id": 168269477,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560722406
    },
    {
        "content": "<p>if you write the schema as read-only then you need a special test set up, so you can run the tests. Or you always have test resources - and only test resources available - which means, a special test set up.</p>",
        "id": 168269501,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560722485
    },
    {
        "content": "<p>but if the test scripts create the resources, you still end up with test resources on the server.... so my take is that you need a special testing server anyway.</p>",
        "id": 168269506,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560722514
    },
    {
        "content": "<p>I prefer to run the test against a pre-canned set up since I already have that pre-canned setup ;-)</p>",
        "id": 168269554,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560722571
    },
    {
        "content": "<p>Our testing framework has some convenient hooks for setting things like this up so this all sounds good to me</p>",
        "id": 168306602,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560775549
    },
    {
        "content": "<p>ok. so we don't create the resources. But i might nominate the dependencies anyway in the json just to be clear. So any chance we can confirm that this test passes ok for <span class=\"user-mention\" data-user-id=\"196306\">@Robert Winterbottom</span>  and <span class=\"user-mention\" data-user-id=\"198505\">@Michele Korell</span> (and does anyone have interest in this)?</p>",
        "id": 168331409,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560793606
    },
    {
        "content": "<p>Yea, I'll take a crack this afternoon at integrating it on our side and let you know how it goes</p>",
        "id": 168331978,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560793965
    },
    {
        "content": "<p>ok thanks</p>",
        "id": 168332229,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560794124
    },
    {
        "content": "<p>For me the idea is ok! I have just a doubt about the endpoint. Our implementation is based on single entry-point for all resources and not as example at resource: Patient/:id/$graphql<br>\nDid you think we can support scenarios where we run queries against base url: myfhirserver.graphql/r4 ?</p>\n<p>What I try to say about IG is: for example we added the ! symbol where we want have parameters that in standard definition are optional. We did it in graphql so the engine check for us.</p>\n<p>Our server are also based on facebook's js lib, the only difference from asymmetrik is that we integrate the graphql-tools lib from apollo. This permit us to manipulate multiples pieces of schema to make them executable and simplify schema stitching</p>",
        "id": 168340752,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560800264
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> So I noticed a few minor things with the test script.</p>\n<p>First was the<code>tests.simple.url</code> was missing a trailing <code>}</code>, so it should be like this instead: <code>/Patient/example/$graphql?query={identifier{system,value}active,name{text,given,family}}</code>.</p>\n<p>This still failed on our server because the query and results needed to include the datatype in them, so instead of <code>query={...&lt;return-fields&gt;}</code>, I needed to change it to <code>query={Patient{...&lt;return-fields&gt;}}</code>. I can't remember off the top of my head what the spec says so I'll need to look this up, but I do not think we are supposed to have an anonymous response, I think the response always needs to reference the data type, e.g. Patient.</p>\n<p>Last, the <code>tests.simple.output</code> was missing the identifier and active response fields, they are in the example patient I downloaded from <a href=\"https://www.hl7.org/fhir/patient-example.json\" target=\"_blank\" title=\"https://www.hl7.org/fhir/patient-example.json\">https://www.hl7.org/fhir/patient-example.json</a>. So I added those in. Our server also returned <code>text:null</code> in some of the objects, like name. This does not cause the test to fail because of the matcher I am using in my tests.</p>\n<p>However, after those changes, the tests work fine against my local server.</p>",
        "id": 168342871,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560801870
    },
    {
        "content": "<p>Also, I think we are in an interesting use case. Our server is open source and a facade, so the version on Github has no backend setup. To make this work, I setup a mock resolver that returned the <code>patient-example.json</code>. I will probably add instructions for anyone implementing a server based on our open source version, that they need to update the test to work against their back end with their resolvers.</p>",
        "id": 168343082,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560802050
    },
    {
        "content": "<blockquote>\n<p>For me the idea is ok! I have just a doubt about the endpoint. Our implementation is based on single entry-point for all resources and not as example at resource: Patient/:id/$graphql<br>\nDid you think we can support scenarios where we run queries against base url: myfhirserver.graphql/r4 ?</p>\n<p>What I try to say about IG is: for example we added the ! symbol where we want have parameters that in standard definition are optional. We did it in graphql so the engine check for us.</p>\n<p>Our server are also based on facebook's js lib, the only difference from asymmetrik is that we integrate the graphql-tools lib from apollo. This permit us to manipulate multiples pieces of schema to make them executable and simplify schema stitching</p>\n</blockquote>\n<p>I agree, I think it would be nice to also have it able to test against the root schema. Could we add a property to the test snippet that signifies whether its an instance query against a single patient with id or whether it's against the root schema?</p>",
        "id": 168343249,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560802191
    },
    {
        "content": "<p>ok I updated the tests. I added instance-tests and root tests</p>",
        "id": 168349364,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560807047
    },
    {
        "content": "<blockquote>\n<p>This still failed on our server because the query and results needed to include the datatype in them, so instead of query={...&lt;return-fields&gt;}, I needed to change it to query={Patient{...&lt;return-fields&gt;}}</p>\n</blockquote>\n<p>this is not what the FHIR spec currently says, and I don't see why that should be. The fact that it's Patient is already known by context, so there's no need to be explicit about that</p>",
        "id": 168349418,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560807095
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>This still failed on our server because the query and results needed to include the datatype in them, so instead of query={...&lt;return-fields&gt;}, I needed to change it to query={Patient{...&lt;return-fields&gt;}}</p>\n</blockquote>\n<p>this is not what the FHIR spec currently says, and I don't see why that should be. The fact that it's Patient is already known by context, so there's no need to be explicit about that</p>\n</blockquote>\n<p>I had issues with doing that in the past (which is why our server did it that way) but was trying it again last night and was able to make it work that way without issue. Should be fairly easy to upgrade our server to use it that way for that context.</p>",
        "id": 168394346,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560860260
    },
    {
        "content": "<p>For the root tests, I think you will need to include the Patient context in the results since the query can hit multiple data types</p>",
        "id": 168394442,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560860307
    },
    {
        "content": "<p>indeed it does, no?</p>",
        "id": 168395774,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560861374
    },
    {
        "content": "<p>I dont see it in the results for <code>root-tests</code></p>",
        "id": 168397667,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560862748
    },
    {
        "content": "<p>Hmm, <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, For the instance queries in your implementation, do you have to specify a resolver for each field?</p>\n<p>When I use queries like this: <code>query={Patient{...&lt;return-fields&gt;}}</code>, it's easy for us to specify a Patient resolver that gets called once and returns the whole patient object. I realized through some more testing this morning that when I was switching our implementation to support <code>query={...&lt;return-fields&gt;}</code>, it invokes the fieldResolver once for each field. I was just curious if your implementation supported a single resolver for the whole object versus one resolver per field.</p>",
        "id": 168407933,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560869274
    },
    {
        "content": "<p>I don't know anything about resolvers. I don't see anything about them in the standard?</p>",
        "id": 168438127,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560880199
    },
    {
        "content": "<blockquote>\n<p>you will need to include the Patient context in the results </p>\n</blockquote>\n<p>I thought that this was it:</p>\n<blockquote>\n<p>/$graphql?query={Patient(id:example){identifier{system,value}active,name{text,given,family}}}</p>\n</blockquote>\n<p>Patient is specified explicitly</p>",
        "id": 168438248,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560880276
    },
    {
        "content": "<p>Ahh sorry, forgot to elaborate, so in that case (<code>/$graphql?query={Patient(id:example){identifier{system,value}active,name{text,given,family}}}</code>) patient is identified in the query, but it's missing in the resulting data. When hitting the root schema, a query could also look like this:</p>\n<div class=\"codehilite\"><pre><span></span>/$graphql?query={Patient(id:example){active}Observation(id:example){active}}\n</pre></div>\n\n\n<p>So the results should look something like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span>\n    <span class=\"nt\">&quot;data&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">&quot;Patient&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;active&quot;</span><span class=\"p\">:</span> <span class=\"kc\">false</span>\n        <span class=\"p\">},</span>\n        <span class=\"nt\">&quot;Observation&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;active&quot;</span><span class=\"p\">:</span> <span class=\"kc\">false</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>Without having the Patient and observation in the results, there is no way the consumer can know exactly what data type the fields are related to. I think the test file is supposed to look like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span>\n    <span class=\"nt\">&quot;root-tests&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">&quot;simple&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;description&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;Just a simple test of the basic graphQL engine: a simple query on a known patient (example, from the spec)&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;url&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;/$graphql?query={Patient(id:example){identifier{system,value}active,name{text,given,family}}}&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;output&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                <span class=\"nt\">&quot;data&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                    <span class=\"nt\">&quot;Patient&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                        <span class=\"nt\">&quot;identifier&quot;</span><span class=\"p\">:</span> <span class=\"p\">[{</span>\n                            <span class=\"nt\">&quot;system&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;urn:oid:1.2.36.146.595.217.0.1&quot;</span><span class=\"p\">,</span>\n                            <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;12345&quot;</span>\n                        <span class=\"p\">}],</span>\n                        <span class=\"nt\">&quot;active&quot;</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n                        <span class=\"nt\">&quot;name&quot;</span><span class=\"p\">:</span> <span class=\"p\">[{</span>\n                            <span class=\"nt\">&quot;given&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Peter&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;James&quot;</span><span class=\"p\">],</span>\n                            <span class=\"nt\">&quot;family&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;Chalmers&quot;</span>\n                        <span class=\"p\">},</span> <span class=\"p\">{</span>\n                            <span class=\"nt\">&quot;given&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Jim&quot;</span><span class=\"p\">]</span>\n                        <span class=\"p\">},</span> <span class=\"p\">{</span>\n                            <span class=\"nt\">&quot;given&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Peter&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;James&quot;</span><span class=\"p\">],</span>\n                            <span class=\"nt\">&quot;family&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;Windsor&quot;</span>\n                        <span class=\"p\">}]</span>\n                    <span class=\"p\">}</span>\n                <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div>",
        "id": 168440829,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560881816
    },
    {
        "content": "<blockquote>\n<p>I don't know anything about resolvers. I don't see anything about them in the standard?</p>\n</blockquote>\n<p>They discuss them here, <a href=\"https://graphql.org/learn/execution/\" target=\"_blank\" title=\"https://graphql.org/learn/execution/\">https://graphql.org/learn/execution/</a>. Essentially, anything that takes an argument will need a resolver to resolve any encapsulated data based on the provided arguments. In the case of the instance query where there aren't any arguments provided via the graphql query, just the rest param, you have to use field resolvers. At least that's the case in JavaScript. I think I can write an abstraction so that anyone implementing something based on our solution, won't have to worry about that. This may be a Javascript only thing.</p>",
        "id": 168441856,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560882470
    },
    {
        "content": "<p>Also, should the search param be <code>_id</code> instead of <code>id</code>(<code>query={Patient(_id:\"example\")</code>)? I do not see <code>id</code> listed in the FHIR spec as a valid search parameter for patient</p>",
        "id": 168443054,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560883246
    },
    {
        "content": "<p>oh. updated the tests for both issues.</p>",
        "id": 168444530,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560884125
    },
    {
        "content": "<p>Great thanks. I'll test it again a little later tonight</p>",
        "id": 168444802,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560884336
    },
    {
        "content": "<p>Hello, actually I'm in holidays for one and half week. My wife forbidden me to take the pc with. So I go to start my test when I'm back.</p>",
        "id": 168459895,
        "sender_full_name": "Michele Korell",
        "timestamp": 1560895728
    },
    {
        "content": "<p>ok</p>",
        "id": 168460004,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560895817
    },
    {
        "content": "<blockquote>\n<p>Hello, actually I'm in holidays for one and half week. My wife forbidden me to take the pc with. So I go to start my test when I'm back.</p>\n</blockquote>\n<p>Did you sneak away to write this message ;)</p>",
        "id": 168500964,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560946931
    },
    {
        "content": "<blockquote>\n<p>oh. updated the tests for both issues.</p>\n</blockquote>\n<p>Looks like the JSON is missing some commas, i'll paste a working version below that fixes the commas and adds quotes to the id in the root-test (without the quotes the graphql parser is treating the _id as an enum)</p>",
        "id": 168501193,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560947154
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span>\n    <span class=\"nt\">&quot;@type&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;graphql-server-tests&quot;</span><span class=\"p\">,</span>\n    <span class=\"nt\">&quot;instance-tests&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">&quot;simple&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;description&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;Just a simple test of the basic graphQL engine: a simple query on a known patient (example, from the spec)&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;url&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;/Patient/example/$graphql?query={identifier{system,value}active,name{text,given,family}}&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;output&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                <span class=\"nt\">&quot;data&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                    <span class=\"nt\">&quot;identifier&quot;</span><span class=\"p\">:</span> <span class=\"p\">[{</span>\n                        <span class=\"nt\">&quot;system&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;urn:oid:1.2.36.146.595.217.0.1&quot;</span><span class=\"p\">,</span>\n                        <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;12345&quot;</span>\n                    <span class=\"p\">}],</span>\n                    <span class=\"nt\">&quot;active&quot;</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n                    <span class=\"nt\">&quot;name&quot;</span><span class=\"p\">:</span> <span class=\"p\">[{</span>\n                        <span class=\"nt\">&quot;given&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Peter&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;James&quot;</span><span class=\"p\">],</span>\n                        <span class=\"nt\">&quot;family&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;Chalmers&quot;</span>\n                    <span class=\"p\">},</span> <span class=\"p\">{</span>\n                        <span class=\"nt\">&quot;given&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Jim&quot;</span><span class=\"p\">]</span>\n                    <span class=\"p\">},</span> <span class=\"p\">{</span>\n                        <span class=\"nt\">&quot;given&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Peter&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;James&quot;</span><span class=\"p\">],</span>\n                        <span class=\"nt\">&quot;family&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;Windsor&quot;</span>\n                    <span class=\"p\">}]</span>\n                <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"nt\">&quot;root-tests&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">&quot;simple&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">&quot;description&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;Just a simple test of the basic graphQL engine: a simple query on a known patient (example, from the spec)&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;url&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;/$graphql?query={Patient(_id:\\&quot;example\\&quot;){identifier{system,value}active,name{text,given,family}}}&quot;</span><span class=\"p\">,</span>\n            <span class=\"nt\">&quot;output&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                <span class=\"nt\">&quot;data&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                    <span class=\"nt\">&quot;Patient&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                        <span class=\"nt\">&quot;identifier&quot;</span><span class=\"p\">:</span> <span class=\"p\">[{</span>\n                            <span class=\"nt\">&quot;system&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;urn:oid:1.2.36.146.595.217.0.1&quot;</span><span class=\"p\">,</span>\n                            <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;12345&quot;</span>\n                        <span class=\"p\">}],</span>\n                        <span class=\"nt\">&quot;active&quot;</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n                        <span class=\"nt\">&quot;name&quot;</span><span class=\"p\">:</span> <span class=\"p\">[{</span>\n                            <span class=\"nt\">&quot;given&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Peter&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;James&quot;</span><span class=\"p\">],</span>\n                            <span class=\"nt\">&quot;family&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;Chalmers&quot;</span>\n                        <span class=\"p\">},</span> <span class=\"p\">{</span>\n                            <span class=\"nt\">&quot;given&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Jim&quot;</span><span class=\"p\">]</span>\n                        <span class=\"p\">},</span> <span class=\"p\">{</span>\n                            <span class=\"nt\">&quot;given&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;Peter&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;James&quot;</span><span class=\"p\">],</span>\n                            <span class=\"nt\">&quot;family&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;Windsor&quot;</span>\n                        <span class=\"p\">}]</span>\n                    <span class=\"p\">}</span>\n                <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div>",
        "id": 168501285,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560947203
    },
    {
        "content": "<p>fixed</p>",
        "id": 168501537,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560947426
    },
    {
        "content": "<p>Great thanks, works for me now!!</p>",
        "id": 168502092,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1560947897
    },
    {
        "content": "<p>great. time to add some more tests ;-)</p>",
        "id": 168502121,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560947928
    },
    {
        "content": "<p>Hello, <br>\ndid you already think how manage resource update when somehow ask partial resource via GraphQL and send back the same object with some changes? Is better to update only parameters that are present or replace the resource? <br>\nIf someone make bad operations, it can erase some part of information. <br>\nWhat you think about that?</p>",
        "id": 170432236,
        "sender_full_name": "Michele Korell",
        "timestamp": 1562659583
    },
    {
        "content": "<p>Hey Michele.</p>\n<p>For our implementation, when users are doing any kind of mutations, we plan to only update the targeted resource with the provided properties and not modify any existing properties that are not provided. We think that replacing the full resource on a mutation could lead to accidental deletes of some properties and would also then force users to ask for the full object every time.  However, after talking with Grahame and others in Seattle, we also plan to allow writes via REST since there are some things with writes that are much more difficult in GraphQL (e.g. input unions are not allowed in GraphQL) than in REST.</p>",
        "id": 170469990,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1562691063
    },
    {
        "content": "<p>my personal opinion is that graphQL writes are a nightmare. It's find to say 'accept the object with some changes\" until you discover that there was a filtered list in there. now what?</p>",
        "id": 170586347,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1562798946
    },
    {
        "content": "<p>I know the graphQL people want to use their hammer so writes are going to be treated as a nail... but I think it's a very bad idea. POST/PUT/PATCH should be the go, even if that makes life more apparently difficult for the client</p>",
        "id": 170586388,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1562798999
    },
    {
        "content": "<p>We was thinking develop an update on only provided fields, but after some review we see that they are to much use cases. I think we have to really look to use REST interfaces inside our microservices environment and GraphQL only to query data for end user application.</p>",
        "id": 170698190,
        "sender_full_name": "Michele Korell",
        "timestamp": 1562912840
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.r5/src/main/resources/graphql/server-tests.json\" target=\"_blank\" title=\"https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.r5/src/main/resources/graphql/server-tests.json\">https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.r5/src/main/resources/graphql/server-tests.json</a></p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> link seems to be dead - did these get moved to <a href=\"https://github.com/hapifhir/org.hl7.fhir.core/blob/857db5f86837ef041332230b8183ed1394b0dfc4/org.hl7.fhir.r5/src/test/resources/graphql/server-tests.json\" target=\"_blank\" title=\"https://github.com/hapifhir/org.hl7.fhir.core/blob/857db5f86837ef041332230b8183ed1394b0dfc4/org.hl7.fhir.r5/src/test/resources/graphql/server-tests.json\">here</a>? Using the commit hash url rather than master in case it happens again.</p>",
        "id": 171071669,
        "sender_full_name": "Misha Kaletsky",
        "timestamp": 1563365210
    },
    {
        "content": "<p>they just got moved by <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span></p>",
        "id": 171080884,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1563372099
    },
    {
        "content": "<p><a href=\"https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.r5/src/test/resources/graphql/server-tests.json\" target=\"_blank\" title=\"https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.r5/src/test/resources/graphql/server-tests.json\">https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.r5/src/test/resources/graphql/server-tests.json</a></p>",
        "id": 171080900,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1563372109
    },
    {
        "content": "<p>Is there a publicly available version of the graphQL-FHIR server that developers and try out (similar to <a href=\"http://hapi.fhir.org/\" target=\"_blank\" title=\"http://hapi.fhir.org/\">http://hapi.fhir.org/</a>)?</p>",
        "id": 176109996,
        "sender_full_name": "Howard Kong",
        "timestamp": 1568906441
    },
    {
        "content": "<p>both <a href=\"http://test.fhir.org\" target=\"_blank\" title=\"http://test.fhir.org\">test.fhir.org</a> and <a href=\"http://hapi.fhir.org\" target=\"_blank\" title=\"http://hapi.fhir.org\">hapi.fhir.org</a> implement graphql and are publicly available, and both are open source</p>",
        "id": 176110032,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568906472
    },
    {
        "content": "<p>Thanks!  I just tried, what is the graphql endpoint?  I tried <a href=\"http://hapi.fhir.org/graphql\" target=\"_blank\" title=\"http://hapi.fhir.org/graphql\">http://hapi.fhir.org/graphql</a>, but got a 404.</p>",
        "id": 176111606,
        "sender_full_name": "Howard Kong",
        "timestamp": 1568907399
    },
    {
        "content": "<p>try the test server - the links to execute the statements are built right into the graphql  page on <a href=\"http://build.fhir.org/graphql.html\" target=\"_blank\" title=\"http://build.fhir.org/graphql.html\">http://build.fhir.org/graphql.html</a></p>",
        "id": 176111854,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568907554
    },
    {
        "content": "<p>Fwiw, here's a working query: <a href=\"http://hapi.fhir.org/baseR4/Patient/13/$graphql?query={name{text,given,family}}\" target=\"_blank\" title=\"http://hapi.fhir.org/baseR4/Patient/13/$graphql?query={name{text,given,family}}\">http://hapi.fhir.org/baseR4/Patient/13/$graphql?query={name{text,given,family}}</a></p>",
        "id": 176112366,
        "sender_full_name": "James Agnew",
        "timestamp": 1568907865
    },
    {
        "content": "<p>Now I get it.  I was looking for a /graphql endpoint and was expecting a GraphiQL interface.  That example link got me in the right direction.  Thank you both!</p>",
        "id": 176113338,
        "sender_full_name": "Howard Kong",
        "timestamp": 1568908371
    },
    {
        "content": "<p>heh- i do notice that the <code>Content-Type</code> is wrong on the link I posted above. Always something.... :) Need to fix that.</p>",
        "id": 176121256,
        "sender_full_name": "James Agnew",
        "timestamp": 1568913618
    },
    {
        "content": "<p>I tried to get some other data using that example, e.g., <a href=\"http://hapi.fhir.org/baseR4/Patient/14/$graphql?query={name{text,use,family,given},telecom{text,system}}\" target=\"_blank\" title=\"http://hapi.fhir.org/baseR4/Patient/14/$graphql?query={name{text,use,family,given},telecom{text,system}}\">http://hapi.fhir.org/baseR4/Patient/14/$graphql?query={name{text,use,family,given},telecom{text,system}}</a> or even <a href=\"http://hapi.fhir.org/baseR4/Patient/14/$graphql?query={name{text,use,family,given},gender}\" target=\"_blank\" title=\"http://hapi.fhir.org/baseR4/Patient/14/$graphql?query={name{text,use,family,given},gender}\">http://hapi.fhir.org/baseR4/Patient/14/$graphql?query={name{text,use,family,given},gender}</a> and got the same response as without the extra fields.  Is there a schema associated with the graphql endpoint, something I can get via <a href=\"http://hapi.fhir.org/baseR4/$graphql?query={__schema\" target=\"_blank\" title=\"http://hapi.fhir.org/baseR4/$graphql?query={__schema\">http://hapi.fhir.org/baseR4/$graphql?query={__schema</a> {types {name}}} ?</p>",
        "id": 176140929,
        "sender_full_name": "Howard Kong",
        "timestamp": 1568926377
    },
    {
        "content": "<p>there should be, but I haven't got to that for <a href=\"http://test.fhir.org\" target=\"_blank\" title=\"http://test.fhir.org\">test.fhir.org</a> and I don't think that it's been done for <a href=\"http://hapi.fhir.org\" target=\"_blank\" title=\"http://hapi.fhir.org\">hapi.fhir.org</a></p>",
        "id": 176140979,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1568926422
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"237430\">@Howard Kong</span> We also have one you can spin up with the option of enabling a Graphiql interface. It's an open source facade server so it's not connected to a data source and is not currently deployed. However you can easily get it up and running with a couple of npm/yarn commands. It's available at <a href=\"https://github.com/Asymmetrik/graphql-fhir\" target=\"_blank\" title=\"https://github.com/Asymmetrik/graphql-fhir\">https://github.com/Asymmetrik/graphql-fhir</a></p>",
        "id": 176189897,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1568984347
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"196306\">@Robert Winterbottom</span> !</p>",
        "id": 176389606,
        "sender_full_name": "Howard Kong",
        "timestamp": 1569259307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span>  I noticed that in Chrome, but it's ok in Postman, even with no headers specified.</p>",
        "id": 176650089,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1569498086
    },
    {
        "content": "<p>Hi GraphQL'ers . Is graphql powerful enough to support something (sorry for the non-standard yet usefull  dialect):</p>\n<div class=\"codehilite\"><pre><span></span>( Condition(coding=xxx, recorded-date=2019) after(20 days) Medication(coding=yyy) ) and Patient(deaceasedBoolean=true, gender=male)\n</pre></div>\n\n\n<p>this means give me all dead male patients who had a condition  20 days after  one medication. More generally do graphql handles complex operators between resources ? thanks a lot</p>",
        "id": 178334307,
        "sender_full_name": "natus",
        "timestamp": 1571265882
    },
    {
        "content": "<p>in principle it sounds doable. Did you try?</p>",
        "id": 178337951,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1571270046
    },
    {
        "content": "<p>No. I tried to master GraphQL a bit, but I didnt find a way of expressing this.<br>\nI only have the search engine ready to eat that logic (complex relationis between fhir resources)</p>",
        "id": 178359756,
        "sender_full_name": "natus",
        "timestamp": 1571300064
    },
    {
        "content": "<p>any people experimented in GraphQL?</p>",
        "id": 178559474,
        "sender_full_name": "natus",
        "timestamp": 1571512820
    },
    {
        "content": "<p>I can't see why this would not be doable. You may need to add additional arguments to your GraphQL definitions, but GraphQL allows you to define field level resolvers, which can aid in traversing relationships. You can also pass data between parent and child resolvers (check out this link, <a href=\"https://medium.com/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55\" target=\"_blank\" title=\"https://medium.com/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55\">https://medium.com/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55</a>). With this particular query, you might need to think about how these resources are related in FHIR, e.g., who refers to who.  A medication statement can point to a condition which can point to a patient, but patients do not point towards conditions.  Typically in GraphQL you want to think in graphs, but there is no reason why you cannot do aggregations of the data behind the scenes and add a simple custom schema on top.  I have done that for analytics and other things in the past. </p>\n<p>There are a ton of articles about how to represent complex relationships in GraphQL, just try searching some and seeing if any design patterns jump out to you.</p>",
        "id": 178756552,
        "sender_full_name": "Robert Winterbottom",
        "timestamp": 1571751654
    },
    {
        "content": "<p>Hello, our way is to pass a single string parameter that reflect the standard FHIR search. Behind the resolver can pass to desired connector, we have two case:</p>\n<ul>\n<li>the first one is that we are fetching data from a remote RESTful FHIR api, so we simple add the search string directly on path</li>\n<li>the second one is that we search data on our internal database and our parser is able to build SQL query that reflect the db structure to complete the resource.</li>\n</ul>",
        "id": 178834545,
        "sender_full_name": "Michele Korell",
        "timestamp": 1571821158
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198505\">@Michele Korell</span> could you elaborate on what use case you are solving with those two approaches ?</p>\n<p>I also have in mind such syntax (which can be translated into low level database query or other fhir endpoints)</p>\n<div class=\"codehilite\"><pre><span></span>( Condition?coding=xxx&amp;recorded-date=2019 after(patient, recorded-date, date, 20 days) Medication?coding=yyy ) AND Patient?deaceasedBoolean=true&amp;gender=male )\n</pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"196306\">@Robert Winterbottom</span> thanks for the valuable pointers. I definitely have to look how this could be defined within Graphql dialect not to reinvent the wheel. Also I suspect graphQL is not as readible than the above syntax</p>",
        "id": 178985622,
        "sender_full_name": "natus",
        "timestamp": 1571943652
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"198505\">Michele Korell</span> could you elaborate on what use case you are solving with those two approaches ?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"213944\">@natus</span> :</p>\n<p>Actually we developed a standard interface template inTypescript that permits to us to call differents implementations of connector. At front of our microservices we have a GraphQL and REST routes. They call the logic of the microservice that is able using a general query builder to call the standard connector interface. In this way we are able to call databases or others REST/GraphQL APIs. In Switzerland a lot of healthcare software manufacturer still develop proprietary interfaces because they believe that oblige customers keep their solution, our workaround is to build an FHIR based abstraction layer. This layer is able to translate all queries between all employed technologies.<br>\nBy the way, with our experience we found that GraphQL is very flexible for querying from FrontEnd application to a gateway. But for the communication between microservices we didn't found a good strategy to prevent lost of information if some fields are not in the mutation queries.</p>",
        "id": 178995847,
        "sender_full_name": "Michele Korell",
        "timestamp": 1571949995
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Actually I'm working on testing with the specification you provided and did you think that it can be useful specify test scenario with Gherkin syntax?<br>\nfor example we can transform</p>\n<div class=\"codehilite\"><pre><span></span> &quot;description&quot; : &quot;Just a simple test of the basic graphQL engine: a simple query on a known patient (example, from the spec)&quot;,\n</pre></div>\n\n\n<p>to </p>\n<div class=\"codehilite\"><pre><span></span> &quot;description&quot; : &quot;Given a GraphQL patient endpoint When I call the \\&quot;url\\&quot; route Then I get the patient \\&quot;output\\&quot; data&quot;,\n</pre></div>\n\n\n<p>This is just a fast written example, but on our agility organisation we receive UserStories described in this way. Actually Cucumber is developed for a lot of frameworks (<a href=\"https://cucumber.io/docs/installation/\" target=\"_blank\" title=\"https://cucumber.io/docs/installation/\">https://cucumber.io/docs/installation/</a>). In our hospital we use SpecFlow to drive Appium test framework and Cypress for e2e web applications tests.</p>\n<p>What do you think about that?</p>",
        "id": 179002432,
        "sender_full_name": "Michele Korell",
        "timestamp": 1571954690
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198505\">@Michele Korell</span> </p>\n<blockquote>\n<p>By the way, with our experience we found that GraphQL is very flexible for querying from FrontEnd application to a gateway. </p>\n</blockquote>\n<p>Good to know graphQL allows to federate switherland. I would be glad to have a deep look into this. By the way, I am not sure the use case I am looking for is covered by your design: joining resources together with complex criteria (counts, temporal, inner/outer/anti joins)</p>",
        "id": 179121001,
        "sender_full_name": "natus",
        "timestamp": 1572087605
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193729\">@natus</span> in this case I don't understand well what you want really do. Can you provide an example? Try to build the query on a FHIR REST test server and describe how it has to work on graphql.</p>",
        "id": 179159392,
        "sender_full_name": "Michele Korell",
        "timestamp": 1572161519
    },
    {
        "content": "<p>Do you guys know if it would be feasible to make a GraphQL adapter over a FHIR REST API (without GraphQL support)?</p>",
        "id": 182699963,
        "sender_full_name": "Kendall Park",
        "timestamp": 1575577473
    },
    {
        "content": "<p>I believe it's feasible</p>",
        "id": 182700849,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575578130
    },
    {
        "content": "<p>I'm trying to figure out how much work it would be, and whether someone else is already attempting a similar project. There are existing resources for using GraphQL with REST API's (<a href=\"https://github.com/apollographql/apollo-link-rest\" target=\"_blank\" title=\"https://github.com/apollographql/apollo-link-rest\">https://github.com/apollographql/apollo-link-rest</a>). </p>\n<p>To zoom out a bit, I'm trying to find a more expressive way to query an existing FHIR database. One option is to do a relational DB mirror (eg, fhirbase). Another option is GraphQL. The queries would be used for predictive modeling (training or inference). Like, \"give me these specific lab results from Patient X within the last 24 hours.\"</p>",
        "id": 182702251,
        "sender_full_name": "Kendall Park",
        "timestamp": 1575579132
    },
    {
        "content": "<p>a graphQL proxy on a standard rest interface is very smart but has a real performance penalty that a direct DB approach wouldn't have</p>",
        "id": 182702525,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575579276
    },
    {
        "content": "<p>The requirements for training are substantially different than for inference. For training I'd be thinking more about bulk data extraction. For inference... I think it's important to lay out what your goals are.  I sketched out a quick take on how wrapping FHIR REST with Graphql would work <a href=\"https://github.com/jmandel/gra-fhir-ql\" target=\"_blank\" title=\"https://github.com/jmandel/gra-fhir-ql\">back in 2015</a> and was pretty happy with it functionally -- but this approach will never be faster than REST API access.</p>",
        "id": 182702553,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1575579298
    },
    {
        "content": "<p>The performance is going to be worse, but the relational mirror will come with its own headaches (eg, if you want run inference on a particular case on demand). You can use the proxy as a stand-in while you wait for GraphQL support in the original system. This is more about creating a sane and generalizable data science pipeline than it is about maximizing performance.</p>",
        "id": 182703613,
        "sender_full_name": "Kendall Park",
        "timestamp": 1575579834
    },
    {
        "content": "<p>If data scientists work directly with the REST API, they'll be making multiple API calls and sifting through a ton of excess data in their Jupyter notebook (or container the model is deployed in). It's a bit unwieldy.</p>",
        "id": 182705915,
        "sender_full_name": "Kendall Park",
        "timestamp": 1575581044
    },
    {
        "content": "<p>yes, data scientists need some ETL running. graphQL is an option. So is sql as discussed om <a class=\"stream\" data-stream-id=\"179219\" href=\"/#narrow/stream/179219-analytics-on-FHIR\">#analytics on FHIR</a></p>",
        "id": 182708116,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575582270
    },
    {
        "content": "<p>though I'm sure a general purpose reusable graphQL proxy would be something that people would like. The HAPI graphQL engine could be used for that - just have to map from the callbacks to the REST API</p>",
        "id": 182708229,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575582345
    },
    {
        "content": "<p>Dear GraphQL-FHIR group, I would love to take a look at the graphql fhir schema, however the provided download link \"<a href=\"http://build.fhir.org/fhir.graph.schema.zip\">http://build.fhir.org/fhir.graph.schema.zip</a>\" 404's. <br>\nIs it deprecated or has it just moved?<br>\nI hope this is the correct place to ask this question and apologize if it is not!</p>",
        "id": 199733450,
        "sender_full_name": "j k",
        "timestamp": 1591270230
    },
    {
        "content": "<p><a href=\"http://build.fhir.org/fhir.schema.graphql.zip\">http://build.fhir.org/fhir.schema.graphql.zip</a></p>",
        "id": 199733620,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1591270358
    },
    {
        "content": "<p>is this it?</p>",
        "id": 199733623,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1591270361
    },
    {
        "content": "<p>exactly! thanks for the quick response.</p>",
        "id": 199733855,
        "sender_full_name": "j k",
        "timestamp": 1591270560
    },
    {
        "content": "<p>Is there a library or something we could use to directly and easily convert GraphQL responses to FHIR resources? Or how could we do this using the JAVA language?</p>",
        "id": 208189422,
        "sender_full_name": "Andreea Dorca",
        "timestamp": 1598516417
    },
    {
        "content": "<p>See duplicate thread <a href=\"#narrow/stream/179166-implementers/topic/GraphQL.20to.20FHIR\">https://chat.fhir.org/#narrow/stream/179166-implementers/topic/GraphQL.20to.20FHIR</a></p>",
        "id": 208225553,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1598539197
    }
]