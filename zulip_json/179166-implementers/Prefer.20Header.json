[
    {
        "content": "<p>rom an implementer: I ran into different behaviors when creating a resource on different FHIR servers that brought up an interesting question. The issue was the following: I was creating a new resource and expecting the full resource back in the response with the ID of the resource populated. Two servers did this by default. One (HAPI) did not. In order to provide a hint to the server to return the full resource rather than just the ID, we looked at the specification, in particular the ‘prefer’ header. The specification states that servers can choose either behavior as the default but that callers can specify which one the prefer using the prefer header. That part is great. However, it then states that server implementors SHOULD honor this. This brings us back to square one in the sense that one still is not sure what one is going to get. We thought that if this is not a MUST, then at least adherence to prefer should be specified in the conformance statement in some way. Yet, we could not find where one could find this in the conformance statement.</p>",
        "id": 153822070,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460771472
    },
    {
        "content": "<p>It's a fair point. Can someone remind me why respecting the <code>prefer</code> header isn't a MUST? </p>",
        "id": 153822074,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1460777350
    },
    {
        "content": "<p>I can't find the record</p>",
        "id": 153822078,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460777761
    },
    {
        "content": "<p>I think that it is implied by RFC 7240:<br>\n\"The Prefer request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.\"</p>",
        "id": 153822079,
        "sender_full_name": "Peter Scholz",
        "timestamp": 1460789005
    },
    {
        "content": "<p>I would say it's a MUST. On most interfaces we have, we're only using the http responseCode and/or full resource. Also normally develop without operationOutcome responses as errors are more useful in original format (except for 400-499 errors). </p>",
        "id": 153822083,
        "sender_full_name": "Kevin Mayfield",
        "timestamp": 1460792632
    },
    {
        "content": "<p>I'm curious why so many people seem to want servers to return the resource that they just sent it. It doesn't seem useful to me, but obviously lots of people disagree.</p>",
        "id": 153822323,
        "sender_full_name": "James Agnew",
        "timestamp": 1460998766
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> I think it may be because many of the RESTful frameworks do this as default behaviour. People simply have an expectation that this is 'what you do'. </p>",
        "id": 153822324,
        "sender_full_name": "Andy Stechishin",
        "timestamp": 1460999042
    },
    {
        "content": "<p>As well, servers aren't required to store exactly what they're given, so if you want to do a subsequent update, passing back what was actually stored saves you from having to do a GET before submitting an update.</p>",
        "id": 153822325,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1460999426
    },
    {
        "content": "<p>And James, in this case, whatever is the default behavior by the server, the ask is that it be predictable somehow. In the current spec, it is unpredictable.</p>",
        "id": 153822328,
        "sender_full_name": "Claude Nanjo",
        "timestamp": 1461001688
    },
    {
        "content": "<p>I thought we had determined the default to be to not return the resource as this conserved bandwidth.</p>",
        "id": 153822329,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1461002000
    },
    {
        "content": "<p>no. we said that the default behavior was up to the server since this allows them to decide what is optimal in their context. the prefer header is used to make the behaviour predictable</p>",
        "id": 153822330,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461002736
    },
    {
        "content": "<p>We could always say something to the effect of \"Servers SHALL return the updated resource content if they do not support the <code>Prefer</code> header\", which would help on the predictability front</p>",
        "id": 153822333,
        "sender_full_name": "James Agnew",
        "timestamp": 1461007235
    },
    {
        "content": "<p>That seems like a reasonable suggestion <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> </p>",
        "id": 153822360,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461011260
    },
    {
        "content": "<p>But then there is no place to \"register\" that the server supports the prefer header? (nothing in conformance)</p>",
        "id": 153822361,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461011329
    },
    {
        "content": "<p>Maybe this needs to be a part of the patient track at connectathons to get people aware that this can happen.</p>",
        "id": 153822362,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461011368
    },
    {
        "content": "<p>If we are going to allow Servers to do just one choice of send or not send resource then I'd rather the not send is the default. Alternately if severs are required to support both then clients can set their expected behaviour by using the Prefer header.</p>",
        "id": 153822363,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1461011442
    },
    {
        "content": "<p>I find it useful to read the new id from it, for when I don't have access to the response headers.</p>",
        "id": 153822382,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1461019778
    },
    {
        "content": "<p>when would you not have access to the response headers?</p>",
        "id": 153822389,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461021074
    },
    {
        "content": "<p>XSLT? Although I'm not doing this in XSLT. I'll stop being lazy and add the Prefer header.</p>",
        "id": 153822408,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1461026866
    },
    {
        "content": "<p>In order to for you to be assured to get the 'Prefered' behaviour we would need to require servers to follow the Prefer header whereas the current behaviour is might follow.</p>",
        "id": 153822422,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1461048002
    },
    {
        "content": "<p>right. I'm ambivalent about this. From a client's point of view,  it would be good to have that the server SHALL observe the prefer header. But it seems to me that there's lots of times I'm writing a server where I know which I'm going to do, and forcing the server to check the prefer header is overhead, particularly since it's about optimization</p>",
        "id": 153822424,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461048137
    },
    {
        "content": "<p>In Vadim's case if he provides the Prefer header and the server is allowed to ignore then he is 'hooped'.</p>",
        "id": 153822426,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1461048201
    },
    {
        "content": "<p>well, if the server doesn't return the content, yes</p>",
        "id": 153822431,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461052235
    },
    {
        "content": "<p>Life is no game of wishful thinking,<br>\nThe RFC defining the Prefer Header does state that it is solely at the discretion of the server what amount it returns. The prefer return header allows the server to take into consideration what the client wishes. That's exactly how it is defined in FHIR when it reads a sever SHOULD honor the header. A MUST definition is contrary to the RFC </p>",
        "id": 153822477,
        "sender_full_name": "Peter Scholz",
        "timestamp": 1461082584
    },
    {
        "content": "<p>Otherwise, I guess the header would have been called \"Require\" rather than \"Prefer\" I guess</p>",
        "id": 153822580,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461142562
    },
    {
        "content": "<p>So then this will work just fine in all cases except for when it doesn't - does that provide the needed level of consistency and assurance?</p>",
        "id": 153822721,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1461228160
    },
    {
        "content": "<p>It should work fine for everyone, except for those clients making false assumptions</p>\n<p>If you do ask for a minimal return, you can ignore the body if the server does not honor the Prefer return header.<br>\nIf you need the resource persisted, and the server does not honor the return=represenstion, you can take the ID from the header an perform a read.</p>\n<p>So where's the point ?</p>",
        "id": 153822722,
        "sender_full_name": "Peter Scholz",
        "timestamp": 1461231762
    },
    {
        "content": "<p>Functionally, as long as those who need the Id can obtain it correctly from the location header then their need will be satisfied. <br>\nYou are correct, the the return of unncessary content, or the lack of supression of that through ignoring of the Prefered header, does not present a fundamentatl problem, it is merely a waste. Some will care, others will not.</p>",
        "id": 153822723,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1461235553
    },
    {
        "content": "<p>It's like everywhere else,<br>\nthose who follow the specs will have no problem, those who don't might fail</p>\n<p>And the spec for Prefer headers is RFC 7240</p>",
        "id": 153822724,
        "sender_full_name": "Peter Scholz",
        "timestamp": 1461235811
    },
    {
        "content": "<p>That's true. It is unfortunate the spec wasn't written to effectively manage the waste, but it is what it is. Ewout is also correct and maybe a Required header would better meet the need.</p>",
        "id": 153822725,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1461236032
    },
    {
        "content": "<p>IMHO there is no need,<br>\neveryone implementing his client correctly will be able to gain the amount of information he needs.<br>\nMost servers will honor the Prefer return, as they don't want to waste bandwidth and performance<br>\nIt's the same as the Accept-Encoding Header indicating if client might support gzip compression on content<br>\nSome servers will honor it and send compressed content, others won't. Thats the way HHTP works well for quite a while now.</p>\n<p>we should not try to take all burden away from the clients, and put it on the shoulder of the servers.</p>",
        "id": 153822726,
        "sender_full_name": "Peter Scholz",
        "timestamp": 1461236486
    },
    {
        "content": "<p>if w3c had defined a required header, we would have used it.</p>",
        "id": 153822727,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461242714
    },
    {
        "content": "<p>So, I admit this isn't my area of strength, but I've been following this conversation, and don't understand why you don't want to make it a requirement  the server SHALL honor the header? I realize that this is stronger than the RFC, but we layer more stringent requirements on underlying standards in other places.<br>\nAlso, although a client can deal with the different server behaviors, it adds complexity--the client needs be prepared to try two different approaches. First, I'd rather put complexity on the server, than the client. Secondly, if most servers have one behavior, many client implementers might not even recognize they should be prepared to encounter the other behavior.</p>",
        "id": 153822760,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1461258533
    },
    {
        "content": "<blockquote>\n<p>If you do ask for a minimal return, you can ignore the body if the server does not honor the Prefer return header.<br>\nIf you need the resource persisted, and the server does not honor the return=represenstion, you can take the ID from the header an perform a read.</p>\n</blockquote>\n<p>This is actually what the .NET API does do hide these differences for the client: when return=representation and the server does not obey the prefer header, the .NET API will send out a GET, and return the representation to the client after all.</p>",
        "id": 153823199,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461694028
    },
    {
        "content": "<p>That's a good idea!</p>\n<p>I'm stealing it. :)</p>",
        "id": 153823784,
        "sender_full_name": "James Agnew",
        "timestamp": 1461934129
    },
    {
        "content": "<p>Technically, you're not stealing this, since this was the outcome of the discussion between me, Grahame and yourself in Paris ;-) You've just forgotten about it ;-)</p>",
        "id": 153824179,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1462217660
    },
    {
        "content": "<p>And this conversation has reminded me to implement it in my server (done yesterday)</p>",
        "id": 153824290,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1462230657
    },
    {
        "content": "<p>If the client sends <code>Prefer: return=minimal</code>, is the server allowed to return an OperationOutcome? This has always been my understanding, but as Lloyd points out the spec seems to indicate that the options are either the created/update resource body or no body at all (see <a href=\"http://hl7-fhir.github.io/http.html#2.1.0.5.2\" target=\"_blank\" title=\"http://hl7-fhir.github.io/http.html#2.1.0.5.2\">here</a> )</p>",
        "id": 153834692,
        "sender_full_name": "James Agnew",
        "timestamp": 1466734317
    },
    {
        "content": "<p>Client's need to be able to handle the OperationOutcome case anyway for when the validation/save fails, and the results are returned.</p>",
        "id": 153834697,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1466734839
    },
    {
        "content": "<p>The question is: Can a Create return an OperationOutcome on a success?</p>",
        "id": 153834729,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1466736722
    },
    {
        "content": "<p>My understanding is that on a success, you either get back nothing or a copy of the resource that was created.</p>",
        "id": 153834730,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1466736738
    },
    {
        "content": "<p>Could you pass back warnings to the client using this mechanism?</p>",
        "id": 153834731,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1466737191
    },
    {
        "content": "<p>Errors cause a fail, warnings are happy for the save to complete, but do want to inform that something happened.</p>",
        "id": 153834732,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1466737234
    },
    {
        "content": "<p>Yes, that would be the purpose.</p>",
        "id": 153834734,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1466737259
    },
    {
        "content": "<p>Anyone logged the tracker yet to suggest this change?<br>\n(which some of us appear to have thought was the case anyway)</p>",
        "id": 153834738,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1466737427
    },
    {
        "content": "<p>Well, the problem is that there's sometimes a need to echo back the created resource (because you want to see what actually got stored - often not exactly what you sent).  And you can't do both a copy of the created resource and an OperationOutcome, even though both might sometimes be relevant.</p>",
        "id": 153834741,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1466737518
    },
    {
        "content": "<p>I say that if you think there's utility in returning hints and warnings (seems like a big waste to me) you need it whether you want to hte body of the resource or not - that's an orthogonal issue. </p>",
        "id": 153834744,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466737724
    },
    {
        "content": "<p>so the alternative is a X-FHIR-Notes header, that has an operation outcome in json</p>",
        "id": 153834745,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466737751
    },
    {
        "content": "<p>Technically, we could put two resources in the Body too, but I think that would be less expected.</p>",
        "id": 153834747,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1466737800
    },
    {
        "content": "<p>But I'm correct that right now, OperationOutcome is prohibited as a response to a successful create, correct?  (Because that's not what HAPI does right now.)</p>",
        "id": 153834748,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1466737830
    },
    {
        "content": "<p>right. that's not conformant</p>",
        "id": 153834753,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466738342
    },
    {
        "content": "<p>The idea of putting an OperationOutcome in a header is a non-starter unfortunately.</p>\n<p>I experimented with this for a little bit, every create/update would get a header with an OO containing the validation results. As I quickly discovered, several pretty fundamental bits of web infrastructure (apache server, squid proxy, probably others) don't like header values longer than 1024 characters without special configuration. This is just asking for trouble.</p>\n<p>Using a repeating header with a note in each repetition (i.e. not encoded in an OO) could be an option. Is there any reason not to allow an OO back though as HAPI is (currently incorrectly) doing? I think this behaviour should be allowable.. will file a tracker unless there is objection.</p>",
        "id": 153834787,
        "sender_full_name": "James Agnew",
        "timestamp": 1466761590
    },
    {
        "content": "<p>well, the problem is that we have 2 difference choices: OO with warnings or not, and resource or not. And we have one on|off header</p>",
        "id": 153834788,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466764956
    },
    {
        "content": "<p>Yeah, agree this isn't perfect. But would allowing OO on response make things worse? I don't actually see any rationale for not allowing it.</p>",
        "id": 153834805,
        "sender_full_name": "James Agnew",
        "timestamp": 1466770975
    },
    {
        "content": "<p>Well, if we have a usecase for OO on response, then we have a use-case for both OO and payload on response - so the question is, is there any way we can pass back both in a manner that won't be totally surprising/breaking?</p>",
        "id": 153834822,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1466781271
    },
    {
        "content": "<p>I don't see any way that is nice.. You could</p>\n<ul>\n<li>Return a bundle with two entries (blech)</li>\n<li>Use an operation and return the two things in a Parameters (only slightly less blech)</li>\n</ul>\n<p>Nonetheless, I don't think that means we shouldn't allow the OO back by itself. Tracker filed.</p>",
        "id": 153834844,
        "sender_full_name": "James Agnew",
        "timestamp": 1466788980
    },
    {
        "content": "<p>I'm sure FHIR already has a position on this, but what about a multi-part response?</p>",
        "id": 153834856,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1466793877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191380\">@Elliot Silver</span> I was thinking the same - is there a prohibition against having multiple payloads in the body (without going to Bundle)?</p>",
        "id": 153834860,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1466796848
    },
    {
        "content": "<p>It seems to me that would accomplish the same thing as returning a bundle, but in a perhaps less client-friendly way.</p>",
        "id": 153834862,
        "sender_full_name": "James Agnew",
        "timestamp": 1466798449
    },
    {
        "content": "<p>yes  much less friendly</p>",
        "id": 153834863,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466798501
    },
    {
        "content": "<p>I don't actually see a usecase for returning the OO in this topic</p>",
        "id": 153834864,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466798586
    },
    {
        "content": "<p>I like to use it to return validation results</p>",
        "id": 153834865,
        "sender_full_name": "James Agnew",
        "timestamp": 1466798612
    },
    {
        "content": "<p>The other use-case is to warn about data that you've ignored or changed from what was submitted.</p>",
        "id": 153834866,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1466800406
    },
    {
        "content": "<p>If you echo back the content, they can see what you did, but they don't have any information as to \"why?\".</p>",
        "id": 153834867,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1466800442
    },
    {
        "content": "<p>neither of these are use cases. What does the client do with it other than ignore it?</p>",
        "id": 153834878,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466806396
    },
    {
        "content": "<p>In our case, they just log it. Obviously not a clinical use case if that's the bar, but we find it quite useful for debugging.</p>",
        "id": 153834879,
        "sender_full_name": "James Agnew",
        "timestamp": 1466806608
    },
    {
        "content": "<p>really belongs in the header then. According to the http standards mailing list, headers over 8k in length are common, so I'm surprised to heara it's a problem</p>",
        "id": 153834900,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466843716
    },
    {
        "content": "<p>That surprises me.</p>\n<p>I looked it up, and the max length in <a href=\"https://tomcat.apache.org/tomcat-7.0-doc/config/http.html\" target=\"_blank\" title=\"https://tomcat.apache.org/tomcat-7.0-doc/config/http.html\">Tomcat is 8k</a> (not 1k as I remembered) oddly enough. According to <a href=\"http://stackoverflow.com/questions/1097651/is-there-a-practical-http-header-length-limit\" target=\"_blank\" title=\"http://stackoverflow.com/questions/1097651/is-there-a-practical-http-header-length-limit\">this link</a> Apache is also 8k, IIS 6 is 16k, and NGINx is 4k or 8k depending on platform.</p>\n<p>Obviously that gives a fair bit of room, but the validator certainly managed to exceed the 8k limit when I had it running for people's casual testing.</p>\n<p>I dunno, I'd feel uncomfortable recommending a solution that requires reconfiguring something as basic as Apache. There are lots of situations where this type of configuration isn't accessible to you, and this isn't something that fails gracefully.</p>",
        "id": 153835155,
        "sender_full_name": "James Agnew",
        "timestamp": 1467046863
    },
    {
        "content": "<p>well, all that makes sense. What this comes to is: there's no un-surprising way to return both a resource and hints and warnings about it. And there's no way to manage a split two-way choice which is what we logically have here either</p>",
        "id": 153835190,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467060541
    },
    {
        "content": "<p>Well, given that the OperationOutcome isn't persisted, if there's a need for both to come back, the logical thing would be to return the OperationOutcome and let the client query for the created resource if they need that too.  But that behavior would be \"surprising\" from a RESTful perspective to most systems.</p>",
        "id": 153835200,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1467061239
    },
    {
        "content": "<p>I dunno, I guess I'm in the minority here but I just don't find that behaviour surprising at all. Basically every (non-FHIR) REST API we have here at UHN follows the same pattern for POSTing data: You send it data in whatever structure it requires, and it replies with a much smaller and entirely different structure that contains any relevant status information about what it did.</p>\n<p>To me, returning the same entity that it just received is the surprising behaviour. I get that there are valid reasons to do this, but banning returning a status object is just odd to me.</p>",
        "id": 153835203,
        "sender_full_name": "James Agnew",
        "timestamp": 1467061699
    },
    {
        "content": "<p>What about a header on  the request that identifies whether the client wants back the saved resource (default), the OperationOutcome, or (in a multipart response) both? This gives the \"usual\" RESTful behaviour*, but also gives the option for info that a more advanced client can make use of.<br>\n(*I'm going to go with  that spelling, given James, Lloyd, and Grahame's participation on the thread.)</p>",
        "id": 153835208,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1467062037
    },
    {
        "content": "<p>oh man if we have corrupted an American into spelling <code>behaviour</code>correctly, this whole FHIR adventure has been worth it.</p>",
        "id": 153835211,
        "sender_full_name": "James Agnew",
        "timestamp": 1467062304
    },
    {
        "content": "<p>Sorry <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> , not to invalidate your experience, but as a Canadian, I've always spelt it correctly.</p>",
        "id": 153835213,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1467062492
    },
    {
        "content": "<p>lol ok I thought you were.... but your comment made me think otherwise :p</p>",
        "id": 153835214,
        "sender_full_name": "James Agnew",
        "timestamp": 1467062749
    },
    {
        "content": "<p>well, the prefer header is more than just minimal vs representation. it's extensible, and servers are requried to ignore values they do not understand. </p>",
        "id": 153835216,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467063020
    },
    {
        "content": "<p>so we could define a value 'warnings' to indicate that the client wishes for the server to return an OperationOutcome instead of the full resource </p>",
        "id": 153835217,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467063057
    },
    {
        "content": "<p>+1</p>",
        "id": 153835219,
        "sender_full_name": "James Agnew",
        "timestamp": 1467063117
    },
    {
        "content": "<p>Something like this in the prefer header? <br>\nreturn=minimal<br>\nreturn=representation<br>\nreturn=outcome</p>",
        "id": 153835291,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1467075586
    },
    {
        "content": "<p>well, suggested: <br>\nreturn=minimal<br>\nreturn=representation<br>\nreturn=warnings</p>",
        "id": 153835295,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467075691
    },
    {
        "content": "<p>but the exact word is not important</p>",
        "id": 153835296,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467075697
    },
    {
        "content": "<p>warnings wouldn't be clear that you were always after the OperationOutcome, regardless of the result.<br>\n(which is how I'd interpretted what this discussion was after, and would be happy with)</p>",
        "id": 153835310,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1467076487
    },
    {
        "content": "<p>outcome isn't obvious that you don't want the outcome of the posting the resource ;-)</p>",
        "id": 153835311,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467076530
    },
    {
        "content": "<p>make it explicit<br>\n<code>Prefer: return=operationoutcome</code></p>",
        "id": 153835312,
        "sender_full_name": "James Agnew",
        "timestamp": 1467076604
    },
    {
        "content": "<p>:) This one.</p>",
        "id": 153835316,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1467076909
    },
    {
        "content": "<p>That last suggestion would be okay I guess. Contrary to James I'd totally expect the same resource back after a create/update from a RESTful service, never something entirely different (except on 400+).</p>",
        "id": 153835430,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1467113049
    },
    {
        "content": "<p>time for a task. <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=10250\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=10250\">GF#10250</a></p>",
        "id": 153835507,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467142683
    },
    {
        "content": "<p>The spec is quiet about how to represent multiple prefer headers...</p>\n<p><a href=\"http://hl7.org/implement/standards/fhir/search.html#errors\" target=\"_blank\" title=\"http://hl7.org/implement/standards/fhir/search.html#errors\">http://hl7.org/implement/standards/fhir/search.html#errors</a></p>\n<ul>\n<li>Prefer: handling=strict: Client requests that the server return an error for any unknown or unsupported parameter</li>\n<li>Prefer: handling=lenient: Client requests that the server ignore any unknown or unsupported parameter</li>\n</ul>\n<p><a href=\"http://hl7.org/implement/standards/fhir/http.html#prefer\" target=\"_blank\" title=\"http://hl7.org/implement/standards/fhir/http.html#prefer\">http://hl7.org/implement/standards/fhir/http.html#prefer</a></p>\n<ul>\n<li>Prefer: return=minimal</li>\n<li>Prefer: return=representation</li>\n<li>Prefer: return=OperationOutcome</li>\n</ul>\n<p><a href=\"http://hl7.org/implement/standards/fhir/async.html#3.1.6.2.0.1\" target=\"_blank\" title=\"http://hl7.org/implement/standards/fhir/async.html#3.1.6.2.0.1\">http://hl7.org/implement/standards/fhir/async.html#3.1.6.2.0.1</a></p>\n<ul>\n<li>Prefer: respond-Async</li>\n</ul>\n<p>Specifically how you might request for search strict and Async.</p>",
        "id": 161109974,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1552955907
    },
    {
        "content": "<p>Per <a href=\"https://tools.ietf.org/html/rfc7240\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc7240\">https://tools.ietf.org/html/rfc7240</a> section 2, either comma-separated or two separate Prefer headers are both accepted.</p>",
        "id": 161110527,
        "sender_full_name": "Paul Church",
        "timestamp": 1552956609
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 161110669,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1552956824
    }
]