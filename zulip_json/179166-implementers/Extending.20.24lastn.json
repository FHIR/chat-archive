[
    {
        "content": "<p>NLM has been working with SmileCDR to get $lastn implemented in HAPI FHIR, and we have some extra capabilities we would like add to the $lastn specification:</p>\n<p>1) $lastn takes a category or a code.  We would like be able to specify multiple codes (and get back n Observations per code).<br>\n2) $lastn takes a patient.  We would like to be able to specify multiple patients, and get back n Observations per patient/code combination.<br>\n3) If no codes are specified, return n of each code per patient.<br>\n4) If no patients or codes are specified, return n of each distinct code (across all patients).  This is one we are less certain about, but it would be useful for getting a list of unique codes actually used in the database.  The more consistent interpretation would be n of each code/patient combination, but we think that would not be useful to anyone working with a realistically-sized data set.</p>\n<p>There is also the issue that Observation takes a CodeableConcept, so it can have more than one code, but for simplicity in considering the above, let's assume one code per Observation which (I am told) is usually the case.</p>",
        "id": 195784445,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1588204121
    },
    {
        "content": "<p>I don't understand 3 - if no codes are specified, return n of the codes that aren't specified?</p>",
        "id": 195784506,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588204182
    },
    {
        "content": "<p>3 would be of all the codes that exist for that patient on that server</p>",
        "id": 195791862,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1588212279
    },
    {
        "content": "<p>For the multiple patients and multiple codes, it might be nice to point to a group or a value set, respectively</p>",
        "id": 195791867,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1588212301
    },
    {
        "content": "<p>what if there's 100s of codes? What if they are grouped or not by CodeableConcept?</p>",
        "id": 195792084,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1588212668
    },
    {
        "content": "<p>If there are 100s of codes, you'd get a lot of data - probably bulk data retrieval time if you did it for all patients</p>",
        "id": 195792364,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1588213097
    },
    {
        "content": "<p>In our flowsheet demo (<a href=\"https://lhcflowsheet.nlm.nih.gov/\" title=\"https://lhcflowsheet.nlm.nih.gov/\">https://lhcflowsheet.nlm.nih.gov/</a>, click \"select patient\") we typically pull in 1000 or more observations at once, so 100s of codes is not necessarily an issue depending \"n\" and the number patients.</p>",
        "id": 195848112,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1588257424
    },
    {
        "content": "<p>With regards to 3- I don't know if this is even technically feasible, but a reasonable approach might be for the server to be allowed to reject the request if there are so many codes that it can't reasonably answer, but to answer otherwise.. This feels consistent with how other things work to me.</p>\n<p>In terms of \"what about CodeableConcept with multiple codes\".. We could perhaps allow a syntax similar to in search where you could ask for <code>|http://loinc.org</code> which means that you'd get any LOINC codes but not any equivalents?</p>",
        "id": 195856064,
        "sender_full_name": "James Agnew",
        "timestamp": 1588260386
    },
    {
        "content": "<p>I would think the amount of data  returned  at once would be constrained by the server's page size (possibly set by _count).</p>",
        "id": 195858648,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1588261469
    },
    {
        "content": "<p>For (3), the number of possible (patient, code) combinations can be a real concern (and thus limiting its usefulness), as implied in <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> 's post. One possible approach is to interpret the \"subject\" parameter as a \"filter\", that is, it limits the code set to those that appear in the records of the given  subject(s). When no subject(s) is provided, it includes all the codes in all observations. This interpretation is consistent across all the four use cases and should be practical for implementation as well. For use case(2), it can be achieved using batched/bundle of operations based on (1), without incurring too much overhead. For example, for randomly selected 100 patients in the (moderate) Regenstrief 10K data set, there are about 20K patient-code combinations, which is probably the practical limit for what you can do in real time applications.</p>",
        "id": 195862643,
        "sender_full_name": "Xiaocheng Luan",
        "timestamp": 1588263013
    },
    {
        "content": "<p>It's not easy to paginate the response if the number of combinations gets out of control. You can constrain the amount of data returned per page but the server probably needs to be able to marshal the entire result set.</p>",
        "id": 195867949,
        "sender_full_name": "Paul Church",
        "timestamp": 1588265258
    },
    {
        "content": "<p>Just to add to Paul Lynch's and Xiaocheng's comments, for numbers 1, 2 and 3, I believe the idea is that $lastn would return a list of observations ordered and grouped first by Subject (if more than one is specified) and then Observation Code (if more than one is specified). For 3, if no Observation Codes are provided, then all Observation codes applicable for the patient(s) would be included in the result set. </p>\n<p>Its understood that the result set could potentially be extremely large depending on the number of patients and observation codes. This is intentional as one of the intended purposes would be to generate large data sets for research purposes. Assuming that the server is able to handle the query and that the observations in the response are ordered by Subject and Code, it should be possible to paginate the response if needed.</p>\n<p>For number 4, the use case that NLM is trying to address is that they need a way to retrieve the list of distinct Observation codes for all Observations in the repository. The idea here would be to adapt the $lastn operation so that if it is invoked with no subject params and no code params, it would simply return the last N most recent Observation resource(s) for each distinct Observation code. If the max param is set to 1, it would simply return the most recent Observation resource for each distinct Observation code in the database. </p>\n<p>Paul and Xiaocheng - feel free to correct or add to my comments above.</p>",
        "id": 196245774,
        "sender_full_name": "Ian Marshall",
        "timestamp": 1588630164
    }
]