[
    {
        "content": "<p>Having a chat with one of the attendees at the Conformance WGM,  requires me to get some clarification on supported vs 1..1 cardinality</p>\n<p>A element with a cardinality of 1 \"may not\" be supported by the receiving system but a supported element may be empty.  Does it mean that all supported elements have to have a cardinality 1..1? </p>\n<p>Any help is appreciated.  Thanks</p>\n<p><span class=\"user-mention\" data-user-id=\"192433\">@Heather Patrick</span></p>",
        "id": 155185030,
        "sender_full_name": "Joel Francis",
        "timestamp": 1547571227
    },
    {
        "content": "<p>no they don't. You can have must-support elements with a 0..[something] cardinality.</p>",
        "id": 155186119,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1547572092
    },
    {
        "content": "<p>from: <a href=\"https://www.hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.mustSupport\" target=\"_blank\" title=\"https://www.hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.mustSupport\">https://www.hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.mustSupport</a></p>",
        "id": 155186209,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1547572189
    },
    {
        "content": "<p>If true, implementations that produce or consume resources SHALL provide \"support\" for the element in some meaningful way. If false, the element may be ignored and not supported. If false, whether to populate or use the data element in any way is at the discretion of the implementation.</p>",
        "id": 155186226,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1547572199
    },
    {
        "content": "<blockquote>\n<p>no they don't. You can have must-support elements with a 0..[something] cardinality.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191451\">@Patrick Werner</span>  thanks. So a missing element with a cardinality of 1..1 is non-conformant with a profile that deems it 1..1 where as a must supported  is allowed to be empty or have the element missing completely?</p>",
        "id": 155186351,
        "sender_full_name": "Joel Francis",
        "timestamp": 1547572277
    },
    {
        "content": "<p>The latter. Empty Elements are not allowed.</p>",
        "id": 155186644,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1547572501
    },
    {
        "content": "<blockquote>\n<p>The latter. Empty Elements are not allowed.</p>\n</blockquote>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"191450\">@Simone Heckmann</span></p>",
        "id": 155186830,
        "sender_full_name": "Joel Francis",
        "timestamp": 1547572667
    },
    {
        "content": "<p>Cardinality is validation focused, where must-support is implementation focused. 1..1 with must-support=false doesn't make logical sense, but is technically allowed. ( At least i haven't found something forbidding it)</p>",
        "id": 155188142,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1547573793
    },
    {
        "content": "<p>I think I remeber someone mentioning once that implementations could theoretically comply with 1..1 requirements without actually supporting the element in any meaningful way by e.g. populating the element with hardcoded values...</p>",
        "id": 155190322,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1547575594
    },
    {
        "content": "<p>that is very much the case</p>",
        "id": 155190864,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1547576074
    },
    {
        "content": "<p>I'm still not getting how conceptually data is required to be present, but it's okay for the receiving system not to support it.</p>",
        "id": 155192869,
        "sender_full_name": "Heather Patrick",
        "timestamp": 1547577538
    },
    {
        "content": "<blockquote>\n<p>I'm still not getting how conceptually data is required to be present, but it's okay for the receiving system not to support it.</p>\n</blockquote>\n<p>I think as <span class=\"user-mention\" data-user-id=\"191451\">@Patrick Werner</span>  describes it,  it may be required that the information be present but a particular receiving system with not-supported = false will not be required to process that element and may even choose to ignore it.</p>",
        "id": 155194077,
        "sender_full_name": "Joel Francis",
        "timestamp": 1547578441
    },
    {
        "content": "<p>If I'm reading it right: 1..1 means that the element has to be present for the resource to be valid.  So if mustSupport is false, that means that the profile doesn't particularly care about that element, though they still aren't allowed to drop the element entirely.  So a producer could populate it with a hard coded value, and a consumer could ignore it, and both would be compliant with the profile.  If the producer didn't include the element or the consumer threw an error when the element is populated, they would be in violation of the base spec.</p>",
        "id": 155195739,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1547579623
    },
    {
        "content": "<p>Must Support is defined for each implementation and describes the expected behavior of both parties and the server requirement may indeed be different from the client.   i.e. the server must represent the data in the must support element and the client must not raise an error if it is supplied.  - here there is very little expectation on the client.</p>",
        "id": 155203323,
        "sender_full_name": "Eric Haas",
        "timestamp": 1547585612
    },
    {
        "content": "<p>A good example is Patient.deceased[x].  You certainly wouldn't ever make it mandatory (unless you're a death reporting application), but you might make it mustSupport (system must be capable of sending if it applies, receiver must be capable of receiving and doing something useful with it.)</p>",
        "id": 155205997,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1547587738
    },
    {
        "content": "<p>We have a use case for List where the only value for mode is \"snapshot\". In the resource mode is 1..1. In our profile mode is fixed to \"snapshot\" but is not \"must support\". The writer has to populate it with \"snapshot\", and the reader can ignore it.</p>",
        "id": 155215978,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1547597495
    },
    {
        "content": "<p>Wow, this sounds suspiciously like the \"RE\" in V2 conformance?   The notion was that if the sender has the data they are Required to send it but if they don't then the value can be Empty.   (I don't remember the receiver requirements.)    Is this FHIR notion a similar conformance construct?</p>",
        "id": 155253629,
        "sender_full_name": "John Silva",
        "timestamp": 1547645826
    },
    {
        "content": "<p>it's similar, yes</p>",
        "id": 155254418,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1547646721
    },
    {
        "content": "<p>The fact that the authors of implementation guides define the behavior of Must Support means it can be exactly like RE or can be subtly or markedly different.</p>",
        "id": 155255339,
        "sender_full_name": "Eric Haas",
        "timestamp": 1547647487
    },
    {
        "content": "<p>The specific meaning of \"must support\" is actually IG/profile-specific.  The profile or IG is required to define the meaning in the context of that IG.  Possibilities include: must expose on a screen, must store, must consider in processing logic, etc.</p>",
        "id": 155255357,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1547647498
    },
    {
        "content": "<p>Last week, we had the opportunity to discuss our implementation profiles with Lloyd M. and Iryna R., and one of the key pieces of feedback was to avoid profiling with 0..0, even with out strictly outbound/egress resources, and to use the MustSupport flag to indicate to implementers that data will be sent in the elements flagged as \"MustSupport\", if available (whether the field is 0..1, 0..<em>, 1..1, 1..</em>, etc). <br>\nOne of the key reasons cited for leaving the unused elements unchanged was to maintain flexibility, in the event that those elements were  introduced in a later update to our implementation.</p>\n<p>Is this the approach that most implementers/profiles are taking? I've seen that the Argonaut project has adopted the MustSupport approach, while Nictiz in the Netherlands is not using MustSupport but also not using 0..0 for unused fields (<a href=\"https://simplifier.net/nictizstu3-zib2017/nl-core-patient\" target=\"_blank\" title=\"https://simplifier.net/nictizstu3-zib2017/nl-core-patient\">https://simplifier.net/nictizstu3-zib2017/nl-core-patient</a>). Meanwhile, Finland is not using MustSupport, and is using the 0..0 to indicate unused fields (e.g. <a href=\"https://simplifier.net/finnishphr/fiphr-patient-stu3\" target=\"_blank\" title=\"https://simplifier.net/finnishphr/fiphr-patient-stu3\">https://simplifier.net/finnishphr/fiphr-patient-stu3</a>).</p>\n<p>Just wanted to get an assessment of how widespread this approach is, e.g. using MustSupport to indicate that a field is sent, and lack of MustSupport to indicate otherwise. <br>\n(I did look at <a href=\"#narrow/stream/179177-conformance/topic/.22Mute.22.20button.20for.20StructureDefinition.20elements\" title=\"#narrow/stream/179177-conformance/topic/.22Mute.22.20button.20for.20StructureDefinition.20elements\">https://chat.fhir.org/#narrow/stream/179177-conformance/topic/.22Mute.22.20button.20for.20StructureDefinition.20elements</a>, plus many other threads, for the current discussions/thoughts on the topic)</p>\n<p>A second question, how are people handling situations where the base resource definition allows 0..<em>, but your system only supplies 0..1 (egress) or allows/consumes for 0..1 (ingress)? For example, <a href=\"http://patient.name\" target=\"_blank\" title=\"http://patient.name\">patient.name</a> is 0..</em>, but we only ever send back one <a href=\"http://patient.name\" target=\"_blank\" title=\"http://patient.name\">patient.name</a> from our repository. Are implementers/profilers profiling this as 0..1, or are they leaving it as 0..<em>, and defining a 0..1 slice w/ MustSupport? How do you codify the discriminant of a single instance that may not have any distinguishing values, aside from forcibly applying one, e.g. forcing the instance to have patient.name.use=official? Or in the case of something less distinguishable, patient.address.line being 0..2 instead of 0..</em> -- is there a way to have a blank discriminant, for all the elements where we constrain from 0..* to 0..1? That's a lot of extra noise for an implementer to parse in a profile, instead of a strict contraint from 0..* down to 0..1.</p>",
        "id": 158385648,
        "sender_full_name": "Ken Sinn",
        "timestamp": 1550004025
    },
    {
        "content": "<p>Incidentally, I was looking at the Argonaut profile for patient, and noticed that patient.name.family is 1..* -- doesn't that result in non-conformance against the FHIR standard, where patient.name.family is 0..1?</p>",
        "id": 158385950,
        "sender_full_name": "Ken Sinn",
        "timestamp": 1550004301
    },
    {
        "content": "<p>Argonaut is based on STU2, where family was also 0..*</p>",
        "id": 158386327,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550004652
    },
    {
        "content": "<p>Profiling the \"emitting\" side is sort of a question of cost now vs. cost later.  If you only emit one now and are confident that there's zero chance in the next 30 years that you'll ever emit more than one, then defining slices that distinguish your current \"1\" from amongst a possible selection of others is unnecessary.  However, if you define 0..1 now and then in two years start emitting 2 or 3, you can't do that without forcing clients who built to the original interface to update their interfaces.  Even if they continue to only display 1, they'd have no way of knowing which one to display.  However, if you take the slicing approach, then an implementer who rolls out the original interface will happily tolerate the presence of additional repetitions, even though they're only exposing one - because the slicing rules told them which one to grab.</p>\n<p>So - more effort to define (and understand) the profiles, but simpler and lower-cost upgrade path because there's not a need to coordinate and do a big-bang update.</p>",
        "id": 158386738,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550005000
    },
    {
        "content": "<p>Profiling the consuming side has the same sort of thing.  If you expect systems to only supply 1, but in the future might allow multiple, then you might want to require the inclusion of metadata now that will distinguish what \"kind\" of repetition is being sent when there might be more than one kind in the future.   (E.g. use=\"official\").  However, the consuming side adds on the question of whether you expect clients to talk <em>only</em> to your system or whether they'll be talking to others as well.  If clients will be talking to multiple systems and you impose constraints prohibiting data you could ignore, then that means the client is forced to create (and maintain) a custom interface to talk to your server.  That will drive two things - increased costs for clients, and/or decreased number of clients that can talk to your server.  It will also increase migration costs because if you add support for things you used to prohibit, you'll either need to force everyone to migrate simultaneously or you'll have to maintain and manage multiple interfaces on the server side (and handle conversion) as you share data between systems that are providing a new element and systems that are told to prohibit it.</p>",
        "id": 158387163,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550005336
    },
    {
        "content": "<p>So for both exposing and consuming profiles, whenever there's a constrain down from 0..* to 0..1, all such elements need to be sliced for must-support, if we were to adopt these best practices? Should these best practices be documented somewhere, other than here in the chats, as an official FHIR recommended approach?<br>\nAs demonstrated by our own profiles, and those of finland and netherlands, this approach is un-intuitive (maybe just for lack explicit documentation) -- it's very different from the v2 and v3 approaches, and is worth fully expanding upon, if this is FHIR's position. Otherwise, leaving \"Must-Support\" to be defined by implementers leaves signifant gaps, and goes no further in supporting interoperability if not everyone is adopting the same approach.</p>",
        "id": 158387514,
        "sender_full_name": "Ken Sinn",
        "timestamp": 1550005669
    },
    {
        "content": "<p>If you're consuming and want to allow for receiving more than one in the future, then yes slicing would be best practice.  We've committed to writing some profiling best practices, but other things have gotten in the way of that.</p>\n<p>I strongly agree that slicing isn't terribly intuitive to define or to read when looking at profiles.  The intuitive reaction of most first time profilers is indeed to just constrain cardinality - even though that might not be the most desirable thing from a long-term cost perspective.</p>",
        "id": 158387735,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550005820
    },
    {
        "content": "<p>I would not like to slice just for must-support on the first slice. And given the information gap implicit in must-support (see my blog here <a href=\"http://www.healthintersections.com.au/?p=2908\" target=\"_blank\" title=\"http://www.healthintersections.com.au/?p=2908\">http://www.healthintersections.com.au/?p=2908</a>, and read the comments), it seems unnecssary to slice - just mark it must support and explain what you mean</p>",
        "id": 158431681,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550056364
    },
    {
        "content": "<p>The reason for slicing is to distinguish which \"1\" of the potential many you expect systems to deal with.  Not slicing means the implementer doesn't have the information on how to extract from a potential future collection - which means that changing to a collection in the future becomes much more difficult</p>",
        "id": 158453482,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1550074368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> on a similar related topic, is there any profiling guidance/best-practice around constraining of bindings? For example, consider an outbound/egress profile. There is an element with extensible binding strength, from ValueSet {A,B,C,D,E}, and our interface uses ValueSet {A,B,C,P,Q}. Is the best practice to:<br>\nA) bind to ValueSet {A,B,C,P,Q} and keep the binding as extensible or<br>\nB) bind to ValueSet {A,B,C,P,Q} and keep the binding as required?<br>\nA subsequent/future inbound/ingress profile would produce errors, if values D or E are sent, as they are not accepted.</p>",
        "id": 160100622,
        "sender_full_name": "Ken Sinn",
        "timestamp": 1551883005
    },
    {
        "content": "<p>The general recommendation is to follow Postel's law: be tolerant when receiving and strict when sending.  Extensible also raises some questions as it matters whether P or Q are sub-concepts of A, B, C, D or E.  If the answer is \"yes\" then the expectation is that if you're going to support P or Q, you must accept the corresponding broader concept too.</p>\n<p>In the end, the profile that corresponds to your interface should reflect what you'll accept and what you'll do something useful with.  The binding for an element defines the 'max' value set - the set of codes that won't result in an error if they're met.  The 'min' value set - the set of codes that must actually be supported can be conveyed by an extension.  If you're going to raise an error if a given code is the only one that's present, then it shouldn't be in the max value set and the binding shouldn't be extensible.  (Whether the profile for your implementation is conformant with the base spec is a different question :))</p>",
        "id": 160108882,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1551888508
    },
    {
        "content": "<p>Hello <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> . I wanted to please ask for further clarification. Imagine there is an extensible binding strength value set that has values A, B, C, D, and E. But my implementation will only accept C, D, and E. Can I constrain the value set to just C, D, and E while still keeping binding strength at extensible? Or would I have to support all the values that were in the preferred value set? Or would I have to change the binding strength to a tighter level of constraint (for example, required)? Thank you!</p>",
        "id": 162843494,
        "sender_full_name": "Shamhad Abdi",
        "timestamp": 1554748662
    },
    {
        "content": "<p>When you say \"my implementation will ony accept C, D and E\", does that mean that you won't accept other codes of any sort, nor will you accept just plain text?  If that's the case, then you should have a \"required\" (not 'extensible') binding to C, D and E - and that would be completely conformant.  If you were willing to accept other codes or plain text as well as C, D and E, then you could have a constrained extensible binding, but that wouldn't override the original binding.  I.e. in a situation where A applied, the A code would still have to be sent - you couldn't send another code or plain text where A applied without sending A.</p>",
        "id": 162855298,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1554757742
    }
]