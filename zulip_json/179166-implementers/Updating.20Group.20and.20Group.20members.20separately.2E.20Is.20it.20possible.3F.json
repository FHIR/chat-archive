[
    {
        "content": "<p>I am hoping to gather some insight on the best way to implement the Group resource as a REST API.<br>\nWhat we're trying to do: <br>\n1. Create, destroy, and update Groups and their descriptions<br>\n2. Add and remove members from any given group without changing other attributes of the group</p>\n<p>My team devised three approaches to doing this:<br>\n1. Have two endpoints: one for modifying the Group by ID as a template, and another for getting the group populated with members and deleting/adding members<br>\n2. Having the member-group relationship resource collection (like a Bundle) available as a sub-endpoint of the template Group resource. /api/Group/{group-id}/member/{member-id or member-group-relationship-id} and the respective collection endpoint.<br>\n3. Passing around a query parameter for whether we are modifying members in a group or the group properties itself. </p>\n<p>The major worry here is that neither of these appear to confirm strictly to FHIR spec. It seems as though the spec indicates that the group resources and all of the contained members are ONE resource, and should be fetched and updated in a unified fashion. </p>\n<p>The problem we face is, if I want to simply modify the attributes of the Group such as the name or characteristics, but don't want to interfere with external traffic (which is rapidly and transactionally inserting/removing members), how can I do it without splitting the resource into two pieces? Even if we use a special identifier to ensure data isn't lost in this process (block out-of-order changes), at some point, the updated resource becomes too large for a single HTTP request. It also means a lot of rejected update requests and retries during heavy load scenarios. This doesn't seem sustainable nor scalable. </p>\n<p>I would appreciate hearing any input on what we ought to do in this case. This is my first post. If I've done it wrong, please feel welcome to move it or instruct me to do so!</p>",
        "id": 154008563,
        "sender_full_name": "Erik Greif",
        "timestamp": 1539363029
    },
    {
        "content": "<p>If external systems are \"transactionally\" adding and removing members, then they're going to need to query before the addition/removal of a member and ensure that the record hasn't changed when they do their PUT using the <a href=\"http://build.fhir.org/http.html#concurrency\" target=\"_blank\" title=\"http://build.fhir.org/http.html#concurrency\">if-match</a> mechanism.  If that's already in place, then an update to the group name or other metadata would be handled the same as any other update collision - requery, then re-update.</p>\n<p>If the concern is with the volume of data transmitted when updating the resource, you could look at PATCH.</p>",
        "id": 154008565,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1539363357
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> Thank you for the input. We don't have that mechanism in place, but we are looking into it. Patch makes sense. I was mostly worried about removing from groups in that case. I guess that would be a deactivate operation on the members entry, rather than actually removing that member from the list. Since curation of the group's metadata (all except members) is done by manual requests right now, patch would be required because it does not use the if-match.</p>\n<p>As a follow-up, we also want to know whether there is a way to fetch all groups for a member. I forgot to mention this problem earlier... <br>\nWe thought maybe we should get a Bundle of Group resources, and filter based on ?patientId=whatever. Lingering questions are...<br>\n1. Is this operation even supported by FHIR? <br>\n2. Do the bundled Group resources returned contain the member field?<br>\n3. Should we filter to only the given member, or leave all members?</p>",
        "id": 154008579,
        "sender_full_name": "Erik Greif",
        "timestamp": 1539366541
    },
    {
        "content": "<p>You should be able to use <code>[base]/Group?member=Patient/123</code> to grab all groups that the patient is a member of.  You could also tag _summary onto that if you didn't want to see the full member list</p>",
        "id": 154008582,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1539367203
    },
    {
        "content": "<p>Fantastic suggestion, thank you! I didn't know that was how that worked.</p>",
        "id": 154008621,
        "sender_full_name": "Erik Greif",
        "timestamp": 1539372816
    }
]