[
    {
        "content": "<p>We have a new team member that is looking at the XML serialisation used in FHIR.<br>\nWe have a question as to why XML serialises  primitive values in to attributes</p>",
        "id": 153822316,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1460997642
    },
    {
        "content": "<p>So why does FHIR do this<br>\n &lt;name&gt;<br>\n    &lt;use value=\"usual\"/&gt;<br>\n    &lt;given value=\"Jim\"/&gt;<br>\n  &lt;/name&gt;</p>",
        "id": 153822317,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1460997676
    },
    {
        "content": "<p>Instead of this</p>",
        "id": 153822318,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1460997684
    },
    {
        "content": "<p>&lt;name&gt;<br>\n    &lt;use&gt;usual&lt;/use&gt;<br>\n    &lt;given&gt;Jim&lt;/given&gt;<br>\n  &lt;/name&gt;</p>",
        "id": 153822319,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1460997720
    },
    {
        "content": "<p>I know there is a rationale for this and this has been debated extensively in the history of FHIR. I'm struggling to find those reasons documented though.</p>",
        "id": 153822320,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1460997761
    },
    {
        "content": "<p>I seem to recall it had something to do with extensions and/or multiple values....</p>",
        "id": 153822321,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1460997844
    },
    {
        "content": "<p><a href=\"https://thefhirplace.com/2013/03/16/attributes-versus-elements-in-fhir-xml/\" target=\"_blank\" title=\"https://thefhirplace.com/2013/03/16/attributes-versus-elements-in-fhir-xml/\">https://thefhirplace.com/2013/03/16/attributes-versus-elements-in-fhir-xml/</a></p>",
        "id": 153822322,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460997882
    },
    {
        "content": "<p>yes. we hate mixed content</p>",
        "id": 153822331,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461002847
    },
    {
        "content": "<p>I know this horse has _long_ bolted, but it is sad.  Mixed content is not at all hard to handle and this \"It is however, clearly more painful for those using JSON, where any member is now expanded to a complex object: \"birthDate\": {\"value\": \"1973-05-31\"}\" is a ginormous pain in the butt when switching between formats.  Somehow the argument for the more natural \"birthDate\": \"1973-05-31\" in JSON won but the not in XML. :(</p>",
        "id": 153822381,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1461019565
    },
    {
        "content": "<p>P.S. The reason you want mixed content in XML is you can allow richer data, even allowing the value to be more XML if you need, e.g. &lt;birthDate&gt;&lt;year&gt;1973&lt;/year&gt;&lt;month&gt;5&lt;/month&gt;&lt;day&gt;31&lt;/day&gt;&lt;/birthDate&gt;.</p>",
        "id": 153822383,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1461019782
    },
    {
        "content": "<p>(Which obviously breaks stuff, but just making the point.)</p>",
        "id": 153822384,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1461019832
    },
    {
        "content": "<p>mixed data is an absolute pain to handle <br>\n&lt;code&gt;<br>\n  this<br>\n &lt;extension .../&gt;<br>\n  that<br>\n&lt;/code&gt;</p>",
        "id": 153822388,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461021053
    },
    {
        "content": "<p>This is not hard to handle.  You can write rules that disallow it if you really want, but actually this is the power of XML and there's very specific rules about what something like that means and how it should be processed.  All you need to do is handle text as a node.  Anyway, the point is moot; it's clearly to late to change it and besides, JSON can't cope with data structures like that; it just would've been nice to maintain consistency with the JSON representation because, out of the box, most converters convert &lt;birthDate&gt;1973-05-31&lt;birthDate&gt; to \"birthDate\": \"1973-05-31\" and vice versa.  As it is, to get a JSON format from native XML, I now have to use an intermediate step to convert a resource to XML that uses the hated mixed content and then convert to JSON (and vice versa).</p>",
        "id": 153822399,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1461023805
    },
    {
        "content": "<p>You also have to consider the FHIR schema for several cases when converting anyway.</p>",
        "id": 153822401,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1461023934
    },
    {
        "content": "<p>Not with the converter that comes built in to eXist.  It just works out of the box (except for the nuisance value attribute thing).</p>",
        "id": 153822402,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1461024036
    },
    {
        "content": "<p>I doubt it works correctly. How would it know to create a JSON array when there's just one XML value but the FHIR has a max multiplicity of *, for example</p>",
        "id": 153822403,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1461024129
    },
    {
        "content": "<p>It's schema-aware, that's one of the reasons for using the schemaLocation in the internal storage.</p>",
        "id": 153822404,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1461024195
    },
    {
        "content": "<p>Although, admittedly, the only resource I'm using in any significant way is StructureDefinition, so I may not have come up against any edge cases.</p>",
        "id": 153822405,
        "sender_full_name": "Stephen Royce",
        "timestamp": 1461024485
    }
]