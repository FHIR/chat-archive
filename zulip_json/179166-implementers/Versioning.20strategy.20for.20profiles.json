[
    {
        "content": "<p>Hi,</p>\n<p>We are setting up some processes in place to handle versioning of profiles in our project. Basically we have multiple profiles and most of them are used by multiple applications. So when one application needs a breaking change in a profile, it breaks functionality in other applications. I have listed down here some approaches to handle this. Can you please suggest what the best practices are and if there is any other way we can go. </p>\n<p>1. Create a new profile version with a new URL (something like patient-2) --&gt; the application that needs this new profile will send the meta.profile in its resources. I understand that we need to be careful about also fixing references between profiles in this case. <br>\n2. Use canonical URL with version using the pipe token --&gt; again here the application needs to send meta.profile in its resources. This seems to be very similar to approach 1. Only we will not have multiple copies of the Profile. Is this correct?<br>\n3. Packaging --&gt; I understand that this is basically grouping related conformance resources together like a zip and sharing. I am not clear how we leverage this in our case. For example, if we have separate packages for the applications, all the data at the end is going to a common DB. How can data extraction happen? I mean which profile should be considered?<br>\nLooking forward to your support!</p>",
        "id": 174140840,
        "sender_full_name": "Keerthi M",
        "timestamp": 1566826078
    },
    {
        "content": "<p>Different profiles should not cause breaking changes</p>",
        "id": 174141436,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1566826486
    },
    {
        "content": "<p>Hi, sorry, I meant each profile is used by multiple applications.</p>",
        "id": 174142329,
        "sender_full_name": "Keerthi M",
        "timestamp": 1566827138
    },
    {
        "content": "<p>Breaking changes between versions of profiles is certainly possible when the profiles are low-maturity.  Ideally, you'll have a maturity scale where, at some point, you lock profiles (and value sets and other things) down and promise to maintain backward compatibility - such that if you make a breaking change, you have to use a new canonical URL.  In the meantime though, distinguishing profiles by business version is completely reasonable.  Applications should ideally comply with a particular IG version and that IG version will contain (and/or reference) specific profile versions.  If you're receiving inbound data and don't know a priori what version of the IG a given source is using, then it's certainly helpful if the instances declare what profile version(s) they're valid against.  However, in many cases, that's not something you can guarantee.  The alternative is you need to check inbound instances against the various possibilities.</p>",
        "id": 174194195,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1566877477
    },
    {
        "content": "<p>Also note that well-defined profiles try hard not to prohibit extra data, so it's often possible to have instances that comply with multiple profiles even if they have different expectations.</p>",
        "id": 174194209,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1566877517
    },
    {
        "content": "<p>Many thanks for the response! <br>\nOne question about using the canonical url with business version (using the pipe token)..<br>\nin STU3 i see that the meta.profile is of type URI. In R4 it is changed to canonical. <br>\nWe are still currently on STU3. Can we still use the canonical URL with the pipe token in meta.profile of STU3? or is there any other way to handle this?</p>",
        "id": 174200344,
        "sender_full_name": "Keerthi M",
        "timestamp": 1566887443
    },
    {
        "content": "<p>Many tools will just treat the STU3 URI as a canonical as it will work just fine - but that's not guaranteed.  There isn't any other way I'm afraid.</p>",
        "id": 174234390,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1566916139
    },
    {
        "content": "<p>Resurrecting an old thread here but what if it's the norm to version profiles? In my case, we're using a FHIR API as part of a bigger platform that powers all our internal and external apps. There's an API version number associated with the platform that we can cross cut into FHIR using the business version but there doesn't seem like a way to iterate on IG, Profiles and StructureDefinition safely. Ideally, we could version our IGs in a semantic fashion and allow every client to pin to a semantic version and get both binary and behavior that matches the version requested.</p>\n<p>For example, in v1.0.0 of our platform API we might add field A to patient. In v1.1.0 we might add field B to patient. Our single FHIR API implementation should be smart enough to serve up IGs for both v1.0.0 and v1.1.0 and we can have clients pinning to either version at any time. </p>\n<p>Is there any facility to have a client specify business version in a request similar to the fhirVersion Accept header?</p>",
        "id": 242215729,
        "sender_full_name": "Mike Lohmeier",
        "timestamp": 1623335415
    },
    {
        "content": "<p>You can't generally specify what profile you want when you're requesting data.  A system will express all data it has for a resource that you're allowed to see - and that interface will comply with whatever profiles (and profile versions) it complies with.</p>",
        "id": 242219304,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1623336644
    },
    {
        "content": "<p>Typically profiles are all up-versioned with each new release of the implementation guide they're part of (whether the specific profile has changed or not).</p>",
        "id": 242219376,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1623336672
    },
    {
        "content": "<p>How do you guarantee clients won't break then? While most clients have no problems with minor version changes like adding a new field but it will break some clients.</p>",
        "id": 242220493,
        "sender_full_name": "Mike Lohmeier",
        "timestamp": 1623337087
    },
    {
        "content": "<p>A good example is an enum. If version 1.0.0 has an enum defined as A,B,C and version 1.1.0 has an enum defined as A,B,C,D we will break any client compiled against v1.0.0 when a value of D is returned.</p>",
        "id": 242221248,
        "sender_full_name": "Mike Lohmeier",
        "timestamp": 1623337364
    },
    {
        "content": "<p>You won't have any enums that can change for versions of a profile unless you're talking about an extension.  Any 'code' elements (e.g. Patient.gender) are tied to the version of FHIR you're using and can't be changed by profile - at least not beyond constraining them.  For extensions, clients would need to be robust against code value sets changing - or the Extension data type should be Coding or CodeableConcept to encourage such robustness.</p>\n<p>You <em>can</em> choose to expose different endpoints for different clients and keep them frozen to particular profile versions if you wish, but that's the only way to control what profiles will be exposed by the endpoint.</p>",
        "id": 242222505,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1623337810
    },
    {
        "content": "<p>hmm thanks. We should be able at the infrastructure level expose a version number of the API in the URL and have the same implementation servicing all versions. It's a bit clunky but it works. I really don't want to pass the buck of reverse compatibility to all clients and not allow clients to pin to a business version.</p>",
        "id": 242354011,
        "sender_full_name": "Mike Lohmeier",
        "timestamp": 1623422163
    }
]