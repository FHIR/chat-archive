[
    {
        "content": "<p>JS implementation coming along.</p>",
        "id": 153810682,
        "sender_full_name": "Admin",
        "timestamp": 1448012661
    },
    {
        "content": "<p>Whoa, hey Grahame!</p>",
        "id": 153810684,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448014329
    },
    {
        "content": "<p>Demo was updated - <a href=\"http://niquola.github.io/fhirpath-demo/#/\" target=\"_blank\" title=\"http://niquola.github.io/fhirpath-demo/#/\">http://niquola.github.io/fhirpath-demo/#/</a></p>",
        "id": 153810690,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1448018613
    },
    {
        "content": "<p>Here is syntax of jsquery from postgresql guys - <a href=\"https://github.com/postgrespro/jsquery\" target=\"_blank\" title=\"https://github.com/postgrespro/jsquery\">https://github.com/postgrespro/jsquery</a></p>",
        "id": 153810695,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1448018940
    },
    {
        "content": "<p>Oh yeah, I forgot about that. The symbols are pretty cryptic at first look ;-)</p>",
        "id": 153810696,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448018995
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 153810697,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448019138
    },
    {
        "content": "<p>hi</p>",
        "id": 153810699,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448019912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I don't understand when you managed to sign up and join. I was in the room with you the whole time.</p>",
        "id": 153810700,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448019936
    },
    {
        "content": "<p>I still don't understand `.distinct(path,path). Can you help with an example, <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> </p>",
        "id": 153810702,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023066
    },
    {
        "content": "<p>ok, so there's a rule: if you say that an element has more than one type, then the different types must have a different code, or if you have more than one type with the same code, they have to have different profiles </p>",
        "id": 153810703,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023254
    },
    {
        "content": "<p>e,g. you couldn't say element value[x] choice of boolean | boolean</p>",
        "id": 153810704,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023269
    },
    {
        "content": "<p>but you might say element value[x] : choice of Reference(Patient) | Reference(Person)</p>",
        "id": 153810705,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023300
    },
    {
        "content": "<p>hence, invariant on ElementDefinition:</p>\n<p>type.distinct(code,profile)</p>",
        "id": 153810706,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023329
    },
    {
        "content": "<p>So that's the use case. Now help me understand how it applies, as a rule, to data. Each of the two <code>path</code> arguments to <code>distinct()</code> returns a collection. How do I decide, based on those two collections, whether <code>distinct()</code> returns <code>[true]</code> or <code>[false]</code> ?</p>",
        "id": 153810707,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023465
    },
    {
        "content": "<p>Also, @<strong>nicola</strong> and I would love to demo our JS FHIRPath implementation in the demo session, if we can?</p>",
        "id": 153810708,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023532
    },
    {
        "content": "<p>Sounds like a good to me, but Ewout controls things</p>",
        "id": 153810709,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023576
    },
    {
        "content": "<p>my rule for distinct: if all the collections are equal, they are not distinct</p>",
        "id": 153810710,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023601
    },
    {
        "content": "<p>collections are equal if they are the same length, and if all the items in order equal each other </p>",
        "id": 153810711,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023630
    },
    {
        "content": "<p>OK. So why can't <code>distinct()</code> be replaced with <code>!=</code> calls?</p>",
        "id": 153810712,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023635
    },
    {
        "content": "<p>clearly, there's an order problem there</p>",
        "id": 153810713,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023643
    },
    {
        "content": "<p>(Also, @<strong>nicola</strong> says we're already on the list. Shows you what I know.)</p>",
        "id": 153810714,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023648
    },
    {
        "content": "<p>huh? how would that work? </p>",
        "id": 153810715,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023649
    },
    {
        "content": "<p>Order problefm?</p>",
        "id": 153810716,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023651
    },
    {
        "content": "<p>for that use cases above, order doesn't matter - they can't differ only in order </p>",
        "id": 153810717,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023682
    },
    {
        "content": "<p>So... sort then do a comparison, is the basic idea? We'll need to specify that.</p>",
        "id": 153810718,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023703
    },
    {
        "content": "<p>we don't have sort. I don't know how to sort some of those things</p>",
        "id": 153810719,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023727
    },
    {
        "content": "<p>distinct is overlapping 'SQL distinct', so someone would think that distinct is a filter</p>",
        "id": 153810720,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1448023728
    },
    {
        "content": "<p>well, I'm open to name questions</p>",
        "id": 153810721,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023741
    },
    {
        "content": "<p>I'd say say for <code>=</code>, to do something like:</p>\n<div class=\"codehilite\"><pre>ElementDefinition.type.where(code = profile).empty()\n</pre></div>",
        "id": 153810722,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023762
    },
    {
        "content": "<p>intersect?</p>",
        "id": 153810723,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1448023773
    },
    {
        "content": "<p>that's a total different rule</p>",
        "id": 153810724,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023785
    },
    {
        "content": "<p>OK, then I'm still not getting it.</p>",
        "id": 153810725,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023796
    },
    {
        "content": "<p>Intersect and union are nice terms that people understand</p>",
        "id": 153810726,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023804
    },
    {
        "content": "<p>you rule says that for the types, none of them can exist where the type.code = type.profile</p>",
        "id": 153810727,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023843
    },
    {
        "content": "<p>my rule is different to that - all the types must be different from each other, in that they must have different types</p>",
        "id": 153810728,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023880
    },
    {
        "content": "<p>I could try something like this: </p>",
        "id": 153810729,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023893
    },
    {
        "content": "<p>Hmm. I guess I need a passing/failing example to understand what you mean.</p>",
        "id": 153810730,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023920
    },
    {
        "content": "<p>pass:<br>\n  Element xxx.value[x]<br>\n    type : boolean<br>\n   type : integer</p>",
        "id": 153810731,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023945
    },
    {
        "content": "<p>fail:</p>",
        "id": 153810732,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023947
    },
    {
        "content": "<p>Element xxx.value[x]<br>\n  type: boolean<br>\n  type: boolean</p>",
        "id": 153810733,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023968
    },
    {
        "content": "<p>pass:</p>",
        "id": 153810734,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448023970
    },
    {
        "content": "<p>Where does the word \"profile\" appear in those? (The second argument to <code>distinct(type, profile)</code> in your example path)?</p>",
        "id": 153810735,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448023992
    },
    {
        "content": "<p>Element xxx.value[x] <br>\n  type : Reference, profile = Patient<br>\n  type: Reference, profile = Person</p>",
        "id": 153810736,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024008
    },
    {
        "content": "<p>fil:</p>",
        "id": 153810737,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024010
    },
    {
        "content": "<p>fail:</p>",
        "id": 153810738,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024011
    },
    {
        "content": "<p>Element xxx.value[x] <br>\n  type : Reference, profile = Patient<br>\n  type: Reference, profile = Patient</p>",
        "id": 153810739,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024015
    },
    {
        "content": "<p>Um. I'm just not getting what this operation does. </p>",
        "id": 153810740,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024074
    },
    {
        "content": "<p>.type() function?</p>",
        "id": 153810741,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1448024080
    },
    {
        "content": "<p>No, <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> is talking about a simple json property of <code>ElementDefinition</code> whose name just happens to be <code>type</code>. </p>",
        "id": 153810742,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024100
    },
    {
        "content": "<p>it says that none of the items in the collection can have the same values for set of nominated expressions as any other item in the collection</p>",
        "id": 153810743,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024146
    },
    {
        "content": "<p>What does it means to \"have.... values for [a]... set of... expressions\"?</p>",
        "id": 153810744,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024169
    },
    {
        "content": "<p>here's my implementation: (in pascal):</p>",
        "id": 153810745,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024171
    },
    {
        "content": "<p>Great ;-)</p>",
        "id": 153810746,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024196
    },
    {
        "content": "<p>var<br>\n  table : array of array of TFHIRBaseList;<br>\n  i, j : integer;<br>\n  base : TFHIRBase;<br>\n  distinct : boolean;<br>\nbegin<br>\n  distinct := Context.Count &lt;= 1;<br>\n  try<br>\n    SetLength(table, context.Count);<br>\n    for i := 0 to context.Count - 1 do<br>\n    begin<br>\n      SetLength(table[i], exp.Parameters.Count);<br>\n      base := context[i];<br>\n      for j := 0 to exp.Parameters.Count - 1 do<br>\n        table[i][j] := evaluate(base, exp.Parameters[j]);<br>\n    end;<br>\n    for i := 0 to context.Count - 1 do<br>\n      for j := i+1 to context.Count - 1 do<br>\n        if areDistinct(table[i], table[j]) then<br>\n        begin<br>\n          distinct := true;<br>\n          break;<br>\n        end;<br>\n  finally<br>\n    for i := 0 to context.Count - 1 do<br>\n      for j := 0 to exp.Parameters.Count - 1 do<br>\n        table[i][j].Free;<br>\n  end;<br>\n  result := TFHIRBaseList.Create;<br>\n  result.Add(TFhirBoolean.Create(distinct));</p>",
        "id": 153810747,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024199
    },
    {
        "content": "<p>lose the indent... ouch</p>",
        "id": 153810748,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024208
    },
    {
        "content": "<p>Add ``` before/after your code block for code fomatting</p>",
        "id": 153810749,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024212
    },
    {
        "content": "<p>...<br>\nfunction TFHIRPathEvaluator.funcDistinct(resource : TFHIRResource; originalContext, context: TFHIRBaseList; exp: TFHIRPathExpression): TFHIRBaseList;<br>\nvar<br>\n  table : array of array of TFHIRBaseList;<br>\n  i, j : integer;<br>\n  base : TFHIRBase;<br>\n  distinct : boolean;<br>\nbegin<br>\n  distinct := Context.Count &lt;= 1;<br>\n  try<br>\n    SetLength(table, context.Count);<br>\n    for i := 0 to context.Count - 1 do<br>\n    begin<br>\n      SetLength(table[i], exp.Parameters.Count);<br>\n      base := context[i];<br>\n      for j := 0 to exp.Parameters.Count - 1 do<br>\n        table[i][j] := evaluate(base, exp.Parameters[j]);<br>\n    end;<br>\n    for i := 0 to context.Count - 1 do<br>\n      for j := i+1 to context.Count - 1 do<br>\n        if areDistinct(table[i], table[j]) then<br>\n        begin<br>\n          distinct := true;<br>\n          break;<br>\n        end;<br>\n  finally<br>\n    for i := 0 to context.Count - 1 do<br>\n      for j := 0 to exp.Parameters.Count - 1 do<br>\n        table[i][j].Free;<br>\n  end;<br>\n  result := TFHIRBaseList.Create;<br>\n  result.Add(TFhirBoolean.Create(distinct));<br>\nend;<br>\n...</p>",
        "id": 153810750,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024253
    },
    {
        "content": "<p>And do ```pascal at the beginning for syntax highlighting</p>",
        "id": 153810751,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024253
    },
    {
        "content": "<div class=\"codehilite\"><pre><span class=\"k\">function</span> <span class=\"nc\">TFHIRPathEvaluator</span><span class=\"o\">.</span><span class=\"nf\">funcDistinct</span><span class=\"p\">(</span><span class=\"n\">resource</span> <span class=\"o\">:</span> <span class=\"n\">TFHIRResource</span><span class=\"o\">;</span> <span class=\"n\">originalContext</span><span class=\"o\">,</span> <span class=\"n\">context</span><span class=\"o\">:</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span> <span class=\"nb\">exp</span><span class=\"o\">:</span> <span class=\"n\">TFHIRPathExpression</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span>\n<span class=\"k\">var</span> <span class=\"n\">table</span> <span class=\"o\">:</span> <span class=\"k\">array</span> <span class=\"k\">of</span> <span class=\"k\">array</span> <span class=\"k\">of</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span>\n<span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"kt\">integer</span><span class=\"o\">;</span>\n<span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">TFHIRBase</span><span class=\"o\">;</span>\n</pre></div>",
        "id": 153810752,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024261
    },
    {
        "content": "<p>do what? </p>",
        "id": 153810753,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024284
    },
    {
        "content": "<div class=\"codehilite\"><pre>    ```pascal\n   some\n   code\n   here\n   ```\n</pre></div>",
        "id": 153810754,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024305
    },
    {
        "content": "<div class=\"codehilite\"><pre><span class=\"k\">function</span> <span class=\"nc\">TFHIRPathEvaluator</span><span class=\"o\">.</span><span class=\"nf\">funcDistinct</span><span class=\"p\">(</span><span class=\"n\">resource</span> <span class=\"o\">:</span> <span class=\"n\">TFHIRResource</span><span class=\"o\">;</span> <span class=\"n\">originalContext</span><span class=\"o\">,</span> <span class=\"n\">context</span><span class=\"o\">:</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span> <span class=\"nb\">exp</span><span class=\"o\">:</span> <span class=\"n\">TFHIRPathExpression</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span>\n<span class=\"k\">var</span>\n  <span class=\"n\">table</span> <span class=\"o\">:</span> <span class=\"k\">array</span> <span class=\"k\">of</span> <span class=\"k\">array</span> <span class=\"k\">of</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span>\n  <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"kt\">integer</span><span class=\"o\">;</span>\n  <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">TFHIRBase</span><span class=\"o\">;</span>\n  <span class=\"n\">distinct</span> <span class=\"o\">:</span> <span class=\"kt\">boolean</span><span class=\"o\">;</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">distinct</span> <span class=\"o\">:=</span> <span class=\"n\">Context</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n  <span class=\"k\">try</span>\n    <span class=\"nb\">SetLength</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"o\">,</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Count</span><span class=\"p\">)</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n    <span class=\"k\">begin</span>\n      <span class=\"nb\">SetLength</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">,</span> <span class=\"nb\">exp</span><span class=\"o\">.</span><span class=\"n\">Parameters</span><span class=\"o\">.</span><span class=\"n\">Count</span><span class=\"p\">)</span><span class=\"o\">;</span>\n      <span class=\"n\">base</span> <span class=\"o\">:=</span> <span class=\"n\">context</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">;</span>\n      <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"nb\">exp</span><span class=\"o\">.</span><span class=\"n\">Parameters</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n        <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">:=</span> <span class=\"n\">evaluate</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"o\">,</span> <span class=\"nb\">exp</span><span class=\"o\">.</span><span class=\"n\">Parameters</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">])</span><span class=\"o\">;</span>\n    <span class=\"k\">end</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n      <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"k\">to</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n        <span class=\"k\">if</span> <span class=\"n\">areDistinct</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">,</span> <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">])</span> <span class=\"k\">then</span>\n        <span class=\"k\">begin</span>\n          <span class=\"n\">distinct</span> <span class=\"o\">:=</span> <span class=\"k\">true</span><span class=\"o\">;</span>\n          <span class=\"k\">break</span><span class=\"o\">;</span>\n        <span class=\"k\">end</span><span class=\"o\">;</span>\n  <span class=\"k\">finally</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n      <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"nb\">exp</span><span class=\"o\">.</span><span class=\"n\">Parameters</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n        <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">Free</span><span class=\"o\">;</span>\n  <span class=\"k\">end</span><span class=\"o\">;</span>\n  <span class=\"bp\">result</span> <span class=\"o\">:=</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">.</span><span class=\"n\">Create</span><span class=\"o\">;</span>\n  <span class=\"bp\">result</span><span class=\"o\">.</span><span class=\"n\">Add</span><span class=\"p\">(</span><span class=\"n\">TFhirBoolean</span><span class=\"o\">.</span><span class=\"n\">Create</span><span class=\"p\">(</span><span class=\"n\">distinct</span><span class=\"p\">))</span><span class=\"o\">;</span>\n<span class=\"k\">end</span><span class=\"o\">;</span>\n</pre></div>",
        "id": 153810755,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024318
    },
    {
        "content": "<p>Backticks</p>",
        "id": 153810756,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024322
    },
    {
        "content": "<p>You can edit your last message :-)</p>",
        "id": 153810757,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024329
    },
    {
        "content": "<p>great. and also this: </p>",
        "id": 153810758,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024354
    },
    {
        "content": "<div class=\"codehilite\"><pre><span class=\"k\">function</span> <span class=\"nc\">TFHIRPathEvaluator</span><span class=\"o\">.</span><span class=\"nf\">areDistinct</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"o\">,</span> <span class=\"n\">a2</span> <span class=\"o\">:</span> <span class=\"k\">array</span> <span class=\"k\">of</span> <span class=\"n\">TFHIRBaseList</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"kt\">boolean</span><span class=\"o\">;</span>\n<span class=\"k\">var</span>\n  <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"kt\">integer</span><span class=\"o\">;</span>\n  <span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span>\n<span class=\"k\">begin</span>\n  <span class=\"bp\">result</span> <span class=\"o\">:=</span> <span class=\"k\">false</span><span class=\"o\">;</span>\n  <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"n\">opEquals</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">,</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span><span class=\"o\">;</span>\n    <span class=\"k\">try</span>\n      <span class=\"k\">if</span> <span class=\"k\">not</span> <span class=\"n\">convertToBoolean</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">)</span> <span class=\"k\">then</span>\n      <span class=\"k\">begin</span>\n        <span class=\"bp\">result</span> <span class=\"o\">:=</span> <span class=\"k\">true</span><span class=\"o\">;</span>\n        <span class=\"k\">exit</span><span class=\"o\">;</span>\n      <span class=\"k\">end</span><span class=\"o\">;</span>\n    <span class=\"k\">finally</span>\n      <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">Free</span><span class=\"o\">;</span>\n    <span class=\"k\">end</span><span class=\"o\">;</span>\n  <span class=\"k\">end</span><span class=\"o\">;</span>\n<span class=\"k\">end</span><span class=\"o\">;</span>\n</pre></div>",
        "id": 153810759,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024374
    },
    {
        "content": "<p>does this help?</p>",
        "id": 153810760,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024457
    },
    {
        "content": "<p>That helps a ton, in that the code is totally unambiguous :-) (Even if I don't really read Pascal.)</p>",
        "id": 153810761,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024635
    },
    {
        "content": "<p>Also, you gotta admit the fact that <code>pygments</code> handles syntax highlighting for pascal is pretty cool.</p>",
        "id": 153810762,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024655
    },
    {
        "content": "<p>yeah, I figured that piece of pascal wasn't too pascal specific </p>",
        "id": 153810763,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024669
    },
    {
        "content": "<p>yes, the syntax highlighting is sensational</p>",
        "id": 153810764,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448024679
    },
    {
        "content": "<p>(And a feature not supported by Slack ;-))</p>",
        "id": 153810769,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024877
    },
    {
        "content": "<p>BTW, @<strong>nicola</strong>'s demo that we'll show is at <a href=\"https://niquola.github.io/fhirpath-demo\" target=\"_blank\" title=\"https://niquola.github.io/fhirpath-demo\">https://niquola.github.io/fhirpath-demo</a></p>",
        "id": 153810770,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448024935
    },
    {
        "content": "<div class=\"codehilite\"><pre>\n</pre></div>",
        "id": 153810782,
        "sender_full_name": "James Agnew",
        "timestamp": 1448025727
    },
    {
        "content": "<p>oops</p>",
        "id": 153810783,
        "sender_full_name": "James Agnew",
        "timestamp": 1448025744
    },
    {
        "content": "<p>Just testing e-mail integration with updated cron job.</p>",
        "id": 153810838,
        "sender_full_name": "Email Gateway",
        "timestamp": 1448031663
    },
    {
        "content": "<p>Published an npm package <a href=\"https://www.npmjs.com/package/fhirpath.js\" target=\"_blank\" title=\"https://www.npmjs.com/package/fhirpath.js\">fhirpath.js</a>  â€” and a set of <a href=\"https://github.com/jmandel/fhirpath.js/blob/master/test-case-dump.json\" target=\"_blank\" title=\"https://github.com/jmandel/fhirpath.js/blob/master/test-case-dump.json\">test cases</a></p>",
        "id": 153810850,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448062868
    },
    {
        "content": "<ul>\n<li>Added support for <code>$context</code>.</li>\n<li>And support for custom lookup constants</li>\n</ul>",
        "id": 153810852,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448065377
    },
    {
        "content": "<p>need to be specific in the spec that you can't use the characters #13, #10 and #9 in a string literal </p>",
        "id": 153810879,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448112424
    },
    {
        "content": "<p>Josh, are you going to implement FHIR path in XML as well as JSON? </p>",
        "id": 153811108,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448334149
    },
    {
        "content": "<p>Wasn't planning to; I'd say just convert the XML to JSON first if you want to use <code>fhirpath.js.</code></p>",
        "id": 153811109,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448334177
    },
    {
        "content": "<p>if you are, there's a gotcha in XML like there is in JSON - the way resources are included at DomainResource.contained and Bundle.entry</p>",
        "id": 153811110,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448334179
    },
    {
        "content": "<p>then you don't need to worry about ti </p>",
        "id": 153811111,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448334198
    },
    {
        "content": "<p>what's the gotcha there? (I do want to understand it, at least :-))</p>",
        "id": 153811112,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448334212
    },
    {
        "content": "<p>well, we have </p>\n<div class=\"codehilite\"><pre>  <span class=\"nt\">&lt;contained&gt;</span>\n   <span class=\"err\">&lt;</span>[resource]&gt;\n   <span class=\"err\">&lt;</span>/resource]&gt;   \n <span class=\"nt\">&lt;/contained&gt;</span>\n</pre></div>",
        "id": 153811113,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448334265
    },
    {
        "content": "<p>The inner element is XML only, and not included in the path statement</p>",
        "id": 153811114,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448334286
    },
    {
        "content": "<p>Sorry, you're saying that in the following:</p>\n<div class=\"codehilite\"><pre><span class=\"nt\">&lt;Patient&gt;</span>\n  <span class=\"nt\">&lt;contained&gt;</span>\n    <span class=\"nt\">&lt;Practitioner&gt;</span>\n      <span class=\"nt\">&lt;name&gt;&lt;text&gt;</span>John<span class=\"nt\">&lt;/text&gt;&lt;/name&gt;</span>\n    <span class=\"nt\">&lt;/Practitioner&gt;</span>\n  <span class=\"nt\">&lt;/contained&gt;</span>\n<span class=\"nt\">&lt;/Patient&gt;</span>\n</pre></div>\n\n\n<p>to get \"John\", I'd evaluate <code>Patient.contained.name</code> instead of <code>Patient.contained.Practitioner.name</code> ?</p>",
        "id": 153811115,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448335147
    },
    {
        "content": "<p>yes, that's right. </p>",
        "id": 153811116,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335202
    },
    {
        "content": "<p>the path needs to be the same for json and xml </p>",
        "id": 153811117,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335217
    },
    {
        "content": "<p>Agreed on that point, but I'd kind of think that this query is supposed to work with or without the word Practitioner.</p>",
        "id": 153811118,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448335350
    },
    {
        "content": "<p>hah. You might have missed our earlier discussion on that</p>",
        "id": 153811119,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335369
    },
    {
        "content": "<p>We currently allow Type.path only at the entry point, where it stands as a type filter. We allow that because we do this on 90+% of the paths that we have </p>",
        "id": 153811120,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335409
    },
    {
        "content": "<p>Sounds like I did. Skype, or here? Was there a short conclusion?</p>",
        "id": 153811121,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448335412
    },
    {
        "content": "<p>Yeah, OK. But it's not really *doing* anything, is what you're saying.</p>",
        "id": 153811122,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448335429
    },
    {
        "content": "<p>I argued that we should allow this internally in the path as well, so you could have Observation.value[x].CodeableConcept.coding </p>",
        "id": 153811123,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335438
    },
    {
        "content": "<p>but James (mainly) argued back say that was counter-intuitive and also that we already have Observation.valueCodeableConcept </p>",
        "id": 153811124,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335475
    },
    {
        "content": "<p>Ha, argh. That's even worse than I imagined; at least the resource types manifest explicitly in JSON (unlike data element ntypes)</p>",
        "id": 153811125,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448335476
    },
    {
        "content": "<p>and even then this path is not the same as that other path </p>",
        "id": 153811126,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335494
    },
    {
        "content": "<p>so I ended up agreeing with James, and we only allow Type. at the entry point</p>",
        "id": 153811127,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335510
    },
    {
        "content": "<p>and so  <code>Patient.contained.Practitioner.name</code> is not valid</p>",
        "id": 153811128,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335531
    },
    {
        "content": "<p>Well, there was a potential middle ground (that Type is allowed at any resource entry point, rather than just the top-level resource entry point).</p>",
        "id": 153811129,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448335592
    },
    {
        "content": "<p>we didn't discuss that </p>",
        "id": 153811130,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335611
    },
    {
        "content": "<p>I have no strong feeling except that Observation.value[x].CodeableConcept is an abomination :-)</p>",
        "id": 153811131,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448335612
    },
    {
        "content": "<p>James may have an opinion on the middle ground </p>",
        "id": 153811132,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335648
    },
    {
        "content": "<p>or others....</p>",
        "id": 153811133,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> - just seeing how tagging works</p>",
        "id": 153811134,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335676
    },
    {
        "content": "<p>even given the middle ground, it would still be a special case gotcha</p>",
        "id": 153811135,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335707
    },
    {
        "content": "<p>but it's good that you only mild feelings about Observation.value[x].CodeableConcept ;-)</p>",
        "id": 153811136,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448335798
    },
    {
        "content": "<p>so Josh, my implementation of distinct was wrong. here's the debugged version:</p>",
        "id": 153811206,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448495370
    },
    {
        "content": "<div class=\"codehilite\"><pre>\n</pre></div>",
        "id": 153811207,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448495394
    },
    {
        "content": "<div class=\"codehilite\"><pre><span class=\"k\">function</span> <span class=\"nc\">TFHIRPathEvaluator</span><span class=\"o\">.</span><span class=\"nf\">areDistinct</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"o\">,</span> <span class=\"n\">a2</span> <span class=\"o\">:</span> <span class=\"k\">array</span> <span class=\"k\">of</span> <span class=\"n\">TFHIRBaseList</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"kt\">boolean</span><span class=\"o\">;</span>\n<span class=\"k\">var</span>\n  <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"kt\">integer</span><span class=\"o\">;</span>\n  <span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span>\n<span class=\"k\">begin</span>\n  <span class=\"bp\">result</span> <span class=\"o\">:=</span> <span class=\"k\">false</span><span class=\"o\">;</span>\n  <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"n\">opEquals</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">,</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span><span class=\"o\">;</span>\n    <span class=\"k\">try</span>\n      <span class=\"k\">if</span> <span class=\"k\">not</span> <span class=\"n\">convertToBoolean</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">)</span> <span class=\"k\">then</span>\n      <span class=\"k\">begin</span>\n        <span class=\"bp\">result</span> <span class=\"o\">:=</span> <span class=\"k\">true</span><span class=\"o\">;</span>\n        <span class=\"k\">exit</span><span class=\"o\">;</span>\n      <span class=\"k\">end</span><span class=\"o\">;</span>\n    <span class=\"k\">finally</span>\n      <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">Free</span><span class=\"o\">;</span>\n    <span class=\"k\">end</span><span class=\"o\">;</span>\n  <span class=\"k\">end</span><span class=\"o\">;</span>\n<span class=\"k\">end</span><span class=\"o\">;</span>\n\n<span class=\"k\">function</span> <span class=\"nc\">TFHIRPathEvaluator</span><span class=\"o\">.</span><span class=\"nf\">funcDistinct</span><span class=\"p\">(</span><span class=\"n\">ctxt</span> <span class=\"o\">:</span> <span class=\"n\">TFHIRPathExecutionContext</span><span class=\"o\">;</span> <span class=\"n\">context</span><span class=\"o\">:</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span> <span class=\"nb\">exp</span><span class=\"o\">:</span> <span class=\"n\">TFHIRExpressionNode</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span>\n<span class=\"k\">var</span>\n  <span class=\"n\">table</span> <span class=\"o\">:</span> <span class=\"k\">array</span> <span class=\"k\">of</span> <span class=\"k\">array</span> <span class=\"k\">of</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">;</span>\n  <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"kt\">integer</span><span class=\"o\">;</span>\n  <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">TFHIRBase</span><span class=\"o\">;</span>\n  <span class=\"n\">distinct</span> <span class=\"o\">:</span> <span class=\"kt\">boolean</span><span class=\"o\">;</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">distinct</span> <span class=\"o\">:=</span> <span class=\"n\">Context</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n  <span class=\"k\">try</span>\n    <span class=\"nb\">SetLength</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"o\">,</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Count</span><span class=\"p\">)</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n    <span class=\"k\">begin</span>\n      <span class=\"nb\">SetLength</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">,</span> <span class=\"nb\">exp</span><span class=\"o\">.</span><span class=\"n\">Parameters</span><span class=\"o\">.</span><span class=\"n\">Count</span><span class=\"p\">)</span><span class=\"o\">;</span>\n      <span class=\"n\">base</span> <span class=\"o\">:=</span> <span class=\"n\">context</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">;</span>\n      <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"nb\">exp</span><span class=\"o\">.</span><span class=\"n\">Parameters</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n        <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">:=</span> <span class=\"n\">evaluate</span><span class=\"p\">(</span><span class=\"n\">ctxt</span><span class=\"o\">,</span> <span class=\"n\">base</span><span class=\"o\">,</span> <span class=\"nb\">exp</span><span class=\"o\">.</span><span class=\"n\">Parameters</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">])</span><span class=\"o\">;</span>\n    <span class=\"k\">end</span><span class=\"o\">;</span>\n    <span class=\"n\">distinct</span> <span class=\"o\">:=</span> <span class=\"k\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n      <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"k\">to</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n        <span class=\"k\">if</span> <span class=\"k\">not</span> <span class=\"n\">areDistinct</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">,</span> <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">])</span> <span class=\"k\">then</span>\n        <span class=\"k\">begin</span>\n          <span class=\"n\">distinct</span> <span class=\"o\">:=</span> <span class=\"k\">false</span><span class=\"o\">;</span>\n          <span class=\"k\">break</span><span class=\"o\">;</span>\n        <span class=\"k\">end</span><span class=\"o\">;</span>\n  <span class=\"k\">finally</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n      <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"k\">to</span> <span class=\"nb\">exp</span><span class=\"o\">.</span><span class=\"n\">Parameters</span><span class=\"o\">.</span><span class=\"n\">Count</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n        <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">Free</span><span class=\"o\">;</span>\n  <span class=\"k\">end</span><span class=\"o\">;</span>\n  <span class=\"bp\">result</span> <span class=\"o\">:=</span> <span class=\"n\">TFHIRBaseList</span><span class=\"o\">.</span><span class=\"n\">Create</span><span class=\"p\">(</span><span class=\"n\">TFhirBoolean</span><span class=\"o\">.</span><span class=\"n\">Create</span><span class=\"p\">(</span><span class=\"n\">distinct</span><span class=\"p\">))</span><span class=\"o\">;</span>\n<span class=\"k\">end</span><span class=\"o\">;</span>\n</pre></div>",
        "id": 153811208,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448495416
    },
    {
        "content": "<p>Can you clarify what the error was, and whether <a href=\"http://niquola.github.io/fhirpath-demo/#/\" target=\"_blank\" title=\"http://niquola.github.io/fhirpath-demo/#/\">niquola.github.io/fhirpath-demo/#/</a> is susceptible?</p>",
        "id": 153811212,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448516701
    },
    {
        "content": "<p>The error was that I returned true if any of them were differentiable, not all of them </p>",
        "id": 153811213,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448519952
    },
    {
        "content": "<p>looks like your implementation is right to me </p>",
        "id": 153811214,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448519962
    },
    {
        "content": "<p>Gotcha - thanks!</p>",
        "id": 153811218,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448539936
    },
    {
        "content": "<p>Is it worth translating FHIR path expressions to Javascript equivalents?</p>",
        "id": 153811271,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448686402
    },
    {
        "content": "<p>Can you give an example of what you mean? I mean, for a vaguely complicated one? Is the idea that you want to return something human-readable, or something  <code>eval</code>-able? If the latter, why not just return the whole library in a self-evaluating function, with the input already bound?</p>",
        "id": 153811272,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448718073
    },
    {
        "content": "<p>i think I mean the second - just generate a javascript function that returns the output if the query</p>",
        "id": 153811273,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448720050
    },
    {
        "content": "<p>OK -- and the function could be huge? What would you do with said function (i.e. why would you use it instead of just calling the fhirpath evaluator)?</p>",
        "id": 153811274,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720107
    },
    {
        "content": "<p>well, it could be several sub-functions, and a small library too. </p>",
        "id": 153811275,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448720156
    },
    {
        "content": "<p>A pattern for this in JS would be just:</p>\n<div class=\"codehilite\"><pre><span class=\"kd\">function</span> <span class=\"nx\">withExpression</span><span class=\"p\">(</span><span class=\"nx\">expr</span><span class=\"p\">){</span>\n  <span class=\"k\">return</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">target</span><span class=\"p\">){</span>\n    <span class=\"k\">return</span> <span class=\"nx\">fhirpath</span><span class=\"p\">.</span><span class=\"nx\">evaluate</span><span class=\"p\">(</span><span class=\"nx\">expr</span><span class=\"p\">,</span> <span class=\"nx\">target</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>(Note:  this may reverse the order of args from what my actual library expects.)</p>",
        "id": 153811276,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720167
    },
    {
        "content": "<p>and your second question is the on I am asking myself - is it better?</p>",
        "id": 153811277,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448720175
    },
    {
        "content": "<p>So you can pre-bind the expression and get a function you can run against any target.</p>",
        "id": 153811278,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720182
    },
    {
        "content": "<p>well, not against any target,  I think. I would have to generate for specific target  - e.g. a function might look different run against a patient instead of a practitioner</p>",
        "id": 153811279,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448720235
    },
    {
        "content": "<p>By \"target\" I meant a specific resource (i.e. not \"Patient\", but a specific patient resource)</p>",
        "id": 153811280,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720263
    },
    {
        "content": "<p>sure. that would be the idea. </p>",
        "id": 153811281,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448720274
    },
    {
        "content": "<p>Currently the evaluator takes a path and a target as inputs.</p>",
        "id": 153811282,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720275
    },
    {
        "content": "<p>I think you're saying you want a function that just takes a target, and has the path baked-in.</p>",
        "id": 153811283,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720291
    },
    {
        "content": "<p>but if you have a javascript evaulator, is pre-generating code instead better for some kind of conditions? </p>",
        "id": 153811284,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448720298
    },
    {
        "content": "<p>The snippet above shows you how to do this.</p>",
        "id": 153811285,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720299
    },
    {
        "content": "<p>I mean, really optimized code maybe. But it sounds like you're trying to solve a performance problem.</p>",
        "id": 153811286,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720327
    },
    {
        "content": "<p>There are lots of thing we could do to just make the evlauator faster.</p>",
        "id": 153811287,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720343
    },
    {
        "content": "<p>(Like starting from a bunch of hard test cases and profiling it, for a start.)</p>",
        "id": 153811288,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720365
    },
    {
        "content": "<p>if really optimised code is the only reason that would be better, it wouldn't be worth doing</p>",
        "id": 153811289,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448720375
    },
    {
        "content": "<p>I had planned to do it prior to you writing the evaluator, but now I'm thinking it would be a waste of time</p>",
        "id": 153811290,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448720403
    },
    {
        "content": "<p>Fair enough -- sounds like, effectively, a different style for writing an evaluator.</p>",
        "id": 153811291,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448720945
    },
    {
        "content": "<p>do we need to be explicit that '=' is not pointer based but property based?</p>",
        "id": 153811292,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448746314
    },
    {
        "content": "<p>but are these different: </p>\n<p>&lt;code id=\"1\"&gt;<br>\n  &lt;system value=\"http://loinc.org\"/&gt;<br>\n  &lt;code value=\"23\"/&gt;<br>\n&lt;/code&gt;</p>\n<p>&lt;code id=\"2\"&gt;<br>\n  &lt;system value=\"http://loinc.org\"/&gt;<br>\n  &lt;code value=\"23\"/&gt;<br>\n&lt;/code&gt;</p>",
        "id": 153811293,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448747226
    },
    {
        "content": "<p>?</p>",
        "id": 153811294,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448747228
    },
    {
        "content": "<p>I'd like to say they're the same. Otherwise the language is going to get heavy/hard-to-use for dealing with special cases.</p>",
        "id": 153811295,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1448748343
    },
    {
        "content": "<p>I'd like them to be the same, but on what grounds do you exempt things from the equality test? I guess, tad things that are format specific, and not described in the logical model. I'll update the documentation accordingly </p>",
        "id": 153811296,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448756098
    },
    {
        "content": "<p>Except that id is described explicitly </p>",
        "id": 153811297,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448756230
    },
    {
        "content": "<p>And what about resources? Are 2 resources with the same content and different ids equal? I think not</p>",
        "id": 153811298,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448757578
    },
    {
        "content": "<p>I'm just finishing off my Fhir path implementation - been working on it all week. I've been fixing my implementation, the Fhir path statements, the invariants, and the example resources</p>",
        "id": 153811299,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448795096
    },
    {
        "content": "<p>What would be really really nice would be to able to indicate in the Fhir path expression a particular test to inject into the error message</p>",
        "id": 153811300,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448795165
    },
    {
        "content": "<p>It's kind of hard to describe, and it wouldn't always be possible, but sometimes it would save such a lot of debugging - and I can debug. Lots of people wouldn't be</p>",
        "id": 153811301,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448795210
    },
    {
        "content": "<p>Maybe a .log()? Or appending ^ to an operation?</p>",
        "id": 153811302,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448795260
    },
    {
        "content": "<p>I'm down to 135 errors...</p>",
        "id": 153811303,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448795320
    },
    {
        "content": "<blockquote>\n<p>Is it worth translating FHIR path expressions to Javascript equivalents?</p>\n</blockquote>\n<p>I am doing this in the .NET implementation.  But there, I'd need to find a plausible name for the \".\" operation --&gt; moving to a child. So, \"Patient.name.where().count()\" would now turn into   context.Children(\"name\").Where(p=&gt;p.some condition).Count()</p>",
        "id": 153811321,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1448897157
    },
    {
        "content": "<blockquote>\n<p>So you can pre-bind the expression and get a function you can run against any target.</p>\n</blockquote>\n<p>And the .NET parses a FhirPath expression and turns it into a function that you can use to run that expression against an instance. So, in fact you'd get a pre-compiled evaluator based on that expression.  Under the hood, it dynamically creates a function that does the calls as I showed above.</p>",
        "id": 153811322,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1448897219
    },
    {
        "content": "<p>well, is that based on raw JSON, or on yhe .net object model? </p>",
        "id": 153811329,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448939025
    },
    {
        "content": "<p>It's built on top of an abstract model representing \"FHIR data\", which is mostly nested dictionaries, except that elements may repeat</p>",
        "id": 153811331,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1448958072
    },
    {
        "content": "<p>so you can run javascript against that? is this using the dotnet javascript infrastructure? why not just generate C#?</p>",
        "id": 153811333,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1448972711
    },
    {
        "content": "<p>Sorry, missed this reply!  No, it's all .NET based, so there's a .NET parser for FhirPath which produces a dynamically created function that is the parser, which you can repeatedly call without having to parse again.  But it runs against an abstract model of nested dictionaries, not against json or xml per se.</p>",
        "id": 153811422,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1449170543
    },
    {
        "content": "<p>If I do  Patient.name.substring(2,4)  (instead of Patient.name.text.substring()), what will your FhirPath evaluators do?</p>",
        "id": 153811642,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450781202
    },
    {
        "content": "<p>And, presuming my names look like integers, will Patient.name.text.asInteger() produce an array or integers?  What if one of my names is not parseable as an integer?</p>",
        "id": 153811643,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450781377
    },
    {
        "content": "<p>\"This means that Patient.telecom.system = 'phone' will return an empty collection if there is more than one telecom with a use\". Since the \"==\" operator returns a boolean, I assume it is supposed to say \"it returns False if there is more than one telecom with a use\" ?</p>",
        "id": 153811644,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450781672
    },
    {
        "content": "<p>Or do the operations return a collection?  E.g. the \"==\" returns a collection with { True } as the single element?  In which case this is valid:<br>\n(Patient.name.use == 'official').count() ?</p>",
        "id": 153811645,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450781891
    },
    {
        "content": "<p>Patient.name.substring(2,4) would be an empty collection </p>",
        "id": 153811646,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450781974
    },
    {
        "content": "<p>\"* this and the other 3 order related operations can only be used for strings, codes, integers, and decimals\"  I don't think \"code\" is a type in FhirPath....It also means the comparison operations cannot be used on dates?</p>",
        "id": 153811647,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450782046
    },
    {
        "content": "<p>we could remove code from that list - I wrote that before I sorted out the base types </p>",
        "id": 153811648,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782090
    },
    {
        "content": "<p>I avoided oprations on dates, since they're so tricky. A yagni thing...</p>",
        "id": 153811649,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782111
    },
    {
        "content": "<p>asInteger for me only returns an integer on a single string. else it will be an empty collection</p>",
        "id": 153811650,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782152
    },
    {
        "content": "<p>yes Patient.telecom.system = 'phone'  should be false not empty collection </p>",
        "id": 153811651,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782186
    },
    {
        "content": "<p>I have operations returning a collection with a single value. it's usually a boolean </p>",
        "id": 153811652,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782215
    },
    {
        "content": "<p>case op of<br>\n    poEquals: result := TAdvStringSet.Create('boolean');<br>\n    poEquivalent: result := TAdvStringSet.Create('boolean');<br>\n    poNotEquals: result := TAdvStringSet.Create('boolean');<br>\n    poNotEquivalent: result := TAdvStringSet.Create('boolean');<br>\n    poLessThen: result := TAdvStringSet.Create('boolean');<br>\n    poGreater: result := TAdvStringSet.Create('boolean');<br>\n    poLessOrEqual: result := TAdvStringSet.Create('boolean');<br>\n    poGreaterOrEqual: result := TAdvStringSet.Create('boolean');<br>\n    poIn: result := TAdvStringSet.Create('boolean');<br>\n    poPlus: result := TAdvStringSet.Create('string');<br>\n    poMinus: result := TAdvStringSet.Create('string');<br>\n    poConcatenate: result := TAdvStringSet.Create('boolean');<br>\n    poOr: result := TAdvStringSet.Create('boolean');<br>\n    poAnd: result := TAdvStringSet.Create('boolean');<br>\n    poXor: result := TAdvStringSet.Create('boolean');<br>\n    poImplies: result := TAdvStringSet.Create('boolean');<br>\n    poUnion: result := TAdvStringSet.Create(left, right);<br>\n  else<br>\n    raise Exception.Create('not done yet');<br>\n  end;</p>",
        "id": 153811653,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782239
    },
    {
        "content": "<p>technically this is valid : (Patient.name.use == 'official').count() ? - return value will be always be one </p>",
        "id": 153811654,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782377
    },
    {
        "content": "<p>What I find confusing is that we use the term \"collection\" in the FhirPath spec.  Json has a collection, but Xml does not. And we have not described a \"logical\" FHIR model so far.  So, since every operation returns \"a collection of Elements of various types\", saying that the behaviour for \"==\" depends on the fact that something is a \"collection\" (\"comparison is order dependent\") does not sound right.  I think the text should say: \"If == operates on collections with more than one element, order is significant\" ?</p>",
        "id": 153811655,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450782438
    },
    {
        "content": "<p>I am assuming \"a collection\" means \"a list of elements matching the expression so far\"</p>",
        "id": 153811656,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450782469
    },
    {
        "content": "<p>xml has a logical collection </p>",
        "id": 153811657,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782505
    },
    {
        "content": "<p>and your assumption is correct </p>",
        "id": 153811658,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782511
    },
    {
        "content": "<p>Sure, but <a href=\"http://Patient.name\" target=\"_blank\" title=\"http://Patient.name\">Patient.name</a> returns \"a collection of name elements\", not a single name which is a collection!</p>",
        "id": 153811659,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450782534
    },
    {
        "content": "<blockquote>\n<p>and your assumption is correct<br>\nGreat.</p>\n</blockquote>\n<p>So, maybe I should go through the spec for FhirPath and make sure that everywhere we say \"collection\" we mean the resultset, and not \"a repeating element\" ?</p>",
        "id": 153811660,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450782573
    },
    {
        "content": "<p>well, umm, ok. I guess I don't find any confusion here, so it seems like a backwards step to me </p>",
        "id": 153811661,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782826
    },
    {
        "content": "<p>because I don't know what this means: \"a collection of name elements\", not a single name which is a collection!</p>",
        "id": 153811662,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450782842
    },
    {
        "content": "<p>I also have the feeling the spec makes a subtle distinction between selecting something that originates in an Element, and something that does not.  E.g. If I'd execute   myPatient.Evaluate(\"<a href=\"http://Patient.name\" target=\"_blank\" title=\"http://Patient.name\">Patient.name</a>\"), I would get back a collection of Elements, which trace back to the original elements in the POCO \"myPatient\". But if I do, e.g. substring() on a collection, I'd get a set of strings that have no origin in the original data, so cannot be used to select elements from the POCO.   Is FhirPath supposed to make this possible?</p>",
        "id": 153811663,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450782951
    },
    {
        "content": "<blockquote>\n<p>\"All elements in a collection will always have a FHIR type\" </p>\n</blockquote>\n<p>Are we saying FhirPath is always evaluated against a typed model? Is that really necessary?  This means we need the full StructureDefinition parser machinery to evaluate FhirPath?  Or always evaluate it against an in-memory POCO that has type information? I think we should not do that! </p>",
        "id": 153811664,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450783272
    },
    {
        "content": "<p>I don't understand either of these either </p>",
        "id": 153811665,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783311
    },
    {
        "content": "<p>the execution operates against an object model, and the outcomes are always objects </p>",
        "id": 153811666,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783335
    },
    {
        "content": "<p>some queries will return you objects that are also in the original object graph, and some will return new objects. I care about this when presenting outcomes, for instance, but it makes no difference to the evaluation engine</p>",
        "id": 153811667,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783378
    },
    {
        "content": "<p>Why would that be?  You mean high-performance evaluators need to read all instance data into an object model first? </p>",
        "id": 153811668,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450783382
    },
    {
        "content": "<p>again, I don't know what you mean</p>",
        "id": 153811669,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783410
    },
    {
        "content": "<p>you do need some type information to execute properly, yes</p>",
        "id": 153811670,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783451
    },
    {
        "content": "<p>I am not building the .NET FhirPath evaluator against the .NET POCO model, since why would you read data into a POCO if you just want to validate it against FhirPath rules?</p>",
        "id": 153811671,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450783466
    },
    {
        "content": "<p>And also, doing reflection on a POCO is slow.</p>",
        "id": 153811672,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450783482
    },
    {
        "content": "<p>I think you're doing it wrong. I'll tell you why</p>",
        "id": 153811673,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783493
    },
    {
        "content": "<p>your users will mostly use FHIRPath against POCO models. </p>",
        "id": 153811674,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783507
    },
    {
        "content": "<p>it's only validation where you think ohterwise, and that's a special case that's not the general case </p>",
        "id": 153811675,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783531
    },
    {
        "content": "<p>here's how my engines work: </p>",
        "id": 153811676,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783537
    },
    {
        "content": "<p>- they don't know anything about FHIR types. They operate on collections of FHIR base</p>",
        "id": 153811677,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783551
    },
    {
        "content": "<p>Base object</p>",
        "id": 153811678,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783556
    },
    {
        "content": "<p>which comes fom the POCO</p>",
        "id": 153811679,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783562
    },
    {
        "content": "<p>POJO for me</p>",
        "id": 153811680,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783566
    },
    {
        "content": "<p>I have a method for asking the base object for the value of a property</p>",
        "id": 153811681,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783608
    },
    {
        "content": "<p>there's two instantiations of that - one that uses the built in POJO property accessor, and one that users the validation framework</p>",
        "id": 153811682,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783639
    },
    {
        "content": "<p>if reflection is slow, generate something faster. </p>",
        "id": 153811683,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783655
    },
    {
        "content": "<p>that's not magic, and that's what I do for pascal and java - has heaps of uses, being able to iterate the properties</p>",
        "id": 153811684,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783675
    },
    {
        "content": "<p>there's also a method for asking a base type what the type of a property is, but you only need that if you want to check type safety</p>",
        "id": 153811685,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783710
    },
    {
        "content": "<p>I don't think we should let the design of FhirPath be influenced on how WE or you generate stuff.  Unless we REALLY REALLY need typed information in FhirPath we should avoid it.  Where do we need type info in FhirPath?</p>",
        "id": 153811686,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450783746
    },
    {
        "content": "<p>the design of it is not influenced by how you generate stuff. </p>",
        "id": 153811687,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783796
    },
    {
        "content": "<p>here's where I use the type information </p>",
        "id": 153811688,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783857
    },
    {
        "content": "<p>Well, yes, you are assuming you have type information around in a efficent way.  Which I *might* include in my implementation if necessary, but it comes at a cost.</p>",
        "id": 153811689,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450783866
    },
    {
        "content": "<p>we say that if the context is Observation, you can do either code.xx or Observation.code.xx</p>",
        "id": 153811690,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783909
    },
    {
        "content": "<p>I need type information here to allow me to safely ignore the Observation. bit</p>",
        "id": 153811691,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783925
    },
    {
        "content": "<p>I need type information when checking type safety, but you don't need to do that</p>",
        "id": 153811692,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783953
    },
    {
        "content": "<p>I need to be able to list all the children or descendents of an object. I use property iterators to do that. that may or may not be type information, depending on your context</p>",
        "id": 153811693,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450783993
    },
    {
        "content": "<p>or I get a property by name. however that happens; that's an interface for me</p>",
        "id": 153811694,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450784023
    },
    {
        "content": "<p>So, if that's the list, having a type around is optional. Which is fine, it matches my usecase. In fact, I now parse xml/json data to a tree-representation. I can \"parse\" POCO's to the same tree-representation.  Then, I can \"annotate\" this tree with type information from a StructureDefinition  (when it was parsed from a POCO, I don't need to do this -&gt; the information is present in the POCO model).  So, my tree (on which the FhirPath executes) *may* have type information to give better validation or warnings.  In any case, I don't think that so far we should require having types in FhirPath.</p>",
        "id": 153811695,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450784330
    },
    {
        "content": "<p>I got into this when reading about \"datetime\", which is sometimes mentioned as a type and sometimes it is not.  The constant &lt;2015&gt; in a FhirPath expression can currently be both an integer and a datetime I guess, which is what triggered this. Certainly after reading: \"The evaluation engine will automatically elevate constants to the right FHIR type.\".....  I am saying we should not put this in the spec.</p>",
        "id": 153811696,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450784453
    },
    {
        "content": "<p>(Xpath1 worked perfectly without typed information, and we won't try to go where xpath2 went...)</p>",
        "id": 153811697,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450784494
    },
    {
        "content": "<p>I don't see how we can not put it in the spec, and xpath certainly does have types at the primitive level</p>",
        "id": 153811698,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450784511
    },
    {
        "content": "<p>where's the spec again? </p>",
        "id": 153811699,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450784536
    },
    {
        "content": "<p>there's no date type </p>",
        "id": 153811700,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450784582
    },
    {
        "content": "<p>I don't see how those base types are ambiguous or problematic</p>",
        "id": 153811701,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450784600
    },
    {
        "content": "<p>there's one other place I need type information - I need to know whether the object is a primitive or not, and which of the base data types it maps to</p>",
        "id": 153811702,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450784772
    },
    {
        "content": "<p>that's fine on the JSON implementation, but needs type information on xml...</p>",
        "id": 153811703,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450784792
    },
    {
        "content": "<blockquote>\n<p>There are only 5 basic types in FHIRPath: boolean, string, integer, decimal, and datetime</p>\n</blockquote>",
        "id": 153811704,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450784835
    },
    {
        "content": "<blockquote>\n<p>xpath certainly does have types at the primitive level</p>\n</blockquote>\n<p>Sure, and we can keep that, since I can derive that (just like xpath) from the notation of the constants in an expression</p>",
        "id": 153811705,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450784867
    },
    {
        "content": "<p>And \"datetime\" can just be a year so, you can have confusion between a datetime just being the year and an int..</p>",
        "id": 153811706,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450784926
    },
    {
        "content": "<p>hm I read the wrong list. ok, there is ambiguity with regard to a year only. Its' going to be an integer. tough </p>",
        "id": 153811707,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450784988
    },
    {
        "content": "<p>Maybe we should have an explicit syntax for datetime, e.g. #2015#</p>",
        "id": 153811708,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450785639
    },
    {
        "content": "<p>Anyway, I am updating the document to reflect some of our discussion....(not the requirements on typeinfo, though ;-)</p>",
        "id": 153811709,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450785661
    },
    {
        "content": "<p>well, we don't even say whether date time is a string or not </p>",
        "id": 153811710,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450785868
    },
    {
        "content": "<blockquote>\n<p>if the right collection is a URI, and it refers to a value set, value set membership testing will be performed</p>\n</blockquote>\n<p>I think we'd better define an explicit operation for this, instead of overloading the IN operation...</p>",
        "id": 153811711,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450785873
    },
    {
        "content": "<p>No, we don't say that. We do say all primitives have a string representation.</p>",
        "id": 153811712,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450785897
    },
    {
        "content": "<p>E.g. the length() operation is dependent on this</p>",
        "id": 153811713,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450785912
    },
    {
        "content": "<p>yes it's in those that I need to know whether there's a primitive to evaluate on </p>",
        "id": 153811714,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450785933
    },
    {
        "content": "<p>I have updated some of the text of the FhirPath spec to be more elaborate about where we return collections and what asInteger and substring() do when they are executed on a collection with multiple values.</p>",
        "id": 153811715,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450786193
    },
    {
        "content": "<p>I wonder whether Josh/Nikolai have type information...I think they are parsing the json, so they recognize the basic json types, no more...</p>",
        "id": 153811716,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450786260
    },
    {
        "content": "<p>right, They probably haven't run into the date issue. which I haven't either, actually </p>",
        "id": 153811717,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450786287
    },
    {
        "content": "<p>and they would need special logic for the Observation. thing</p>",
        "id": 153811718,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450786364
    },
    {
        "content": "<p>Ah! The fun of actually implementing what we've written....as usual that's when things come up...</p>",
        "id": 153811719,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450786486
    },
    {
        "content": "<p>well, I'll spend some time tomorrow looking into the date question</p>",
        "id": 153811720,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450786563
    },
    {
        "content": "<p>What's the desired behaviour for Patient.name.use.something?  An empty set, or an error that \"use\" does not have children to select?</p>",
        "id": 153811735,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1450871734
    },
    {
        "content": "<p>empty set</p>",
        "id": 153811736,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450872656
    },
    {
        "content": "<p>I will make a compile error</p>",
        "id": 153811737,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1450872667
    },
    {
        "content": "<p>What's the behaviour of your fhirpath evaluator when you try to \"+\" collections with &gt; 1 element or incompatible types?</p>",
        "id": 153811833,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1451917270
    },
    {
        "content": "<p>... empty collection?</p>",
        "id": 153811835,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1452009585
    },
    {
        "content": "<p>yes, empty collection</p>",
        "id": 153811836,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452023629
    },
    {
        "content": "<p>Our grammar only has a notation for \"decimal\", but our type system distinguishes intergers and decimals. So does the evaluation of .valueQuantity.value = 4 (comparing decimal and integer?) differ from .valueQuantity.value = 4.0? Are both regarded as comparisons between decimals?  And for .multipleBirthInteger = 4 and 4.0?  Are you using the type of the (Typed) element to cast the constant to the right type?</p>",
        "id": 153811854,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452066282
    },
    {
        "content": "<p>What's the difference between \"aadf\" + \"qewr\" and \"aadf\" &amp; \"qewr\" ?</p>",
        "id": 153811855,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452066548
    },
    {
        "content": "<p>there's no difference, but it might ne redudant. I added + and &amp; before we really had control over primitives</p>",
        "id": 153811856,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452070875
    },
    {
        "content": "<p>so maybe it isn't needed now? </p>",
        "id": 153811857,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452070886
    },
    {
        "content": "<p>decimal and integer - I don't think the difference matters anywhere?</p>",
        "id": 153811858,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452070903
    },
    {
        "content": "<p>Well, we explicitly mention the two as separate types in FhirPath, so if it doesn't matter, should we remove \"integer\" as a separate type and just have \"decimal\" ?</p>",
        "id": 153811859,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452070970
    },
    {
        "content": "<p>Or does that introduce problems with the comparison operators?</p>",
        "id": 153811860,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452070987
    },
    {
        "content": "<p>it might. </p>",
        "id": 153811861,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452070993
    },
    {
        "content": "<p>integers are decimals with fixed precision </p>",
        "id": 153811862,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452071000
    },
    {
        "content": "<p>I'm busy today and tomorrow. I'll review this on the plane - is that ok?</p>",
        "id": 153811863,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452071033
    },
    {
        "content": "<p>tomorrow is a big day - oldest daughter's 18th birthday </p>",
        "id": 153811864,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452071043
    },
    {
        "content": "<p>Of course. No hurry.</p>",
        "id": 153811865,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452071048
    },
    {
        "content": "<p>So, I take it you are on a plane back home ;-)</p>",
        "id": 153811866,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452071056
    },
    {
        "content": "<p>a few formalities to go through </p>",
        "id": 153811867,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452071056
    },
    {
        "content": "<p>dirvers license!</p>",
        "id": 153811868,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452071066
    },
    {
        "content": "<p>no, I'm home, been home for a few weeks</p>",
        "id": 153811869,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452071100
    },
    {
        "content": "<p>leave in 36 hrs</p>",
        "id": 153811870,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452071110
    },
    {
        "content": "<p>That's ok. I have a few more suggestions to talk through now I have almost fully implemented fhirpath on .net...</p>",
        "id": 153811871,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452071147
    },
    {
        "content": "<p>ok</p>",
        "id": 153811872,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452071160
    },
    {
        "content": "<p>Our grammar currently also allows 4 &gt; 5 &lt;= 6.  I think that's an oversight...</p>",
        "id": 153811873,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452073435
    },
    {
        "content": "<p>how does it allow that?</p>",
        "id": 153811874,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452077885
    },
    {
        "content": "<p>expression  = term (righthand)*<br>\nrighthand   = op term | \".\" function</p>\n<p>term op term op term op term, where op also includes = etc.</p>",
        "id": 153811875,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452080046
    },
    {
        "content": "<p>yes I suppose it does. Is it a problem that you can string together some non-sensical operations? we'll complicate the grammar immensiely if we try to make it explicit which operations are allowed in sequence or not</p>",
        "id": 153811877,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452105870
    },
    {
        "content": "<p>ACtually, no.  It's just that the expression turns into a boolean, like  5 &gt; 6 = true != false (left associative)</p>",
        "id": 153811878,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452108542
    },
    {
        "content": "<p>yes there's lots of valid uses</p>",
        "id": 153811879,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452108574
    },
    {
        "content": "<p>What about  Patient.identifier.where(use = 'official') = Patient.identifier.skip(1) ? </p>",
        "id": 153811880,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452113918
    },
    {
        "content": "<p>Can you 'restart' the context to Patient like this?  Or you'd need $parent?</p>",
        "id": 153811881,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452113959
    },
    {
        "content": "<p>Well, it works in my parser and looks logical.</p>",
        "id": 153811882,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452114111
    },
    {
        "content": "<p>that's ok. \"Patient.\" is a null thing that is allowed to appear at the start of an expression at the root context</p>",
        "id": 153811883,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452117186
    },
    {
        "content": "<p>all expressionsi in an operation have the same context. </p>",
        "id": 153811884,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452117202
    },
    {
        "content": "<p>so that's not restarting the context</p>",
        "id": 153811885,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452117214
    },
    {
        "content": "<p>sorry, all expressions in a set linked by operators</p>",
        "id": 153811886,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1452118211
    },
    {
        "content": "<p>No, you're right, thwo whole expression runs in the same context. My code was smarter than my brain at that time.</p>",
        "id": 153811889,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452159830
    },
    {
        "content": "<p>I think we should rename the $parent axis to $parents, since -using the | operator for example- you could combine nodes from different part of a tree, so you can have multiple different parents...</p>",
        "id": 153811891,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452174358
    },
    {
        "content": "<p>It's also true, that when you have combined trees with  |  ** can result in duplicate nodes...</p>",
        "id": 153811892,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452174458
    },
    {
        "content": "<p>Yeah. The | operator can also cause you to have a focus with both \"values (primitive elements)\" and \"elements\", which makes the interpretation of asInteger() a bit ambiguous. Contains a \"single value\" is different from contains a single element...</p>",
        "id": 153811896,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452180088
    },
    {
        "content": "<p>[13-1-2016 20:29:31] <strong>* Ewout Kramer added Bryn Rhodes, Grahame Grieve </strong>*<br>\n[13-1-2016 20:29:44] Ewout Kramer: Hi Bryn. Reading through the thread, but not quite finished it.  I am thinking of changing the way we handle choice elements ([x])...</p>\n<p>What if this:<br>\n      Observation.value[x]   was turned into a normal   Observation.value</p>\n<p>and</p>\n<p>Observation.valueBoolean turned into</p>\n<p>Observation.value.of(boolean)    </p>\n<p>So we get a \"type\" filter, which would probably be useful in other circumstances as well<br>\n[13-1-2016 20:30:11] Grahame Grieve: busy, but I will think about that<br>\n[13-1-2016 20:30:25] Grahame Grieve: but I don't like losing the .valueBoolean for all sorts of reasons<br>\n[13-1-2016 20:30:55] Grahame Grieve: don't mind losing the [x] quite so much but I think it increases complexity for some implementations<br>\n[13-1-2016 20:32:39] Ewout Kramer: The valueBoolean is a very FHIR specific way of type filtering, that feels natural only if you have seen FHIR instances, so if we use FhirPath (or ????Path) outside FHIR, this will look alien to people.<br>\n[13-1-2016 20:42:28] Grahame Grieve: yes. I agree to that. but it sounds like we can have our cake and eat it too then<br>\n[13-1-2016 20:43:00] Grahame Grieve: because if you are applying FHIRPath in the context where you have a type attribute instead of a pre-coordinated name, then .valueBoolean would be weird<br>\n[13-1-2016 20:43:20 | Edited 20:43:25] Grahame Grieve: so we could say that the base is .value.type(boolean) and in FHIR, you can do .valueBoolean<br>\n[13-1-2016 21:19:38] Ewout Kramer: \"However, this seems to be ambiguous in the grammar with the multiplication operator\"</p>\n<p>It's not really ambiguous because the multiplication requires a second operand, so either the bla* expression is followed by nothing (=path expression) or it's follow by another path (bla*bla =&gt; multiplication) or followed by an invocation (=&gt; path expression).   So my parser does indeed support Resource.element**4<br>\n[13-1-2016 21:20:29 | Edited 21:21:00] Ewout Kramer: But yes, my parser framework has unlimited lookahead ;)<br>\n[13-1-2016 21:21:18] Ewout Kramer: It requires some lookahead to disambiguate, agreed<br>\n[13-1-2016 21:34:31] Ewout Kramer: \"A.B + A.C If either of B or C are actually lists, then under CQL, this would be a compile-time error, but under FHIRPath, it would be allowed\"</p>\n<p>We could disallow this is FhirPath, and define the + - / * etc operators to work on single values / lists with one element. The compiler can statically check that.  </p>\n<p>To allow adding in circumstances where the user is sure there can be only a single value (because the criteria expressed limit the possibilities to only one value), he/she could indicate that explicitly:</p>\n<p>A.B.single() + A.C.single()</p>\n<p>This would conceptually \"cast\" an array of one value to a \"single\" value and then allow addition. The single() function would throw at runtime when there's &gt; 1 one value in A.B. If the user does not care, he/she could do A.B.first() + A.C.first().</p>\n<p>This has the advantage of enabling static type checking (i.e. adding elements with cardinality 0..1 would still look natural as A+B), keeps the normal path navigation simple A.B.C (no addition of [] necessary), and is very explicit in rare(?) circumstances where a collection would need to be added.<br>\n[13-1-2016 21:34:34] Grahame Grieve: I don't much like the look ahead part<br>\n[13-1-2016 21:35:04] Ewout Kramer: I agree. It requires a strong parser framework<br>\n[13-1-2016 21:36:15 | Edited 21:36:32] Ewout Kramer: Maybe we should use  Bla.[name] STAR. This would also enable more complex repeats like Questionnaire.[group.question] STAR <br>\n[13-1-2016 21:36:55] Ewout Kramer: Where STAR=*.  Skype is turning my asterix into bold....<br>\n[13-1-2016 21:47:44] Ewout Kramer: I've checked the current fhirpath expressions for the use of \"+\", they are used on constructs that can statically be determined to be single values, so no change would be necessary to the current statements.<br>\n[13-1-2016 22:01:57 | Edited 22:02:24] Ewout Kramer: \"FHIRPath defines contexts using a \"$\" <br>\nyou might find that you don't need some of them, but a couple are kind of handy in an expression - particular $context <br>\nYeah, they are definitely useful, Iâ€™m just saying they are parameters, <br>\nI picked $context because that's the one that's not a parameter - it arises inline.\" </p>\n<p>In my implementation $context and $resource are indeed treated exactly the same as constant values, in this case passed as parameters into the execution engine.</p>\n<p>$parent and $focus are not constant, but we could change $parent to a function application .parents().</p>\n<p>$focus is the \"variable\" in the sense of a lambda expression, e.g.   where(x =&gt; x&gt;1) in C#, or \\x -&gt;x&gt;1 in Haskell for example.  Rather than introducing a syntax like this, we could keep treating $focus as the exception (the only non-constant looking like a constant), or replace it by '_', as used in Scala:</p>\n<p>(1|2|3|4|5).where( _ &gt; 3)<br>\n[13-1-2016 22:05:54] Ewout Kramer: Then, I don't think there is a difference between $xxxx or %xxxxx  anymore and they can be merged to mean \"constant value\".   (although stuff like %vs-xxxxx act more like a function with a single param)<br>\n[13-1-2016 22:09:12 | Edited 22:09:22] Ewout Kramer: \"A.. <br>\nThe second invocation of * would have no type information, it would have to be a run-time invocation. </p>\n<p>(...)</p>\n<p>That is what I was thinking, define a \"dynamic\" type that would push it to run-time, similar to the way XPath or C# support dynamic types. \"</p>\n<p>I like that idea, in fact, my compiler currently does not do static typechecking and treats everything exactly like a \"dynamic\".</p>\n<p>So, paths like '*' and '**', and also Observation.value would evaluate to a dynamic.  Disadvantage is that it is not immediately clear in an expression like Observation.value.unit that halfway, we have switched to a dynamic type.<br>\n[13-1-2016 22:12:53 | Edited 22:12:57] Ewout Kramer: I did not find any examples where missing 3VL for booleans is a problem?<br>\n[13-1-2016 22:14:49 | Edited 22:15:02] Ewout Kramer: But I think we should not do null propagation, except for '+' on strings, where null would be the empty string.  Again, I did not find occurrences for '+' in the current fhirpath invariants that use the effect of null propagation.<br>\n[13-1-2016 22:16:11] Ewout Kramer: I think that was all. Phew!<br>\n[13-1-2016 22:19:38] Grahame Grieve: \"The single() function would throw at runtime\" - as currently specified, there is no exceptions, just null outcomes.<br>\n[13-1-2016 22:20:24] Ewout Kramer: Yes, and I don't like that at all. It requires null propagation from that moment on and results in unexpected behaviour<br>\n[13-1-2016 22:20:34] Grahame Grieve: [woensdag 13 januari 2016 21:36] Ewout Kramer: </p>\n<p>&lt;&lt;&lt; A.B.single() + A.C.single()why tax the user like this? if the user knows this is ok, why make them say it's ok?<br>\n[13-1-2016 22:20:56] Grahame Grieve: Bla.[name]* - isn't this a problem for use of []?<br>\n[13-1-2016 22:21:00] Ewout Kramer: Because it harldy ever happens (0 occurences in the current invariants), and when it does, it's very explicit for the reader.<br>\n[13-1-2016 22:21:25 | Edited 22:21:30] Ewout Kramer: We have removed \"[]\" if we don't use [x] anymore for value.<br>\n[13-1-2016 22:21:37] Ewout Kramer: Oh, in CQL. Yes, that could be.<br>\n[13-1-2016 22:21:59] Grahame Grieve: don't like .parents() because suddenly you need a grammatical way to start with a '.'<br>\n[13-1-2016 22:22:27] Grahame Grieve: Rather than introducing a syntax like this, we could keep treating $focus as the exceptionI didn't understand that bit<br>\n[13-1-2016 22:23:54] Grahame Grieve: Generally, there was a lot there I wasn't confident I understood.<br>\n[13-1-2016 22:24:21] Grahame Grieve: in particular, the notion of null return vs exceptions is important. Right now, you can do this:</p>\n<p>rule.path.something.empty()<br>\n[13-1-2016 22:24:48] Grahame Grieve: and know that this will be true, that there will be no errors.<br>\n[13-1-2016 22:24:59] Grahame Grieve: allowing exceptions..... makes that really really hard<br>\n[13-1-2016 22:35:53] Ewout Kramer: don't like .parents() because suddenly you need a grammatical way to start with a '.'Yuck. No we dont want that<br>\n[13-1-2016 22:42:20] Ewout Kramer: Yes, I agree the null return vs. exception is one of the biggest issues to tackle.<br>\n[13-1-2016 22:50:22] Ewout Kramer: So, let's see.  I don't mind single() returning an empty collection, and I don't mind propagating it over child navigation (yada.single().family), but I think  4 + [] = [] is almost always unintended, as is [3,4] + 4 = []<br>\n[13-1-2016 22:53:04] Ewout Kramer: Actually, I get confused by most of the operations, including functions, that will return empty when their input is unexpected, like toInteger():</p>\n<p>Patient.identifier.id.toInteger() will now return a single integer when there is exactly 1 id, but will return empty when there are 0 or more than 1. I cannot imagine this is desired behaviour.<br>\n[13-1-2016 22:53:10] Grahame Grieve: so, maybe. but thing.property.where(otherproperty+4).otherthing<br>\n[13-1-2016 22:53:12] Grahame Grieve: that's not clear<br>\n[13-1-2016 22:54:25 | Edited 22:54:39] Ewout Kramer: Luckily, when we would introdue select(), we could do what we want:</p>\n<p>Patient.identifier.select(id.toInteger()) would return a collection of ids as integers.<br>\n[13-1-2016 22:55:04] Grahame Grieve: what if they aren't integers?<br>\n[13-1-2016 22:55:57] Bryn Rhodes: I actually really like the empty collection is equivalent to \"null\", I think that's very clean.<br>\n[13-1-2016 22:56:07] Ewout Kramer: Yes<br>\n[13-1-2016 22:56:10] Bryn Rhodes: I think if they aren't integers, that's an error, because it's a mistake.<br>\n[13-1-2016 22:56:14] Ewout Kramer: But what to do with null +4 ?<br>\n[13-1-2016 22:56:26] Bryn Rhodes: null + 4 returns null, just like it does in SQL.<br>\n[13-1-2016 22:56:38] Grahame Grieve: I think that you either have exceptions, or query null handling.<br>\n[13-1-2016 22:56:49] Bryn Rhodes: Null propagation is good because it allows you to write expressions without regard to whether or not the information isn't there.</p>",
        "id": 153812343,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452806213
    },
    {
        "content": "<p>[13-1-2016 22:56:51] Ewout Kramer: Grahame: correct<br>\n[13-1-2016 22:57:15] Bryn Rhodes: But turning exception conditions into nulls is very bad.<br>\n[13-1-2016 22:57:18] Bryn Rhodes: IMHO.<br>\n[13-1-2016 22:57:18] Grahame Grieve: you can do type checking at compile time, as I do, and warn the user that the effects might be not what they think<br>\n[13-1-2016 22:57:19] Grahame Grieve: so I think it's ok because of that<br>\n[13-1-2016 22:57:37] Grahame Grieve: it's one or the other. mixing them is very bad<br>\n[13-1-2016 22:57:43] Bryn Rhodes: Why?<br>\n[13-1-2016 22:58:12] Bryn Rhodes: The point, I think is that the fact that information is missing isn't an error, it's \"i don't know\".<br>\n[13-1-2016 22:58:19] Bryn Rhodes: But 1 + \"Steve\" is an error.<br>\n[13-1-2016 22:58:27] Grahame Grieve: If you mix the conditions, you'll have to define which is which, and then users will have to guess which is<br>\n[13-1-2016 22:58:43] Grahame Grieve: so how does a user handle the case where it might be an error or not?<br>\n[13-1-2016 22:59:12] Grahame Grieve: if they're constants, it's always going to be an error. but a real world case, one or both are going to things extracted from objects by query<br>\n[13-1-2016 23:00:07] Grahame Grieve: if you say it's always null, the user has predictability, and can make queries without being taxed to make all sorts of type checks and error condition checks - this in a language that is not geared to procedural case statements<br>\n[13-1-2016 23:01:22] Bryn Rhodes: So, my problem with that is that \"null\" is a valid result, it means something, and if you make an error \"null\" then you  don't know whether it's null because it really was null, or it's null because you had some error in your expression.<br>\n[13-1-2016 23:01:47] Bryn Rhodes: It ends up hiding important information from the user.<br>\n[13-1-2016 23:02:42 | Edited 23:02:44] Bryn Rhodes: Especially in a really complicated expression, that becomes a really big issue.<br>\n[13-1-2016 23:03:02] Ewout Kramer: So, Bryn, 4 + [] = [], but 4 + [3,4,5] = error, right?<br>\n[13-1-2016 23:03:26] Grahame Grieve: you need to stop using constants. They mislead you about what's going on<br>\n[13-1-2016 23:03:32] Bryn Rhodes: Well, I would actually prefer to see that as a \"compile-time\" error, because you can't add a singular and a list.<br>\n[13-1-2016 23:04:24] Bryn Rhodes: But if we accept that there can be implicit conversions to lists, then yes, that would be a run-time error, because there is more than one.<br>\n[13-1-2016 23:07:57] Ewout Kramer: So, I suggested making this a compile time error indeed, and add single() for the circumstances where you really want to add to collections together, because you know they are single values (or nulls -  if we keep the null propagation).  And then if single() encounters &gt; 1 element....a runtime error?<br>\n[13-1-2016 23:08:39] Bryn Rhodes: Yes, I like that. In fact CQL has a \"singleton from\" operator with exactly those semantics.<br>\n[13-1-2016 23:08:46] Ewout Kramer: ok<br>\n[13-1-2016 23:09:56] Ewout Kramer: So, I see 2 votes for propagating nulls over math. operators and comparisons, so null &gt; 4 = null (=false)<br>\n[13-1-2016 23:11:28] Grahame Grieve: so you make users specify singleton even when they know it's null, so that the compiler doesn't tell them that they're wrong, even when they aren't<br>\n[13-1-2016 23:12:31] Ewout Kramer: I don't understand that<br>\n[13-1-2016 23:13:06] Ewout Kramer: You make them specify singleton if you are doing operations that can statically be determined to be collections. What does that have to do with null?<br>\n[13-1-2016 23:14:59] Grahame Grieve: you said you make them specify singletons so that a collection is proven to be single.<br>\n[13-1-2016 23:15:00] Bryn Rhodes: I actually really like that because it means you don't have to provide list-valued overloads for all singular operators to enable type analysis.<br>\n[13-1-2016 23:15:31] Grahame Grieve: you didn't say anything about statically determined<br>\n[13-1-2016 23:15:31] Grahame Grieve: Bryn, like which?<br>\n[13-1-2016 23:15:49] Bryn Rhodes: Like .single()<br>\n[13-1-2016 23:16:09] Ewout Kramer: I think I had conceded that single() would only throw when there's &gt; 1 element, and return empty on an empty collection<br>\n[13-1-2016 23:16:28 | Edited 23:16:34] Bryn Rhodes: Yeah, I was just providing another reason that I like it.<br>\n[13-1-2016 23:17:10] Ewout Kramer: That makes sense if we stick to null propagation, as you and Bryn both like to do.<br>\n[13-1-2016 23:18:50] Grahame Grieve: but you're going to make a user specify .single() everywhere, because if they do something like </p>\n<p>something[thisIsPossiblyOneOrMoreIntegersButIKnowItsOnlyOne + 4].other<br>\n[13-1-2016 23:18:56 | Edited 23:18:57] Grahame Grieve: then you'll make that an error anyway<br>\n[13-1-2016 23:20:12] Ewout Kramer: I was looking at the operators, certainly not path navigation.<br>\n[13-1-2016 23:20:46] Ewout Kramer: What we do with functions that expect a single input (like toInteger) that receive &gt; 1 element, we have not yet discussed.<br>\n[13-1-2016 23:22:14] Ewout Kramer: So, I really think single() is going to be exceptional.<br>\n[13-1-2016 23:22:21] Ewout Kramer: It should<br>\n[13-1-2016 23:22:26] Ewout Kramer: Otherwise, I'd agree with you<br>\n[13-1-2016 23:22:45] Grahame Grieve: I was just concluding that I have no idea how what you're describing works<br>\n[13-1-2016 23:23:25] Grahame Grieve: under some set of circumstances, it blows up, and .empty() returns false instead of true, and I can no longer understand in my head how a user could know which was which<br>\n[13-1-2016 23:24:12 | Edited 23:24:17] Ewout Kramer: So, currently, what would x+y do if either x or y &gt; 1 element?<br>\n[13-1-2016 23:24:46] Bryn Rhodes: Hmmm.....<br>\n[13-1-2016 23:25:40] Bryn Rhodes: If you allow for dynamics, then the compiler can't know in all cases when single() is required, which means it would be allowed to be inconsistently applied in the language, which would kind of defeat it's usefulness... I think.<br>\n[13-1-2016 23:26:37] Ewout Kramer: Ah, but that's true of dynamic in general, and is separate from single()<br>\n[13-1-2016 23:26:47] Bryn Rhodes: Agreed.<br>\n[13-1-2016 23:26:50] Grahame Grieve: that's why I think that .single() and exceptions is a bad idea<br>\n[13-1-2016 23:27:11] Bryn Rhodes: I think swallowing exceptions is an even worse idea.<br>\n[13-1-2016 23:28:20] Bryn Rhodes: How would I ever know if something went wrong?<br>\n[13-1-2016 23:29:21] Bryn Rhodes: FHIR Path as currently defined doesn't swallow exceptions, right?<br>\n[13-1-2016 23:29:32] Ewout Kramer: Right.<br>\n[13-1-2016 23:29:52] Ewout Kramer: Adding something to a collection &gt; 1 elmenent returns in an empty collection.<br>\n[13-1-2016 23:31:18] Grahame Grieve: so I agree that this is not a comfortable case for me. But I think that any other approach is less comfortable<br>\n[13-1-2016 23:31:29] Ewout Kramer: Well, maybe we should propagate both the null and the exception. So, at the end of evaluation, you can either live with the thing being null, or inspect an exception property of the evaluation engine.<br>\n[13-1-2016 23:31:46] Ewout Kramer: But how would the caller decide which behaviour he want?<br>\n[13-1-2016 23:31:49] Grahame Grieve: but .empty.....<br>\n[13-1-2016 23:32:09] Grahame Grieve: this is how OCL works... no exceptions.... just null<br>\n[13-1-2016 23:32:14] Bryn Rhodes: What about just .single() semantics but not having to invoke it?<br>\n[13-1-2016 23:32:25] Grahame Grieve: not having to invoke it?<br>\n[13-1-2016 23:32:41] Ewout Kramer: well, you'd still have to chose between resulting in null or throwing an exception<br>\n[13-1-2016 23:32:51] Bryn Rhodes: Yeah, so if you invoked a singular operation on operands with more than one item, it would throw an exception.<br>\n[13-1-2016 23:33:09] Bryn Rhodes: If either operand is empty, return empty.<br>\n[13-1-2016 23:33:18] Bryn Rhodes: Otherwise, perform the singular operation.<br>\n[13-1-2016 23:33:37] Ewout Kramer: well, you'd still have to chose between resulting in null or throwing an exceptionThat remains the devilish dilemma<br>\n[13-1-2016 23:33:45] Bryn Rhodes: Yeah, and that's one of the main reasons we didn't use OCL.<br>\n[13-1-2016 23:33:48 | Edited 23:33:49] Bryn Rhodes: That's just not safe.<br>\n[13-1-2016 23:34:17] Bryn Rhodes: What's the problem with .empty()?<br>\n[13-1-2016 23:34:21] Bryn Rhodes: I don't understand.<br>\n[13-1-2016 23:35:01] Grahame Grieve: well, at present, objects.filter(criteria).empty returns true if there's no object in the objects that meets criteria<br>\n[13-1-2016 23:35:27] Grahame Grieve: but you guys re arguing that for some combinations of criteria, it should return false even if there are no objects that meet the criteria<br>\n[13-1-2016 23:36:18 | Edited 23:36:32] Ewout Kramer: no, we are arguing that if the criteria dont make sense, they should not be considered a \"false\" outcome<br>\n[13-1-2016 23:37:19] Ewout Kramer: Alternatively, we define how + works on collections, e.g. result in a collection where  4 is added to all input values<br>\n[13-1-2016 23:37:32] Grahame Grieve: so the result of that is the user has to tell the compiler that they do make sense, even when the user knows that they make sense because the language works that way<br>\n[13-1-2016 23:38:23 | Edited 23:38:37] Ewout Kramer: If I understand correctly what you are saying, you are saying: \"it's ok to produce nonsense results because we have specified that we produce nonsense results\"<br>\n[13-1-2016 23:39:09] Ewout Kramer: Let's find some actual examples.<br>\n[13-1-2016 23:39:38] Ewout Kramer: Becuase I am sure that in practice, our proposal does not change your current way of working.<br>\n[13-1-2016 23:40:08] Bryn Rhodes: +1<br>\n[13-1-2016 23:41:04] Grahame Grieve: The case that I see is that the resource defines something as a collection.<br>\n[13-1-2016 23:41:06] Grahame Grieve: Patient name.<br>\n[13-1-2016 23:41:15] Grahame Grieve: Patient.name.first + 'that'<br>\n[13-1-2016 23:41:46] Grahame Grieve: a user would have lots of grounds to know that although the specification says it's a collection, they only ever have a single name<br>\n[13-1-2016 23:42:19] Ewout Kramer: So, how would you use this in an invariant?<br>\n[13-1-2016 23:43:02] Grahame Gr</p>",
        "id": 153812344,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452806303
    },
    {
        "content": "<p>[13-1-2016 23:43:02] Grahame Grieve: contained.all(\"#\"+id in **.reference)<br>\n[13-1-2016 23:44:02 | Edited 23:44:08] Ewout Kramer: id is 0..1, and the compiler would not complain. But you mean, if id were defined as 0..*?<br>\n[13-1-2016 23:44:09 | Edited 23:44:09] Grahame Grieve: yes<br>\n[13-1-2016 23:46:28] Bryn Rhodes: That would still work, so long as the id did have at most one id at runtime.<br>\n[13-1-2016 23:46:51] Bryn Rhodes: As an aside, how does the compiler know that the \"id\" is applied to the current iteration target, and the ** is applied to the top level resource?<br>\n[13-1-2016 23:47:24] Ewout Kramer: ** would, in my evaluator, be applied to the current iteration target<br>\n[13-1-2016 23:47:58 | Edited 23:48:00] Bryn Rhodes: Am I misunderstanding what that invariant is supposed to be enforcing then?<br>\n[13-1-2016 23:48:25] Ewout Kramer: I think the invariant should read $context.**reference<br>\n[13-1-2016 23:49:00] Grahame Grieve: yes it's wrong. good pick<br>\n[13-1-2016 23:49:13] Bryn Rhodes: Okay, and then it would work, so long as there was at most one identifier?<br>\n[13-1-2016 23:49:31] Bryn Rhodes: id, sorry<br>\n[13-1-2016 23:49:35] Ewout Kramer: Currently, it would become false if &gt; 1 id<br>\n[13-1-2016 23:50:07] Ewout Kramer: And you could say that's a correct outcome, but really, I wonder if the writer of the invariant was aware of that consequence.<br>\n[13-1-2016 23:50:25] Ewout Kramer: (in this case, since it is Grahame, he was....but generally speaking)<br>\n[13-1-2016 23:50:29] Bryn Rhodes: Yeah, and it could just as easily have resulted in the wrong outcome if there was negation involved.<br>\n[13-1-2016 23:50:33] Ewout Kramer: y<br>\n[13-1-2016 23:51:59] Bryn Rhodes: An error in an invariant though, is still a \"false\" because it means the same thing, so I don't see how that changes the behavior, it just gives the user more information about what went wrong.<br>\n[13-1-2016 23:52:09] Grahame Grieve: yes, this one, it would be ok for it to be handled either way, because the invariant would be false either way<br>\n[13-1-2016 23:52:23] Grahame Grieve: that was the 1st + I found. I'll find a more difficult case now<br>\n[13-1-2016 23:53:23] Ewout Kramer: And, I think if there COULD have been &gt; 1 you'd really have wanted:</p>\n<p>contained.select('#' + id) in **.reference<br>\n[13-1-2016 23:54:29] Ewout Kramer: which is a more safe, and more true statment, because then all id's would have to appear in a reference<br>\n[13-1-2016 23:54:59 | Edited 23:55:10] Ewout Kramer: (I call it select, but many langues call it map())<br>\n[13-1-2016 23:55:41] Bryn Rhodes: I like select.<br>\n[13-1-2016 23:56:08] Bryn Rhodes: CQL actually uses return, but there was considerable debate about that.<br>\n[13-1-2016 23:57:03] Grahame Grieve: maybe I'm just stupid, but I don't understand how that is different<br>\n[13-1-2016 23:58:31] Ewout Kramer: contained.all('#' + id...) has the problem that the \"+\" would return empty, so when there is &gt; 1 id, the statement becomes false.<br>\n[13-1-2016 23:59:06] Ewout Kramer: While the version with select() would return true (it seemed to me that IF there are &gt; 1 id, you'd wanted those other id's to also be referenced)<br>\n[13-1-2016 23:59:14] Ewout Kramer: That's a user's choice of course.<br>\n[13-1-2016 23:59:27] Grahame Grieve: ok I get it<br>\n[13-1-2016 23:59:31] Grahame Grieve: snapshot.element.tail().all(path.startsWith($context.snapshot.element.first().path+\".\"))<br>\n[00:00:06] Grahame Grieve: I suppose you're going to argue with this one that first() makes it single. so this is not going to be a problem<br>\n[00:00:08] Ewout Kramer: here, the first() fixes the problem<br>\n[00:00:10] Ewout Kramer: yep<br>\n[00:00:15] Ewout Kramer: you know me by now.<br>\n[00:02:47] Grahame Grieve: (Range): low.empty() or high.empty() or (low &lt;= high)<br>\n[00:02:57] Ewout Kramer: But the main question is: that contained.all() statement, should that have thrown when the user is 100 % there cannot be &gt; 1 id?<br>\n[00:03:16] Ewout Kramer: can low and high repeat?<br>\n[00:03:27] Ewout Kramer: or is this a subclause on something that is repeating?<br>\n[00:04:13] Grahame Grieve: they can't repeat now<br>\n[00:04:37] Bryn Rhodes: If the user is 100% certain that there cannot be &gt; 1 id and there isn't actually &gt; 1 id at runtime, then there would be no error.<br>\n[00:05:23] Grahame Grieve: here's a much more interesting case:<br>\n[00:05:25] Grahame Grieve: component.where(code = $context.code).empty()<br>\n[00:05:51] Grahame Grieve: on Observation<br>\n[00:06:08] Ewout Kramer: Ah, but I like how we have defined = on collections....<br>\n[00:06:31] Ewout Kramer: no problem here for me.<br>\n[00:06:51] Bryn Rhodes: Me either, = is overloaded for collections, makes sense.<br>\n[00:07:53] Grahame Grieve: I think it's going to be hard to find something out of the existing resource based things<br>\n[00:08:15] Ewout Kramer: in the high and low case, it would depend on whether they would need to be compared in pairs, or all lows must be &lt; highest high, or lower than the lowest high.<br>\n[00:08:31] Grahame Grieve: for more interesting examples, I'm going to have to talk about profiles<br>\n[00:08:31] Grahame Grieve: because is your compiler profile aware?<br>\n[00:09:25] Grahame Grieve: it can't be. actually. that's the problem<br>\n[00:09:46] Grahame Grieve: I'm writing an evaluation on patient that knows that the cardinality of a collection ix fixed to 1.<br>\n[00:10:02] Grahame Grieve: but your evaluation engine doesn't know that, so the user has to tell it<br>\n[00:11:13] Ewout Kramer: Yes.  So, if you use that statement to validate the profile, of course you would have to check for occurences &gt; 1.  This is the situation where we know the statement is executed in an environment where the isntances is already validated against the profile and we are 100% sure it will not repeat.<br>\n[00:11:32] Grahame Grieve: yes, but the engine is not clued into this<br>\n[00:11:36] Ewout Kramer: Rght.<br>\n[00:12:58 | Edited 00:14:47] Ewout Kramer: So, there's someone who has written a profile and has told the author of the statement that there's one occurrence only. Author is a consumer of the output of a system where the profile has been run to validate incoming instances.<br>\n[00:16:02] Grahame Grieve: yes<br>\n[00:16:28 | Edited 00:16:36] Ewout Kramer: So, it depends whether the FP compiler is run against the base resources or against the gatekeeper profile...<br>\n[00:16:58] Ewout Kramer: oh, we didn't do static checking anymore.<br>\n[00:18:19] Ewout Kramer: So, now the configuration changes. The author is not updated of this fact (might be quite some time later).  Would we prefer run-time errors, or unpredictable behaviour of the downstream FP expressions?<br>\n[00:18:31] Ewout Kramer: Or still - static checking?<br>\n[00:18:53] Ewout Kramer: Or static checking? (but that would require single())<br>\n[00:20:01] Ewout Kramer: Let's see if a night of sleep brings more insights. Gentlemen, thank you for an entertaining discussion ;-)<br>\n[00:20:34] Grahame Grieve: yes sleep time<br>\n[07:14:18] Ewout Kramer: Thought about it some more. </p>\n<p>[00:18] Ewout Kramer: </p>\n<p>&lt;&lt;&lt; So, now the configuration changes. The author is not updated of this fact (might be quite some time later).  Would we prefer run-time errors, or unpredictable behaviour of the downstream FP expressions?<br>\nMy answer is: runtime error (at least).  Your assumptions have changed because of an upstream change. This means that your FP queries based on those assumptions are now potentially doing the wrong thing, so they need to throw and you need to take a look at your queries to update them to the new situation (upstream profile causes different cardinality)</p>\n<p>If you want to be future proof &amp; you can use single() or first(), and that's an explicit choice stating that you have covered the case where the cardinality turns out to be &gt; 1<br>\n[07:15:21] Ewout Kramer: And I think I would add a parameter to my evaluator to use \"strict\" evaluation. If you enable that, the compiler will track cardinalities and point you out where you'd need to do single() or first() (or however you want to handle it)<br>\n[07:15:31 | Edited 07:16:43] Ewout Kramer: CQL might decide to require \"strict\" mode, while FHIR does not.<br>\n[07:18:53] Ewout Kramer: Note: the discussion about single() also holds for functions taking a parameter (like substring) that needs to be single-valued. returning empty on a substring() just because the parameter turns out to be a collection has the same risks.<br>\n[07:20:24 | Removed 07:21:34] Ewout Kramer: This message has been removed.<br>\n[07:51:11] Grahame Grieve: I think we need to understand the impacts on the various ways you use a query<br>\n- indexing for search parameter<br>\n- invariant<br>\n- mapping<br>\n- decision support library<br>\n[07:51:20] Grahame Grieve: how do these fail in the various cases?<br>\n[08:02:13] Ewout Kramer: That makes sense<br>\n[08:02:31] Ewout Kramer: To validate my statement ;-)<br>\n[08:11:05] Ewout Kramer: bryn, we're sitting front right in the breakfast room<br>\n[13:50:23] Grahame Grieve: so we didn't close this out did we?<br>\n[14:12:09] Grahame Grieve: let me know if this gets interesting<br>\n[14:15:20] Ewout Kramer: ok<br>\n[14:42:56] Bryn Rhodes: So, as far as next steps here, I was thinking I could start by actually taking a branch of the CQL tooling and implement the changes that have been proposed to enable the CQL grammar to express FHIRPath.<br>\n[14:43:01] Bryn Rhodes: Does that sound like a good next step?<br>\n[14:55:32 | Edited 14:55:51] Ewout Kramer: I think I know \"I\" agreed on ;)  But as a summary:</p>\n<ul>\n<li>Stick to null propagation (but we still need to define if nulls propagate through parameters, i.e. if you pass null to substring() what happens?). We agreed 4 + null = null, but what about string + null?</li>\n<li>Will now throw an exception if operators / functions are called on collections with &gt; 1 element when 1 element (or null) is expected. </li>\n<li>Throwing exceptions at runtime can be avoided by <br>\na) being absolutely sure (because you're downstream from a profile validator) that cardinality will be 1 or <br>\nb) defensively use mechanisms like first(), <br>\nc) Have static validation capabilities in the compiler (which can be switched on/off or are effectively warnings) to point out where </li>\n</ul>",
        "id": 153812345,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452806374
    },
    {
        "content": "<p>[14:55:32 | Edited 14:55:51] Ewout Kramer: I think I know \"I\" agreed on ;)  But as a summary:</p>\n<ul>\n<li>Stick to null propagation (but we still need to define if nulls propagate through parameters, i.e. if you pass null to substring() what happens?). We agreed 4 + null = null, but what about string + null?</li>\n<li>Will now throw an exception if operators / functions are called on collections with &gt; 1 element when 1 element (or null) is expected. </li>\n<li>\n<p>Throwing exceptions at runtime can be avoided by <br>\na) being absolutely sure (because you're downstream from a profile validator) that cardinality will be 1 or <br>\nb) defensively use mechanisms like first(), <br>\nc) Have static validation capabilities in the compiler (which can be switched on/off or are effectively warnings) to point out where cardinalities can cause throwing errors.</p>\n</li>\n<li>\n<p>Introduce a type filter ofType() or of() or type() to work with choice elements (which I think can also be used to filter '**' or '*' expressions to filter only certain types of nodes, which would enable static typechecking to continue after such expressions)</p>\n</li>\n</ul>",
        "id": 153812346,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452806393
    },
    {
        "content": "<p>Ok, switch from Skype....</p>",
        "id": 153812347,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1452806421
    },
    {
        "content": "<ul>\n<li>Regarding \"Stick to null propagation\": In general, CQL operations return null if any argument is null. There are a few exceptions to ensure expected behavior, but they are all documented in the operator appendix.</li>\n<li>Regarding \"ofType()\": In CQL, we have \"is\", \"as\", and \"cast as\", with semantics equivalent to the \"is\", \"as\", and \"cast\" of C#. We have a type specifier production rule that allows these clauses to be used with any type. In FHIRPath, I would think there would just be ofType() operators for each primitive, yes?</li>\n</ul>",
        "id": 153812369,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1452968410
    },
    {
        "content": "<p>Oh, and for consistency of naming, I wonder if \"asType\" would be okay?</p>",
        "id": 153812370,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1452968462
    },
    {
        "content": "<p>ofType(x), where x is one of the primitives, yes, that's what I mean.  asType() would be perfect!</p>",
        "id": 153812374,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1453145668
    },
    {
        "content": "<p>Looking for how I might prepare this xpath expression as a fhirpath expression<br>\nif(//Condition/code/coding/code[@value='ihd' or @value='hearf']) then 'Yes' else ''</p>",
        "id": 153812518,
        "sender_full_name": "z Brian Postlethwaite (old - don't use)",
        "timestamp": 1454315036
    },
    {
        "content": "<p>How does this look for people?<br>\n('Yes'.where($resource.code.coding.where(code='ihd' or code='hearf')) | '').first()</p>",
        "id": 153812522,
        "sender_full_name": "z Brian Postlethwaite (old - don't use)",
        "timestamp": 1454326115
    },
    {
        "content": "<p>Simpler example: ('Yes'.where(false) | 'No').first() returns 'No'<br>\nand ('Yes'.where(true) | 'No').first() returns 'Yes'</p>",
        "id": 153812523,
        "sender_full_name": "z Brian Postlethwaite (old - don't use)",
        "timestamp": 1454327046
    },
    {
        "content": "<p>very creative ;-)  Looking for an if function?</p>",
        "id": 153812524,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1454331309
    },
    {
        "content": "<p>Yes, an if function would have made it much nicer,,,</p>",
        "id": 153812525,
        "sender_full_name": "z Brian Postlethwaite (old - don't use)",
        "timestamp": 1454331423
    },
    {
        "content": "<p>Yes I like the if function </p>",
        "id": 153812609,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1454651939
    },
    {
        "content": "<p>Sorry, just now seeing this. CQL defines an \"if\" that looks just like the XPath syntax. Not sure that would fit within FluentPath, but worth considering I think.</p>",
        "id": 153812772,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1455125933
    },
    {
        "content": "<p>Yes, I was thinking along those lines....I will update the spec this week.</p>",
        "id": 153812826,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1455529676
    },
    {
        "content": "<p>So, I have basically decided to add an iif(), <a href=\"https://en.wikipedia.org/wiki/IIf\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/IIf\">https://en.wikipedia.org/wiki/IIf</a>. where the \"false\" part will be selected when the input is either false or empty.</p>",
        "id": 153813052,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1456150737
    },
    {
        "content": "<p>Having missed Orlando, I probably missed the plan for FHIRPath/FluentPath... when is this going to replace the XPath invariants in the StructureDefinitions?</p>",
        "id": 153813059,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1456154741
    },
    {
        "content": "<p>It's actually already there in the build, but just as an extension, e.g.</p>\n<div class=\"codehilite\"><pre>            &lt;constraint&gt;\n              &lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/structuredefinition-expression&quot;&gt;\n                &lt;valueString value=&quot;compose.import.count() != 1 or compose.include or compose.exclude or codeSystem&quot;/&gt;\n              &lt;/extension&gt;\n              &lt;key value=&quot;vsd-2&quot;/&gt;\n              &lt;severity value=&quot;error&quot;/&gt;\n              &lt;human value=&quot;A value set with only one import SHALL also have an include and/or an exclude unless the value set includes and inline code system&quot;/&gt;\n              &lt;xpath value=&quot;not(exists(f:compose)) or (count(f:compose/f:import)!=1 or exists(f:compose/f:include) or exists(f:compose/f:exclude) or exists(f:codeSystem))&quot;/&gt;\n            &lt;/constraint&gt;\n</pre></div>",
        "id": 153813060,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1456154885
    },
    {
        "content": "<p>Are they being kept in-sync?</p>",
        "id": 153813061,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1456154974
    },
    {
        "content": "<p>I'm trying to decide how heavily I'm going to invest development time in fhirpath... is the XPath going to go away?</p>",
        "id": 153813062,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1456155025
    },
    {
        "content": "<p>Jason - I very much want it to go away, but other people have committed to it. So it looks likely that we will flip to using FHIRPath (or whatever it is called) as the primary, and generate XPath from them</p>",
        "id": 153813064,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1456170335
    },
    {
        "content": "<p>I want to implement support for fhirpath (or is it called fluentpath?) when I move to STU3... is <a href=\"https://github.com/ewoutkramer/fhirpath\" target=\"_blank\" title=\"https://github.com/ewoutkramer/fhirpath\">https://github.com/ewoutkramer/fhirpath</a> the official documentation ?</p>",
        "id": 153814778,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1457625281
    },
    {
        "content": "<p>@Jason that is correct, Ewout has documented  the official FHIR Path syntax definition.</p>",
        "id": 153814791,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1457627259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> thanks. Is there an official reference implementation?</p>",
        "id": 153814792,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1457627385
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span> Ewout has been implementing FHIR Path into the .NET FHIR API. This implementation now covers most - if not all - of the spec, verified by a set of unit tests. So you could  consider this as a reference implementation. There are also implementations available in other languages.</p>",
        "id": 153814798,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1457627959
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> Ok, thanks!</p>",
        "id": 153814799,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1457628051
    },
    {
        "content": "<p>Note that it's still a work in progress and we're currently updating it. So what's there is changing, and we'll be balloting the update in the May ballot cycle.</p>",
        "id": 153814804,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1457629978
    },
    {
        "content": "<p>You might want to hold off a little bit on implementing until those changes are in place, over the next few weeks.</p>",
        "id": 153814805,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1457630009
    },
    {
        "content": "<p>Well, is there a stable core? I wanted to be checking the invariants at the connectathon.</p>",
        "id": 153814850,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1457633291
    },
    {
        "content": "<p>The fluentpath.g4 that's there is very close, there's another round of changes we're still discussing, but they're minor changes to the syntax itself. Our goal is to be validating by the connectathon as well.</p>",
        "id": 153814872,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1457640754
    },
    {
        "content": "<p>Hi  Jason, the invariants that are currently present in the spec are based on the jan/orlando draft of the FHIRPath spec.  In Orlando we've discussed FHIRPath broadly and we've embarked on aligning it with the needs of the CQL team (of which Bryn is a member). The rename to \"FluentPath\" signals the fact that it is no longer a FHIR-only technology....</p>",
        "id": 153815372,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1457948336
    },
    {
        "content": "<p>btw, as well as updated versions of everything else, we have posted the candidate STU1 version of FHIRPath at <a href=\"http://hl7.org/fhirpath\" target=\"_blank\" title=\"http://hl7.org/fhirpath\">http://hl7.org/fhirpath</a>. It's not finally approved by the relevent committee yet, but we expect it will be soon, and we don't expect any substantiative changes. Thanks to <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> for taking the lead on this</p>",
        "id": 153861570,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481107869
    },
    {
        "content": "<p>Yes, a big thanks <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> </p>",
        "id": 153862873,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1481352562
    },
    {
        "content": "<p>Is it possible for a fhir expression to follow references? for example, suppose you have a contained resource and you want to follow the reference form the parent resource to return it. For example, suppose that Observation.supbect refers to a contained Patient resource, who could you return that Patient? sort of:  Observation.contained.where(id=Observation.subject.reference.substring(1)) ...</p>",
        "id": 153902423,
        "sender_full_name": "David Hay",
        "timestamp": 1502739613
    },
    {
        "content": "<p>search in the fhirpath spec for .resolve()</p>",
        "id": 153902424,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1502742788
    },
    {
        "content": "<p>Thanks Grahame - alas it doesn't seem to work in the javascript version that's on the web (as it's a couple of years old I guess that's not too surprising :) ) . Hopefully will be resolved when the new version is available...</p>",
        "id": 153902427,
        "sender_full_name": "David Hay",
        "timestamp": 1502745916
    },
    {
        "content": "<p>ITS is planning to ballot FHIRPath as normative in May. There's several implementations in different languages by different authors, there's plenty of use in the FHIR spec, there's a solid set of tests. There's some production use. And there's been very little substantiative change</p>",
        "id": 153927887,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515359159
    },
    {
        "content": "<p>there is several change requests:</p>",
        "id": 153927888,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515359188
    },
    {
        "content": "<p>Yes we are so planning to ballot. Curious if there has been <em>any</em> substantive change?</p>",
        "id": 153927889,
        "sender_full_name": "Dale Nelson",
        "timestamp": 1515359306
    },
    {
        "content": "<ul>\n<li>add sum()</li>\n<li>add quantity comparison</li>\n<li>clarify about date rounding</li>\n<li>relax definitions of concept equivalents</li>\n</ul>",
        "id": 153927890,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515359350
    },
    {
        "content": "<p>Dale: no substantiative change proposed as yet</p>",
        "id": 153927891,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515359366
    },
    {
        "content": "<p>maybe the last one might count as substantiative?possible.</p>",
        "id": 153927892,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515359393
    },
    {
        "content": "<p>anyway, this is a call for comments and consideration on making this normative. In particular, has anyone used the v2 part (other than me?)</p>",
        "id": 153927893,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515359419
    },
    {
        "content": "<p>We would have a hard time arguing to go another round of STU rather than normative,  IMO.  For all the reasons you stated.</p>",
        "id": 153927894,
        "sender_full_name": "Dale Nelson",
        "timestamp": 1515359672
    },
    {
        "content": "<p>need to do some stuff in the appendices:<br>\n- Appendix A needs to be normalised in the spec<br>\n- Appendix D probably needs to be trial use still<br>\n- Appendix E might need to be moved to somewhere else non-normative to allow it to be updated</p>",
        "id": 153927895,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515359810
    },
    {
        "content": "<p>Agree, Appendix E should not be part of normative spec, and we might want to think about V2/Appendix D.  So some work to do, but clearly on a May normative track.</p>",
        "id": 153927896,
        "sender_full_name": "Dale Nelson",
        "timestamp": 1515360374
    },
    {
        "content": "<p>Has it been published as STU in 2 publication cycles?</p>",
        "id": 153927900,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1515362161
    },
    {
        "content": "<p>no. only one.</p>",
        "id": 153927901,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515363684
    },
    {
        "content": "<p>Is there a reason we wouldn't adhere to the 2-cycle rule for this one to get to FMM-5 (which is the pre-req for normative) that we have for all FHIR artifacts?</p>",
        "id": 153927902,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1515364300
    },
    {
        "content": "<p>because it's not a FHIR artifact directly. And the implementation hasn't thrown up the kind of content model issues that make that investment of time necessary. And because ITS indicated a desire go straight to normative</p>",
        "id": 153927903,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515364551
    },
    {
        "content": "<p>and as you say elsewhere, we use it in some candidate normative artifacts</p>",
        "id": 153927904,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515366147
    },
    {
        "content": "<p>We will be using things in normative artifacts that aren't normative for the next 5-10 years.  So that's not a compelling reason to move forward.  Nor is a WG's indication of desire.  Given the high level of dependence FHIR has on FHIRPath, I would hope that we'd adhere to the same quality expectations.  At minimum, I'd expect to see an argument presented of how the objectives intended by the requirements we're waiving are either met or irrelevant in this situation with supporting evidence or rationale.  I'd also expect evidence of why adhering to the requirement was problematic.  None of that's been shared yet.</p>",
        "id": 153927905,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1515367620
    },
    {
        "content": "<p>\"We will be using things in normative artifacts that aren't normative for the next 5-10 years\" - really? what?</p>",
        "id": 153927906,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515368330
    },
    {
        "content": "<p>Many resources have References that point to other resources that will include at least some resources that aren't normative yet.  And I expect there it'll take us at least 3 more publications after R4 becore the vast majority of resources are normative.</p>",
        "id": 153927911,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1515375697
    },
    {
        "content": "<p>so there's a big difference between 'target of a reference' and included right in the resource</p>",
        "id": 153927912,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515375972
    },
    {
        "content": "<p>To be clear, ITS has not decided anything about going Normative. Bryn was asked what he would like to do with the STU period coming to a close. Bryn indicated he thought it should go Normative and so this will be discussed in the joint ITS/FHIR-i quarter at the WGM. If you feel this is inapproriate, I would suggest that you attend this session as I would expect Bryn to be making a motion at some point.</p>",
        "id": 153927914,
        "sender_full_name": "Andy Stechishin",
        "timestamp": 1515376656
    },
    {
        "content": "<p>I should have been clear about that. No formal decision at this point, but that's the proposed motion</p>",
        "id": 153927915,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515378246
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191369\">@Andy Stechishin</span> Unfortunately I can't make that session, which is why I'm sharing my concerns now.  I think the risk of leaving it non-normative is low.  If we are going to take it normative, I think we need to establish why we think the FMM level rules should be waived, at least in part.  Out of curiousity, what management group is responsible for FHIRPath?</p>",
        "id": 153927916,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1515379364
    },
    {
        "content": "<p>it is in the FHIR product family. I don't think we've really talked about the difference between FMG scope and FHIR product family</p>",
        "id": 153927918,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515380680
    },
    {
        "content": "<p>Something for the TSC to discuss?  (And perhaps for the FMG and other management groups to share their thoughts on?)</p>",
        "id": 153927919,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1515380905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191690\">@Anne Wizauer</span> Can you tentatively add this to the next FMG agenda?</p>",
        "id": 153927920,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1515380959
    },
    {
        "content": "<p>Actually, I would believe that FHIRPath is broader than FHIR and resides outside of FMG. Recall the name of the product was only b/c of copyrights not b/c it was a FHIR-specific language</p>",
        "id": 153927921,
        "sender_full_name": "Dale Nelson",
        "timestamp": 1515381122
    },
    {
        "content": "<p>that's correct. But it's still in the FHIR Product family.</p>",
        "id": 153927922,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515381158
    },
    {
        "content": "<p>So yes, FMG can share thoughts as you say, also V2, CQI, SDTC etc - but the decision on normative readiness would not be based on the FMM criteria.</p>",
        "id": 153927923,
        "sender_full_name": "Dale Nelson",
        "timestamp": 1515381507
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191690\">@Anne Wizauer</span> Can you tentatively add this to the next FMG agenda?</p>\n</blockquote>\n<p>Sure thing!</p>",
        "id": 153927952,
        "sender_full_name": "Anne Wizauer",
        "timestamp": 1515422155
    },
    {
        "content": "<p>please, split FHIRpath into simple core and set of extensions (like time operators etc)</p>",
        "id": 153928174,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1515535546
    },
    {
        "content": "<p>why?</p>",
        "id": 153928175,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1515535806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span>, are you referring to our previous discussion on subsets of FHIRPath?: a simple subset to use in Discriminators, a subset for searches etc.  I think the invariants may want to use everything there is, but I can imaginge some useful subsets.</p>",
        "id": 153928845,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1516020219
    },
    {
        "content": "<p>Then, about FHIRPath language extensions. You mentioned \"sum()\".  One of the major \"usual\" operations that come with these kind of languages is fold/aggregate (of which sum() would be a specialization).  We might need to talk about whether we just stick to sum() or take a look at fold() (though that would need lambda notation in the language, now we're talking major changes).</p>",
        "id": 153928846,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1516020309
    },
    {
        "content": "<p>I want to set a constraint for a practitioner's name (German base profile). With fhirpath I would like to express that at least one name should be official (use = \"official\"). I have formulated the following fhirpath expression: (use = 'official').count ()&gt; 0 . When I validate an example practitioner that does not have a name with use=official, I expect an error, but there is no. Can anyone help me with fhirpath expression?</p>",
        "id": 165149330,
        "sender_full_name": "Katarina",
        "timestamp": 1557309715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span>  i think we have to wait for more database-oriented people to start this subset - I would define it as efficient FHIRpath subset for data extraction to index and search FHIR resources. For DSL I think it's ok to have min, max, sum and avg as built-ins (for performance reason)</p>",
        "id": 165149591,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1557309965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"221154\">@Katarina</span> I expect that to work - whatever the problem is not in the FHIRPath statement. Can you turn it into a profile / instance combination and submit an issue so I can look at it?</p>",
        "id": 165150275,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1557310793
    },
    {
        "content": "<p>@ Grahame Grieve Thanks for your feedback. My profile looks like this:</p>\n<p>&lt;StructureDefinition xmlns=\"<a href=\"http://hl7.org/fhir\" target=\"_blank\" title=\"http://hl7.org/fhir\">http://hl7.org/fhir</a>\"&gt;<br>\n&lt;url value=\"https://example.de/fhir/StructureDefinition/MyPractitioner\"/&gt;<br>\n&lt;name value=\"MyPractitioner\"/&gt;<br>\n&lt;status value=\"draft\"/&gt;<br>\n&lt;fhirVersion value=\"3.0.1\"/&gt;<br>\n&lt;kind value=\"resource\"/&gt;<br>\n&lt;abstract value=\"false\"/&gt;<br>\n&lt;type value=\"Practitioner\"/&gt;<br>\n&lt;baseDefinition value=\"http://fhir.de/StructureDefinition/practitioner-de-basis/0.2\"/&gt;<br>\n&lt;derivation value=\"constraint\"/&gt;<br>\n &lt;differential&gt;<br>\n &lt;element id=\"<a href=\"http://Practitioner.name\" target=\"_blank\" title=\"http://Practitioner.name\">Practitioner.name</a>\"&gt;<br>\n&lt;path value=\"Practitioner.name\"/&gt;<br>\n&lt;min value=\"1\"/&gt;<br>\n &lt;constraint&gt;<br>\n&lt;key value=\"oneOfficialName\"/&gt;<br>\n&lt;severity value=\"error\"/&gt;<br>\n&lt;human value=\"One name must be official.\"/&gt;<br>\n&lt;expression value=\"(use='official').count()&gt;0\"/&gt;<br>\n&lt;/constraint&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.name.family\"&gt;<br>\n&lt;path value=\"Practitioner.name.family\"/&gt;<br>\n&lt;min value=\"1\"/&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.name.given\"&gt;<br>\n&lt;path value=\"Practitioner.name.given\"/&gt;<br>\n&lt;min value=\"1\"/&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.address\"&gt;<br>\n&lt;path value=\"Practitioner.address\"/&gt;<br>\n&lt;min value=\"1\"/&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.address.use\"&gt;<br>\n&lt;path value=\"Practitioner.address.use\"/&gt;<br>\n&lt;fixedCode value=\"work\"/&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.address.type\"&gt;<br>\n&lt;path value=\"Practitioner.address.type\"/&gt;<br>\n&lt;fixedCode value=\"physical\"/&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.address.line.extension:Postfach\"&gt;<br>\n&lt;path value=\"Practitioner.address.line.extension\"/&gt;<br>\n&lt;sliceName value=\"Postfach\"/&gt;<br>\n&lt;max value=\"0\"/&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.address.state\"&gt;<br>\n&lt;path value=\"Practitioner.address.state\"/&gt;<br>\n &lt;binding&gt;<br>\n&lt;strength value=\"required\"/&gt;<br>\n&lt;description value=\"BundeslÃ¤nder\"/&gt;<br>\n&lt;/binding&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.address.postalCode\"&gt;<br>\n&lt;path value=\"Practitioner.address.postalCode\"/&gt;<br>\n&lt;min value=\"1\"/&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.address.country\"&gt;<br>\n&lt;path value=\"Practitioner.address.country\"/&gt;<br>\n&lt;min value=\"1\"/&gt;<br>\n &lt;binding&gt;<br>\n&lt;strength value=\"required\"/&gt;<br>\n&lt;/binding&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.gender\"&gt;<br>\n&lt;path value=\"Practitioner.gender\"/&gt;<br>\n&lt;max value=\"0\"/&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.birthDate\"&gt;<br>\n&lt;path value=\"Practitioner.birthDate\"/&gt;<br>\n&lt;max value=\"0\"/&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.photo\"&gt;<br>\n&lt;path value=\"Practitioner.photo\"/&gt;<br>\n&lt;max value=\"0\"/&gt;<br>\n&lt;/element&gt;<br>\n &lt;element id=\"Practitioner.communication\"&gt;<br>\n&lt;path value=\"Practitioner.communication\"/&gt;<br>\n&lt;max value=\"0\"/&gt;<br>\n&lt;/element&gt;<br>\n&lt;/differential&gt;<br>\n&lt;/StructureDefinition&gt;</p>\n<p>And my example:</p>\n<p>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br>\n&lt;Practitioner xmlns=\"<a href=\"http://hl7.org/fhir\" target=\"_blank\" title=\"http://hl7.org/fhir\">http://hl7.org/fhir</a>\"&gt;<br>\n    &lt;meta&gt;<br>\n        &lt;profile value = \"https://example.de/fhir/StructureDefinition/MyPractitioner\"/&gt;<br>\n    &lt;/meta&gt;<br>\n    &lt;active value=\"true\"/&gt;<br>\n    &lt;name&gt;<br>\n        &lt;use value = \"temp\"/&gt;<br>\n        &lt;family value=\"Meier\"/&gt;<br>\n        &lt;given value=\"Maria\"/&gt;<br>\n        &lt;given value=\"Anna\"/&gt;<br>\n        &lt;prefix value = \"Dr.med.\"/&gt;<br>\n    &lt;/name&gt;<br>\n    &lt;name&gt;<br>\n        &lt;use value = \"maiden\"/&gt;<br>\n        &lt;family value=\"MÃ¼ller\"/&gt;<br>\n        &lt;given value=\"Maria\"/&gt;<br>\n        &lt;given value=\"Anna\"/&gt;<br>\n        &lt;prefix value = \"Dr.med.\"/&gt;<br>\n    &lt;/name&gt;<br>\n    &lt;telecom&gt;<br>\n        &lt;system value=\"phone\" /&gt;      <br>\n        &lt;value value= \"030-1234567\"/&gt;<br>\n        &lt;use value = \"work\"/&gt;<br>\n    &lt;/telecom&gt;<br>\n    &lt;telecom&gt;<br>\n        &lt;system value=\"email\" /&gt;      <br>\n        &lt;value value= \"meierA@hno.de\"/&gt;<br>\n        &lt;use value = \"work\"/&gt;<br>\n    &lt;/telecom&gt;<br>\n    &lt;address&gt;<br>\n        &lt;use value = \"work\"/&gt;<br>\n        &lt;type value = \"physical\"/&gt;<br>\n        &lt;postalCode value = \"10117\"/&gt;<br>\n        &lt;country value = \"DE\"/&gt;<br>\n        &lt;state value = \"DE-BE\"/&gt;<br>\n    &lt;/address&gt;<br>\n&lt;/Practitioner&gt;</p>",
        "id": 165164213,
        "sender_full_name": "Katarina",
        "timestamp": 1557323264
    },
    {
        "content": "<p>Want to be sure I'm reading this correctly. <br>\nHave this fhirpath expression:<br>\n      &lt;expression value=\"Xor(Observation.valueCodeableConcept.exists(), Observation.dataAbsentReason.exists())\"/&gt;<br>\nGet:<br>\n      Exception in thread \"main\" java.lang.Error: Not done yet (ValidatorHostServices.resolveFunction): Xor<br>\nThis means not implemented? Or is something else going on?</p>",
        "id": 186298194,
        "sender_full_name": "Eric Mays",
        "timestamp": 1579707822
    },
    {
        "content": "<p>I am not sure this is the problem, but I think \"xor\" should be all lowercase.</p>",
        "id": 186312362,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1579716016
    },
    {
        "content": "<p>Thanks, but that's not it:<br>\nException in thread \"main\" java.lang.Error: Not done yet (ValidatorHostServices.resolveFunction): xor<br>\nHave a workaround, so moving on...</p>",
        "id": 186328190,
        "sender_full_name": "Eric Mays",
        "timestamp": 1579725363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span></p>",
        "id": 186328288,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1579725450
    },
    {
        "content": "<p>xor is an operator not a function</p>",
        "id": 186333259,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1579728779
    },
    {
        "content": "<p>Thanks. Got it. Ooops...</p>",
        "id": 186341926,
        "sender_full_name": "Eric Mays",
        "timestamp": 1579735069
    },
    {
        "content": "<p>Hi, I have the following usecase: I have an extension that is a reference to an organization profile. For the organization the type has a valueSet binding. I would like to make restrictions on the organizations that can be referenced. How would I write a fhirpath constraint to say that in the extension only organizations can be referenced for these only a restricted valueSet is valid?</p>\n<p>My Organization profile with valueSet binding:</p>\n<p>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;<br>\n&lt;StructureDefinition xmlns=\"<a href=\"http://hl7.org/fhir\" target=\"_blank\" title=\"http://hl7.org/fhir\">http://hl7.org/fhir</a>\"&gt;<br>\n  &lt;url value=\"<a href=\"https://example/fhir/StructureDefinition/Facility\" target=\"_blank\" title=\"https://example/fhir/StructureDefinition/Facility\">https://example/fhir/StructureDefinition/Facility</a>\" /&gt;<br>\n  &lt;name value=\"Facility\" /&gt;<br>\n  &lt;status value=\"draft\" /&gt;<br>\n  &lt;fhirVersion value=\"3.0.1\" /&gt;<br>\n  &lt;kind value=\"resource\" /&gt;<br>\n  &lt;abstract value=\"false\" /&gt;<br>\n  &lt;type value=\"Organization\" /&gt;<br>\n  &lt;baseDefinition value=\"<a href=\"http://fhir.de/StructureDefinition/organization-de-basis/0.2\" target=\"_blank\" title=\"http://fhir.de/StructureDefinition/organization-de-basis/0.2\">http://fhir.de/StructureDefinition/organization-de-basis/0.2</a>\" /&gt;<br>\n  &lt;derivation value=\"constraint\" /&gt;<br>\n  &lt;differential&gt;<br>\n    &lt;element id=\"Organization.type\"&gt;<br>\n      &lt;path value=\"Organization.type\" /&gt;<br>\n      &lt;min value=\"1\" /&gt;<br>\n      &lt;max value=\"1\" /&gt;<br>\n    &lt;/element&gt;<br>\n    &lt;element id=\"Organization.type.coding\"&gt;<br>\n      &lt;path value=\"Organization.type.coding\" /&gt;<br>\n      &lt;min value=\"1\" /&gt;<br>\n      &lt;max value=\"1\" /&gt;<br>\n    &lt;/element&gt;<br>\n    &lt;element id=\"Organization.type.coding.system\"&gt;<br>\n      &lt;path value=\"Organization.type.coding.system\" /&gt;<br>\n      &lt;min value=\"1\" /&gt;<br>\n      &lt;binding&gt;<br>\n        &lt;strength value=\"required\" /&gt;<br>\n        &lt;valueSetUri value=\"<a href=\"https://example/fhir/ValueSet/facilityType\" target=\"_blank\" title=\"https://example/fhir/ValueSet/facilityType\">https://example/fhir/ValueSet/facilityType</a>\" /&gt;<br>\n      &lt;/binding&gt;<br>\n    &lt;/element&gt;<br>\n    &lt;element id=\"Organization.type.coding.code\"&gt;<br>\n      &lt;path value=\"Organization.type.coding.code\" /&gt;<br>\n      &lt;min value=\"1\" /&gt;<br>\n    &lt;/element&gt;<br>\n  &lt;/differential&gt;<br>\n&lt;/StructureDefinition&gt;</p>\n<p>Usage of the extension:<br>\n&lt;Bundle xmlns=\"<a href=\"http://hl7.org/fhir\" target=\"_blank\" title=\"http://hl7.org/fhir\">http://hl7.org/fhir</a>\"&gt;<br>\n    &lt;type value=\"document\" /&gt;<br>\n    &lt;entry&gt;<br>\n        &lt;resource&gt;<br>\n            &lt;Composition&gt;<br>\n                ...<br>\n                &lt;extension url=\"<a href=\"https://example/fhir/StructureDefinition/IsCaredIn\" target=\"_blank\" title=\"https://example/fhir/StructureDefinition/IsCaredIn\">https://example/fhir/StructureDefinition/IsCaredIn</a>\"&gt;<br>\n                    &lt;extension url=\"organization\" &gt;<br>\n                        &lt;valueReference&gt;<br>\n                            &lt;reference value=\"urn:uuid:61ebe359-bfdc-4613-8bf2-c5e300945f22\" /&gt;<br>\n                        &lt;/valueReference&gt;<br>\n                    &lt;/extension&gt;<br>\n                &lt;/extension&gt;<br>\n            &lt;/Composition&gt;<br>\n        &lt;/resource&gt;<br>\n    &lt;/entry&gt;<br>\n    &lt;entry&gt;<br>\n        &lt;fullUrl value=\"urn:uuid:61ebe359-bfdc-4613-8bf2-c5e300945f22\" /&gt;<br>\n        &lt;resource&gt;<br>\n            &lt;Organization&gt;<br>\n                &lt;meta&gt;<br>\n                    &lt;profile value=\"<a href=\"https://example/fhir/StructureDefinition/Facility\" target=\"_blank\" title=\"https://example/fhir/StructureDefinition/Facility\">https://example/fhir/StructureDefinition/Facility</a>\" /&gt;<br>\n                &lt;/meta&gt;<br>\n                &lt;name value=\"Waldkindergarten\"/&gt;<br>\n<strong>here not every code in <a href=\"https://example/fhir/ValueSet/facilityType\" target=\"_blank\" title=\"https://example/fhir/ValueSet/facilityType\">https://example/fhir/ValueSet/facilityType</a> should be allowed, only a specific set</strong><br>\n            &lt;/Organization&gt;<br>\n        &lt;/resource&gt;<br>\n    &lt;/entry&gt;<br>\n&lt;/Bundle&gt;</p>\n<p>Is fhirpath the right way or are there other possibilities?</p>",
        "id": 188723916,
        "sender_full_name": "Katarina",
        "timestamp": 1582285018
    },
    {
        "content": "<p>It seems that you would just declare a targetProfile for the reference indicating that the Organization needs to be valid against the specified profile</p>",
        "id": 188755801,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1582307043
    },
    {
        "content": "<p>Hi, how can I get the valueReference in a complex extension with fhirpath?</p>\n<p>I tried this: <br>\nComposition.where(extension('https://example/fhir/StructureDefinition/IsCaredIn')).children().where(extension('organization').value='12345')</p>\n<p>My Composition looks like this:<br>\n            &lt;Composition&gt;<br>\n                                ...<br>\n                &lt;extension url=\"<a href=\"https://example/fhir/StructureDefinition/IsCaredIn\" target=\"_blank\" title=\"https://example/fhir/StructureDefinition/IsCaredIn\">https://example/fhir/StructureDefinition/IsCaredIn</a>\"&gt;<br>\n                      &lt;extension url=\"groupInOrganization\" &gt;<br>\n                        &lt;valueString value=\"Spechte und KÃ¤uze\" /&gt;<br>\n                      &lt;/extension&gt;<br>\n                          &lt;extension url=\"lastStayInOrganization\" &gt;<br>\n                         &lt;valueDate value=\"2020-02-02\" /&gt;   <br>\n                          &lt;/extension&gt;<br>\n                          &lt;extension url=\"organization\" &gt;<br>\n                        &lt;valueReference&gt;<br>\n                            &lt;reference value=\"12345\" /&gt;<br>\n                        &lt;/valueReference&gt;<br>\n                    &lt;/extension&gt;<br>\n                &lt;/extension&gt;<br>\n            &lt;/Composition&gt;</p>",
        "id": 189099392,
        "sender_full_name": "Katarina",
        "timestamp": 1582710731
    },
    {
        "content": "<p>And another question:</p>\n<p>\"Bundle.entry.resource.ofType(Composition)\" should bring all Composition-entries in the bundle, right?<br>\nI have three compositions in the bundle, but \"Bundle.entry.resource.ofType(Composition).count()=3\" does not validate in true. What am I doing wrong?</p>",
        "id": 189099687,
        "sender_full_name": "Katarina",
        "timestamp": 1582711027
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span></p>",
        "id": 189130234,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1582734341
    },
    {
        "content": "<p>The extension is a reference, so that it will have the structure of a <a href=\"http://hl7.org/fhir/references.html#Reference\" target=\"_blank\" title=\"http://hl7.org/fhir/references.html#Reference\">Reference</a>, so you need to dig in to the actual <code>reference</code> element: <code>...extension('organization').value.reference='12345'</code></p>",
        "id": 189152888,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1582747428
    },
    {
        "content": "<p>On the second one, that seems like that ought to work, but I wonder if it's getting tripped up by the way resource elements are actually serialized. Can you try <code>Bundle.entry.where(resource is Composition).count() = 3</code>?</p>",
        "id": 189153386,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1582747664
    },
    {
        "content": "<p>Hi, thank you <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span>  that worked!. </p>\n<p>How can I check if the type of an Organization is within a valueSet?</p>\n<p>This seems not to work:<br>\nentry.where(fullUrl='urn:uuid:61ebe359-bfdc-4613-8bf2-c5e300945f22').select(resource as Organization).type.coding.code.memberOf('<a href=\"https://example/fhir/ValueSet/organizationTypesCaredIn\" target=\"_blank\" title=\"https://example/fhir/ValueSet/organizationTypesCaredIn\">https://example/fhir/ValueSet/organizationTypesCaredIn</a>')</p>\n<p>also </p>\n<p>...type.coding.code='code1'  seems not to work.</p>",
        "id": 189226117,
        "sender_full_name": "Katarina",
        "timestamp": 1582818952
    },
    {
        "content": "<p>Hmm... that seems like that memberOf ought to work, what environment are you running the FHIRPath in?</p>",
        "id": 189324782,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1582906911
    },
    {
        "content": "<p>I use Vonk.Server/3.1.1. </p>\n<p>My Organization looks like this:<br>\n            &lt;Organization&gt;<br>\n                &lt;id value=\"23\"/&gt;<br>\n                &lt;meta&gt;<br>\n                    &lt;profile value=\"<a href=\"https://example/fhir/StructureDefinition/Facility\" target=\"_blank\" title=\"https://example/fhir/StructureDefinition/Facility\">https://example/fhir/StructureDefinition/Facility</a>\" /&gt;<br>\n                &lt;/meta&gt;<br>\n                &lt;name value=\"Waldkindergarten\"/&gt;<br>\n                  &lt;type&gt; <br>\n                    &lt;coding&gt; <br>\n                         &lt;system value=\"https://example/fhir/ValueSet/organizationTypesCaredIn\"/&gt; <br>\n                         &lt;code value=\"foodfacility\"/&gt; <br>\n                        &lt;/coding&gt; <br>\n                  &lt;/type&gt;<br>\n            &lt;/Organization&gt;</p>\n<p>I checked the CodeSystem organizationType that contains \"foodfacility\" and the corresponding ValueSet.<br>\nBut I get an error no matter if i put \"foodfacility\" as value for code or some other value not contained in the ValueSet.</p>",
        "id": 189475317,
        "sender_full_name": "Katarina",
        "timestamp": 1583141989
    },
    {
        "content": "<p>Hi,</p>\n<p>Needed a clarification regarding the FHIRPath expression defined in SearchParameter for value[x] parameters.</p>\n<p>The expression for searchparameter to search a value[x] field should have all possible variants allowed for seach ?<br>\nfor example, As of now the FHIRPath expression for the field CarePlan-&gt;activity-&gt;detail-&gt;scheduled  is defined as</p>\n<ol>\n<li>\n<p>\"CarePlan.activity.detail.scheduled\" <br>\nOR</p>\n</li>\n<li>\n<p>\"CarePlan.activity.detail.scheduled as Timing | CarePlan.activity.detail.scheduled as Period | CarePlan.activity.detail.scheduled as string\" ?</p>\n</li>\n</ol>",
        "id": 197897803,
        "sender_full_name": "Nikhil",
        "timestamp": 1589786238
    },
    {
        "content": "<p>What is 'System' referred in System.String? It basically points to the datatype of the language we implement it. Can someone help?</p>",
        "id": 199445559,
        "sender_full_name": "Keerthivasan Ramanathan",
        "timestamp": 1591066039
    },
    {
        "content": "<p>Are you asking about Resource.language? <a href=\"http://hl7.org/fhir/R4/resource.html#Resource\">http://hl7.org/fhir/R4/resource.html#Resource</a><br>\nWhat do you want to know?</p>",
        "id": 199449308,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1591071894
    },
    {
        "content": "<p>When i read the FHIRPath specification, I saw about FHIRPath type that talks about</p>",
        "id": 199450063,
        "sender_full_name": "Keerthivasan Ramanathan",
        "timestamp": 1591072976
    },
    {
        "content": "<p>The evaluation engine will automatically convert the value of FHIR types representing primitives to FHIRPath types when they are used in expressions according to the following mapping:</p>",
        "id": 199450065,
        "sender_full_name": "Keerthivasan Ramanathan",
        "timestamp": 1591072978
    },
    {
        "content": "<p>FHIRPath type represents different values : System.Boolean, System.String, System.Integer</p>",
        "id": 199450093,
        "sender_full_name": "Keerthivasan Ramanathan",
        "timestamp": 1591073025
    },
    {
        "content": "<p>What does System refer to?</p>",
        "id": 199450095,
        "sender_full_name": "Keerthivasan Ramanathan",
        "timestamp": 1591073031
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span></p>",
        "id": 199450193,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1591073147
    },
    {
        "content": "<p>The System namespace is used to define all the system-defined types in FHIRPath (and CQL). The <a href=\"http://hl7.org/fhirpath/#models\">models</a> topic in FHIRPath talks about the System namespace.</p>",
        "id": 199451506,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1591075369
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> and <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span></p>",
        "id": 199471207,
        "sender_full_name": "Keerthivasan Ramanathan",
        "timestamp": 1591092571
    },
    {
        "content": "<p>Quick question about the FHIRPath spec on the hl7 site. I was just wondering if one of the lines is misplaced.<br>\n<a href=\"http://hl7.org/fhirpath/#todate-date\">toDate() : Date</a> It states nothing about partial dates<br>\n<a href=\"http://hl7.org/fhirpath/#convertstodate-boolean\">convertsToDate() : Boolean</a> it states \"If the item contains a partial date (e.g. '2012-01'), the result is a partial date.\"<br>\n<a href=\"http://hl7.org/fhirpath/#todatetime-datetime\">toDateTime() : DateTime</a> it states \"If the item contains a partial datetime (e.g. '2012-01-01T10:00'), the result is a partial datetime.\"<br>\n<a href=\"http://hl7.org/fhirpath/#convertstodatetime-boolean\">convertsToDateTime() : Boolean</a> it states nothing about partial dateTimes</p>",
        "id": 243521968,
        "sender_full_name": "Grey Faulkenberry",
        "timestamp": 1624371004
    },
    {
        "content": "<p>can you ask this on <a class=\"stream\" data-stream-id=\"179266\" href=\"/#narrow/stream/179266-fhirpath\">#fhirpath</a></p>",
        "id": 243525497,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624372376
    },
    {
        "content": "<p>I have a question about restricting one of multiple types of references allowed. For an Observation.basedOn field which allows multiple references, I would like to define a requirement where a reference to a specific profile should only be allowed once. Other references to other profiles should still be valid. Is there a way to express this? I have not been able to find an example or the right syntax.</p>",
        "id": 267670635,
        "sender_full_name": "Gabriela Espinosa",
        "timestamp": 1641949878
    },
    {
        "content": "<p>To check whether the is only one use count().<br>\nThe following test will return true with 0 or 1 matching instances of basedOn.display and false otherwise.<br>\n<code>basedOn.where(display='HHH').count()&lt;=1</code></p>",
        "id": 267677938,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1641957557
    },
    {
        "content": "<p>Why do you want to ensure that at most one referent conforms to the profile? Is it enough to say that only 1 referent of a resource type is allowed, e.g. at most one CarePlan?</p>",
        "id": 267678291,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1641957901
    },
    {
        "content": "<p>To follow a reference use the <code>resolve()</code> function</p>",
        "id": 267678706,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1641958323
    },
    {
        "content": "<p>You can also slice by profile and set a max cardinality of 1 on your slice</p>",
        "id": 267680094,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641959926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179166-implementers/topic/FHIRPath/near/267680094\">said</a>:</p>\n<blockquote>\n<p>You can also slice by profile and set a max cardinality of 1 on your slice</p>\n</blockquote>\n<p>I like the idea of adding a slice for the particular reference and setting the cardinality there. Thanks for the feedback!</p>",
        "id": 267766326,
        "sender_full_name": "Gabriela Espinosa",
        "timestamp": 1642012177
    }
]