[
    {
        "content": "<p>I know you can't slice non-repeating elements. But I would love to slice observation.code (1..1), and then have a choice of three slices (all 0..1) to define a choice. I know I could create a ValueSet binding to a new ValueSet with the three options to do the same thing, but I prefer the slicing option (never thougt I would say that).</p>",
        "id": 153869796,
        "sender_full_name": "Marten Smits",
        "timestamp": 1486047359
    },
    {
        "content": "<p>Also, it's odd that FHIR allows me to slice a <strong>repeating</strong> element, constrain it to 1..1 and have all my slices 0..1<br>\nWhich is exactly the same thing.</p>",
        "id": 153869797,
        "sender_full_name": "Marten Smits",
        "timestamp": 1486047426
    },
    {
        "content": "<p>I can't believe you are saying that as well.   Why not a choice of three profiles one for code a , b and c and what wrong with using a valueset?</p>",
        "id": 153869820,
        "sender_full_name": "Eric Haas",
        "timestamp": 1486072994
    },
    {
        "content": "<p>You would then need an invariant to ensure that 1 of the 3 was selected (as this is a required field)</p>",
        "id": 153869834,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1486078337
    },
    {
        "content": "<p>Seems like a lot of work instead of just providing a restricted binding to the 3 values you want.</p>",
        "id": 153869835,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1486078364
    },
    {
        "content": "<p>Why would I need an invariant? If I define a closed slice on a required element, with all slices 0..1. The slice intro will already tell me that you have to select 1 off the options. For me, this is far less work than creating a new valueset.</p>",
        "id": 153871837,
        "sender_full_name": "Marten Smits",
        "timestamp": 1487236187
    },
    {
        "content": "<p>By having a slice on an element that is 0..1, in which each slice itself has cardinality 0..1, you could create constraints that are alternatives:  e.g. the string length is between 1--5 (one slice) OR 10--20 (the other slice).     Or maybe even more realistic:  with this binding these invariants hold (slice A), with this other binding another set of invariants hold (slice B). </p>",
        "id": 153871838,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1487236874
    },
    {
        "content": "<p>I wonder: if you are allowed to constrain an already sliced element to cardinality 0..1 in a derived profile, why not allow it in the first place?  I think most of our tooling would naturally do the \"right\" thing, unless we explicitly forbid it (as e.g. Forge does now).  Does anyone see unexpected consequences?</p>",
        "id": 153871840,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1487236974
    },
    {
        "content": "<p>I'm about to process a task that changes the way slicing works for 0..1 elements</p>",
        "id": 153872110,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1487275619
    },
    {
        "content": "<p>Where are we at currently? We would use slicing to define a choice of bindings for example. I believe that was what we thought of when we discussed multiple bindings.</p>",
        "id": 165889657,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1558090134
    },
    {
        "content": "<p>We also have a type slice defined on Dosage.dose 0..1 (<a href=\"https://simplifier.net/nictizstu3-zib2017/zib-instructionsforuse\" target=\"_blank\" title=\"https://simplifier.net/nictizstu3-zib2017/zib-instructionsforuse\">https://simplifier.net/nictizstu3-zib2017/zib-instructionsforuse</a>). This aims to say specific things for when Dosage.dose is a SimpleQuantity and for when it's a Range.</p>",
        "id": 165890034,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1558090595
    },
    {
        "content": "<p>you don't slice for different restrictions on different types</p>",
        "id": 165941338,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1558131550
    },
    {
        "content": "<p>I don't follow the multiple bindings thing</p>",
        "id": 165941347,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1558131567
    },
    {
        "content": "<blockquote>\n<p>you don't slice for different restrictions on different types</p>\n</blockquote>\n<p>So what do you do? Do you just start Dosage.doseQuantity versus Dosage.doseRange without slicing discriminator? They are both the same element, distinguishable by type, are they not?</p>",
        "id": 166055695,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1558326588
    },
    {
        "content": "<blockquote>\n<p>I don't follow the multiple bindings thing</p>\n</blockquote>\n<p>Suppose I want codes from ValueSet A or ValueSet B: I'd slice the element and add ValueSet A as binding to the one and ValueSet B to the other.</p>\n<p>The alternative could be that I create a new third ValueSet C and include A &amp; B but I do not want a new ad hoc ValueSet for every combination of ValueSets. I want multiple separate bindings.</p>\n<p>Suppose I want to say use ValueSet A, or use NullFlavor UNK or use NullFlavor  OTH , which is very very common in V3, in FHIR I'd say:</p>\n<ul>\n<li>Slice element</li>\n<li>Add binding to ValueSet A on first slice</li>\n<li>Extend element to support <a href=\"http://build.fhir.org/extension-iso21090-nullflavor.html\" target=\"_blank\" title=\"http://build.fhir.org/extension-iso21090-nullflavor.html\">NullFlavor extension</a> 0..1</li>\n<li>Slice NullFlavor.valueCode</li>\n<li>Add fixedCode UNK to slice1</li>\n<li>Add fixedCode OTH to slice2</li>\n</ul>\n<p>In Templates ITS things could look like this:</p>\n<div class=\"codehilite\"><pre><span></span>&lt;element name=&quot;hl7:value&quot; strength=&quot;required&quot; datatype=&quot;CD&quot; conformance=&quot;R&quot; minimumMultiplicity=&quot;1&quot; maximumMultiplicity=&quot;1&quot;&gt;\n    &lt;vocabulary valueSet=&quot;ValueSetA&quot; flexibility=&quot;2019-01-01T12:34:56&quot;/&gt;\n    &lt;attribute name=&quot;xsi:type&quot; isOptional=&quot;false&quot;/&gt;\n    &lt;attribute name=&quot;nullFlavor&quot; isOptional=&quot;true&quot;&gt;\n        &lt;desc language=&quot;en-US&quot;&gt;Use NullFlavor when there&#39;s no relevant code&lt;/desc&gt;\n        &lt;vocabulary code=&quot;UNK&quot;/&gt;\n        &lt;vocabulary code=&quot;OTH&quot;/&gt;\n    &lt;/attribute&gt;\n&lt;/element&gt;\n</pre></div>",
        "id": 166056309,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1558327587
    },
    {
        "content": "<blockquote>\n<p>Do you just start Dosage.doseQuantity versus Dosage.doseRange without slicing discriminator?</p>\n</blockquote>\n<p>yes</p>",
        "id": 166056536,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1558327956
    },
    {
        "content": "<blockquote>\n<p>create a new third ValueSet C and include A &amp; B</p>\n</blockquote>\n<p>yes. Much better than slicing. And inline the value set if you want</p>",
        "id": 166056553,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1558328002
    },
    {
        "content": "<p>Why? there's slicing involved. Is it all implicit here? Would you do the same for effectiveTime as SXPR_TS versus IVL_TS? This is the V3 equivalent for type slicing</p>",
        "id": 166056605,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1558328073
    },
    {
        "content": "<p>yes. you would</p>",
        "id": 166056745,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1558328319
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>create a new third ValueSet C and include A &amp; B</p>\n</blockquote>\n<p>yes. Much better than slicing. And inline the value set if you want</p>\n</blockquote>\n<p>I've been chewing on that. If I inline an ad hoc valueset then how would a validator request validation on that? There's nowhere to ask for expansion.</p>",
        "id": 166067315,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1558341773
    },
    {
        "content": "<blockquote>\n<p>Why? there's slicing involved. Is it all implicit here? Would you do the same for effectiveTime as SXPR_TS versus IVL_TS? This is the V3 equivalent for type slicing</p>\n<blockquote>\n<p>yes, you would</p>\n</blockquote>\n</blockquote>\n<p>But for V3 effectiveTime, contrary to FHIR doseRange vs dosePeriod, there would not be any difference in path name, so something like \"Use SXPR_TS with a comp IVL_TS and a comp PIVL_TS, OR use IVL_TS with a low and a high\" could look like:</p>\n<p>element SubstanceAdministration.effectiveTime <br>\n.... type SXPR_TS<br>\nelement SubstanceAdministration.effectiveTime.comp<br>\n.... type IVL_TS<br>\nelement SubstanceAdministration.effectiveTime.comp<br>\n.... type PIVL_TS<br>\nelement SubstanceAdministration.effectiveTime <br>\n.... type IVL_TS<br>\nelement SubstanceAdministration.effectiveTime.low<br>\n.... type TS<br>\nelement SubstanceAdministration.effectiveTime.high<br>\n.... type TS</p>",
        "id": 166067528,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1558342021
    },
    {
        "content": "<p>the validator does inline expansion on inline value sets</p>",
        "id": 166069080,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1558343589
    },
    {
        "content": "<p>hmm. that issue will require some thought</p>",
        "id": 166069091,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1558343607
    },
    {
        "content": "<blockquote>\n<p>the validator does inline expansion on inline value sets</p>\n</blockquote>\n<p>Only if it knows about the systems involved, or if it is an extensional set I'm assuming</p>",
        "id": 166074971,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1558349663
    },
    {
        "content": "<p>it can handle pretty much anything, I think. If it can't resolve the value set, it just passes it to the terminology server as a parameter</p>",
        "id": 166075015,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1558349747
    },
    {
        "content": "<p>Did anyone ever think of a terminology server hint extension on a ValueSet so you don't have to wonder where to search for answers based on just the ValueSet?</p>",
        "id": 166096104,
        "sender_full_name": "Alexander Henket",
        "timestamp": 1558367501
    },
    {
        "content": "<p>can you explain that a bit more please</p>",
        "id": 166121918,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1558388227
    },
    {
        "content": "<p>I'm raising this issue again.  Have we categorically decided to reject this possibility (now and forever), or is it still open for consideration?  There is no clear answer that I see to that up to this point in the topic thread.  In the spec under <a href=\"http://build.fhir.org/profiling.html#slicing\">Slicing</a> it says:</p>\n<blockquote>\n<p>One common feature of constraining StructureDefinitions is to take an element that may occur more than once (e.g. in a list), and then split the list into a series of sub-lists, each with different restrictions on the elements in the sub-list with associated additional meaning.</p>\n</blockquote>\n<p>But that statement doesn't even include slicing polymorphic elements on type, which clearly <strong>is</strong> allowed, so the statement is obviously incomplete.  And the <a href=\"http://build.fhir.org/elementdefinition.html#slicing\">Rules about Slicing</a> in ElementDefinition also don't address this.  We've also had several Zulip topics which have brought up the issue, but I don't see any firm conclusions on it.</p>\n<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> said <a href=\"#narrow/stream/179252-IG-creation/topic/IG.20Publisher.20error.3A.20slice.20does.20not.20repeat\">here</a> in Sep 2018 that:</p>\n<blockquote>\n<p>It's legitimate to slice non-repeating elements</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> disagreed with that and said that is documented <a href=\"http://build.fhir.org/elementdefinition.html#typesx\">here</a>, but that actually only says (at least currently in the CI build) that you <strong>can</strong> slice polymorphic elements.  Lloyd added that:</p>\n<blockquote>\n<p>I still thought we supported slicing non-repeating elements. E.g. allowing you to say that a non-repeating element needs to follow constraint set X or Y</p>\n</blockquote>\n<p>And <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> questioned:</p>\n<blockquote>\n<p>I wasn't aware that slicing is apparently only allowed for repeating elements... why would cardinality be a limiting factor?</p>\n</blockquote>\n<p>The remainder of that Zulip topic thread had some further discussion, but (to my reading) didn't resolve whether this is (or should be) allowed or not - just that the tools likely didn't support it, but there was no significant technical barrier to implementing it.  The same issue has been picked up and discussed in several other topics (the ones that I've found are <a href=\"#narrow/stream/179177-conformance/topic/Slicing.20a.20non-repeating.20element\">here</a>, <a href=\"#narrow/stream/179166-implementers/topic/Choice.2Falternatives.20example.20over.20the.20same.20type\">here</a> and <a href=\"#narrow/stream/179252-IG-creation/topic/Binding.20vs.20Slicing.20one.20coded.20field.20for.20multiple.20value.20sets\">here</a>) - with my summary of the overall conclusions being Grahame's thoughts that it's \"semantically wrong\" and \"non-sensical\", and also the observations that it's not currently supported (or at least not fully supported) by the tooling.</p>\n<p>After looking again through all of this, it seems to me that <span class=\"user-mention\" data-user-id=\"191334\">@Marten Smits</span>'s original request at the beginning of this topic thread, also repeated by others (including myself), to be able to slice a non-repeating non-polymorphic element to allow a choice between multiple sets of constraints would be useful to have in a number of situations.  And it also doesn't seem that it's been clearly explained (at least not yet) why this should be explicitly <strong>disallowed</strong>.  I'm interested in hearing what the community thinks about it at this point.  And if we come to the conclusion yet again that we <strong>don't</strong> allow this, then I would at least like to see that made explicit and explained to a reasonable degree in the specification, so that maybe we can lessen any confusion and ideally avoid the need to keep discussing this.</p>",
        "id": 200730537,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1592000126
    },
    {
        "content": "<blockquote>\n<p>Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types.</p>\n</blockquote>",
        "id": 200730950,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1592000421
    },
    {
        "content": "<p><a href=\"http://hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.slicing\">http://hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.slicing</a></p>",
        "id": 200730964,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1592000440
    },
    {
        "content": "<p>Yes.  I read it again but missed including that in the post.  So it is stated there.  But I still haven't seen a clear explanation of why it <strong>should</strong> be that way, as opposed to the alternative.  What else have I missed?</p>",
        "id": 200731200,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1592000602
    },
    {
        "content": "<p>for me, it's about minimising complexity. Slicing is nasty and hard.</p>",
        "id": 201169071,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1592412768
    },
    {
        "content": "<p>Yes.  I agree that slicing is hard (I don't really want to call it nasty!) - but we decided to include it as a feature in FHIR from the very beginning, so we're kind of stuck with that at this point. :)  And, (not presuming to discuss internal representations here) we've already built the code that handles this complexity.  To restate the basic premise of slicing, it's that it allows multiple sets of constraints to be defined and then for one of those sets of constraints to be applied (based on the values of the discriminators) for a particular repeat of a repeating (max = *) element.  But logically, a non-repeating (max = 1) element is simply the degenerate case of a repeating element - the single repeat in that case can have one of the defined constraint sets applied, just like any other repeat.  And, beyond that, we're already slicing non-repeating elements in the polymorphic case - it's just that in that case we've pre-defined the slicing based on type rather than allowing other discriminators.  So, at a simplistic level, if we stop explicitly <strong>excluding</strong> the non-repeating non-polymorphic case, then it should already be covered.</p>",
        "id": 201190533,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1592422916
    },
    {
        "content": "<p>Do we have a tracker item for this or any other formal vote on the issue?</p>",
        "id": 202784500,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1593768708
    },
    {
        "content": "<p>I'm not sure. It was a decision from a long time ago, that's for sure</p>",
        "id": 202784912,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1593768984
    },
    {
        "content": "<p>I just have the feeling that with some hindsight more people are in favor of allowing it and the .NET tooling supports it like <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> and <span class=\"user-mention\" data-user-id=\"191334\">@Marten Smits</span> described it in 2017.</p>",
        "id": 202785542,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1593769503
    },
    {
        "content": "<p>Any proposals on how to move this forward?</p>",
        "id": 202786301,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1593770052
    },
    {
        "content": "<p>I guess to create a task and ask FHIR-I to consider it.</p>",
        "id": 202788873,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1593771933
    },
    {
        "content": "<p>I'm not in favour, as you can probably tell. I don't really see the use case</p>",
        "id": 202788891,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1593771948
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> Could you create this tracker item and highlight a few IPS use cases based on which we could discuss the issue?</p>",
        "id": 202790108,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1593772932
    },
    {
        "content": "<p>The use-case is to describe alternatives where it's clearer, cleaner - or in some cases, only possible - to use element-based constraints to define the alternatives (i.e. FHIRPath invariants don't meet the requirement)</p>",
        "id": 202804611,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1593783569
    },
    {
        "content": "<p>Yes, I can create a tracker for this and include the cases that we have in IPS (and probably some others that I've heard about).  I'll try to do that later today.</p>",
        "id": 202818435,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1593792444
    },
    {
        "content": "<p>it's hard for to imagine that slicing is better than some other alternative</p>",
        "id": 202836316,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1593809691
    },
    {
        "content": "<p>It's not too hard for me to imagine - it seems like a good fit for what we want to do, and that's why we went that way.  I think it seems preferable, at least in some cases, to having a single value set with everything included.  Of course that can be discussed and debated, and either can work.  Do you have some other alternatives in mind?</p>",
        "id": 202853149,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1593831824
    },
    {
        "content": "<p>The only other alternative I'm aware of is FHIRPath, and slicing is generally better than that - both for being more expressive than FHIRPath can be and for being easier for most folks to read and understand.</p>",
        "id": 202854027,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1593833563
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> Did you create the tracker item with the IPS use cases? Would this be a good topic for the WGM?</p>",
        "id": 210051049,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1600111252
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193430\">@Alexander Zautke</span> Sorry for the slow reply.  I had a tracker (with quite a bit of text) ready to submit but lost it due to a Confluence glitch. :(  It's still on my plate to redo and submit it.  We're tracking it on the IPS calls (including yesterday).  I agree that it is a good topic for the WGM, so I will get it on the front burner again and have the tracker submitted and ready in advance of next week.  I guess we need to figure out where best to discuss it?</p>",
        "id": 210391060,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1600350094
    },
    {
        "content": "<p>Presumably a FHIR-I session, so I will look at that.</p>",
        "id": 210391148,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1600350127
    },
    {
        "content": "<p>I'll still submit that tracker.</p>",
        "id": 210796080,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1600720401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193430\">@Alexander Zautke</span> I added this to Monday's regular call agenda (Monday 3 PM ET). <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> If you have tracker number, I can add to agenda.</p>",
        "id": 211005754,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1600869163
    },
    {
        "content": "<p>Thanks, Yunwei.  I'm still working on finding the time to collect the details again and get the tracker submitted (I <strong>should</strong> be able to do that today).  I'll let you know the tracker number when I do.</p>",
        "id": 211012129,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1600871711
    },
    {
        "content": "<p>We talked about your issue in the FHIR-I call <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> (didn't see whether or not you were there too). The request was denied on grounds of complexity and the fact that it would impact the implementations in toolings on different platforms. However, we as Firely maintain the .NET tooling (the SDK/API) and for us the impact of implementing this would be relatively small since we already make very little distinction between 'singular' and 'plural' element definitions. So for us the complexity would actually ga down, since we wouldn't have to make the distinction anymore. And logically it also makes sense to synchronize the two. I can imagine this can be (much) harder in other implementations though. <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> , for example, told us that it would be a lot of work in the Java tooling. Since it is potentially also quite an incompatible change, I would personally suggest to at least defer the change a little bit and put it on the road map for R5? Would that be an option?</p>",
        "id": 224866683,
        "sender_full_name": "Abel Enthoven",
        "timestamp": 1612270601
    },
    {
        "content": "<p>Yes, I saw that (and chatted with <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> about it a bit afterward).  I normally try to make it for the FHIR-I calls, but had to miss it yesterday. :(  And I had no idea that this tracker was going to be on the agenda.  I appreciate hearing your perspective on it from Firely, <span class=\"user-mention\" data-user-id=\"221719\">@Abel Enthoven</span>, as what you said is what makes sense to me.  I agree that ultimately this should actually help to reduce the overall complexity, rather than add to it - but rework is always hard, as <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> indicated.  It doesn't seem to me that the change to support this would be incompatible, as it would be officially supporting an additional capability but would not be removing or changing anything that is already being supported.  And I think in the spec itself it is only the text describing slicing and the rules for it that would need to be changed?  That is why if it had been approved, this could potentially be used in R4 if the tooling was updated to support it.  And at this point I'm fine with looking further at any possibilities for R5, as long as there is sufficient interest (probably beyond just the IPS team). <span class=\"user-mention\" data-user-id=\"191415\">@Giorgio Cangioli</span></p>\n<p>But my interpretation of the vote and resolution yesterday and the subsequent discussion so far is that the intent of that was pretty much to close the door on this - unless \"there are a number of convincing use-cases brought forward that can't reasonably be met by another technical solution\".  I think we've already made the case for including this, and I'm not sure that anyone will bring forward new use cases (or very many of them) that don't have, even if not as elegant, some available workaround.  And actually I think you could probably make that same argument for slicing in general.  Slicing is now a very prominent and useful feature in FHIR profiling.  But I suspect it may be correct to say that if FHIR didn't already have slicing, that we could argue against adding it at all because it doesn't provide any capabilities that couldn't \"reasonably be met by another technical solution\".  That's my take at the moment, and I'm happy to have further discussion.</p>",
        "id": 224879420,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1612276791
    },
    {
        "content": "<p>Changing cardinality breaks the json representation, so it's somewhat problematic, but technically allowed to do.  The use-cases that we saw submitted so far were ones that could be handled easily enough with invariants.  If you have convincing use-cases that <em>can't</em> be met with invariants, please bring them forward.</p>",
        "id": 224881055,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612277468
    },
    {
        "content": "<p>Of course you are right <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> that there are no use cases demanding these changes as all of them could be covered by invariants. I do think there is one compelling argument for me to change it anyway though. As <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> says all of the restrictions made using slicing on 'plural' element definitions could also be covered using invariants. But if you continue on that path, there is much more of the restrictions (minvalue, maxvalue, fixed, etc.) that could be covered using invariants. To me (but correct me if I'm wrong) one of the reasons for separating those restrictions out in their own fields was that a user interface would be able to use them to 'automagically' generate the appropriate components. For example: knowing the maximum length of a string you can generate an appropriately sized text field. At a certain point though, the elementDefinition cannot continue to grow more complex and invariants take over. And for many situations they suffice, for they can be executed against the model and generate warnings or errors bound to an element. So there is a balance between complexity of the ElementDefinition and the use of the model for automation. In the case of slicing of the 'singular' element definition, I think I could argue that it would be useful for an automated system to know which possibilities it needs to support for a singular element. Although it is theoretically possible to derive that from invariants I think it would be very beneficial to be able to read them directly from the sliced ElementDefinition.</p>",
        "id": 224888953,
        "sender_full_name": "Abel Enthoven",
        "timestamp": 1612280756
    },
    {
        "content": "<p>To be clear, I am in favor of allowing slicing on non-repeating elements.  Conceptually, there are all sorts of reasons why it could be useful.  The resolution was saying that we're not going to undertake the degree of effort required for conceptual benefits - we need concrete practical benefits.  \"Real-world\" scenarios that obviously need to be supported, but where using invariants can't cut it - either because it's expressing things that invariants can't do, or because the invariants would get unreasonably complex/non-maintainable/non-comprehensible.</p>",
        "id": 224889548,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612280981
    },
    {
        "content": "<p>We'll continue to think about and see about compiling the \"Real-world\" scenarios.  At least if the bar is \"invariants can't cut it\" because they \"would get unreasonably complex/non-maintainable/non-comprehensible\", that is somewhat easier to meet than \"<em>can't</em> be met with invariants\", which would be nearly or completely impossible.</p>",
        "id": 224903313,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1612285972
    },
    {
        "content": "<p>Invariants can't express mustSupport, can't provide documentation or usage notes.</p>",
        "id": 224903526,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612286046
    },
    {
        "content": "<p>Yes, that is true.  Maybe we can further describe why those items are needed, or at least are very useful to have.</p>",
        "id": 224904298,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1612286301
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> I'm also not clear what you are thinking of in regard to \"changing cardinality\", as I don't think that allowing a non-repeating (0..1 or 1..1) element to be sliced has anything to do with making changes to cardinality or anything that would affect the json representation.  Can you explain?</p>",
        "id": 224904473,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1612286378
    },
    {
        "content": "<p>Never mind.  My head was thinking about something else that wasn't relevant.  No cardinality change would be involved in loosening this restriction.</p>",
        "id": 224905819,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612286869
    },
    {
        "content": "<p>No problem - thanks for the clarification!</p>",
        "id": 224906040,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1612286966
    },
    {
        "content": "<p>any change to the snapshot generation / validation code is now scary - changes to test cases are starting to mean weeks of work to deal with the ramifications. Irrespective of the actual work in the code.</p>",
        "id": 224938909,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612301126
    },
    {
        "content": "<p>I think that the real driver is bindings. I'm going to work on them independently</p>",
        "id": 224938959,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612301149
    },
    {
        "content": "<p>I'm happy that you are planning to work on bindings.  But a binding is a type of constraint.  And a slice is a set of constraints (which may include a binding) which is applied for an instance of an element or group of elements that matches the condition(s) in the discriminator (assuming that a discriminator has been defined, which is by far the most common and the preferred case).  I'm not sure (yet) entirely what you have in mind for bindings going forward, but whatever it is it should be able to be and actually be applied consistently across the board - whether the element includes or is part of defined slices or not.  And I assume that you already have that well in mind, but I'm just stating it to be clear.</p>",
        "id": 224941109,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1612302145
    },
    {
        "content": "<p>i'm reading this with interest as I have had a number of cases in my guides where I wanted to slice a choice - if you send me a code, it has these constraint, if it is a reference, it has these constraints, if it is an integer, it has these constraints (to make up a purely arbitrary set of slices).  I can obviously use constraints to provide the restrictions on each choice, but I feel that it is a presentation perspective.  It seems to me that it is easier to portray and understand if it were presented as constraints on slices versus having to read the constraints.</p>",
        "id": 224942210,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1612302656
    },
    {
        "content": "<p>we're not proposing to remove type slicing</p>",
        "id": 224943138,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612303130
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192166\">@Jean Duteau</span>  A choice type (i.e. a polymorphic element) uses the slicing mechanism internally.  And I think the display in the spec (core or IG) is for the most part consistent with that.  So I'm not quite sure what you are describing or looking for that is different from or goes beyond that.  If there is something, maybe you can clarify that?</p>",
        "id": 224943217,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1612303175
    },
    {
        "content": "<p>no, i misread Abel's statement as removing any slicing on non-repeating elements including type slicing.  so my bad.</p>",
        "id": 224943416,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1612303253
    },
    {
        "content": "<p>Oh, right, that makes sense.  As Grahame said, there hasn't been a suggestion or a decision to change that.</p>",
        "id": 224943707,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1612303395
    },
    {
        "content": "<p>going back to reading his statement it isn't as \"omg, what are they doing!\" as I first read. :)</p>",
        "id": 224943872,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1612303466
    },
    {
        "content": "<p>We've just been arguing that non-repeating non-polymorphic elements should be given equal treatment. :)</p>",
        "id": 224944007,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1612303551
    }
]