[
    {
        "content": "<p>What if the base constraint says  \"Only  If A is true\"  and the profile says \"Only if A is false\"?   Is there a  way to validate the profile has properly constrained the invarient?  Or do you figure it out when you start validate profile instances?  </p>",
        "id": 153823008,
        "sender_full_name": "Eric Haas",
        "timestamp": 1461619385
    },
    {
        "content": "<p>I can't validate that invariants clash like that</p>",
        "id": 153823019,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461630799
    },
    {
        "content": "<p>there just isn't any instances that can satisfy that profile</p>",
        "id": 153823020,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461630810
    },
    {
        "content": "<p>In principle, we could use OWL to test those (if we figure out an algorithm to express all FluentPaths in OWL), but we're a ways away from that level of sophistication</p>",
        "id": 153823030,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1461634383
    },
    {
        "content": "<p>pfft. in theory. man. I have the full object model and I know as much about the constraints as anyone. And I have no clue how I could realistically infer from what I know that there's ( A) no instances that are valid and ( B) that's not what you want</p>",
        "id": 153823031,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461634452
    },
    {
        "content": "<p>Well, I think we can presume that no valid instances is never the desired outcome.  To test, we'd enforce all the constraints and then assert that there's at least one valid instance and see if the reasoner blows up.</p>",
        "id": 153823035,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1461634668
    },
    {
        "content": "<p>(but it doesn't blow up if you remove the assertion there's at least one instance)</p>",
        "id": 153823037,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1461634686
    },
    {
        "content": "<p>how do you infer whats' a valid instance from a expression that defines what isn't a valid instance? </p>",
        "id": 153823041,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461635382
    },
    {
        "content": "<p>that's rather harder than it sounds </p>",
        "id": 153823042,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461635389
    },
    {
        "content": "<p>You don't have to.  With the test I described, the reasoner will simply test if any instance is possible.  It won't evaluate whether the possible instance is \"useful\" though.</p>",
        "id": 153823107,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1461679148
    },
    {
        "content": "<p>going to brute force an infinite space, are you? </p>",
        "id": 153823111,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461679277
    },
    {
        "content": "<p>There's nothing brute force about it.  If you've got one constraint that says \"must have A or B but not both\" and a separate constraint that says \"If A or B then must be both\" and you put those together, then the reasoner will simply say \"ok, there can't be any instances of this\".  If you add a separate assertion that there is an instance, the reasoner will blow up.  It doesn't brute force anything, it just checks for consistency.  That said, my experience with this sort of testing is it's not exactly super fast.  Not the kind of thing we'd want to do at run-time</p>",
        "id": 153823160,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1461685452
    }
]