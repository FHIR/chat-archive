[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span><br>\nHi Grahame,<br>\nYou mentioned during today's presentation in Helsinki that you had an example showing why access control logic cannot sit outside the repository in the GraphQL layer? (leftmost vs. rightmost case on the attached slide)<br>\nBR,<br>\n     --Oskari</p>\n<p><a href=\"/user_uploads/10155/lrbyZEH3U1Xzt7GhYK8UVnVN/FHIR_security.jpg\" target=\"_blank\" title=\"FHIR_security.jpg\">FHIR_security.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/lrbyZEH3U1Xzt7GhYK8UVnVN/FHIR_security.jpg\" target=\"_blank\" title=\"FHIR_security.jpg\"><img src=\"/user_uploads/10155/lrbyZEH3U1Xzt7GhYK8UVnVN/FHIR_security.jpg\"></a></div>",
        "id": 181965279,
        "sender_full_name": "Oskari Koskimies",
        "timestamp": 1574803160
    },
    {
        "content": "<p>When elaboration, please differentiate Access Control 'decision' from 'enforcement'. Clearly enforcement is, and will always bee something that is within the FHIR Server. That said, the current SMART scopes are rather blunt to support many authorization decisions.</p>",
        "id": 181975077,
        "sender_full_name": "John Moehrke",
        "timestamp": 1574811238
    },
    {
        "content": "<p>this is a prompt for me to elaborate the use case</p>",
        "id": 181989756,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574830481
    },
    {
        "content": "<blockquote>\n<p>Clearly enforcement is, and will always bee something that is within the FHIR Server.</p>\n</blockquote>\n<p>Could you elaborate? I'm new to FHIR, but if I have a simple CRUD REST API service for a given set of resources, I can't think of any reason why you couldn't implement both access control decision and enforcement in the GraphQL layer on top of the REST API (assuming of course that the REST API cannot be accessed directly by users). See e.g. <a href=\"https://www.apollographql.com/docs/apollo-server/security/authentication/\" target=\"_blank\" title=\"https://www.apollographql.com/docs/apollo-server/security/authentication/\">https://www.apollographql.com/docs/apollo-server/security/authentication/</a>. So there is something special to FHIR in this regard?</p>",
        "id": 181990948,
        "sender_full_name": "Oskari Koskimies",
        "timestamp": 1574832288
    },
    {
        "content": "<p>in principle, you can enforce security in a layer in front of the engine as long as all the decision are made based on what you can see. So a graphQL based decision maker can see all the request and response resources, and decide, for instance, that a returned resource from the REST Api has a security label on it, and not return it</p>",
        "id": 181995118,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574838446
    },
    {
        "content": "<p>this approach doesn't work if access control decisions are made on resources that don't you don't even see on the graphql layer. This principally occurs with chained search parameters</p>",
        "id": 181995186,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574838543
    },
    {
        "content": "<p>e.g. if I do </p>\n<p><code>GET [base]/Observation?code=xxx</code></p>\n<p>The graphQL layer can inspect each returned resource, and decide whether it's acceptable according to some security rules</p>",
        "id": 181995252,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574838613
    },
    {
        "content": "<p>but if the I do </p>\n<p><code>GET [base]/Observation?code=xxx&amp;encounter.class=yy</code></p>",
        "id": 181995265,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574838648
    },
    {
        "content": "<p>the security rules for whether I can do that join, and which encounters can be seen in that join, cannot be enforced outside the join engine - e.g. in the graphQL engine that consumes that the REST Api. It doesn't know anything about the encounters</p>",
        "id": 181995294,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574838707
    },
    {
        "content": "<p>in fact, extending that... a perfectly reasonable rule in the REST Api would be that you can't see observations associated with encounters that you can't see.... that's also pretty difficult to enforce in the graphQL layer, since the encounters aren't naturally visible </p>\n<p>Also, this is all terribly slow compared to integrating these security things into you index / joins</p>",
        "id": 181995375,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574838812
    },
    {
        "content": "<p>that is hard enough in pure FHIR REST... so, yes I could see how it is much harder in graphQL layer.  <br>\nAlso, similar complexity comes if the access control is \"Attribute Based Access Control (ABAC)\", that is where rules are leveraging various elements within Resources.  Such as use of security/privacy tags in .meta.security to segment data.</p>",
        "id": 182023007,
        "sender_full_name": "John Moehrke",
        "timestamp": 1574864622
    },
    {
        "content": "<p>is it appropriate to consider graphQL in a case where data is so highly segmented based on privacy rules and business rules? It seems to be more appropriate to data that are singularly protected (such as a de-identified research database). In the case of a de-identified research database this would not be such a problem.. right?</p>",
        "id": 182023194,
        "sender_full_name": "John Moehrke",
        "timestamp": 1574864733
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> this discussion was effectively about our diagram on the security page that shows implementation of a security engine in front the RESTful API. When teaching in Finland this week, I claimed that you could not implement all of the things you need to do for security in front of the API. the specific question nominated graphQL here because of personal relevance, but it's not the point; it's simply: what is it that you need to integrate into the query engine and you can't achieve in front of it</p>",
        "id": 182031033,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574869835
    },
    {
        "content": "<p>and you're right that a de-identified database probably doesn't have any such cases</p>",
        "id": 182031055,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574869854
    },
    {
        "content": "<p>yup. all models are broken, some are useful</p>",
        "id": 182031933,
        "sender_full_name": "John Moehrke",
        "timestamp": 1574870406
    },
    {
        "content": "<blockquote>\n<p>in principle, you can enforce security in a layer in front of the engine as long as all the decision are made based on what you can see. So a graphQL based decision maker can see all the request and response resources, and decide, for instance, that a returned resource from the REST Api has a security label on it, and not return it</p>\n<p>this approach doesn't work if access control decisions are made on resources that don't you don't even see on the graphql layer. This principally occurs with chained search parameters</p>\n</blockquote>\n<p>Thanks for the explanation! I think the main difficulty I had in understanding the picture on the slide was that it only shows the GraphQL access to the system, and the system <em>looks</em> like a simple data repository. If it were only a database with REST API on top and a GraphQL interface on top of the REST API, I don't think there would be any issue with access control in the GraphQL layer. But in reality it is of course an arbitrarily complex healthcare backend system which has also other interfaces and which might not expose all of its data via the REST API (like you said). Maybe make the \"clinical/healthcare repository\" icon on the slide look less like a database and more like a backend system?</p>",
        "id": 182909121,
        "sender_full_name": "Oskari Koskimies",
        "timestamp": 1575839346
    },
    {
        "content": "<p>ok I'll see what I can do in future, thanks</p>",
        "id": 182910377,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575841633
    }
]