[
    {
        "content": "<p>There's an inconsistency in the specification around the use of the :text modifier on token searches.</p>\n<p>The specification says that the :text modifier \"the match does a partial searches on the text portion of a CodeableConcept or the display portion of a Coding\"</p>\n<p>But it also says: \"the search functions as a normal string search\"</p>\n<p>Those are not the same thing since a normal string search is left match only. (they were, once, so whatever we do counts as at least as a technical correction). And we don't want left match search only in this case. </p>\n<p>But what do we want in this case? That's not so obvious, and we didn't quickly come to resolution on the FHIR-I call where we just discussed it. Partly that's because we're not clear on the use case boundaries. For instance, I've only seen the :text modifier used where a human is driving the search interactively - that matches the use of the :text modifier on a normal string search: we've never said exactly how this works, and we say explicitly that we don't specify it, on the grounds that the use case is some human searching speculatively and adapting to the behavior of the system. But is that what we expect for this field?</p>\n<p>Given that, we'd like some feedback, in two different ways:</p>\n<ul>\n<li>if you have implemented :text search on a token search in your server, how did you do it, and why?</li>\n<li>what you would you like it to do, and why?</li>\n</ul>",
        "id": 243436827,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624306544
    },
    {
        "content": "<p>As a user I would have no idea if the keyword I was looking for is the 1st word, last word or some other position in any coding system. (What's a coding system?) My expectation would be to return everything that might be what I'm looking for. \"Diabetes\" Code.coding = \"mellitus, Diabetes, Type 2\" or \"Diabetes, type\" or .text = \"Suspect Diabetes II\". </p>\n<p>In FHIR words it would be essentially :contains. Case independent, whitespace squashed, special characters removed, contains. <br>\nIf I'm not a layperson, an actual clinical organization then it's likely I'd be searching by the code(s).</p>\n<p>When it comes time for my requirements around implementing :text, that is what I'll be specifying.</p>",
        "id": 243551949,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1624383400
    },
    {
        "content": "<p><code>:contains</code> is substring search. When searching \"eight\", word based search returns like \"every eight hour\". <code>:contains</code> substring search returns \"body weight\" also.</p>",
        "id": 243562158,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1624387809
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"195344\">@Paul Lynch</span></p>",
        "id": 243562213,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1624387841
    },
    {
        "content": "<p>Yes, because if I'm a user (non-clinical) and I'm searching for my \"weight\" observations. I likely have no way to know that the actual dictionary definition of the observation is \"body weight\". Returning 0 records is dirty, you didn't specify the right magic word. There are no observations that \"start-with\" weight. Which is why I say a token param with a text modifier like \"code:text\" does the same operation that a StringParam:contains does.</p>",
        "id": 243573203,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1624392981
    },
    {
        "content": "<p>:contains is definitely an improvement over left-matching, but it has the drawback that it finds the middle of words, as <span class=\"user-mention\" data-user-id=\"191506\">@Yunwei Wang</span>   pointed out.  What users would want is matching on the start of words, not the middle of words.  So, (to borrow Yunwei's example) \"weight\" should match \"body weight\" but \"eight\" should not match \"body weight\".    However, if :contains behavior were the best that could be done for code:text, I would take it.</p>",
        "id": 243694023,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1624473174
    },
    {
        "content": "<p>why would you not want matching on the middle of words? Prefixing is a common practice...</p>",
        "id": 243706870,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624479561
    },
    {
        "content": "<p>If you are trying to do autocompletion, and the user types \"h\", they are expecting to see words beginning with \"h\", not containing \"h\".</p>",
        "id": 243714074,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1624483015
    },
    {
        "content": "<p>I use case I have is that when search <code>cancer lung</code>,  the results includes \"lung cancer\", \"cancer of left lung\", and \"cancer of right lung\". So the search is based on \"any concept has both words lung and word cancer ignoring the order\"</p>",
        "id": 243789250,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1624542891
    },
    {
        "content": "<p>Simple substring :contains could not achieve that.</p>",
        "id": 243789529,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1624543001
    },
    {
        "content": "<p>Generally, the Google implementation uses three kinds of search - exact, substring, and word-based (i.e. matches entire words, in any order, occurring anywhere in the string, like....google search). Prefix search is pretty uncommon.</p>\n<p>Our token:text is word-based. This covers most of the cases people have mentioned, without running into the substring matching problems of \"eight\" matching \"weight\" which seems unhelpful. To be really fancy you'd do stemming and synonyms on top of that, so \"weight\" still matches \"weights\" (we're not doing that currently).</p>\n<p>This is what we think it should do. For that matter, it would be nice if default string search did the same but I suppose that ship has sailed.</p>",
        "id": 243826424,
        "sender_full_name": "Paul Church",
        "timestamp": 1624559053
    },
    {
        "content": "<p>If your parameter is specified as a TokenOrList then would you not query by:<br>\ntoken:text=lung,cancer<br>\ncheck the text of the token for lung or cancer? And if your :text modifier executes as a string:contains....<br>\nMaybe a TokenAndListParam<br>\ntoken:text=lung&amp;token:text=cancer</p>",
        "id": 243836666,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1624563786
    },
    {
        "content": "<p>What do you mean \"TokenOrList\"?</p>",
        "id": 243847444,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1624569118
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197072\">Paul Church</span> <a href=\"#narrow/stream/179166-implementers/topic/Modifiers.20for.20text.20searching.20on.20Tokens/near/243826424\">said</a>:</p>\n<blockquote>\n<p>Our token:text is word-based. </p>\n</blockquote>\n<p>I just wanted a note here that Google's \"word-based\" searching is not the same as word-boundary matching. In our experience with Google's FHIR implementation, searching on code:text only matches on complete words, and won't match prefixes (unless maybe we're missing some configuration option).  To be able to match as the user types, to provide a continually updated list of suggestions, prefix matching at word boundaries is needed.  For example, \"w\" should match \"body weight\" (but  \"e\" should not match it).</p>\n<p>I agree the specification's decription of :text is ambiguous enough to allow for Google's interpretation, though.</p>",
        "id": 249763083,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1629226727
    },
    {
        "content": "<p>Aidbox implemented it as <code>ilike</code> (contains)</p>",
        "id": 249819738,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1629274514
    },
    {
        "content": "<p>I would expect a full text search here. There are many full text search algorithms like trigrams or distance based like Levenshtein.</p>",
        "id": 249879092,
        "sender_full_name": "Alexander Kiel",
        "timestamp": 1629305744
    },
    {
        "content": "<p>trigram is ilike optimization :)</p>",
        "id": 249980775,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1629377290
    }
]