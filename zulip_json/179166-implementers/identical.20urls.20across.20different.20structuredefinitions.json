[
    {
        "content": "<p>Whats the expected behavior for FHIR servers where multiple structuredefinitions are stored with identical urls (I guess this case is not much different from updating a structuredef where the server support versioned structuredefs). Should the server allow it at all? Which structuredef can the client expect its resources to be validated against? Is it random?</p>",
        "id": 158123156,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1549983415
    },
    {
        "content": "<p>It's totally ok for the same canonical URL to appear on multiple instances on the same server.  (Though the 'version' element of each should be different.)  If servers validate against the local copy of a referenced profile, the expectation is they'll use the most recent 'version' unless the declaration is version-specific.  (And in general, version-specific profile declarations are recommended.)</p>",
        "id": 158129837,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1549988287
    },
    {
        "content": "<p>As an example, Simplifier also allows duplicate canonical urls. A common canonical url may be assigned to many profiles across many different projects. However the system requires that all public resources must have a unique canonical url - to prevent globally visible url conflicts.</p>",
        "id": 158130111,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1549988511
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> How would you handle exposing different versions of a profile or value set?  (Given that the canonical URL can - and generally should - remain the same across versions)</p>",
        "id": 158130989,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1549989193
    },
    {
        "content": "<p>Good question!<br>\nMore precisely, for <em>public</em> resources, Simplifier requires that the canonical url and version are globally unique.<br>\nFor private resources, Simplifier requires that the canonical url and version are unique within the containing project.</p>",
        "id": 158133737,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1549991243
    },
    {
        "content": "<p>(And requests for unversioned canonical urls get the latest available version)</p>",
        "id": 158133846,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1549991324
    },
    {
        "content": "<blockquote>\n<p>It's totally ok for the same canonical URL to appear on multiple instances on the same server.  (Though the 'version' element of each should be different.)  If servers validate against the local copy of a referenced profile, the expectation is they'll use the most recent 'version' unless the declaration is version-specific.  (And in general, version-specific profile declarations are recommended.)</p>\n</blockquote>\n<p>So for instance, <a href=\"http://hapi.fhir.org/baseDstu3/StructureDefinition?url=http://trifork.dk/fhir/StructureDefinition/dk-tm-message&amp;_count=3\" target=\"_blank\" title=\"http://hapi.fhir.org/baseDstu3/StructureDefinition?url=http://trifork.dk/fhir/StructureDefinition/dk-tm-message&amp;_count=3\">http://hapi.fhir.org/baseDstu3/StructureDefinition?url=http://trifork.dk/fhir/StructureDefinition/dk-tm-message&amp;_count=3</a> gives you 3 StructureDefs all with the same canonical url and the 3 StructureDefs are independent of each other - meaning that they carry independent version numbers (all v1). Which one should the server use for validation ?</p>",
        "id": 158423880,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1550048598
    },
    {
        "content": "<p>that can't be resolved. It's probably bad business practice to allow that, but it's a business decision to decide how that's resolved</p>",
        "id": 158430042,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550054520
    },
    {
        "content": "<p>Its really bad practice ... so since its so evidently bad practice why allow it in terms of the standard?</p>",
        "id": 158430566,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1550055068
    },
    {
        "content": "<p>are you claiming that there should be no way to have a server like simplifier that allows compartmented duplications? Are you sure that there's never a valid use for a serer to allow duplicates even if it doesn't and can't do validation? Just a general purpose repository, maybe for audit/archive purposes?</p>",
        "id": 158431167,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550055822
    },
    {
        "content": "<p>when we define a conformance service (parallel to the terminology service) then that's the place to make rules about URLs and  business management decisions</p>",
        "id": 158431218,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550055860
    },
    {
        "content": "<p>so whats the terminology here ... we have terminology services, conformance services .... and what is the name for the actual FHIR services hosting the actual data</p>",
        "id": 158432694,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1550057459
    },
    {
        "content": "<p>it's about purpose, not which is actually hosting the data. If you're hosting the resources in order to provide validation services, you shouldn't allow duplicates to exist</p>",
        "id": 158433004,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550057807
    },
    {
        "content": "<p>I would say that Simplifiers approach seems valid - but I would also think that Simplifier is more of an exception to most of the FHIR servers out there</p>",
        "id": 158433702,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1550058542
    },
    {
        "content": "<p>it is. but hard rules don't allow for exceptions</p>",
        "id": 158439046,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550064043
    },
    {
        "content": "<p>I guess I'll have to index myself out of that one - and so does everybody else or do something alike</p>",
        "id": 158449589,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1550071898
    },
    {
        "content": "<p>Ontoserver's general approach is to delay raising it as a problem. So you can add ValueSets/StructureDefinitions/CodeSystems/etc with identical urls/versions, and it will only be raised as a problem when an operation needs to resolve one and can't</p>",
        "id": 158506816,
        "sender_full_name": "Jim Steel",
        "timestamp": 1550126553
    },
    {
        "content": "<p>e.g. if you use type-level ValueSet $expand with a url and no version, then we will try to resolve either a unique ValueSet with that URL, or if there are multiple versions available, with a uniform version string format that allows the server to determine a latest version, then it will work. Otherwise Ontoserver will return either 400 or 422 (depending on where the ambiguity comes from), along with a message saying what the ambiguity was</p>",
        "id": 158506878,
        "sender_full_name": "Jim Steel",
        "timestamp": 1550126665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191376\">@Jim Steel</span> - so if you would like to validate  incoming a resource that is to be created and you have multiple structuredefs with the same url but with different (conflicting) requirements - what do you then do?</p>",
        "id": 158511999,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1550133132
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> - I can suggest that there would be a set of recommended constraints for each type of services that's out there - e.g. conformance services, terminology services and 'treatment services (regular instances that aids in storing state for patient treatment)' and so on - stating what would be good practice and why</p>",
        "id": 158517844,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1550139378
    },
    {
        "content": "<p>Same logic. If the StructureDefs all have a version, and all of those versions are in a consistent format (e.g. 1.2.3 or 20190215), then we will use the most recent. If not, we will return a 400 (if the SD url was provided in the request) or a 422 (if the SD url was in a resource that was already on the server).</p>",
        "id": 158574557,
        "sender_full_name": "Jim Steel",
        "timestamp": 1550186356
    },
    {
        "content": "<p>Maybe there's a need for a search parameter type of canonical that applies these rules in the server for resolution.<br>\nWorking out which is the latest version etc. Without the client needing to know about it.<br>\n(Then the resolve from the validator can call that, and doesn't have to work things out itself)</p>",
        "id": 158583537,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1550197103
    },
    {
        "content": "<p>If the validator calls an operation without specifying a version, the same thing will happen</p>",
        "id": 158586837,
        "sender_full_name": "Jim Steel",
        "timestamp": 1550201603
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> I could see the canonical being useful, but I'd have to review the existing spec to see if it is actually new functionality not already defined</p>\n<p><span class=\"user-mention\" data-user-id=\"191427\">@Jens Villadsen</span> I agree that this would be good. Since we only have one service defined, we should start by adding a section to that one.. a task would be good</p>",
        "id": 158605751,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550227688
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> <a href=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20398\" target=\"_blank\" title=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20398\">https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=20398</a></p>",
        "id": 158785641,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1550481338
    },
    {
        "content": "<p>What about uniqueness on SearchParameters ... shouldn't that also be the case?</p>",
        "id": 177515481,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1570452564
    },
    {
        "content": "<p>Yes</p>",
        "id": 177517533,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1570454152
    },
    {
        "content": "<p>maybe it all could be a BOF topic on devdays?</p>",
        "id": 177517784,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1570454299
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191376\">@Jim Steel</span>, yes, Forge takes the same approach. If the project folder contains multiple profiles with a common canonical url, then Forge allows you to open/edit each of the duplicates. However if you open some other profile with a reference to that canonical url, then Forge will raise a runtime error (ambiguous).<br>\nNote: we could implement a opoup dialog that allows the user to choose the target profile from a list of available duplicates.</p>",
        "id": 177518528,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1570454822
    },
    {
        "content": "<p>Anyone up for a BoF on this topic in the upcoming days?</p>",
        "id": 180999040,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1574069227
    },
    {
        "content": "<p>what is there to talk about?</p>",
        "id": 180999079,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574069276
    },
    {
        "content": "<p>best practice rules for uniqueness on the different kinds of services out there and what/how uniqueness is best expressed in terms of structuredefs and searchparams</p>",
        "id": 181007685,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1574076806
    },
    {
        "content": "<p>an where such content should be placed</p>",
        "id": 181007873,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1574076980
    },
    {
        "content": "<p>Resources have rules about when changing something should impact its business version.  That's one dimension of the uniqueness story, but it's probably attenuated for any Resource with draft status.<br>\nI think a discussion about version resolution OTOH would be very useful -- If a canonical references blah|4.0.0 is it valid to resolve that to an available resource with url blah|4.0.1 - what about a canonical of the form blah|4.0 - should that match the latest of any blah|4.0.x canonicals?</p>",
        "id": 181007982,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1574077129
    },
    {
        "content": "<p>Having a discussion on version resolution would be very useful. The business version (after the url) is independent of the FHIR version, as a custom profile is extended it gets a new business version but the FHIR version and canonical remains the same. Can I then query a FHIR server for the canonical|business version combination to only get resources of the latest business version of a profile?</p>",
        "id": 181008816,
        "sender_full_name": "Hans van Amstel",
        "timestamp": 1574077935
    },
    {
        "content": "<p>So back to this again (now located on <a href=\"https://jira.hl7.org/browse/FHIR-20398\" title=\"https://jira.hl7.org/browse/FHIR-20398\">https://jira.hl7.org/browse/FHIR-20398</a>). When I advise my clients on the use of FHIR and what they should do in order to establish a safe test bed where they themselves can change the SD's and if they run on the HAPI FHIR stack, I always advise them to make the url on SD's unique by setting up indexes using Search Params using the special HAPI FHIR extensions. I still believe this should be mentioned as a way harnessing a FHIR test environment in order to make which versions of an SD one validates against - <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span>  <span class=\"user-mention\" data-user-id=\"191376\">@Jim Steel</span> <span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> <span class=\"user-mention\" data-user-id=\"218569\">@Hans van Amstel</span>  .</p>",
        "id": 192315750,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1585601484
    }
]