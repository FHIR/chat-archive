[
    {
        "content": "<p>I don't know if anyone wants to add anything here: <a href=\"http://community.fhir.org/t/why-did-you-break-the-international-json-standard/1367/6\" target=\"_blank\" title=\"http://community.fhir.org/t/why-did-you-break-the-international-json-standard/1367/6\">http://community.fhir.org/t/why-did-you-break-the-international-json-standard/1367/6</a></p>",
        "id": 166957879,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559262889
    },
    {
        "content": "<p>I know we had to modify our JSON lib to handle this. It wasn't as simple as one would hope, and it is a place I worry many developers will miss</p>",
        "id": 167026586,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1559331075
    },
    {
        "content": "<p>well, it certainly should be on the safety page, and isn't</p>",
        "id": 167027418,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559331668
    },
    {
        "content": "<p>To be honest, I routinely ignore this rule in FHIR, because I'm not going to write my own JSON library anymore than I'm going to write my own XML or HTTP libraries. And I don't expect anyone else to either.</p>",
        "id": 167027529,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1559331745
    },
    {
        "content": "<p>i don't see why you need to write your own json library.</p>",
        "id": 167027608,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559331797
    },
    {
        "content": "<p><a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=22649\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=22649\">GF#22649</a></p>",
        "id": 167027647,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559331828
    },
    {
        "content": "<p>most of the discussion on this precedes our use of Zulip but I found these: </p>\n<ul>\n<li><a href=\"#narrow/stream/179166-implementers/topic/JSON.20Format.20for.20Primitives.20.26.20extensions\" title=\"#narrow/stream/179166-implementers/topic/JSON.20Format.20for.20Primitives.20.26.20extensions\">https://chat.fhir.org/#narrow/stream/179166-implementers/topic/JSON.20Format.20for.20Primitives.20.26.20extensions</a></li>\n<li><a href=\"#narrow/stream/179166-implementers/topic/Quantity.2Evalue.20precision\" title=\"#narrow/stream/179166-implementers/topic/Quantity.2Evalue.20precision\">https://chat.fhir.org/#narrow/stream/179166-implementers/topic/Quantity.2Evalue.20precision</a></li>\n</ul>",
        "id": 167027944,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559332005
    },
    {
        "content": "<p>the discussion we had, from memory, we passionate and detailed - should we use string, or number. Those of us with laboratory backgrounds preferred string - some quite strongly - but the app developers strongly preferred number, and felt that it would be very unsafe to use string</p>",
        "id": 167028108,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559332133
    },
    {
        "content": "<p>I recall that when we looked at this, there was far less general acceptance in the wider community that strings would be used when precision mattered. And I still don't see any strong statement about this in any of the JSON specifications</p>",
        "id": 167028174,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559332195
    },
    {
        "content": "<blockquote>\n<p>i don't see why you need to write your own json library.</p>\n</blockquote>\n<p>Well, I suppose you don't <em>need</em> to write your own JSON library -- but if you deserialize/inflate FHIR objects (in the programming language of your choice) from the raw JSON, and you want to use native floats/decimals/BigDecimal/Number/whatever, and then you want to round-trip this back into JSON, you <em>need</em> to do something to make sure the original value and the new value are identical.</p>",
        "id": 167028790,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1559332618
    },
    {
        "content": "<p>In most libraries I've used (eg: Java and Ruby) BigDecimal by default serialized to and from String</p>",
        "id": 167029131,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1559332852
    },
    {
        "content": "<p>And that's essentially the equivalent of what FHIR is specifying</p>",
        "id": 167029215,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1559332921
    },
    {
        "content": "<p>right. not all. but most do have some way to preserve precision.</p>",
        "id": 167029611,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559333172
    },
    {
        "content": "<p>There was (not sure it it still exists) an example observation in the spec with a valueQuantity that looked like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"s2\">&quot;valueQuantity&quot;</span><span class=\"err\">:</span> <span class=\"p\">{</span>\n  <span class=\"nt\">&quot;value&quot;</span><span class=\"p\">:</span> <span class=\"mf\">-1.0e+245</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;unit&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;g&quot;</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>Ruby does not handle that well.</p>",
        "id": 167029618,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1559333177
    },
    {
        "content": "<p>what does it do?</p>",
        "id": 167029660,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559333219
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  I mean into JSON String and from JSON String. We had to monkey patch ruby to try to parse from and to JSON Number</p>",
        "id": 167029739,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1559333280
    },
    {
        "content": "<p>On a roundtrip it failed to produce the same number -- it overflowed, I believe, but I don't recall the specifics.</p>",
        "id": 167029787,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1559333286
    },
    {
        "content": "<p>I haven't had the pleasure of dealing with that Observation example b/c we currently only send Observation out, don't write</p>",
        "id": 167029848,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1559333341
    },
    {
        "content": "<p>and I guess technically it's Rails we monkey patched</p>",
        "id": 167030001,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1559333462
    },
    {
        "content": "<p>:)</p>",
        "id": 167030015,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1559333468
    },
    {
        "content": "<p>I think I commented on this before.   Regardless of HOW we specify numeric quantities in FHIR (JSON, XML or Turtle RDF?) the concern I raised (before) is that there should be a way of specifying the precision expected in a particular use case.   In the example of a particular binding to a specific lab measurement, for example, as a developer (and more importantly the clinicians guiding the developers) should be able to say what the expected precision of the lab measurement should be.    This is because the measurement is typically communicated with a certain expected precision (and unit of measure -- these are obviously tied together) and the FHIR 'communication channel' shouldn't alter this precision simply because its transport mechanism (e.g. JSON) can't do the job!    I think I even pointed to how they do this in OpenEHR where they recognize the importance of precision and unit of measure in their model.    Yes, their DV_QUANTIFIED Class:  <a href=\"https://specifications.openehr.org/releases/RM/latest/data_types.html#_dv_quantified_class\" target=\"_blank\" title=\"https://specifications.openehr.org/releases/RM/latest/data_types.html#_dv_quantified_class\">https://specifications.openehr.org/releases/RM/latest/data_types.html#_dv_quantified_class</a></p>",
        "id": 167034010,
        "sender_full_name": "John Silva",
        "timestamp": 1559336384
    },
    {
        "content": "<p>This is one of the major issues I ran into with making my own FHIR server as well. PostgreSQL's JSON support was stripping off the precision. Only solution would be to migrate things between string and numbers. So I agree that it's a problem.</p>",
        "id": 167054700,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1559364017
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194183\">@John Silva</span> that discussion lead to this: <a href=\"http://hl7.org/fhir/extension-quantity-precision.html\" target=\"_blank\" title=\"http://hl7.org/fhir/extension-quantity-precision.html\">http://hl7.org/fhir/extension-quantity-precision.html</a></p>",
        "id": 167054922,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559364453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  - OK, but an extension again -- not a core functionality?  (maybe in R5?)   Precision is SO important in healthcare (and folks in OpenEMR recognized this that it's part of their base modeling) that it seems like it shouldn't be an 'afterthought' in an extension.   Also, as this is tightly coupled to units of measure, there needs to be a FHIR base data type that pulls these two togehter (like DV_Quantity) it seems to me (IMHO).   Also, as this discussion points out about the inherent problems with the 'transports' (if you can call JSON data representation a 'transport') then it seems like this needs to be addressed at the core.</p>",
        "id": 167070137,
        "sender_full_name": "John Silva",
        "timestamp": 1559391341
    },
    {
        "content": "<p>Moving comments into this forum:</p>\n<p>I’ve been building a FHIR library that uses the provided XSDs as a code generation source.</p>\n<p>The biggest issues I’ve encountered thus far:</p>\n<p>1) I’ve had to create a special data structure to facilitate Decimal encoding – and fork the standard JSON decoder to handle decimal types.</p>\n<p>2) (off-topic) There’s no version number in FHIR resources (as there was in HL7). Our integration system will be handling multiple versions of FHIR concurrently due to thousands of existing vendor connections.</p>\n<p>Technically, I have it working on my end.</p>\n<p>My concerns are mostly that deviations from widely used standards could</p>\n<p>1) result in medical errors if someone writes an ad-hoc REST JSON in the browser or another stack and loses precision for a field in which it matters.</p>\n<p>2) means that highly optimized, secure and trusted standard libraries (like JSON.parse) have to be avoided or reimplemented in many technology stacks attempting to work in this space. </p>\n<p>Besides a simple string substitution, the float could be provided with an accompanying precision integer – but, at this point, that seems like a much larger change.</p>\n<p>Every developer with a browser hitting the XML service already receives all numbers as strings. Anyone mapping the data with a library against the spec would have something that could auto-convert them from string to a numeric value with an associated precision without abandoning standard encoders/decoders for the JSON spec.</p>",
        "id": 167076800,
        "sender_full_name": "Scott Southworth",
        "timestamp": 1559402765
    },
    {
        "content": "<p>versioning = sounds like you haven't read the page on versions.</p>",
        "id": 167092781,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559428522
    },
    {
        "content": "<p>I'm not aware of any case where losing precision leads to actual wrong results, only to human concern</p>",
        "id": 167092829,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559428573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194183\">@John Silva</span> it's not an after-thought as an extension. We say that the precision is in the string representation, and as far as we can figure out, the few cases where this is not the case are extremely edge case. </p>\n<blockquote>\n<p>there needs to be a FHIR base data type that pulls these two together</p>\n</blockquote>\n<p>You mean, like Quantity?</p>",
        "id": 167092892,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559428708
    },
    {
        "content": "<p>I believe that I opposed the original decision to use number not string in JSON, but I was overruled on the basis that I didn't really understand JSON (\"too much XML indoctrination\"). I can't find the original records though. (problematic, but before we won the battle about where to keep records)</p>",
        "id": 167092981,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559428908
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span>  I should be able to find records of this in either gForge or the wiki, but I can't. Thoughts on where I should look?</p>",
        "id": 167093162,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559429164
    },
    {
        "content": "<p>Yes, Quantity has units but it doesn't have precision 'built in'.   This statement about the value is very vague:  <br>\n  \"Numerical value (with implicit precision)\"<br>\nWhat does \"implicit precision\" mean?   Doesn't seem very spec-like (or precise, pun intended  ;-) ).</p>\n<p>Here's an example of why precision (and units) matter.   If you tell me your EMR stores weight in Kg and you (as a clinician) are in a Neonatal unit, the precision better have enough decimal places to property represent the neonate's weight since it is critically important for tiny neonates.</p>",
        "id": 167094297,
        "sender_full_name": "John Silva",
        "timestamp": 1559431178
    },
    {
        "content": "<p>Other possibility would be the old Skype discussion - but I don't have access to that.</p>\n<p>Implicit precision = the numeric expression conveys the precision.  I.e. 3.0 has a precision of 2.  3.00 has a precision of 3. 3.00e2 has a precision of 3.  The only time you need the extension is if you want to send \"300\" and want to indicate that it has a precision of 2 or 3 instead of 1. (and 3e2 and 3.0e2 isn't an acceptable representation).</p>",
        "id": 167094900,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559432343
    },
    {
        "content": "<p>Was there a blog about it?</p>",
        "id": 167094954,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559432443
    },
    {
        "content": "<p>OK, but the problem is that JSON would 'loose' the .0 (when sent as a JSON number).   It seems like the precision should be more declarative rather than a 'random side effect' of what happens to be sent.</p>",
        "id": 167095435,
        "sender_full_name": "John Silva",
        "timestamp": 1559433425
    },
    {
        "content": "<p>There's a bit of <a href=\"https://web.archive.org/web/20160601114047/https://chats.fhir.me/feeds/skype/implementers.html#2016-01-07%2016:20:54Z\" target=\"_blank\" title=\"https://web.archive.org/web/20160601114047/https://chats.fhir.me/feeds/skype/implementers.html#2016-01-07%2016:20:54Z\">discussion here</a></p>",
        "id": 167097398,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559437246
    },
    {
        "content": "<blockquote>\n<p>2016-01-07 15:35:01Z Josh Mandel: @James: Indeed, this is a JSON implication that comes with our decision to use JSON numbers rather than strings.</p>\n</blockquote>",
        "id": 167097400,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559437257
    },
    {
        "content": "<blockquote>\n<p>2016-01-07 15:29:45Z Keith W. Boone: @James and others: JSON should be JSON. IEEE Format for numbers should be fine so long accuracy is not impacted. We use JSON and XML to support developers familiar with those formats, not to make JSON and XML consistent.</p>\n</blockquote>",
        "id": 167097412,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559437283
    },
    {
        "content": "<blockquote>\n<p>2016-01-07 15:29:27Z Josh Mandel: You mean having not having your serializer spit it out in exponential notation? That seems fine. But client code should be ready to deal with (parse) either format.</p>\n</blockquote>\n<p>(etc. This was the discussion I remember.)</p>",
        "id": 167097415,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559437313
    },
    {
        "content": "<p>I remember more discussion... but I cannot find it.</p>",
        "id": 167109121,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559459053
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194183\">@John Silva</span> I think that it's clear but I wrote those words, so I don't mind making it clearer in a future version.</p>",
        "id": 167109138,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559459143
    },
    {
        "content": "<p>this discussion is a little frustrating for me - we waited to 6 years to take something normative so that stuff like this didn't emerge. I'm hearing that this is a practical problem, a problem in theory, and that no one is really defending the status quo.</p>",
        "id": 167109199,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559459212
    },
    {
        "content": "<p>I believe that our options are:<br>\n- add more documentation about the current situation <br>\n- add a precision indicator in the json format and .. encourage... people to use it (we did put a precision indicator in the protobuf format for this purpose, since that has no string representation at all) </p>\n<p>If we have other options, they haven't occurred to me. I believe that changing to use string instead (or as well as) number is not an option for procedural reasons</p>",
        "id": 167109278,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559459367
    },
    {
        "content": "<blockquote>\n<p>OK, but the problem is that JSON would 'loose' the .0 (when sent as a JSON number).   It seems like the precision should be more declarative rather than a 'random side effect' of what happens to be sent.</p>\n</blockquote>\n<p>In theory I can say \"this depends on your json serializer and parser; a proper implementation might preserve and interpret this distinction\"— though that doesn't help in practice</p>",
        "id": 167122529,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559482237
    },
    {
        "content": "<p>actually, strictly, having spent more time with the specs, though it's not very well stated, a proper implementation would not</p>",
        "id": 167163332,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559547702
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  - \"a proper implementation will not\" -- do you mean a proper JSON serializer would NOT preserve precision?   I know our experience is that neither the Microsoft .NET JSON serializer nor the Newtonsoft JSON serializer preserve JSON numeric precision with the x.0 like values.   I think Javascript serializers do not preserve it either.   (Does anyone have experience with  Java JSON serializers?)     Regardless, the 'on the wire' or 'in the datastore' representation of numbers needs to have a way to specify intended precision, that just seems to be an important part of how numeric values are communicated in healthcare.</p>",
        "id": 167173262,
        "sender_full_name": "John Silva",
        "timestamp": 1559556033
    },
    {
        "content": "<p>it depends on how you read the json spec. The json spec says: </p>\n<blockquote>\n<p>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard</p>\n</blockquote>",
        "id": 167173685,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559556387
    },
    {
        "content": "<p>how derived is it?</p>",
        "id": 167173690,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559556392
    },
    {
        "content": "<p>the original spec said:</p>",
        "id": 167173691,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559556396
    },
    {
        "content": "<blockquote>\n<p>A number is very much like a C or Java number,</p>\n</blockquote>",
        "id": 167173729,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559556440
    },
    {
        "content": "<p>the current spec says: </p>\n<blockquote>\n<p>This specification allows implementations to set limits on the range and precision of numbers accepted</p>\n</blockquote>",
        "id": 167173733,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559556470
    },
    {
        "content": "<p>if you assume - which people seem to do but isn't actually specified that <code>number</code> refers to the number type defined in ECMAScript - then that is very fully specified to be an 8 byte floating number that ignores precision.</p>",
        "id": 167173805,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559556518
    },
    {
        "content": "<p>bu no such statement is made concerning json. it depends on how much you think 'derived' means</p>",
        "id": 167173813,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559556535
    },
    {
        "content": "<p>json schema doesn't further clarify the issue</p>",
        "id": 167173971,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559556614
    },
    {
        "content": "<p>OK, 'set limits on' -- I suppose even that doesn't mean that it preserves precision, just that an implementation can say HOW many digits (max) of precision it will support.   The practical limitation for now seems to be that actual implementations 'out there' do not preserve precision (maybe or because of this vagueness in the spec or 'just because' JavaScript is really a typeless language and that's what JSON is based on.</p>",
        "id": 167173990,
        "sender_full_name": "John Silva",
        "timestamp": 1559556641
    },
    {
        "content": "<p>right. many don't. It's hard for me to understand why this is only an issue now. Personally, I use my own JSON parsers for the simple reason that I want line numbers in the validator error messages</p>",
        "id": 167174088,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559556735
    },
    {
        "content": "<p>and for some strange reason, there's no way to do that with the normal parsers. and it never occurred to me to lose precision (I guess I've been in healthcare too long)</p>",
        "id": 167174100,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559556768
    },
    {
        "content": "<p>I just did a search for \"json serialization preserve precision\" and it's interesting to see how many problems people have with this, from some implementations 'adding an extra .0' and more.    One useful piece of info was this page on <a href=\"http://JSON.org\" target=\"_blank\" title=\"http://JSON.org\">JSON.org</a> which lists (~&gt; 50) JSON implementations in  many different languages.  <a href=\"http://www.json.org/\" target=\"_blank\" title=\"http://www.json.org/\">http://www.json.org/</a>  (who knows what variances exist in all these different implementations, especially related to precision)</p>",
        "id": 167181676,
        "sender_full_name": "John Silva",
        "timestamp": 1559563351
    },
    {
        "content": "<p>Hi Grahame, re: why is this an issue now: I think part of the issue is that as FHIR becomes more popular, more people are using it in different ways.<br>\nCalling JSON.parse('{\"val\":3.10}') in the major browsers or Node converts the value to a float and loses the precision (3.1).<br>\nIn the cases of someone developing in those environments, it is far more likely to use the built-in JSON support then to add a dependency for external code to parse JSON (which can be fair bit of work to find, since the environments include built-in support).  In these scenarios, the system will work and the developer may never know an issue occurred.<br>\nI would say that at the least making a warning page would be useful, so that people new to FHIR do not unintentionally cause incidents.</p>",
        "id": 167198182,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559573842
    },
    {
        "content": "<p>I had to tweak (rather than hack) the Newtonsoft Json library for .NET to make it retain precision, but it is doable.  It is using the .NET Decimal class which retains the precision - so 3.0000 remains 3.0000.  Unfortunately, .NET's decimal will NOT support anything bigger than approx 8x10^28, so as <span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span> points out I am no longer able to parse all examples in the spec, as there's now an example with 10^245 as a value.   Could do that using double, but then precision is not retained.    So, I decided to stick with decimal, and remove the example from my unit-tests.</p>",
        "id": 167200194,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1559575146
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> Knowing that, I would be curious:<br>\n-Does that feel like a reasonable amount of work for a new developer that wants to use FHIR?<br>\n-As you continued to update, are the changes maintainable for newer releases of Newtonsoft?</p>",
        "id": 167206727,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559579117
    },
    {
        "content": "<p>In general, I wouldn't expect much adoption/support for datatype formats that are not widely supported by popular programming languages and databases, such as enhanced precision or large exponents. Also, I wouldn't recommend anyone to implement their own numeric/datetime storage &amp; operations; way too tricky.</p>",
        "id": 167207293,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1559579423
    },
    {
        "content": "<blockquote>\n<p>I wouldn't expect much adoption/support for datatype formats that are not widely supported</p>\n</blockquote>\n<p>Does this push you to conclude we should be using strings for numbers <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> ?</p>",
        "id": 167220872,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559588706
    },
    {
        "content": "<p>No, actually the opposite - apologies for bad wording.</p>",
        "id": 167223988,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1559590907
    },
    {
        "content": "<p>Well <span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> has been pushing for a <code>fhir+json2</code> mime type for a while :) This would be one more feature to get right.</p>",
        "id": 167231614,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559595615
    },
    {
        "content": "<p>\"-Does that feel like a reasonable amount of work for a new developer that wants to use FHIR?\"</p>\n<p>Well, if you use the .NET FHIR API, this is handled for you - if you are writing your own - I think it's now just a simple setting: <a href=\"https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_FloatParseHandling.htm\" target=\"_blank\" title=\"https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_FloatParseHandling.htm\">https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_FloatParseHandling.htm</a></p>\n<p>But the <em>default</em> is double, so you'd still have to take care.</p>",
        "id": 167232077,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1559595945
    },
    {
        "content": "<p>And anyone using standards database support for JSON, etc, might not even be able to control this behavior. What does FHIRBase do here btw <span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> ?</p>",
        "id": 167232371,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559596147
    },
    {
        "content": "<p>Looks like PostgreSQL JSONB preserve  presicion - <code>select ('{\"a\": 3.00000000}'::jsonb)-&gt;&gt;'a'</code> =&gt; 3.00000000</p>",
        "id": 167235238,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1559598555
    },
    {
        "content": "<p>Internally in jsonb numbers are represented as numeric type - <a href=\"https://www.postgresql.org/docs/current/datatype-numeric.html\" target=\"_blank\" title=\"https://www.postgresql.org/docs/current/datatype-numeric.html\">https://www.postgresql.org/docs/current/datatype-numeric.html</a></p>",
        "id": 167235397,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1559598660
    },
    {
        "content": "<p>In clojure cheshire library we can force bigdecimals.</p>",
        "id": 167235649,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1559598877
    },
    {
        "content": "<p>I've been going over this with <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span>  and we thought we should loop back out with the larger group.<br>\nBackground: right now the FHIR decimal has no limits on either precision or range (see <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=22655\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=22655\">GF#22655</a>).  The serialization behavior is defined as a union of xs:double and xs:decimal from XML (and listed to be applied to JSON).  Otherwise, the value can be an arbitrarily long list of numbers.  For reference, the xs:decmial is only guaranteed to have 18 digits of precision, and float is standard IEEE 64-bit float.<br>\nThe Firely API appears to just use the C# decimal (range ±1.0 x 10^28 to ±7.9228 x 10^28, 28-29 significant digits).  Attempting to parse an observation with a value in range for double but not decimal (e.g., 1E31) causes a parsing failure (<span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> is this correct?).<br>\nIn HAPI, decimals are converted to BigDecimal, so it does support arbitrary precision and range.<br>\nAdditionally, the spec says that decimals may be represented as floats with precision, which would cause rounding errors in many cases (e.g., irrational numbers).  In the cases of required precision, this should be unacceptable.<br>\nFrom what we can tell, the spec indicates that systems must be able to perform calculations with arbitrarily large/small and precise numbers, but could also cap serialization to 18 significant digits.<br>\nWith that in mind, what are the use cases that we are trying to solve?  What is the intention for required precision and range with this type that would be clinically useful?</p>",
        "id": 167242738,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559605364
    },
    {
        "content": "<p>geolocation is actually the primary use case for very precise decimals. I've not seen observations that are reported to more than 4 significant digits even if the measurements are much more precise, since biological processes rarely justify that - e.g. even your weight and height are constantly changing in the 3rd significant place</p>",
        "id": 167246300,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559609471
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> can you find that example? I had a look earlier in this thread and couldn't find it</p>",
        "id": 167246308,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559609507
    },
    {
        "content": "<p>I did add some ludicrous values to check my implementations - but I didn't mean for them to slip out into the real world</p>",
        "id": 167246360,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559609541
    },
    {
        "content": "<p>I've asked Tim Bray for comment. I'll report back if he says something interesting / useful</p>",
        "id": 167246893,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559610267
    },
    {
        "content": "<p>observation-decimal is the one with 10^245 as a value, it's still in the example downloads</p>",
        "id": 167273489,
        "sender_full_name": "Kenneth Myhra",
        "timestamp": 1559639797
    },
    {
        "content": "<p>Ok thanks. I’ll fix that</p>",
        "id": 167282153,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559647267
    },
    {
        "content": "<blockquote>\n<p>Ok thanks. I'll fix that</p>\n</blockquote>\n<p>How? Just removing it isn't really a fix -- in my opinion -- if it is actually a valid example. Removing it would just mask the issue.</p>",
        "id": 167293537,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1559655383
    },
    {
        "content": "<p>it's not really valid. It was just an edge case I added for testing implementations. I've removed it to 1e-24 instead of 1e-245</p>",
        "id": 167293597,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559655418
    },
    {
        "content": "<p>What do you mean by \"not really valid\"? Picking something like e-24 (which is in the decimal range for c# I think?) means we're not testing ability to handle doubles.</p>",
        "id": 167311954,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559665937
    },
    {
        "content": "<p>I think he means \"for which we have a valid use-case\" - i.e. a number that could be expected - even in an edge case - to appear in a real healthcare resource.</p>",
        "id": 167312468,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559666301
    },
    {
        "content": "<p>e-24 is on the molar mass scale, so is theoretically possible.  10^245 is well beyond the countable atoms in the known universe - so not a number we could expect to see a healthcare application sharing.</p>",
        "id": 167312549,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559666379
    },
    {
        "content": "<p>Okay --and I'd say  if we want to limit our spec, we should limit the spec (in addition to the tests/examples).</p>",
        "id": 167315150,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559668126
    },
    {
        "content": "<p>If we can limit the precision (10 digits would allow CT-slices to be individually geo-tagged by lat/lon) and the range based on values expected in a clinical setting (e.g., the 10^24 from above), then we have a type definition we can hold everyone to.</p>\n<p>In Java and C#/.Net, having unquoted precision works well (having addressed concerns about blowing up parsers with doubles vs decimals).</p>\n<p>Looking at JavaScript, JSON support has been part of the language since 2009 so external parsing libraries have begun to rot.  Dusting one off, I was able to modify it to parse numbers as strings (or decimals, bigdecimals, etc.) and keep precision.  This modified parser results in the expected behavior, but I'm not sure how realistic it is to expect in a production setting (forked and modified ~10 year old unmaintained code).</p>\n<p>Looking at Python, JSON has been built-in since 2.6 (also 2009).  The only library with code I found in a quick search was simplejson - which is external version of the internal library used in Python.  It is more complex to modify, but I assume it is doable.  Otherwise, the behavior is the same - decimals are automatically rounded.</p>\n<p>I was going to check Swift, but don't have access to a box with it right now.</p>\n<p>I would guess that the question then becomes (after defining precision and range), what to do about the JSON format issue.  Knowing that the built-in support in two languages I've already tested fail to maintain precision is worrying.</p>",
        "id": 167321730,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559672176
    },
    {
        "content": "<blockquote>\n<p>what to do about the JSON format issue.</p>\n</blockquote>\n<p>Nothing. It is normative. Cannot and should not be changed.</p>",
        "id": 167323803,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1559673327
    },
    {
        "content": "<blockquote>\n<p>Nothing. It is normative. Cannot and should not be changed.</p>\n</blockquote>\n<p>I have to disagree about doing \"nothing\".</p>\n<p>Action items such as adding information/warnings to the \"Getting Started\" or \"FHIR Overview - Developers\" are relatively painless and could prevent issues in patient care/safety.  These items could fall under safety recommendations or best practices for popular languages.</p>\n<p>Packages provided by the FHIR group (e.g., <a href=\"https://github.com/FHIR/fhir.js\" target=\"_blank\" title=\"https://github.com/FHIR/fhir.js\">https://github.com/FHIR/fhir.js</a> ) should probably be updated to ensure safe handling of data.</p>\n<p>These are potential items I thought of in a few minutes [edit], I feel like it would be beneficial to give this some thought.</p>",
        "id": 167326780,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559675408
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>what to do about the JSON format issue.</p>\n</blockquote>\n<p>Nothing. It is normative. Cannot and should not be changed.</p>\n</blockquote>\n<p>but we can create another one! without breaking existing format</p>",
        "id": 167334450,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1559681362
    },
    {
        "content": "<p>And let the future decide, which is more viable</p>",
        "id": 167334531,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1559681405
    },
    {
        "content": "<p>FYI, earlier I posted this link to <a href=\"http://www.json.org/\" target=\"_blank\" title=\"http://www.json.org/\">http://www.json.org/</a> that has many (seems like &gt; 50) languages, more than most have even heard of ;-)  -- 8th, OCaml, Pike, etc.   This webpage lists the many different JSON serializers that are 'out there'; wonder how they handle precision (or not)?</p>",
        "id": 167336486,
        "sender_full_name": "John Silva",
        "timestamp": 1559682870
    },
    {
        "content": "<p>Hi John, I did see that post the other day.</p>\n<p>I've been going back and forth on this internally for some time now.  On the one hand, as long as we communicate the behavior to someone using an obscure language, they should be able to handle it (a danger of using an obscure or new language).  On the other hand, any language adding JSON support is likely going to do so in the ECMA standard way - which we are not.  Swift 4, for example (which I checked this evening) also loses precision on parse.</p>\n<p>If we agree that the precision is clinically relevant and the default behavior causes loss of precision, it is quite likely that an incident will occur.  I am particularly concerned about JavaScript in that it is very widely used, has a low technical bar to entry, and uses \"standard\" JSON internally.</p>\n<p>I would like to determine what steps are needed to mitigate or eliminate that before an incident occurs.</p>",
        "id": 167348206,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559696155
    },
    {
        "content": "<p>Comment from Tim Bray:</p>\n<blockquote>\n<p>Well, I understand the problem, but you're not going to get much help from JSON.  The spec language in <a href=\"https://tools.ietf.org/html/rfc8259#section-6\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc8259#section-6\">https://tools.ietf.org/html/rfc8259#section-6</a> just talks about \"numbers\" and points out that trying to interchange anything not representable as an IEEE double is dangerous.  There are many improvements that could be made to JSON, including timestamps and smarter numeric types, but they're not going to happen because JSON is in such universal use that everyone is terrified of any changes whatsoever no matter how small.</p>\n<p>So, if you have a numeric quantity in a JSON text, for example your Potassium in serum, you're going to have to find another place to express that semantic for consumption by software.  It's an interesting problem; suppose I wanted to do some fairly large-scale arithmetic on a bunch of Potassium numbers, e.g. statistics.  I assume the proper way to do that would be with normal double-precision floating-point to avoid all the nasty error-accumulation scenarios that can happen if you don't, and then you'd present the result with one digit past the decimal point.  So I guess I'm agreeing that this is a <em>presentational</em> requirement, not an arithmetical one. </p>\n<p>Anyhow, I suppose that it's up to the FHIR specs to say \"This quantity must always be presented for human consumption thus and so.\"  I think that, to be safe, you'd also want to express the fact that for purposes of arithmetic, it's a floating-point quantity and should be handled with that in mind.  It would be nice if JSON had a way to express that portably, but it doesn't.</p>\n<p>Good luck!</p>\n</blockquote>",
        "id": 167359459,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559712516
    },
    {
        "content": "<p>... which is pretty much what we do....</p>",
        "id": 167359475,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559712557
    },
    {
        "content": "<p>TIm's comment, \"you're going to have to find another place to express that semantic for consumption by software.\" is what I've been suggesting.  If we need to convey the semantic of precision, the it has to be declarative in FHIR (i.e. in the datatypes) and not dependent on the (JSON or other) transport or encoding.    I also like his point about, \"nasty error-accumulation scenarios\", that is one of the main issues with maintaining the proper precision in measurements and calculations based on those measurement --- error accumulation.   Of course FHIR's job is not a 'calculation engine' but it needs to have a mechanism so that consumers of the data do not loose precision because of the FHIR store.</p>\n<p>(I like this Wikipedia article about accuracy and precision that points out the problems of maintaining and computing with attention to precision: <a href=\"https://en.wikipedia.org/wiki/Accuracy_and_precision\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Accuracy_and_precision\">https://en.wikipedia.org/wiki/Accuracy_and_precision</a> )</p>",
        "id": 167374496,
        "sender_full_name": "John Silva",
        "timestamp": 1559729435
    },
    {
        "content": "<p>we don't agree that it needs to be in the datatypes. The fraction of cases where precision is different to the string representation is very small, and all the cases we found were edge cases. We can add precision elements for formats that don't support string representation of decimals - which may or may not include JSON  (but does definitely include protobuf).</p>",
        "id": 167374720,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559729742
    },
    {
        "content": "<p>I don't know how doing anything about this in JSON will play out</p>",
        "id": 167374780,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559729771
    },
    {
        "content": "<p>OK, not in datatypes (though I'm not comfortable with that, I suppose it's too late to do anything about it.)</p>\n<p>A somewhat related question, when someone profiles an observation for a particular use case, e.g. a vital sign with a specific LOINC code,  does that also imply a specific unit of measure and therefore a certain precision?   If not, (LOINC code doesn't imply UofM) then different UofMs can cause problems with precision loss, e.g. Kg vs gram or mg vs ng, etc.</p>",
        "id": 167375087,
        "sender_full_name": "John Silva",
        "timestamp": 1559730160
    },
    {
        "content": "<p>Well, one difference is that Tim says </p>\n<blockquote>\n<p>to be safe, you'd also want to express the fact that for purposes of arithmetic, it's a floating-point quantity and should be handled with that in mind.</p>\n</blockquote>\n<p>Whereas our specifications seems to say that you should treat it as an arbitrary precision decimal value. (Or do people disagree with this characterization?)</p>",
        "id": 167384779,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559739081
    },
    {
        "content": "<p>Given that we're almost a week into this thread, I would like to ask which way people are leaning on the various items in it.  I am trying to list everything that looks actionable so each item can either be moved forward or left for dead.</p>\n<p>This is <em>not</em> formal.  I just feel there has been enough discussion that I would either like to start on proposals or move on.  At the same time, this thread is too long for me to determine what people feel is worthwhile and thought this could give a quick measure.<br>\nThanks!</p>",
        "id": 167400595,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559748672
    },
    {
        "content": "<p>/poll Should there be additional language for developers to be aware of the JSON decimal encoding behavior (e.g., \"Getting Started\", \"FHIR Overview - Developers\", Best Practices, etc.)<br>\nYes<br>\nNo</p>",
        "id": 167400608,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559748678
    },
    {
        "content": "<p>/poll Should there be clarifying language added to the decimal datatype for explicit precision and range requirements<br>\nYes<br>\nNo</p>",
        "id": 167400619,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559748682
    },
    {
        "content": "<p>/poll Should reference implementations be updated to retain precision by default on platforms where it is currently lost (e.g., fhir.js)<br>\nYes<br>\nNo</p>",
        "id": 167400632,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559748687
    },
    {
        "content": "<p>/poll Should there be a new extension to provide precision information generally for decimals<br>\nYes<br>\nNo</p>",
        "id": 167400643,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559748694
    },
    {
        "content": "<p>/poll Nuclear options<br>\nI see no action items for anything in this thread<br>\nI'd like to change the normative JSON encoding<br>\nI'd like to add a new JSON serialization model</p>",
        "id": 167400654,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559748700
    },
    {
        "content": "<blockquote>\n<p>Should reference implementations be updated </p>\n</blockquote>\n<p>What happens to reference implementation cannot really be decided here - it is up to their maintainers. If someone feels that they need changes the way to go is open issues in their repos (or - even better - pull requests)</p>",
        "id": 167403325,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1559750324
    },
    {
        "content": "<p>That's fair, but lots of those maintainers are here listening and answering questions, so the straw poll is still helpful; and they'll be interested in what \"best practice\" advice we provide in the spec.</p>",
        "id": 167407881,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559753422
    },
    {
        "content": "<p>I added <code>We should consider adding a new property in json for precision</code></p>",
        "id": 167546254,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559881982
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> I disagree with your characterisation. The specification makes clear that we have a <em>presentation</em> issue, not an issue with the value itself</p>",
        "id": 167546279,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559882042
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  - by \"adding a new property in json for precision\" do you mean to the datatype (Quantity) definition so that it works for both JSON and XML (and any other representation like Turtle RDF)?   If so, I'm all for it!  (it could look like DV_QUANTITY that OpenEHR defines)</p>\n<p>Also, I'm not sure about the presentation vs value issue -- FHIR is not about UIs so I'm not sure how this is a presentation issue.  To me it feels like more of a transport issue (thinking of JSON in FHIR as a transport mechanism) or storage mechanism but since FHIR doesn't prescribe FHIR server persistence mechanisms I suppose it can't be that.  (though many implementations that use noSQL approaches end up storing 'raw JSON' in which case any intended precision is lost or at least not specific -- i.e. by itself how do I know that 10  is supposed to be 10.0 if I'm doing calcs based on JSON stored numbers?)</p>",
        "id": 167563580,
        "sender_full_name": "John Silva",
        "timestamp": 1559901574
    },
    {
        "content": "<p>there's no reason to add it to XML and I would be very opposed to that. Nor to RDF. We already added it to ProtoBuf, since that uses raw decimals with no string format. So we could add it to JSON though we could not make it mandatory</p>",
        "id": 167564037,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559902034
    },
    {
        "content": "<p>Can you explain / show an example of what you mean <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> re: json property? And agreed with <span class=\"user-mention\" data-user-id=\"194183\">@John Silva</span>  this isn't a presentation issue, only -- it seems like an issue that could cause errors to accumulate (or at least propagate incorrectly) in automated calculations, if numbers aren't handled properly</p>",
        "id": 167583831,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1559919304
    },
    {
        "content": "<blockquote>\n<p>I added <code>We should consider adding a new property in json for precision</code></p>\n</blockquote>\n<p>If I understand, I think it would go a long way towards resolving this.  Are you suggesting that:</p>\n<div class=\"codehilite\"><pre><span></span>{ &quot;val&quot; : .100, &quot;another&quot; : 1.0 }\n</pre></div>\n\n\n<p>could be serialized to something like:</p>\n<div class=\"codehilite\"><pre><span></span>{ &quot;val&quot; : .100, &quot;val_precision&quot; : 3, &quot;another&quot; : 1.0, &quot;another_precision&quot; : 2 }\n</pre></div>\n\n\n<p>The \"_precision\" field (or whatever was agreed to) would be a field optionally generated during serialization.</p>\n<p>It would then be on the client to either parse the original value exactly or use the additional precision information to reconstruct it.</p>\n<p>Is that correct?</p>",
        "id": 167588785,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1559922870
    },
    {
        "content": "<p>I'm not sure that would solve the problem... Off-the-shelf JSON parsers wouldn't know anything about that convention, so they'd still process the field as a regular <code>Number</code>.  I think you'd need dual fields -- one w/ the normal number (for backwards compatibility) and one with the number as a string (to retain precision).  This could be accomplished today via extensions, but perhaps Grahame was thinking of a more streamlined special-case approach.</p>",
        "id": 167590175,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1559923837
    },
    {
        "content": "<p>Or perhaps I missed your point.  Now that I look at it again, I suppose that the client could still use an off-the-shelf parser and then use the extra precision information to round the <code>Number</code> appropriately using a non-float representation -- which would hopefully take care of any floating point issues.</p>",
        "id": 167590320,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1559923972
    },
    {
        "content": "<blockquote>\n<p>'raw JSON' in which case any intended precision is lost or at least not specific</p>\n</blockquote>\n<p>This is not true - if I create an observation with value 3.500 (that specifies the precision) and serialize that using the .NET library I get: <code>{\"resourceType\":\"Observation\",\"valueQuantity\":{\"value\":3.500}}</code> - and if I parse that I get back 3.500 as a fixed point decimal - so JSON can express the precision just fine - the issue is with the parsers (or the underlying languages not supporting fixed point decimals)</p>",
        "id": 167602691,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1559933200
    },
    {
        "content": "<p>(and a <code>_precision</code> field is pointless)</p>",
        "id": 167602758,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1559933251
    },
    {
        "content": "<p>well, the issue is that JSON is imprecise, so that behavior depends on the libraries choice - they are not wrong to choose that. </p>\n<p><span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> yes that use of precision is what I had in mind based on the example Gino gave. An alternative would be:</p>",
        "id": 167603740,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559933916
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span> <span class=\"nt\">&quot;val&quot;</span> <span class=\"p\">:</span> <span class=\"mf\">0.100</span><span class=\"p\">,</span> <span class=\"nt\">&quot;val_formatted&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;0.100&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;another&quot;</span> <span class=\"p\">:</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"nt\">&quot;another_formatted&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;1.0&quot;</span> <span class=\"p\">}</span>\n</pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span> <span class=\"nt\">&quot;val&quot;</span> <span class=\"p\">:</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"nt\">&quot;val_formatted&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;0.100&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;another&quot;</span> <span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nt\">&quot;another_formatted&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;1.0&quot;</span> <span class=\"p\">}</span>\n</pre></div>",
        "id": 167603873,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559934005
    },
    {
        "content": "<p>I'm not sure which I prefer. we could define it, but we couldn't make it mandatory</p>",
        "id": 167603915,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1559934037
    },
    {
        "content": "<blockquote>\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span> <span class=\"nt\">&quot;val&quot;</span> <span class=\"p\">:</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"nt\">&quot;val_formatted&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;0.100&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;another&quot;</span> <span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nt\">&quot;another_formatted&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;1.0&quot;</span> <span class=\"p\">}</span>\n</pre></div>\n\n\n</blockquote>\n<p>That one would work well for JavaScript, which does not keep track of trailing zeros.</p>",
        "id": 167607820,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1559936816
    },
    {
        "content": "<p>If JSON parser supports precision, let's provide it as well  <code>{\"val\": 0.100, \"val_formated\": \"0.100\"}</code>; Puting all these attributes on the same level again create similar problems as primitive extensions and choice types :(  Another representation hack can be \"val\": [0.1, \"0.1000\"], but probably to solve all of these problems it should be like this <code>{\"attr\": {\"value\": ....., extensions, presicion}}</code></p>",
        "id": 167608847,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1559937587
    },
    {
        "content": "<p>We can't break the existing JSON syntax.  Whatever we do has to remain valid against that.  Introducing a new JSON syntax would effectively mean everyone would need to support both, so that's not really on the table.</p>",
        "id": 167610420,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559938666
    },
    {
        "content": "<p>From the perspective of processing or generating a FHIR resource, I don't see much difference between having to handle new versions of FHIR (handling differences between STU3 and R4) and handling a new version of the JSON format.  I don't see why an \"R6\" couldn't introduce changes to the JSON format to handle this and other problems.  It would just a part of the pain updating to R6.</p>",
        "id": 167612622,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1559940448
    },
    {
        "content": "<p>Or to be more consistent w/ the current FHIR/JSON serialization approach:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span> <span class=\"nt\">&quot;val&quot;</span> <span class=\"p\">:</span> <span class=\"mf\">0.100</span><span class=\"p\">,</span> <span class=\"nt\">&quot;_val&quot;</span> <span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"nt\">&quot;formatted&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;0.100&quot;</span> <span class=\"p\">},</span>\n  <span class=\"nt\">&quot;another&quot;</span> <span class=\"p\">:</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"nt\">&quot;_another&quot;</span> <span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"nt\">&quot;formatted&quot;</span> <span class=\"p\">:</span> <span class=\"s2\">&quot;1.0&quot;</span> <span class=\"p\">}</span> <span class=\"p\">}</span>\n</pre></div>\n\n\n<p>This would probably be less impact on implementors since they already need to check for the existence of <code>\"_val\"</code> anyway to support ids and extensions.</p>",
        "id": 167612631,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1559940460
    },
    {
        "content": "<p>I think we can't change the JSON syntax in R6 (or R-anything) because the JSON serialization is now <em>normative</em>.  Breaking changes are off the table.  We can only do additive non-breaking changes.</p>",
        "id": 167612767,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1559940578
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"195344\">@Paul Lynch</span> The difference is that in R4 we moved certain things to normative.  While there will indeed be pain in moving from R4 to R5 for all of the things that <em>aren't</em> normative, the whole point of normative is that at that point (for those things) the pain stops.  (The eventual objective being that the pain stops for everything.)</p>",
        "id": 167621721,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1559949567
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> That is a helpful explanation.  However, if issues begin to pile up with something called \"normative\", there must be some point where it is better to the fix the problems than to preserve stability.  (Perhaps we haven't reach that point yet.)</p>",
        "id": 167764331,
        "sender_full_name": "Paul Lynch",
        "timestamp": 1560177308
    },
    {
        "content": "<p>It would have to be badly broken indeed for the entire community to agree to the transition.  It's not something we have plans to do and certainly not something we'd entertain lightly.  Our general expectation is that once something is normative, any issues get worked around with changes that align with FHIR's interversion compatibility rules and/or extensions.</p>",
        "id": 167770875,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1560182018
    },
    {
        "content": "<p>For Money.value the description states with implicit precision does that mean precision is implied based on currency code? For monetary amounts is it required to include trailing zeros?  Looking at various examples within FHIR there doesn't seem to be a consistency.  Are these considered all valid based on currency code of \"USD\" : 15, 15.0, 15.5?  Or should they be reflected as 15.00, 15.50?</p>",
        "id": 237487303,
        "sender_full_name": "Mona O",
        "timestamp": 1620218178
    },
    {
        "content": "<p>Hmm.  I think money generally has an implicit precision of 2 decimal places.  I.e. If you say $15, that <em>most</em> of the time, $15.01 would be wrong.  (Though there are contexts where rounding happens and $15 actually represents $14.98 or $15.23.)  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, do you think we need any special guidance around precision when it comes to monetary amounts?</p>",
        "id": 237519506,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1620230002
    },
    {
        "content": "<p>I don't think we want to say anything about it, honestly.</p>",
        "id": 237558627,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1620245844
    },
    {
        "content": "<p>Hopefully YOUR bank doesn't use only 2 digits of precision (and keep any fractional difference) <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span><br>\n(many financial transactions of course use multiplication and division which can introduce imprecision and round-off -- yeh, probably always in the favor of the financial institution! )</p>",
        "id": 237559877,
        "sender_full_name": "John Silva",
        "timestamp": 1620246455
    },
    {
        "content": "<p>From what I know, most err on the side of the customer as they can get in big legal trouble and fractions of a penny is much cheaper then the legal fees, but that's getting off topic</p>",
        "id": 237567289,
        "sender_full_name": "Daryl Moehrke",
        "timestamp": 1620249001
    },
    {
        "content": "<p>right. it's a complicated area, but at least in interop, there's no transferring fractions of a cent. However: the less we can say about this, the less we can get in trouble for what we say</p>",
        "id": 237569191,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1620249478
    }
]