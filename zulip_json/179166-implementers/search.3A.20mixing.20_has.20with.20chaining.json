[
    {
        "content": "<p>I want to write a query that will return all Observations that are created based on CarePlans who's subjects are Patients that are members of a Group with the id of \"cohort1\".</p>\n<p>Would the below query be valid?</p>\n<div class=\"codehilite\"><pre><span></span>GET [base]/Observation?_has:Group:based-on.patient:_id=cohort1\n</pre></div>\n\n\n<p>where <code>based-on</code> is the search param for <code>Observation.basedOn</code>(CarePlan)<br>\nand <code>patient</code> is the search param for <code>CarePlan.subject</code> (Patient)</p>",
        "id": 177849122,
        "sender_full_name": "Severin Skillman",
        "timestamp": 1570738389
    },
    {
        "content": "<p>perhaps an operation would be more appropriate?</p>",
        "id": 177851708,
        "sender_full_name": "Severin Skillman",
        "timestamp": 1570740169
    },
    {
        "content": "<p>Even if you express the search parameters correctly, you may hard-pressed to find a server who'll support it.  You might be better doing something like that with GraphQL</p>",
        "id": 177852729,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1570740926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> ?</p>",
        "id": 177852743,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1570740939
    },
    {
        "content": "<p>Yes,  in theory combining Chaining and Reverse Chaining is allowed using the syntax that you described. However there are two issues with that specific one. First you need to specify the resource linking to Observation as the first element after _has. So, <code>Observation?_has:CarePlan:based-on</code>, otherwise you would look for all Groups referencing Observations directly through the based-on attribute, which would not be valid. Than we chain from CarePlan to Group through the patient search parameter. However that one is defined for either a Patient or a Group resource, so we need to pass a :type modifier <code>...based-on.patient:Group...</code>. And instead of a “:” you need to chain _id using a “.”.</p>\n<p>So <code>GET [base]/Observation?_has:CarePlan:based-on.patient:Group._id=&lt;id&gt;</code> should work.</p>",
        "id": 177854588,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1570742300
    },
    {
        "content": "<p>A bit late here to get my head around that one, but thank you. I think I'll opt for defining a SearchParameter instead.</p>",
        "id": 177858068,
        "sender_full_name": "Severin Skillman",
        "timestamp": 1570745082
    },
    {
        "content": "<p>hi <span class=\"user-mention\" data-user-id=\"197126\">@Severin Skillman</span> are you like me in the process to implement a cohort tool on top of fhir ? glad to share experience and thought on this</p>",
        "id": 178328033,
        "sender_full_name": "natus",
        "timestamp": 1571259730
    },
    {
        "content": "<p>what about using <code>_list</code> parameter as a proxy for group ? The _list would contain the patient within the group. This avoid defining your own SearchParameter</p>",
        "id": 178336291,
        "sender_full_name": "natus",
        "timestamp": 1571268124
    },
    {
        "content": "<p>I want write query to return all Practitioner have name like <code>Mr</code> and base on PractitionerRole who's practitioner is Practitioner that have Organization name is <code>something</code><br>\nQuery like bellow</p>\n<div class=\"codehilite\"><pre><span></span><code>GET [base]/Practitioner?name=Mr&amp;_has:PractitionerRole:practitioner:organization.name=something\n</code></pre></div>\n\n\n<p>I got 2 trouble in here.</p>\n<ol>\n<li>Practitioner name seem like wont work with <code>Mr</code> except i include <code>:exact</code> into it. I was try with another string like <code>Happy</code> and it work without <code>:exact</code></li>\n<li><code>_has</code> not work with field <code>name</code>. I try to change to <code>_has:PractitionerRole:practitioner:organization={ID}</code> and it work<br>\ncc: <span class=\"user-mention\" data-user-id=\"193430\">@Alexander Zautke</span></li>\n</ol>",
        "id": 203586863,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594455614
    },
    {
        "content": "<p>Which server are you testing these queries with?</p>",
        "id": 203596166,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594473217
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> this is GCP FHIR</p>",
        "id": 203599740,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594479149
    },
    {
        "content": "<p>Okay. <span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> should be able to provide some advice. (I'm guessing these features may not be supported or may be incompletely supported.)</p>",
        "id": 203599813,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594479248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> thanks.<br>\nI have one more question about <code>:iterate</code> with GCP FHIR</p>\n<div class=\"codehilite\"><pre><span></span><code>GET [base] /PractitionerRole?_include=PractitionerRole:practitioner&amp;_revinclude:iterate=Encounter:practitioner\n</code></pre></div>\n\n\n<p>I try to get all <code>Encounter</code> which relate to <code>Practitioner</code><br>\nBut seem like <code>:iterate</code> didn't work. Maybe i got some mistake on this query. Can you give me some advice ?</p>",
        "id": 203599945,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594479507
    },
    {
        "content": "<p>Your _revinclude is going to include Encounters that have those practitioners.  What are you expecting to iterate?</p>",
        "id": 203600136,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1594479735
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> i don't think so.<br>\nIf only use <code>_revinclude</code>, that mean we're trying to get Encounters from <code>PractitionerRole</code>. That impossible, right ?<br>\nWhat i try to do is get Encounter base on practitioner, not practitionerRole.<br>\nThat why i add <code>iterate</code> to get all Encounter from <code>included practitioner</code><br>\nDo i understand correct about how this work ?</p>",
        "id": 203600383,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594480079
    },
    {
        "content": "<p>My understanding is that <code>iterate</code> was used to request inclusions for results that are themselves inclusions. So the query actually looks good to me.</p>",
        "id": 203600505,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594480242
    },
    {
        "content": "<p>I think the meta advice is that most servers do not support this behavior or perhaps do not support it very consistently. Spec says:</p>\n<blockquote>\n<p>It is at the server's discretion how deep to iteratively evaluate the inclusions. </p>\n</blockquote>\n<p>and more broadly, support for these include of parameters at all is pretty variable today.</p>",
        "id": 203600528,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594480289
    },
    {
        "content": "<p>I tried to get hapi to return me data using the same pattern of include underverse include you listed above: <a href=\"http://hapi.fhir.org/baseR4/Observation?_id=7195dad9-25aa-449b-8a4d-969333592d17&amp;_include=Observation:patient&amp;_revinclude:iterate=Encounter:subject&amp;_count=1\">http://hapi.fhir.org/baseR4/Observation?_id=7195dad9-25aa-449b-8a4d-969333592d17&amp;_include=Observation:patient&amp;_revinclude:iterate=Encounter:subject&amp;_count=1</a> . (Note that I supplied and ID specifically to make sure I was pointing at an Observation resource that actually has all the relevant links in and out.) I tried with and without iterate but could not get the encounter to be return to using reverse include.</p>",
        "id": 203600617,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594480418
    },
    {
        "content": "<p>(for this particular query there is a simpler way to get the encounter, which is from a direct include on the observation itself, rather than a reverse include on the patient. But I am trying to test server functionality here rather than write efficient queries. :-))</p>",
        "id": 203600671,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594480464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> i got your point.<br>\nI was check on GCP document. Spec says:</p>\n<blockquote>\n<p>The modifier :iterate causes an _include or _revinclude to be evaluated iteratively</p>\n</blockquote>\n<p>But they only have example for <code>_include:iterate</code>. That weird...<br>\n<span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> can you give me some advice about this situation?</p>",
        "id": 203601172,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594481305
    },
    {
        "content": "<p>There are a few different bits of functionality here. GCP FHIR does not support mixing _has with chaining, and does not support _revinclude:iterate.</p>\n<p>The documentation is slightly misleading, sorry about that. I wrote it with one eye on the spec and the other on our implementation, and in the case of _revinclude it incorrectly implies that we support :iterate. I'll get that wording fixed.</p>",
        "id": 203742310,
        "sender_full_name": "Paul Church",
        "timestamp": 1594660455
    },
    {
        "content": "<p>In one of your examples there is also a known limitation/bug - very short tokens (1 or 2 characters) are not indexed for non-exact match. This is why <code>name=Mr</code> does not find <code>Mr</code> but it will find <code>Mrrrr</code>. Any exact match like <code>name:exact=Mr</code> works correctly. We were already looking into this, hopefully we can change it so short tokens will work for prefix match (the default) but not for substring (:contains) to keep the index size under control.</p>",
        "id": 203743602,
        "sender_full_name": "Paul Church",
        "timestamp": 1594661082
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> thanks, i have one more question.<br>\nYesterday, i try to search HumanName with Japanese character(with and without encode UTF-8, with and without :exact) and alot of word doesn’t return the correct result. Do i need add some header into the request ?</p>",
        "id": 203785046,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594684287
    },
    {
        "content": "<p>I expected that would work by default, but you can try the header \"Content-Type: application/fhir+json;charset=utf-8\" to explicitly set UTF-8. If not, send an example of a string that doesn't match and I will investigate.</p>",
        "id": 203789368,
        "sender_full_name": "Paul Church",
        "timestamp": 1594688565
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span>  here is some  word<br>\n木村通男<br>\n会田</p>",
        "id": 203789658,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594688804
    },
    {
        "content": "<p>I already put this content type, but it’s not work</p>",
        "id": 203789678,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594688847
    },
    {
        "content": "<p>And this is word that work well</p>\n<p>张无忌</p>",
        "id": 203789692,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594688881
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> hello, Seem like GCP doesn't support,  is this right ?<br>\nI got trouble while trying get <code>Encounter</code> base on <code>Practitioner name</code><br>\nRelationship like this:<br>\nEncounter   -------&gt;  PractitionerRole ----------&gt; Practitioner<br>\nQuery will be like <br>\n`&lt;Base&gt;Encounter?participant:PractitionerRole.practitioner.name=Morning</p>\n<p>I was check on docs [1] and gcp support for it<br>\nBut i can not  get correct data.</p>\n<p>[1]  <a href=\"https://cloud.google.com/healthcare/docs/how-tos/fhir-advanced-search\">https://cloud.google.com/healthcare/docs/how-tos/fhir-advanced-search</a></p>",
        "id": 203830162,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594731845
    },
    {
        "content": "<p>I can reproduce this problem with Japanese characters and I'll have my team look into it. I see that all of them match when using :exact so this seems specific to substring matching.</p>",
        "id": 203854127,
        "sender_full_name": "Paul Church",
        "timestamp": 1594743739
    },
    {
        "content": "<p>For the 2 level chain example, we only support one level of chaining. Try this query with the header \"Prefer: handling=strict\" (or set the defaultSearchHandlingStrict option on the fhir store config) and you'll see the error \"only single level chaining is supported\". This option is useful for any kind of development work when testing search queries.</p>",
        "id": 203857550,
        "sender_full_name": "Paul Church",
        "timestamp": 1594745468
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span>  i got the point.</p>\n<blockquote>\n<p>For the 2 level chain example, we only support one level of chaining</p>\n</blockquote>\n<p>I don't want make a lot of request into healthcare. That'll scale up when data is bigger everyday.<br>\nDo you have any idea for it ?</p>",
        "id": 203859255,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594746242
    },
    {
        "content": "<p>Depending on the use case you might cache the result of the chain, for example if practitioners do not change often. For non-real-time queries you can export data to BigQuery and do arbitrary levels of joining. Or you can do multiple queries, the API supports a lot of traffic.</p>",
        "id": 203868875,
        "sender_full_name": "Paul Church",
        "timestamp": 1594751055
    },
    {
        "content": "<p>I see, thank you <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 203902122,
        "sender_full_name": "Hue Nguyen",
        "timestamp": 1594770446
    }
]