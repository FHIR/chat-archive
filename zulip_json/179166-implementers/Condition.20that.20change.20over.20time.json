[
    {
        "content": "<p>I am working on a model for conditions to use in home care settings in Denmark. I have not been able to find precise documentation about how to handle conditions that change over time (which is often the case for the prolonged health issues we see in elderly care). In my model, it is very important to be able to track, both the time that the condition was first recorded, but also the time that it was last modified. My suggestion is to use Condition.recordedDate for the date that the condition was first recorded and use Condition.encounter to point to the encounter in which it was last modified. I suggest this solution because the documentation on Condition.encounter reads as follows in the comment section: ‚ÄúThis record indicates the encounter this particular record is associated with. In the case of a \"new\" diagnosis reflecting ongoing/revised information about the condition, this might be distinct from the first encounter in which the underlying condition was first \"known\".‚Äù </p>\n<p>I would appreciate your opinion on whether my solution adheres to the intended use of the Condition resource. (And BTW I plan to use a similar model for tracking change in CarePlans - comments on that will be appreciated as well)</p>\n<p>(Just to avoid comments on the clinical aspects ‚Äì I know that it is always debatable whether a condition that changes, is in fact a new condition. We have a set of principles that guides that already üòâ)</p>",
        "id": 198030504,
        "sender_full_name": "Kirstine Rosenbeck G√∏eg",
        "timestamp": 1589873660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191403\">@Michelle (Moseman) Miller</span> This sounds reasonable to me, but we may wish to broaden the mouseoverlanguage (\"created\") and tighten the definition (\"associated\"). Alternate approaches: use the reference from the Encounter (reason or diagnosis), or the meta.lastUpdated in Encounter.period.</p>",
        "id": 198052041,
        "sender_full_name": "Jay Lyle",
        "timestamp": 1589888014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"194347\">Kirstine Rosenbeck G√∏eg</span></p>\n<p>Does the condition change only once? Otherwise your pointer in Condition.encounter would only be useful for the last encounter where the condition changed. Condition.encounter is a reference and not a list.</p>\n<p>Is this a candidate for \"stage\"? If the conditions always progress along a pathway then this seems feasible.</p>",
        "id": 198056189,
        "sender_full_name": "Scott Rossignol",
        "timestamp": 1589890644
    },
    {
        "content": "<p>Thanks for your answers. <br>\n<span class=\"user-mention\" data-user-id=\"191985\">@Jay Lyle</span> in my understanding, the reference from Encounter to Condition tells what the reason for the encounter was, not when or even whether the Condition content was changed. Could you explain in more words how meta.lastUpdated in Encounter.period is an alternative if there is no relationship between Encounter and Condition?</p>\n<p><span class=\"user-mention\" data-user-id=\"301674\">@Scott Rossignol</span> I know that it is a reference and not a list. In my use case, the condition can change many times, and as such I know that the model only works, if I have access to all the automatic versions of the record (all the historic instances with their different meta.lastUpdated, meta.versionId). Even if I had a list, it would not tell precisely what changed in the condition at the different encounters anyway. My goal is two-fold, I need a current condition for a patient, where I can see when there last was a significant modification/evaluation of the condition (and who took the responsibility for that modification ), and when it was first recorded. For secondary purposes, I am interested in the full history - but as this is a more technical/administrative use case anyway, I assume that I have access to all the historical instances, that would make this possible.</p>\n<p>Using Condition.stage is actually a quite good alternative, if you are sure that the only clinically significant change that you want to keep track of is a stage. In my use case, the significant change could be that Condition.clinicalStatus or Condition.severity was changed or that Condition.abatement was recorded.</p>",
        "id": 198060789,
        "sender_full_name": "Kirstine Rosenbeck G√∏eg",
        "timestamp": 1589892950
    },
    {
        "content": "<p>Condition is an event resource, so its use for describing the 'current' state of the Patient is not advised, I would say. Some application heuristic might be needed which checks several of the Patient's Conditions, or another resource altogether, when an assessment of the Patient's status for a particular care context is required.<br>\nCarePlan, on the other hand, should be used to track state of the Patient's healthcare journey, with some kind of version control (e.g. using the 'replaces' reference)</p>",
        "id": 198064345,
        "sender_full_name": "Petter Wolff",
        "timestamp": 1589894576
    },
    {
        "content": "<ol>\n<li>I think I still like your proposed solution best (Condition.encounter), if we can determine there's no reason not to talk about modifying the definition. Would you be interested in lodging a tracker?</li>\n</ol>\n<p>others:</p>\n<ol start=\"2\">\n<li>\n<p>I'm talking about an inferred relationship based on time (meta.lastUpdated within Encounter.period). That could break if the edits are not done during the Encounter, but to assert an explicit relationship would face the same problem: how and when is that relationship established? Would the provider \"re-open\" the Encounter to do that?</p>\n</li>\n<li>\n<p>Agreed, Encounter.reason and diagnosis have specific semantics and may not be right, but if a condition is updated based on an Encounter, it seems that one of them might be right. I don't know how tight that fit is.</p>\n</li>\n<li>\n<p>stage has pretty specific semantics, and doesn't include Encounter in scope.</p>\n</li>\n<li>\n<p>\"when there last was a significant modification/evaluation of the condition (and who took the responsibility for that modification)\" sounds like Provenance.</p>\n</li>\n</ol>",
        "id": 198068500,
        "sender_full_name": "Jay Lyle",
        "timestamp": 1589896387
    },
    {
        "content": "<p>Typically you use Provenance to look for what happened in the past.  Condition.recorded is when the condition was first created - <em>not</em> when last updated.  To see when a particular server's record was changed, you can use Condition.meta.lastUpdated</p>",
        "id": 198083654,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1589902292
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194313\">@Petter Wolff</span> Yes, I know that Conditions is an event-resource. I did not mean \"current\" in its strict sense. <br>\nThanks for bringing up the \"replaces\" reference. However, I believe that finding out what replaces what, is very difficult to manage in real life. Lets say we have a ulcer treatment, which is described in a care plan. The nurse that delivers the treatment decides that another bandage should be used from now and forward, and changes the CarePlan accordingly e.g. the description in the attribute CarePlan.activity.detail.description. How would you document this change? Is it a new care plan that replaces an old one, is it the same care plan in a new version only managed using the server's record i.e. meta.lastUpdated, or do we use the same mechanism as described for Condition i.e. saying that the encounter that it was created as part of changed, OR as also suggested in this thread create a Provenance resource, and using this to track the change?</p>\n<p><span class=\"user-mention\" data-user-id=\"191985\">@Jay Lyle</span> Very good points. You point to something that have worried me, namely, how to establish the reference, if the change to the documentation i.e. the change in Condition, takes place after the conclusion of the encounter. It still holds true in a clinical sense, but it might be difficult to handle system-wise. Thanks for mentioning the Provenance resource, I had not considered that, and I think that might open for an alternative design altogether. I will need to consider it further.</p>\n<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  I know. One of my goals is to be able to distinguish (all the potentially many) server versions, and the times/versions that signify a clinical change in Condition or CarePlan.</p>",
        "id": 198165305,
        "sender_full_name": "Kirstine Rosenbeck G√∏eg",
        "timestamp": 1589961385
    },
    {
        "content": "<p>I don't really have a suggestion regarding how to version control a CarePlan when making changes to it - it's like you say, complicated. If you intend for a CareTeam to change the care based on a changed detail.description field, there might be a need for a human decision as to whether the change is big enough to warrant a version (major, minor) bump.</p>",
        "id": 198171703,
        "sender_full_name": "Petter Wolff",
        "timestamp": 1589965776
    },
    {
        "content": "<p>I think we should extend the context of the eventHistory extension to support Condition.</p>",
        "id": 198172551,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1589966389
    },
    {
        "content": "<p>EventHistory is a standard extension that supports what I read as the request here- what/when/by whom were the relevant changes to the resource</p>",
        "id": 198172810,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1589966526
    },
    {
        "content": "<p>meta.lastUpdated tells when something has changed, not when something relevant has changed</p>",
        "id": 198172894,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1589966600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194347\">@Kirstine Rosenbeck G√∏eg</span> I think that should answer your original question for Condition.</p>",
        "id": 198173199,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1589966781
    },
    {
        "content": "<p>CarePlan is more of a \"request\" resource (Condition is an event) so you can also use an extension - relevantHistory</p>",
        "id": 198173262,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1589966818
    },
    {
        "content": "<p>for relevantHistory there is already a tracker item to change the extension to support CarePlan<br>\n<a href=\"https://jira.hl7.org/browse/FHIR-26963\">https://jira.hl7.org/browse/FHIR-26963</a></p>",
        "id": 198173304,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1589966847
    },
    {
        "content": "<p>The extensions would be these:<br>\n<a href=\"http://build.fhir.org/extension-event-eventhistory.html\">http://build.fhir.org/extension-event-eventhistory.html</a><br>\n<a href=\"http://build.fhir.org/extension-request-relevanthistory.html\">http://build.fhir.org/extension-request-relevanthistory.html</a></p>",
        "id": 198173424,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1589966910
    },
    {
        "content": "<p>There's no rule about when you must define a new CarePlan (that replaces an old one) vs. just changing the existing resource.  Such rules are driven by business context.  From a pure FHIR interface perspective, it's totally fine to take a CarePlan and change the subject, the author and the full plan content and treat that as a simple update of the same record.  However, the business rules of most environments would frown on that.  The Condition and CarePlan resources are ones that are expected to evolve over time, so it's completely reasonable to change activities in a plan (or add or remove activities) and still call it the same plan.  Seeing what it used to look like would require history.  Capturing who changed what and why would be covered by Provenance.</p>",
        "id": 198212338,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1589987421
    },
    {
        "content": "<p>Thank you for all your suggestions. Choosing a good solution is the next challenge. I wonder if anyone in my Danish network, have something to add to this discussion <span class=\"user-mention\" data-user-id=\"191427\">@Jens Villadsen</span> <span class=\"user-mention\" data-user-id=\"194815\">@Irene Zuschlag</span> <span class=\"user-mention\" data-user-id=\"191539\">@Torben M. Hagensen</span> <span class=\"user-mention\" data-user-id=\"194806\">@Jesper Haffgaard</span> <span class=\"user-mention\" data-user-id=\"262361\">@Annika Sonne Hansen</span> <span class=\"user-mention\" data-user-id=\"192477\">@Thor Schliemann</span></p>",
        "id": 198637897,
        "sender_full_name": "Kirstine Rosenbeck G√∏eg",
        "timestamp": 1590388631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> I would be surprised if your application security/state transfer model would let you make such state change -  ie. changing the subject from John to Jane without barfing. Frowning on that would be a mild interpretation <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 252690607,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1631219605
    },
    {
        "content": "<p>Oh, I agree that business rules, and even laws and regulations would prevent the change.  I'm saying that FHIR doesn't declare any such rules.  What's allowed as an update vs. what must be 'new' is totally driven by business context.  IGs might set expectations, but the FHIR core spec generally won't.</p>",
        "id": 252690885,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1631219703
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 252690947,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1631219729
    }
]