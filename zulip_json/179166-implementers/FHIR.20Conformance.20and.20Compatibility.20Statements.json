[
    {
        "content": "<p>Over the next few weeks we will are working with a number of FHIR Implementers to address issues with their Server Conformance and Compatibility statements - anyone wishing to participate please let either myself of Richard Ettema know.</p>",
        "id": 153864949,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1482624216
    },
    {
        "content": "<p>Question: Can someone explain to me the Conformance Resource element \"kind\" - what is it purpose (yes, I have read the FHIR web site and the Content Logical Definition) - Does anyone have a write up explaining how it is used - sender/receiver?  I currently see a variety of values (is there a code-value list anywhere or are the three values the entire list  (values I have seen \"capability\", \"instance\", I have yet to locate anyone using \"requirements\").  Note a number of Public FHIR Implementations are missing the \"kind\" from their conformance statements.  Appreciate learning more on this item.</p>",
        "id": 153864950,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1482624585
    },
    {
        "content": "<p>Question: During the last HL7 FHIR Connectathon and after party events - we were discussion the need for FHIR Clients to publish or post a Conformance or Compatibility Statement; Is anyone currently developing a FHIR Client who is (or plans to) publish a FHIR Conformance or Compatibility Statement as a client for a FHIR Server to locate and interogate?</p>",
        "id": 153864951,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1482624867
    },
    {
        "content": "<p>Question: Are any FHIR Server implementations currently interrogating (or have plans in the future) inbound FHIR requests to ensure the client (or server) making the request are compatible with the response message about to be generated?  Example, if you expose a FHIR 1.4.0 End-point (with a FHIR Conformance Statement, which identifies your server as 1.4.0) - do you worry or evaluate the requestor to ensure they are a either a 1.4.0 client or 1.4.0 server?  How would your server act/respond if say a FHIR Client with 1.8.0 made a request (we know depending on the resource their could be breaking changes)?  Thoughts or ideas? </p>",
        "id": 153864952,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1482625171
    },
    {
        "content": "<p>how could a server interrogate a client conformance statement? </p>",
        "id": 153864956,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1482698022
    },
    {
        "content": "<p>kind is basically redundant with software and implementations - for making invaraints</p>",
        "id": 153864957,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1482698087
    },
    {
        "content": "<p>I will participate with testing around conformance </p>",
        "id": 153864958,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1482698116
    },
    {
        "content": "<p>Requirements is what we use for all of the conformance statements defined in IGs - it sets out what systems should do rather than what a particular system does do</p>",
        "id": 153864963,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1482723049
    },
    {
        "content": "<p>Sir I want to write code for hl7 - ADT - A03, with HAPI-FHIR, Can any buddy help me! </p>",
        "id": 153865689,
        "sender_full_name": "gulraiz joyia",
        "timestamp": 1483616774
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192928\">@gulraiz joyia</span> : Please refer to our guidelines on how to ask: <a href=\"http://wiki.hl7.org/index.php?title=FHIR_Rules_for_asking_questions\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=FHIR_Rules_for_asking_questions\">http://wiki.hl7.org/index.php?title=FHIR_Rules_for_asking_questions</a></p>",
        "id": 153865698,
        "sender_full_name": "Simone Heckmann",
        "timestamp": 1483623019
    },
    {
        "content": "<p>Hi there, we have a use case in which the capabilities available to one user might be different from another user. In this case, some patients are welcome to submit self-measurements because they participate in a certain chronic disease program, while other patients aren't supposed to send in these self-measurements. </p>\n<p>I understand the Capability Statement explains what an application type or instance supports, and that the above could be viewed more of an authorization thing, and we could have the server remove scopes that aren't valid for a user during the Authorization flow. However, the Capability statement seems like a great way to express also the capabilities a specific  user is authorized for.</p>\n<p>Any ideas on how to deal with this use case?</p>",
        "id": 153885437,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1492758993
    },
    {
        "content": "<p>my server will return a different CapabilityStatement if a user is logged in than if they aren't</p>",
        "id": 153885438,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492759672
    },
    {
        "content": "<p>Hi Grahame, that makes perfect sense, thanks as always for the quick turnaround :)</p>",
        "id": 153885439,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1492759904
    },
    {
        "content": "<p>np</p>",
        "id": 153885441,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492760073
    },
    {
        "content": "<p>I never appreciated that the CapabilityStatement could be user dependant...</p>",
        "id": 153885444,
        "sender_full_name": "David Hay",
        "timestamp": 1492761231
    },
    {
        "content": "<p>It's probably a good idea for us to make that explicit.  Otherwise a system might query it with one user and presume it'll be the same for everyone else and not bother re-querying.  Or query without a logged on user and presume that reflects the set of capabilities it will always have.</p>",
        "id": 153885447,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492761806
    },
    {
        "content": "<p>Lloyd, David, Please read my orginal question. You may not \"like\" it that the CapabilityStatement is also used to reflect user-specific capabilities, but we have the use cases that require it. Please do not dismiss this use case to quickly.</p>",
        "id": 153885453,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1492763335
    },
    {
        "content": "<p>We should not confuse Capabilities, with Rights. A server may have capabilities that are not allowed to all users, all workflows, or against all patients.  These deviations are driven by Privacy (consent), Security (RBAC), or other business rules (workflows). One should not expect that all capabilities published are allowed.</p>",
        "id": 153885468,
        "sender_full_name": "John Moehrke",
        "timestamp": 1492779402
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> concept of customizing the capabilities based on the user is interesting, and would not discourage it. However it is not a general solution to the problem, it just helps subset. It does enable apps to better predict what might succeed,  or more specifically what is clearly not going to succeed. The apps need to be robust to the facts of being denied an activity.</p>",
        "id": 153885469,
        "sender_full_name": "John Moehrke",
        "timestamp": 1492779587
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192814\">@Theo Stolker</span> I wasn't dismissing the use-case, just saying that we should document that that's permitted behavior so people are aware.</p>",
        "id": 153885489,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492787408
    },
    {
        "content": "<p>Our server can disable access to certain resources based on user permissions, and I was about to reflect that in the capability  statement but then I decided against it: the capability is the only resource that can be accessed without having to login - and in that case you do not know which user to use to customize the response, so the server would end up sending different responses to the client before and after login.</p>",
        "id": 153885506,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1492798707
    },
    {
        "content": "<p>Considering this problem I think it won't be a good idea to allow different capability statements depending on the user</p>",
        "id": 153885507,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1492798786
    },
    {
        "content": "<p>There was a presentation last year at devdays about someone who puts up workflow specific end-points so that they can provide capability statements specific to the work flow. </p>",
        "id": 153885525,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492806724
    },
    {
        "content": "<p>e.g. an endpoint specific to a user/appointment combination</p>",
        "id": 153885527,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492806742
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> , thanks, I misunderstood what you said. Documenting this sounds like a great plan!</p>",
        "id": 153885631,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1492960641
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192814\">@Theo Stolker</span> Care to submit a change request? :)</p>",
        "id": 153885633,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492961246
    },
    {
        "content": "<p>The need to fetch <code>/metadata</code> to get at the auth URLs, login and then fetch <code>/metadata</code> again is the flip side of this coin, though.</p>",
        "id": 153885772,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1493056592
    },
    {
        "content": "<p>yes. but how else could it be?</p>",
        "id": 153885779,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493059989
    },
    {
        "content": "<p>This one does hit my sore point with _summary and extensions not being in there, as the SMART security values are in extensions, and thus you need to grab the (sometimes very large) capabilitystatement.</p>",
        "id": 153886233,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1493241493
    },
    {
        "content": "<p>So your proposal would be for an extension to be able to define whether it should appear in a summary?</p>",
        "id": 153886241,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1493250475
    },
    {
        "content": "<p>I don't know, just this one with security bothers me.</p>",
        "id": 153886260,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1493254875
    },
    {
        "content": "<p>as we bring SMART into FHIR, we should think throgh this. Might be good to have a standalone resource for these things. </p>",
        "id": 153886275,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493294544
    },
    {
        "content": "<p>my understanding is that _summary is not intended to be used for low bandwidth use, so much as to support when many results are returned for the purpose of displaying choices to users. Thus the _summary items might not be picked for technical  usefulness, but more for UI usefulness. These are two different purposes, do we need a counter to _summary for requesting all the most important technical bits and non of the UI bits? It isn't exactly the inverse of _summary as there would be overlap in some cases, and missing items from both sets.</p>",
        "id": 153886277,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493294743
    },
    {
        "content": "<p>To circle back to the original question - \"should a FHIR Server vary its capabilityStatement based on User Rights and Security?\" - I am inclinded to disagree.  As I read the FHIR specifications today, the CapabilityStatement is provided to establish what the Server is \"capable\" of doing.  Sure in simple use cases Client to Server we can see benefits to customizing the CapabilityStatements, sure even I can see value here.  But, wider FHIR implemetations server-to-server and Micro-Service, and ESB/SOA I could see Server-to-Server FHIR exchanges happening where the user initiating the request could change with each request.  I would recommend we think on this bit more.  Would like to hear from a few more Enterprise Integration folks.  Good idea, and worth further discussions.</p>",
        "id": 153886453,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1493480859
    },
    {
        "content": "<p>I think there's utility for both.  Sometimes a client wants to know what a system can do in general.  Other times, it only matters what the user can do.  So having different behaviors when there's a user id indicated vs. not seems appropriate - so long as we document this behavior.</p>",
        "id": 153886476,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1493507752
    },
    {
        "content": "<p>Agree with Brian and John that there may be desire to use <code>_summary</code> for what it wasn't designed to be. Even the most basic SMART on FHIR clients will always need to fetch the capability statement only to get at the auth URLs, they usually don't inspect anything else in there, issuing pre-programmed REST requests. That's 2+ MB of data just for three URLs. There should be a better way, maybe even a new resource dedicated to auth and available from <code>/auth</code> or similar. As a side effect this would obviate the need to double-fetch the capability statement and could uncouple capabilities independent of the user from capabilities dependent on the user.</p>",
        "id": 153886492,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1493582832
    },
    {
        "content": "<p>I'd be happy to explore developing an approach for this kind of information! <span class=\"user-mention\" data-user-id=\"191339\">@Pascal Pfiffner</span> do you prefer the idea of a new resource, vs a top level property on the <code>CapabilityStatement</code> to list auth details? (Top level seems important to support something like <code>&amp;elements=auth</code> -- but given that many servers won't support all that fancy element subselection stuff, a separate resource has its appeal. On that subject, do most servers support the <code>summary</code> concept?) </p>",
        "id": 153886493,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1493584055
    },
    {
        "content": "<p>My thought would have been that <code>_summary</code> is a good solution to this problem, provided auth details move from extension to their own element, but <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> points out that this isn't the intention of <code>_summary</code>. I also don't know the level of support for summaries, except that most DSTU-2 servers haven't supported it because our Swift and Python clients would otherwise not have worked (they used to only request the summary conformance). :)</p>\n<p>I never realized that a different capability statement may be returned based on who is logged in. I can see that there is appeal in this even when it's conflating capabilities and rights. I feel it would be cleaner if parts that change and parts that don't change – depending on user/system – would live in separate resources, but then I would also expect <code>/metadata</code> to serve what's user independent and something like <code>/capabilities</code> to serve what may depend on the user. Maybe we are too late for a clean separation, i.e. a two resource solution?</p>",
        "id": 153886505,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1493605721
    },
    {
        "content": "<p>so there's a few different issues at play here. One is how to retrieve a subset that includes the smart on fhir extensions (my server has those extensions as a special case). Another is whether the capabilities is limited per user. What we can say for sure is that the capabilities the server offers may not all be accessible depending on the user's context and rights </p>",
        "id": 153886526,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493618797
    },
    {
        "content": "<p>A third is whether there's utility to identifying certain extensions as appropriate to include in summaries</p>",
        "id": 153886560,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1493656656
    },
    {
        "content": "<p>I think there's agreement that the current approach is not ideal for the use-case where a client or service needs to discover auth methods and endpoints before looking at capabilities – which I'm assuming to become a default behavior for traditional client-server setups, certainly on the app level.</p>\n<p>If we ensure that all necessary auth information is returned when reading the capability statement as a _summary_ (and that it's otherwise lightweight, i.e. the summary resource is much shorter than the full resource) we can improve this workflow with what we already have at our disposal. If servers don't support <code>_summary</code>, we'll be transporting waste but nothing breaks. I'm a little less optimistic about implementers properly including necessary extensions in summaries.</p>\n<p>But I'm starting to think that introduction of a resource pertaining to auth only and to make it available from <code>/auth</code> or similar would be worthwhile. It would be cleanly separated from context-dependent capabilities, timing is not bad now that we're bringing SMART in (because it informs the resource, not because it is FOR SMART) and FHIR would still be auth-agnostic, but have the necessary hooks.</p>",
        "id": 153886569,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1493657509
    },
    {
        "content": "<p>I'm going to add another twist that I think there is an occassional need to differentiate between what a system can do and what it is currently configured to do. </p>",
        "id": 153886570,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1493657939
    },
    {
        "content": "<p>does it need to be a resource? COuld just be a json fragment like the well-known stuff - not everything has to be a resource.</p>",
        "id": 153886599,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493672779
    },
    {
        "content": "<p>\"well-known stuff\"?  can you clarify what you mean?</p>",
        "id": 153886623,
        "sender_full_name": "Eric Haas",
        "timestamp": 1493677013
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> it's a concept used by e.g. OpenID: <a href=\"https://tools.ietf.org/html/rfc5785\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc5785\">https://tools.ietf.org/html/rfc5785</a> , JSON \"resources\" that live at <em>well-known</em>, e.g. <code>.../.well-known/openid-configuration</code></p>",
        "id": 153886625,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1493678225
    },
    {
        "content": "<p>So yes, using well-known would also work for this purpose.</p>",
        "id": 153886626,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1493678286
    },
    {
        "content": "<p>I like this suggestion too.</p>",
        "id": 153886746,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1493782858
    },
    {
        "content": "<p>... the \"what the user can do\" could start to delve into the HATEOS portion of rest, depending on how nitty-gritty this is getting. I feel like a static resource for that specific scenario won't really work for user-specific privs</p>",
        "id": 153887622,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1494080509
    },
    {
        "content": "<p>I know there have been some passionate disscussions of HATEOS</p>",
        "id": 153887623,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1494080527
    },
    {
        "content": "<p>But when you start getting into the \"this user can't modify a control X med\", it will start to be resource instance by resource instance</p>",
        "id": 153887626,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1494080572
    },
    {
        "content": "<p>We flex our confomrance based on user <em>type</em> right now. But to the outside world, those look like different servers (different FQDN)</p>",
        "id": 153887629,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1494080679
    },
    {
        "content": "<p>we do <em>not</em> currently flex it user by user - they would get 403/forbidden if they tried to do something they shouldn't. But the app wouldn't know to flex UI so that they can't even see/access features they can't use.</p>",
        "id": 153887630,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1494080742
    },
    {
        "content": "<p>+1 to Jenni's comment on resource instance by instance - I'd extend that to element by element within the resources.  It is very difficult (impractically so) to design an app with a reasonable user interface when the client can't discover what instances and/or elements the server will communicate.  + all the stuff above.</p>",
        "id": 153888162,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1494232507
    },
    {
        "content": "<p>So an easy thing we could for SMART discovery would be to define <code>[fhir-base]/.well-knwon/smart-configuration</code> as returning a JSON document with the OAuth and OIDC and SMART capability basics. We'd probably want to retain our existing extensions in CapabilityStatement for backwards compatibility (but we could avoid creating a whole bunch more).</p>",
        "id": 153888165,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1494233165
    },
    {
        "content": "<p>I think we're shooting ourselves in the foot by not assuming a large future set of capabilities and discovery needs.  For instance, a set of analytics capabilities.  IMO, it would be prudent to abstract the concept of a capability with a unique URI for each (probably a Capability resource).   Effectively a triple-store, this would allow:</p>\n<ul>\n<li>A specification of any current, future, localized, etc. capabilities (e.g. SMART)</li>\n<li>A complete listing of capabilities (as is possible now)</li>\n<li>Definition of packages of capabilities (possible now only for known capabilities) that could be published as well-known or common capability sets.</li>\n<li>Client interrogation of known or future capabilities individually or as a set (via ReST or operations) by URI<br>\nThis could also better cover the overlap of content vs. API capabilities.</li>\n</ul>",
        "id": 153888180,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1494235731
    }
]