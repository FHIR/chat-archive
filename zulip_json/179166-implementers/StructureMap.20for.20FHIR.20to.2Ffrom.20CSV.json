[
    {
        "content": "<p>Can a StructureMap be used to define mappings to/from a CSV file? If so, does anyone have an example of what it would look like?</p>",
        "id": 190442593,
        "sender_full_name": "John Timm",
        "timestamp": 1584045824
    },
    {
        "content": "<p>yes, in principle. Though it requires a class model for the csv file - two classes - a container that has a list of row classes, and then a row class that has a set of named string properties. Then you write a against that class model like any other class model</p>",
        "id": 190443938,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1584046523
    },
    {
        "content": "<p>And we would want to define said class model in a structure definition I assume?</p>",
        "id": 190444721,
        "sender_full_name": "John Timm",
        "timestamp": 1584046899
    },
    {
        "content": "<p>you could. yes.</p>",
        "id": 190445185,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1584047126
    },
    {
        "content": "<p>to actually make it work, you'd need some software that knew how to turn a csv into instances described by the structure definition.</p>",
        "id": 190445298,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1584047166
    },
    {
        "content": "<p>and maybe some kind of extension on the structure definition to say that it's expected format is CSV</p>",
        "id": 190445371,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1584047217
    },
    {
        "content": "<p>could be a neat extension to the work being done here:<br>\n<a href=\"https://build.fhir.org/ig/HL7/cdmh/profiles.html\" target=\"_blank\" title=\"https://build.fhir.org/ig/HL7/cdmh/profiles.html\">https://build.fhir.org/ig/HL7/cdmh/profiles.html</a></p>",
        "id": 190445837,
        "sender_full_name": "John Timm",
        "timestamp": 1584047536
    },
    {
        "content": "<p>The .NET Implementation for executing StructureMaps does exactly that. You'll only need to pass in a CSV file to $transform, if the CSV contains contains a header row it will become available as source elements in the StructureMap. The underlying StructureDefinition is generated dynamically. <br>\n<span class=\"user-mention\" data-user-id=\"192334\">@John Timm</span> Let me know if you want to try it out, I can give you some pointers on how to start.</p>",
        "id": 190449770,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1584050042
    },
    {
        "content": "<p>it would be helpful if the java one did the same - can you describe the algorithm?</p>",
        "id": 190449954,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1584050133
    },
    {
        "content": "<p>(the non obivous parts like how to handle non-valid names)</p>",
        "id": 190449975,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1584050148
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193430\">@Alexander Zautke</span>  I am working recently on exctly the same thing as John Timm. I would be very thankful if you could give us some pointers on how to start.</p>",
        "id": 190475592,
        "sender_full_name": "Abel Stolz",
        "timestamp": 1584081741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> <a href=\"#narrow/stream/179166-implementers/topic/StructureMap.20for.20FHIR.20to.2Ffrom.20CSV/near/190449954\" title=\"#narrow/stream/179166-implementers/topic/StructureMap.20for.20FHIR.20to.2Ffrom.20CSV/near/190449954\">said</a>:</p>\n<blockquote>\n<p>it would be helpful if the java one did the same - can you describe the algorithm?</p>\n</blockquote>\n<p>Sounds great, I can prepare this for the Mapping Language Track at the connectathon</p>",
        "id": 195293046,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1587833711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256468\">Abel Stolz</span> <a href=\"#narrow/stream/179166-implementers/topic/StructureMap.20for.20FHIR.20to.2Ffrom.20CSV/near/190475592\" title=\"#narrow/stream/179166-implementers/topic/StructureMap.20for.20FHIR.20to.2Ffrom.20CSV/near/190475592\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"193430\">Alexander Zautke</span>  I am working recently on exctly the same thing as John Timm. I would be very thankful if you could give us some pointers on how to start.</p>\n</blockquote>\n<p>Sorry about the long delay! You can find the documentation for CSV support using the .NET FHIR Mapper here: <a href=\"http://docs.simplifier.net/mappingengine/featureslist/supportedformats.html#csv\" title=\"http://docs.simplifier.net/mappingengine/featureslist/supportedformats.html#csv\">http://docs.simplifier.net/mappingengine/featureslist/supportedformats.html#csv</a></p>",
        "id": 195293486,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1587834276
    },
    {
        "content": "<p>I just noticed that the public Vonk endpoint is currently not running the latest version of the FHIR Mapper, I will try to fix this in the next week so you can try it out without setting up your own Vonk server.</p>",
        "id": 195293513,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1587834359
    },
    {
        "content": "<p>With regard to StructureMap - is the StructureDefinition required for either or both of the source and target types? If I wish to map elements from a FHIR JSON object to a non-FHIR JSON object, and I define the mapping via a StructureMap, could the transform operation on a FHIR server perform the transformation even if I do not provide a StructureDefinition for the target structure?</p>",
        "id": 202276644,
        "sender_full_name": "Amrit",
        "timestamp": 1593413229
    },
    {
        "content": "<p>it's possible, though we haven't defined a standard way to process csv files. I think <span class=\"user-mention\" data-user-id=\"193430\">@Alexander Zautke</span> was going to propose something?</p>",
        "id": 202278022,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1593414743
    },
    {
        "content": "<p>Since my question was similar to the one on this thread, I asked the question in the same thread - sorry - as such, I am primarily interested in going from FHIR to V2 and back (and V2 message can easily be represented as a JSON object).</p>",
        "id": 202278607,
        "sender_full_name": "Amrit",
        "timestamp": 1593415306
    },
    {
        "content": "<p>And I asked the question because I did not want to get into the tedious job of creating a StructureDefinition for the V2 JSON.</p>",
        "id": 202278723,
        "sender_full_name": "Amrit",
        "timestamp": 1593415432
    },
    {
        "content": "<p>oh it this same thread !</p>",
        "id": 202278782,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1593415461
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193430\">@Alexander Zautke</span> it now says \"cannot display embedded content\" ...</p>",
        "id": 202278807,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1593415503
    },
    {
        "content": "<p>Oh, the rendering seems to be broken. Will look into it. It should have rendered: <a href=\"https://simplifier.net/fhirmapperr4/csvtransport\">https://simplifier.net/fhirmapperr4/csvtransport</a></p>",
        "id": 202279690,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1593416349
    },
    {
        "content": "<p>The main idea behind the CSV transformation is that the StructureDefinition for the CSV file itself is generated in the background for the user. The .NET implementation does currently not allow for untyped transformations. I think it would make sense to harmonize the way $transform is called for different content-types. The CSV_Transport logical model would be a suggestion on how to represent CSV content.</p>",
        "id": 202279961,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1593416636
    },
    {
        "content": "<p>Our implementation parses the CSV file, then create the StructureDefinition and then allows you use that in your StructureMap. I haven't worked on serializing back to CSV</p>",
        "id": 202280051,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1593416717
    },
    {
        "content": "<p>I still have to write down what the implementation does if it encounters a name in CSV which is not allowed in ElementDefinition.path</p>",
        "id": 202280151,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1593416819
    },
    {
        "content": "<p>so string, with the name of the column. that's straight forward. Questions for me:</p>\n<ul>\n<li>why 1..1?</li>\n<li>what to with with column names that are not regular tokens?</li>\n<li>do we have any support for implicit repeats (e.g. fields with commas in them?)?</li>\n<li>why the header layer? that can't matter for transforms, right?</li>\n</ul>",
        "id": 202280154,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1593416824
    },
    {
        "content": "<p>I choose string because I don't see the need of attempting to infer the type the content. I think it should be the task of the mapping using the cast function.</p>\n<ul>\n<li>The implementation verifies which elements are present in all rows. Depending on that it 0..1 or 1..1 is chosen.</li>\n<li>Two options are implemented in our solution: a) reject the CSV b) specify a replacement character for characters which are not allowed in the path</li>\n<li>I like the idea, though for now it's being handled in the mapping. In most cases you need to simply use FHIRPath to split the strings.</li>\n<li>If no header row is indicated by the Content-Type parameters as defined in <a href=\"https://tools.ietf.org/html/rfc4180#section-3\">RFC 4180</a> the elements are named record.field1 ... record.fieldN. Based on the hasHeader element you can dynamically adjust the mapping</li>\n</ul>",
        "id": 202301714,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1593433488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"301512\">Amrit</span> <a href=\"#narrow/stream/179166-implementers/topic/StructureMap.20for.20FHIR.20to.2Ffrom.20CSV/near/202278723\">said</a>:</p>\n<blockquote>\n<p>And I asked the question because I did not want to get into the tedious job of creating a StructureDefinition for the V2 JSON.</p>\n</blockquote>\n<p>Sorry, I don't know any workaround at the moment. I think many people are currently struggling with this issue. It would be awesome if we could start a project to create StructureDefinitions like we have for CCDA.</p>",
        "id": 202302412,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1593433882
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191549\">@Frank Oemig</span> ?</p>",
        "id": 202302665,
        "sender_full_name": "René Spronk",
        "timestamp": 1593434042
    },
    {
        "content": "<p>We do have structure definitions for v2, at least as a draft. We are working on that in the v2+ tooling project.</p>",
        "id": 202458844,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1593533702
    },
    {
        "content": "<p>Another approach (which is what we do) is to define standardized fixed mapping between CSV and Basic resource (each field would become an extension), then map Basic resource. Not as convenient as having dedicated data model for CSV, but can use existing tooling.</p>",
        "id": 202529478,
        "sender_full_name": "Ivan Dubrov",
        "timestamp": 1593577188
    },
    {
        "content": "<p>Ok, but who is capable to understand this massive set of extensions?<br>\nAn extension is good for solving a single local problem, but each is in principle a new one...</p>",
        "id": 202542506,
        "sender_full_name": "Frank Oemig",
        "timestamp": 1593591841
    }
]