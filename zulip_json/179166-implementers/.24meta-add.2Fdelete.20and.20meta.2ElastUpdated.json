[
    {
        "content": "<p>If I make a change (eg to tags or security) with $meta-add, should the meta.lastUpdated also change?<br>\nThe spec suggests that it is tied to the meta.versionId changing which is tied to the Resource content changing, but the meta is not the Resource content.</p>",
        "id": 193968542,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1586906507
    },
    {
        "content": "<p>My interpretation has always been that it doesn't.</p>",
        "id": 193977941,
        "sender_full_name": "James Agnew",
        "timestamp": 1586916384
    },
    {
        "content": "<p>That was mine also, but because our various caching layers use meta.lastUpdated it doesn't play well.<br>\nAlso, the issue that ETags are supposed to be based on meta.versionId but that doesn't account for changes to the meta itself.</p>",
        "id": 193987542,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1586930296
    },
    {
        "content": "<p>I think it changes</p>",
        "id": 193987562,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1586930342
    },
    {
        "content": "<p>Changing lastUpdated will be really challenging if you can change tags etc on historical things.<br>\nBut the link from ETag to versionId suggests it needs to change as well, which would be undesirable for us</p>",
        "id": 193987658,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1586930478
    },
    {
        "content": "<p>that's why we removed updating historical copies</p>",
        "id": 193987667,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1586930506
    },
    {
        "content": "<p>So I would like to base all our ETags on meta.lastUpdated then, and not meta.versionId as indicated here <a href=\"http://hl7.org/fhir/http.html#read\" title=\"http://hl7.org/fhir/http.html#read\">http://hl7.org/fhir/http.html#read</a></p>",
        "id": 193987740,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1586930594
    },
    {
        "content": "<p>I don't understand why you draw a difference.</p>",
        "id": 193987768,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1586930642
    },
    {
        "content": "<p>One tracks changes to resource content, and the other includes changes to the meta.<br>\nFor a CodeSystem, it has implications on what we need to do under the hood.  Meta changes are cheap, versionId changes are not.</p>",
        "id": 193987894,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1586930766
    },
    {
        "content": "<p>well, I think you'll have to revise that scheme somewhat - the versionId is deliberately tied to ETag, which implies that it needs to change as the meta changes</p>",
        "id": 193987951,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1586930863
    },
    {
        "content": "<p>It is only a SHOULD wrt ETag and versionId and one _could_ interpret the SHOULD text as applying to returning the ETag and not \"with the versionId\".</p>",
        "id": 193999755,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1586939968
    },
    {
        "content": "<blockquote>\n<p><strong>Resource.meta</strong>: The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.</p>\n</blockquote>\n<p>My reading of this is that the Resource.meta is NOT part of the Resource.  Further weight for this is that meta is excluded from the Canonical JSON/XML forms.</p>\n<p>Given that we are free to use whatever scheme (subject to certain uniqueness constraints) for selecting versionId, this follows through to ETags, so it's not clear to me why ETags are tied to versionId -- what will break if they don't match?</p>",
        "id": 194016333,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1586950794
    },
    {
        "content": "<p>Aha, I have found the following use case:</p>\n<blockquote>\n<p>When resources are returned as part of a bundle, there is no ETag, and the versionId of the resource is used directly.</p>\n</blockquote>\n<p>So there's a scenario in which a client may want to construct an ETag rather than use a previously supplied one.</p>",
        "id": 194016782,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1586951133
    },
    {
        "content": "<p>I have a related question, given that I realize now that HAPI is still supporting meta-add and meta-remove on historical versions. We need to fix that clearly.</p>\n<p>If I update the tags on the current version, what is the expectation for tags on the historical version? Are they frozen in time to what they were before the next version was created? Or does modifying the current version change the tags for all versions? Or is it reasonable for this to be configurable behaviour?</p>",
        "id": 194312319,
        "sender_full_name": "James Agnew",
        "timestamp": 1587047324
    },
    {
        "content": "<p>I would expect that history is history. I don't think we should treat meta any different than any other element.</p>",
        "id": 194312805,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587047513
    },
    {
        "content": "<p>That feels like the right answer to me too.</p>",
        "id": 194325190,
        "sender_full_name": "James Agnew",
        "timestamp": 1587052024
    },
    {
        "content": "<p>Although <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> I guess that does raise kind of an interesting security question.. What if I create a resource, update it, and then realize that it should have had a security label on it. If someone asks for an old version of that resource directly, they won't see the security label and the system may not have the chance to act on it. Is that a problem?</p>",
        "id": 194325732,
        "sender_full_name": "James Agnew",
        "timestamp": 1587052233
    },
    {
        "content": "<p>I would expect there is elevated privilege needed to see historic versions. If you ask for a old version, you would tend to get the new one (by policy). It would only be if you had elevated privilege that you would get the one you asked for.</p>",
        "id": 194326085,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587052356
    },
    {
        "content": "<p>YES, data tagging  brings up policy issues, it is not just a solution for policy issues.</p>",
        "id": 194326204,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587052400
    },
    {
        "content": "<p>security is hard... all solutions simply push the hard parts into less traveled corners.</p>",
        "id": 194326440,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587052479
    },
    {
        "content": "<blockquote>\n<p>I would expect there is elevated privilege needed to see historic versions.</p>\n</blockquote>\n<p>Well now there's an interesting thought.</p>\n<p>The HAPI FHIR authorization interceptor currently does not distinguish between a read and a vread/historical one. Seems like it should.</p>",
        "id": 194330277,
        "sender_full_name": "James Agnew",
        "timestamp": 1587054009
    },
    {
        "content": "<p>a more simple model would use the meta.security on the current for access control decisions. Thus if you asked for a historic one, you would need rights to current, and get access to the historic you asked for. This seems likely most appropriate, as the current tags are likely the ones everyone wants used... yet getting the copy of the old resource with the tags that were on it then.</p>",
        "id": 194330989,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587054290
    },
    {
        "content": "<p>Note that these are examples of why I stress that the .meta.security should not be impacted by policy or consent changes... that is to say the .meta.security tags should represent \"meta\" about the object only in the absence of policy changes.  Typically the security tags do not need to change unless the data itself has changed and that would be a normal step in history.  There are counter examples, such as when a lab result was not known to be related to a sensitive health topic but was later associated with a sensitive health topic -- this happened with HIV in the early days.  If the data .meta.security tags are always meta about the data, then all dynamic things are pushed into policy (e.g. consent) where they can be more well managed. E.g.,  I want  HIV sensitive data to be considered normal confidentiality for my consent purposes, and normal data are available for Treatment PurposeOfUse.</p>",
        "id": 194332227,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587054808
    },
    {
        "content": "<p>I (think I) like that more simple model <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> <br>\nA related question I've been pondering is should meta.security be rolled forward independently of the meta in a resource Update?  That is, treat the meta.security in an update as a $meta-add rather than overwriting the meta.security altogether.</p>",
        "id": 194573144,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1587260048
    },
    {
        "content": "<p>I do that</p>",
        "id": 194588827,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1587289547
    },
    {
        "content": "<p>Just for meta.security, or for meta.tag as well?</p>",
        "id": 194589436,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1587290406
    },
    {
        "content": "<p>tag as well</p>",
        "id": 194592693,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1587295372
    },
    {
        "content": "<p>I don't think  these elements should be treated any different than ANY element. That said, there will be users/apps that would not have the authority to update the .meta.security element... but that is true of other things too (for example a user as patient would not be allowed to change a doctor authored diagnosis).  <br>\nI understand the need for the $meta-add, and am fine with that. As it is an operation specifically intended to 'add'. and there is clearly defined services for which this is ALL they can do (e.g. a profile validation service).</p>",
        "id": 194603304,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587310495
    },
    {
        "content": "<p>My concern is a situation where someone has write permissions for a resource, but they don't have permissions to change the security labels on the resource.</p>",
        "id": 194624399,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1587341654
    },
    {
        "content": "<p>I agree, that is likely need for authorization enforcement.  If you are saying that you would like to implement a UPDATE policy that pulls forward the .meta.security from previous, and ignoring the .meta.security in the update; that is a fine solution for users that are not authorized to change .meta.security. I just want you to recognize that this is a policy, not a rule.    This pulling forward of previous values while ignoring some elements in an UPDATE is not too unusual of a need for policy enforcement. It is counter to the pure REST model, which does trust users to pull whole previous resource, update only what they are allowed to update, and then submit the updated resource. <br>\nAnd I point out that it is no unlike many policies that restrict what some users can do on update.  It is possible that a clinical user might be able to update a measurement, but not be able to change the author element.</p>",
        "id": 194690493,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587396191
    },
    {
        "content": "<p>alternative is to just fail the UPDATE when the user tries to change some element they are not authorized to change. Which is what would happen if the user tried to change an element to something invalid, so it would seem more proper.  But I do understand the desire to  hide automation in an API to enable best outcomes with misbehaving apps.</p>",
        "id": 194691103,
        "sender_full_name": "John Moehrke",
        "timestamp": 1587396382
    },
    {
        "content": "<p>We wouldn't ignore meta from the UPDATE - we would include it, subject to permissions. But also, we would bring forward (preserve) any existing meta.security and meta.tag content. The consequence is that the only way to remove these things would be via $meta-delete</p>",
        "id": 194751581,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1587431036
    }
]