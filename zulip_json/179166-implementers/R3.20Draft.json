[
    {
        "content": "<p>I have applied all the FHIR-Infrastructure tasks that I'm going to prior to the R3 draft publication next week (stable version for January connectathon and also IG ballots). This is a heads up so that if you care, you can check the outstanding task list for FHIR-I and let me know if there's anything in there that you think we should get to in the next couple of days</p>",
        "id": 153859509,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480561573
    },
    {
        "content": "<p>actually, <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=11088\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=11088\">GF#11088</a> is something we should look at <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> </p>",
        "id": 153859510,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480561753
    },
    {
        "content": "<p>I'm having trouble adding a follow-up in gforge,  but here's the issue: if a composite parameter simply provides references to the two parameters that it composes, we would end up in a situation where invalid combinations of paths were indexed. For example on Observation,  we might combine a top-level <code>code</code> with a component level <code>valueString</code> and index that combination, which would be nonsense.</p>",
        "id": 153859606,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480596405
    },
    {
        "content": "<p>Josh's point was one of my concerns -- he just voiced it better.  I think that #2 of the proposed resolution addresses this though, right?  It would require the author to indicate the exact combinations of paths that are valid -- so the author wouldn't group a top-level <code>code</code> with a component level <code>valueString</code>.</p>\n<p>That said, I think the actual example in the proposed resolution is incorrect.  (1) First \"expresssion\" has three \"s\", (2) Is it valid to have the value of the \"expression\" be an array of expressions (maybe it is, I don't know), (3) I expect the second expression grouping is intended to be of the <code>Observation.component.code</code> and <code>Observation.component.valueQuantity</code>, right?</p>",
        "id": 153859611,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1480599992
    },
    {
        "content": "<p>I like this idea, making composites be properly computable would be great.</p>\n<p>It does seem like the proposal addresses Josh's concern, since it's pointing to paths instead of parameter names. I guess it would exclude components entirely though, based on how it's written.... </p>\n<p>...though reading it again I see what Chris means. Presumably that's a typo and it addresses that too.</p>",
        "id": 153859633,
        "sender_full_name": "James Agnew",
        "timestamp": 1480614750
    },
    {
        "content": "<p>Yes, the proposal was designed to address this concern! My response here was to <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>'s comment at the bottom (~\"what's [wrong] with the current solution\")</p>",
        "id": 153859639,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480616015
    },
    {
        "content": "<p>so I'm fine with breaking up the observation value-[x] composite search. But What I don't undesrtand is why the proposed change has anything to do with the comments here</p>",
        "id": 153859640,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480617368
    },
    {
        "content": "<p>you can still end up with invalid combinations of paths - if indeed you're right that the particular combination you identify is incorrect (I'd have to think about it). But the change doesn't change whether you can have that combination, or whether you can find out what it says it means </p>",
        "id": 153859641,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480617430
    },
    {
        "content": "<p>and I don't see how it makes the composites any more computable than they are now</p>",
        "id": 153859643,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480617457
    },
    {
        "content": "<p>back to you <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> </p>",
        "id": 153859644,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480617512
    },
    {
        "content": "<blockquote>\n<p>But the change doesn't change whether you can have that combination</p>\n</blockquote>\n<p>Doesn't it? The current way of declaring composites is that a composite is a composite of two search params, and search params are of course backed by paths. So currently, </p>\n<p><code>code-value-quantity</code> = <br>\n<code>code &amp; value-quantity</code> =<br>\n<code>(Observation.code|Observation.component.code) &amp; (Observation.valueQuantity|Observation.component.valueQuantity)</code></p>\n<p>The proposed change would allow to express</p>\n<p><code>code-value-quantity</code> = <br>\n<code>(Observation.code &amp; Observation.valueQuantity) | (Observation.component.code &amp; Observation.component.valueQuantity)</code></p>\n<p>..which is surely the intent</p>",
        "id": 153859657,
        "sender_full_name": "James Agnew",
        "timestamp": 1480618178
    },
    {
        "content": "<p>interesting. It surely is the intent, but what it means is that is not actually a composite parameter</p>",
        "id": 153859660,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480618427
    },
    {
        "content": "<p>Having support for this feature (explicitly listing paths for composites) doesn't magically make everything work; somebody needs to actually <em>write down</em> the correct combinations and publish them as part of the spec. +1 to what <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> said.</p>",
        "id": 153859661,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480618427
    },
    {
        "content": "<p>so the issues are:<br>\n- the observation composite search parameters do not sensibly conform to the current definition of a composite search parameter<br>\n- the proposed change to the search parameter doesn't conform to the current definition of a composite search parameter (it conforms to the way it's being used in Observation)<br>\n- the proposal is wrong, in that if we're going to define composites that way the proposal anticipates, the components need a bunch of other data as well as just the expression - at least type | expression | xpathUsage and possible comparator</p>",
        "id": 153859662,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480618811
    },
    {
        "content": "<p>why do we need the other data? Isn't it enough to just specify that the components are defined as \"1..* pairs of resource paths\"</p>",
        "id": 153859664,
        "sender_full_name": "James Agnew",
        "timestamp": 1480619140
    },
    {
        "content": "<p>how do you know what the components are then? </p>",
        "id": 153859665,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480619241
    },
    {
        "content": "<p>token$quanitity - but there's no way for a client to find that out. Nor is there a way for a server to find out how to index them because you need xPathUsage</p>",
        "id": 153859666,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480619288
    },
    {
        "content": "<p>the current arrangement provides all that information.</p>",
        "id": 153859667,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480619293
    },
    {
        "content": "<p>Oh, you mean how does the client/server figure out the \"search type\" of the components.. Yeah, I guess that's a problem.</p>",
        "id": 153859669,
        "sender_full_name": "James Agnew",
        "timestamp": 1480619387
    },
    {
        "content": "<p>I think we need to specify which parameters are being composed, yes. And then separately provide a list of which path tuples should be indexed.</p>",
        "id": 153859670,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480619403
    },
    {
        "content": "<p>In other words, we keep what's defined today and *add* what's in the GForge proposal.</p>",
        "id": 153859671,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480619416
    },
    {
        "content": "<p>We can even have automated checks to ensure that the path tuples fall within the cartesian product of the individual component paths.</p>\n<p>In other words if I have a composite parameter like <code>a$b</code>, where <code>a</code> has paths of <code>path1, path2</code>, and <code>b</code> has paths of <code>path3, path4</code>, then my <code>a$b</code> composite's paths must be a subset of <code>(path1, path3), (path1, path4), (path2, path3), (path2, path4)</code>.</p>",
        "id": 153859672,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480619523
    },
    {
        "content": "<p>I don't think that you can do that. either you define the composite in terms of other search parameters, or you define the composite directly. Please let's not mix the models</p>",
        "id": 153859673,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480619534
    },
    {
        "content": "<p>If you want to repeat the types while defining the composite, that's fine by me too â€” it's just a bit of denormalization. </p>",
        "id": 153859674,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480619573
    },
    {
        "content": "<p>But either way, it'd be nice to automatically check that composite definitions are \"consistent with\" their components' definitions.</p>",
        "id": 153859675,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480619596
    },
    {
        "content": "<p>As part of an automated QA process (not a burden that gets passed onto users)</p>",
        "id": 153859676,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480619613
    },
    {
        "content": "<p>I don't know how such a check could be written. </p>",
        "id": 153859677,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480619695
    },
    {
        "content": "<p>and I'm - now that we've had this discussion - against the way composites are defined in terms of other search parameters. That's really just lazy short cut on my part for supporting spreadsheets. We should define them properly, and just define them directly as a thing that has x parts. </p>",
        "id": 153859678,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480619774
    },
    {
        "content": "<p>but even if we do, the observation search parameters with their nested grouping are a challenge</p>",
        "id": 153859679,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480619812
    },
    {
        "content": "<p>that the proposal doesn't really address</p>",
        "id": 153859680,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480619829
    },
    {
        "content": "<p>\"has x parts\" or \"has 2 parts\"? i think that distinction has pretty big implications for how you write indexing code</p>",
        "id": 153859681,
        "sender_full_name": "James Agnew",
        "timestamp": 1480619837
    },
    {
        "content": "<p>well, in the case of these observation search parameters, has 2 parts</p>",
        "id": 153859682,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480619865
    },
    {
        "content": "<p>but in general? is it valid to define a composite of 3 parts?</p>",
        "id": 153859683,
        "sender_full_name": "James Agnew",
        "timestamp": 1480619891
    },
    {
        "content": "<p>currently yes, though there's no examples of that </p>",
        "id": 153859684,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480619934
    },
    {
        "content": "<p>I think there is one actually.. It broke the HAPI build for a while. At the time I asked and iirc the response was that it's not allowable to have 3-part composites so I excluded it in HAPI's build. </p>\n<p>Lemme find it.</p>",
        "id": 153859685,
        "sender_full_name": "James Agnew",
        "timestamp": 1480619986
    },
    {
        "content": "<p>Sequence.coordinate</p>",
        "id": 153859686,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480620084
    },
    {
        "content": "<p>yeah, that's the one.</p>\n<p>so that's ok? HAPI has no support for that currently</p>",
        "id": 153859687,
        "sender_full_name": "James Agnew",
        "timestamp": 1480620132
    },
    {
        "content": "<p>well, it's currently legal, yes</p>",
        "id": 153859688,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480620145
    },
    {
        "content": "<p>do you support it in your server?</p>\n<p>the whole way I implement support for composites wouldn't work for composites of arbitrary length... I mean I can see the use case for wanting them, it's just not clear to me how you'd write a performant server implementation</p>",
        "id": 153859689,
        "sender_full_name": "James Agnew",
        "timestamp": 1480620242
    },
    {
        "content": "<p>yeah it works for me. I just decompose them to their parts on the fly. For me, they're just a syntax trick to get grouping into the query. </p>",
        "id": 153859690,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480620302
    },
    {
        "content": "<p>that's why my implementation depends on the fact that they refer to other search parameters. and also, my implementation is going to produce non-sensical results on the Observation composite</p>",
        "id": 153859691,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480620348
    },
    {
        "content": "<p>because I am implementing exactly it's current definition</p>",
        "id": 153859692,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480620362
    },
    {
        "content": "<p>it sounds like your implementation probably works the same way as mine...</p>\n<p>so you probably suffer from the same issue that I do, where an observation<br>\n<code>{ systolic = 120, diastolic = 80 }</code><br>\nwould be matched by <code>systolic | lt110</code> even though that is not the intent</p>\n<p>That's the part that is hard to solve (in a relational database at least) for N components</p>",
        "id": 153859694,
        "sender_full_name": "James Agnew",
        "timestamp": 1480620767
    },
    {
        "content": "<p>yes. that's the core problem here. But it's in the definitions, not our implementations. And the proposed solution is effectively a kludge to fix up the definitions being broken</p>",
        "id": 153859695,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480620859
    },
    {
        "content": "<p>No I know, I'm tangent-ing a bit to ponder the question of whether we should allow composites of N parts or not. If we change composites, we should examine this question based on implementability</p>",
        "id": 153859696,
        "sender_full_name": "James Agnew",
        "timestamp": 1480620941
    },
    {
        "content": "<p>yes. so back to Sequence.coordinate - there doesn't seem to be a slicker way to do that</p>",
        "id": 153859697,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480621063
    },
    {
        "content": "<p>I'm trying to follow this, but I can't tell if we landed on something that everyone is happy with.  FWIW, Josh's proposal makes sense to me, particularly w/ his clarification that the valid path combinations would have to actually be written by someone (they can't be automatically inferred), and they'd be in addition to what's already in place.  While it does make some extra work (probably including adjustments to the spreadsheet template), it seems to me that it covers the bases better than anything else I've heard.</p>",
        "id": 153859731,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1480626884
    },
    {
        "content": "<p>The only \"simpler\" solution I can think of is to not allow composite search parameters where one of the parts has multiple paths.  Or to indicate that when that does happen, all possible permutations of paths between the composite parts *must* produce \"unsurprising\" results.  So this Observation use case would not be allowed at all.</p>",
        "id": 153859732,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1480627186
    },
    {
        "content": "<p>Actually, I just understood James's point about systolic/diastolic -- if those are both Observation components, then does the problem still exist even with Josh's solution?  Or is it understood that if two parts of a composite share a common parent path, and an element in that common path is a list, that the parts need to apply to the same item?</p>",
        "id": 153859735,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1480627341
    },
    {
        "content": "<p>I believe the systolic/diastolic thing *can* be resolved with Josh's solution. We just need to explicitly state in the definition that in the case of paths which descend into repeating structures, the index applies only to pairs within the same repetition. That seems like a fair thing to state.</p>\n<p>The thing I'm worried about then though is that in order to implement that, i'm thinking it'll be hard to implement a system that respects that rule and performs well for an arbitrary number of paths in a single composite.</p>",
        "id": 153859738,
        "sender_full_name": "James Agnew",
        "timestamp": 1480629287
    },
    {
        "content": "<p>..at least that is the case for the sequence example. I mean I'd probably in an RDBMS just have a table dedicated to that one index. </p>\n<p>Maybe that's not such a big deal though.... It's not like there are hundreds of composites.</p>",
        "id": 153859739,
        "sender_full_name": "James Agnew",
        "timestamp": 1480629369
    },
    {
        "content": "<p>so, Josh's proposal solves the particular problem of the the observation search parameter, but it creates lots of other problems. His revised hybrid proposal just creates a mess. My proposal to redefine composte parameters solves the general problem, but doesn't resolve this particular parameter </p>",
        "id": 153859745,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480630040
    },
    {
        "content": "<p>the problem is the pairing where different composites have different paths, and you can permutate them. in some cases, that might be what you want, while in others, it might not </p>",
        "id": 153859746,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480630100
    },
    {
        "content": "<p>and, in fact, Josh's solution does not work either </p>",
        "id": 153859748,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480630620
    },
    {
        "content": "<p>What breaks in \"the general case\"?</p>",
        "id": 153859755,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480632299
    },
    {
        "content": "<p>(And why does \"my\" solution \"not work either\"?)</p>",
        "id": 153859756,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480632342
    },
    {
        "content": "<p>well, your original solution broke the link to the definitions. </p>",
        "id": 153859757,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480632950
    },
    {
        "content": "<p>and your solution doesn't work because while you separate nicely the root code/value and the component code/value, there's still an unresolved permutational explosion between the component codes and values</p>",
        "id": 153859758,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480632990
    },
    {
        "content": "<p>Do we have (or anticipate) examples where the set size is greater than 2 or 3?</p>",
        "id": 153859759,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480633035
    },
    {
        "content": "<p>I don't know. </p>",
        "id": 153859760,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480633048
    },
    {
        "content": "<p>really, the solution is for a single expression that gives a list of tuples back. </p>",
        "id": 153859761,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480633062
    },
    {
        "content": "<p>I'm going to see if I can write one shortly </p>",
        "id": 153859762,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480633068
    },
    {
        "content": "<p>Thinking back to how I did this for the SMART server, I introduced a path  from the resource root to \"a composite param common root\", and then relative paths to the components.  So for example...</p>",
        "id": 153859763,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480633233
    },
    {
        "content": "<p><strong>param: <code>code$value-string</code>:</strong></p>\n<p>1. Top-level pairs</p>\n<ul>\n<li>path to composite param common root: <code>Observation</code></li>\n<li>path to <code>code</code> component: <code>code</code></li>\n<li>path to <code>value-string</code> component: <code>valueString</code></li>\n</ul>\n<p>2. Component pairs</p>\n<ul>\n<li>path to composite param common root: <code>Observation.component</code></li>\n<li>path to <code>code</code> component: <code>code</code></li>\n<li>path to <code>value-string</code> component: <code>valueString</code></li>\n</ul>",
        "id": 153859764,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480633263
    },
    {
        "content": "<p>yes. I prefer to do all that in the fhirpath expression</p>",
        "id": 153859765,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480633513
    },
    {
        "content": "<p>All in a single expression?</p>",
        "id": 153859766,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480633548
    },
    {
        "content": "<p>i am so intrigued by what you have in mind.. :)</p>",
        "id": 153859767,
        "sender_full_name": "James Agnew",
        "timestamp": 1480633551
    },
    {
        "content": "<p>I would have through you'd need a few.</p>",
        "id": 153859768,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480633554
    },
    {
        "content": "<p>no FHIRPath selects are flattened. So you can't do that. </p>",
        "id": 153859770,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480633728
    },
    {
        "content": "<p>but you can do :</p>\n<div class=\"codehilite\"><pre>SearchParameter\n   type: composite\n   expression: {main expression}\n   component\n      reference\n      sub-expression\n   component\n      reference\n     sub-expression\n</pre></div>",
        "id": 153859772,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480633809
    },
    {
        "content": "<p>so for the observation example:</p>\n<div class=\"codehilite\"><pre>  code-value-quantity\n  expression=Observation | Observation.component\n\n  component\n     reference = code\n     expression = code\n  component\n     reference = value-quantity\n     expression = value.as(Quantity)\n</pre></div>",
        "id": 153859773,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480634020
    },
    {
        "content": "<p>though you could just as well do:</p>\n<div class=\"codehilite\"><pre>SearchParameter\n   type: composite\n   expression: {main expression}\n   component\n      type | usage | comparators\n      sub-expression\n   component\n     type | usage | comparators\n     sub-expression\n</pre></div>",
        "id": 153859774,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480634093
    },
    {
        "content": "<p>and inline them rather than having them be a reference to another parameter that has to exist independently. I do not know which I prefer. <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> or <span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span>  or <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> might have a preference</p>",
        "id": 153859775,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480634138
    },
    {
        "content": "<p>isn't that just a different syntax for exactly what Josh proposed that you hated? you've got the search parameter names that are being composited, plus an expression for the paths, and presumably a rule that they have to match</p>",
        "id": 153859776,
        "sender_full_name": "James Agnew",
        "timestamp": 1480634438
    },
    {
        "content": "<p>..and for the record I prefer the first, and I like it.</p>",
        "id": 153859777,
        "sender_full_name": "James Agnew",
        "timestamp": 1480634460
    },
    {
        "content": "<p>what I disliked greatly about the original proposal was that <br>\n- the metadata was lost<br>\n- the expressions didn't work right</p>",
        "id": 153859778,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480634494
    },
    {
        "content": "<p>I'll tell you want I'll do: I'll update SearchParameter for this right now, and we can look at the changes</p>",
        "id": 153859779,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480634512
    },
    {
        "content": "<p>based on the first option</p>",
        "id": 153859780,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480634534
    },
    {
        "content": "<p>ok. committed (svn 10444) for you all to have a look at once it's built. The question is, how do I show this in the resource specific pages?</p>",
        "id": 153859792,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480637334
    },
    {
        "content": "<p>and James.... at least for my implementation, I will probably have to keep the one index multiple times now - once for it as a standalone parameter, and once for each composite it's involved in, since the composite ones are tried in groups</p>",
        "id": 153859794,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480637477
    },
    {
        "content": "<p>update is visible now. </p>",
        "id": 153859817,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480644494
    },
    {
        "content": "<p>I haven't implemented composites in my search indexing as of yet.<br>\nThe proposal of a parent expression to get to the correct component, then sub-expressions to retrieve the actual values is good.<br>\nThe other Idea I had was to modify fhirpath to be able to return tuples, which would permt a fhirpath only definition of the index, and have no dependance on the other indexes.<br>\ncomponent.select(code.coding.first().select( system + '#' + code) , value.value.)</p>",
        "id": 153859832,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1480655971
    },
    {
        "content": "<p>By the way, my custom questionnaire data extract logic does exactly the main expression, then sub-expressions for extracting content.</p>",
        "id": 153859833,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1480656030
    },
    {
        "content": "<p>well, no one has commented on my draft... I guess it will be published as is</p>",
        "id": 153860217,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480880894
    },
    {
        "content": "<p>Sorry... it's been the weekend you know :)</p>\n<p>Will give it a read today.</p>",
        "id": 153860617,
        "sender_full_name": "James Agnew",
        "timestamp": 1480940269
    },
    {
        "content": "<p><a href=\"https://github.com/hl7-fhir/fhir-svn/commit/68419bcb2a6d7db5c593bf3137d754b4c921217f\" target=\"_blank\" title=\"https://github.com/hl7-fhir/fhir-svn/commit/68419bcb2a6d7db5c593bf3137d754b4c921217f\">https://github.com/hl7-fhir/fhir-svn/commit/68419bcb2a6d7db5c593bf3137d754b4c921217f</a> implements Grahame's change for #11088 but I can't quite follow</p>",
        "id": 153860875,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480968681
    },
    {
        "content": "<p>Does this implement one of the approaches we discussed <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> ? Viewing the rendered spec I only see things like:</p>\n<p><a href=\"/user_uploads/10155/Ciyk6UkI3rU7GPufDnebnMCb/pasted_image.png\" target=\"_blank\" title=\"pasted_image.png\">pasted image</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/Ciyk6UkI3rU7GPufDnebnMCb/pasted_image.png\" target=\"_blank\" title=\"pasted image\"><img src=\"/user_uploads/10155/Ciyk6UkI3rU7GPufDnebnMCb/pasted_image.png\"></a></div><p>at <a href=\"http://build.fhir.org/searchparameter-registry.html\" target=\"_blank\" title=\"http://build.fhir.org/searchparameter-registry.html\">http://build.fhir.org/searchparameter-registry.html</a></p>",
        "id": 153860877,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480968750
    },
    {
        "content": "<p>Also the search param registry at <a href=\"http://build.fhir.org/searchparameter-registry.html\" target=\"_blank\" title=\"http://build.fhir.org/searchparameter-registry.html\">http://build.fhir.org/searchparameter-registry.html</a> doesn't list canonical URLs or links to the search parameter resource instances.</p>",
        "id": 153860881,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480968865
    },
    {
        "content": "<p>And following search param links in <a href=\"http://build.fhir.org/capabilitystatement-terminology-server.json.html\" target=\"_blank\" title=\"http://build.fhir.org/capabilitystatement-terminology-server.json.html\">http://build.fhir.org/capabilitystatement-terminology-server.json.html</a> for example doesn't quite work. A link like <code>http://hl7.org/fhir/SearchParameter/ValueSet-version</code> just redirects to <code>http://hl7.org/fhir/valueset.html</code>.</p>",
        "id": 153860891,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480969059
    },
    {
        "content": "<p>the search parameter registry does not show the execution details, and not for composite parameters either</p>",
        "id": 153860957,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480971400
    },
    {
        "content": "<p>I don't have space for canonical URLs in the search parameter registry, so they appear as fly-overs. And I didn't have time to render every search parameter resource so I could link to it from the registry. If you want to create a task about that, that'll make sure I get to it</p>",
        "id": 153860960,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480971472
    },
    {
        "content": "<p>and all the canonical URL redirects are broken in the current build because the canonical URL points to the final location, not the current build</p>",
        "id": 153860961,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480971551
    },
    {
        "content": "<p>OK. We tried to review your resolution on today's FHIR-I call, but nobody could understand what the resolution was.</p>",
        "id": 153860962,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480971573
    },
    {
        "content": "<p>Oh shoot. I thought today was cancelled... Sorry, would have joined!</p>",
        "id": 153860963,
        "sender_full_name": "James Agnew",
        "timestamp": 1480971605
    },
    {
        "content": "<p>We wound up ending early.</p>",
        "id": 153860964,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480971622
    },
    {
        "content": "<p>'nobody could understand what the resolution was' is obviously a problem.</p>",
        "id": 153860981,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480972598
    },
    {
        "content": "<p>if we were not in freeze, I ould add a paragraph explaining. That'll have to come next time</p>",
        "id": 153860984,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480972620
    },
    {
        "content": "<p>This definitely doesn't seem like something crucial to make STU3 in the grand scheme of things.. It's a pretty niche feature.</p>",
        "id": 153860988,
        "sender_full_name": "James Agnew",
        "timestamp": 1480972713
    },
    {
        "content": "<p>Could you add a paragraph here, though?</p>",
        "id": 153860999,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480973515
    },
    {
        "content": "<p>When a search parameter is a composite, the parts of which it is composed are specifed by other parameters, in SearchParameter.component.definition</p>",
        "id": 153861004,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480973646
    },
    {
        "content": "<p>these provide the declaration of their functionality. </p>",
        "id": 153861005,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480973661
    },
    {
        "content": "<p>when it comes to determining the correct values for the search on the composite field, a different arrangement specifies the values. It's not possible to simply execute the individual component search parameter because the point of a composite is to tie the values of the components together, not to permutate them with each other </p>",
        "id": 153861008,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480973807
    },
    {
        "content": "<p>so for composite parameters, the expression is split into parts. The first expression (SearchParameter.expression) specifies the main expression that returns the list of indexable items. These are usually anonymous element types (e.g. Observation.component). Then, for each component, there's a sub-expression that specifies how to determine the correct value of the component for that indexable item. For composite parameters, the sub-expression must return only a single value</p>",
        "id": 153861011,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480973925
    },
    {
        "content": "<p>does that help?</p>",
        "id": 153861012,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480973945
    },
    {
        "content": "<p>Yes! And is there an example (like for Observation:code-value-string)?</p>",
        "id": 153861015,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480973989
    },
    {
        "content": "<p>sure. that's all in the spec. but only really available - because of my band-width limitations - in the file searchparameters.[xml/json] which is in the various definition downloads. </p>",
        "id": 153861017,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480974063
    },
    {
        "content": "<p>so for your ease:</p>",
        "id": 153861018,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480974070
    },
    {
        "content": "<div class=\"codehilite\"><pre>      &quot;resource&quot;: {\n        &quot;resourceType&quot;: &quot;SearchParameter&quot;,\n        &quot;url&quot;: &quot;http://hl7.org/fhir/SearchParameter/Observation-code-value-concept&quot;,\n        &quot;code&quot;: &quot;code-value-concept&quot;,\n        &quot;base&quot;: [ &quot;Observation&quot; ],\n        &quot;type&quot;: &quot;composite&quot;,\n        &quot;expression&quot;: &quot;Observation | Observation.component&quot;,\n        &quot;xpathUsage&quot;: &quot;normal&quot;,\n        &quot;component&quot;: [\n          {\n            &quot;definition&quot;: {\n              &quot;reference&quot;: &quot;http://hl7.org/fhir/SearchParameter/Observation-code&quot;\n            },\n            &quot;expression&quot;: &quot;code&quot;\n          },\n          {\n            &quot;definition&quot;: {\n              &quot;reference&quot;: &quot;http://hl7.org/fhir/SearchParameter/Observation-value-concept&quot;\n            },\n            &quot;expression&quot;: &quot;value.as(CodeableConcept)&quot;\n          }\n        ]\n      }\n</pre></div>",
        "id": 153861021,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480974214
    },
    {
        "content": "<p>Ah, I was looking for searchparameters.json: do we link to it from somewhere? <a href=\"http://build.fhir.org/searchparameter-registry.html\" target=\"_blank\" title=\"http://build.fhir.org/searchparameter-registry.html\">http://build.fhir.org/searchparameter-registry.html</a> would be a good place.</p>",
        "id": 153861026,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480974450
    },
    {
        "content": "<p>I can add a tracker item if that helps.</p>",
        "id": 153861027,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480974457
    },
    {
        "content": "<p>it's just included in the various definitions zips. I don't think we link to it directly anywhere</p>",
        "id": 153861028,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480974490
    },
    {
        "content": "<p>should include it on searchparameter-examples.html</p>",
        "id": 153861029,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480974504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> wrong topic?</p>",
        "id": 153861031,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1480974534
    },
    {
        "content": "<p>yes it was. fixed</p>",
        "id": 153861032,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480974655
    }
]