[
    {
        "content": "<p>And again about polymorphic elements wire format:</p>\n<ul>\n<li>impossible to have collection of different types (without realistic reason, just because format)</li>\n<li>problematic validation (it's not so simple to express exclusiveness &amp; required elements)</li>\n</ul>\n<div class=\"codehilite\"><pre>// what we have\n{ valueNumber:  42, valueString: &quot;some&quot;}\n\n// how it could be\n{value: {type: &quot;number&quot;, value: 42}}\n// this isomorphic to  {resourceType: &quot;....&quot;} solution, or we could use something like @type for both :)\n\n// if it&#39;s collection\n{value: [{type: &quot;number&quot;, value: 5}, {type: &quot;string&quot;, value: &quot;some&quot;}]}\n</pre></div>",
        "id": 153862347,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481210709
    },
    {
        "content": "<p>Not 100% sure what the question is here, but it really just depends on your database.  MongoDB can certainly handle collections of different resource types.  You could even have an index on the <code>resourceType</code> field, for fast collapse/lookup of resources.  It wouldn't be the most efficient lookup ever, but would be perfectly fine for inbound queues and caches.  </p>\n<p>Schema validation is another area where it just depends on your implementation.  We're using a schema constructed called SimpleSchema, which supports nested schemas, schema extensions, and partial schemas.  So we constructed a BaseSchema and MetaSchema, which all of our other resource schemas inherit from.  So, if we want to validate on a set of required elements, plus a base schema, we can do so.  </p>\n<p>That being said, we were careful not to bake the schema validation into the  database itself.   MongoDB, NoSQL, and all that.   </p>",
        "id": 153862367,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1481218724
    },
    {
        "content": "<p>We used to be able to do that, back when we had the format for primitive types as :</p>\n<div class=\"codehilite\"><pre>&quot;code&quot;: {\n  &quot;value&quot; : &quot;xxxx&quot;,\n  &quot;extension&quot; : {\n  }\n}\n</pre></div>",
        "id": 153862381,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481224001
    },
    {
        "content": "<p>instead of </p>\n<div class=\"codehilite\"><pre>&quot;code&quot; : &quot;xxxx&quot;,\n&quot;code_&quot; : {\n}\n</pre></div>",
        "id": 153862382,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481224024
    },
    {
        "content": "<p>but we continually had implementers come to us and say \"you guys just don't even understand JSON do you. It's just not xml\"</p>",
        "id": 153862383,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481224051
    },
    {
        "content": "<p>so eventually we bowed to the pressure and went to the split representation. We knew, when we did this, that it would mean no polymorphic collections</p>",
        "id": 153862384,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481224101
    },
    {
        "content": "<p>from my point of view, this was a step backwards. But it's not going to change now</p>",
        "id": 153862385,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481224127
    },
    {
        "content": "<p>For json purists we could use something like this: <code>{type: \"string\", string: \"...value...\"}, {type: \"date\", date: \"...value...\"}</code></p>",
        "id": 153862398,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481225624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> might want to comment but changing the name of \"value\" to the name of the type wasn't going to do it. </p>",
        "id": 153862400,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481225713
    },
    {
        "content": "<p>Changing value to datetype could simplify fhir/fluent path expressions and will play well with db indexes - so every type has it's own path</p>",
        "id": 153862407,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481225915
    },
    {
        "content": "<p>and it looks uniform with <code>{resourceType: \"....\"}</code> polymorphism</p>",
        "id": 153862408,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481225977
    },
    {
        "content": "<p>let say <code>{dataType: \".....\", ...}</code> :)</p>",
        "id": 153862409,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481226017
    },
    {
        "content": "<p>it wouldn't change fhirpath at all. but it would complicate navigation of the json where you just wanted to value, irrespective of the type. e.g. string, integer, boolean, uri, I don't care</p>",
        "id": 153862411,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481226090
    },
    {
        "content": "<p>Looking back at all of the pain this has caused,  I certainly can't say that I'm happy with where we've landed. Extensible primitives with our current json representation is hard for everyone. </p>",
        "id": 153862413,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481226102
    },
    {
        "content": "<p>But yeah, calling the property <code>value</code> vs <code>dateTime</code> (or whatever) doesn't seem to matter much to me. </p>",
        "id": 153862416,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481226158
    },
    {
        "content": "<p>It matters for example for elasticsearch :)</p>",
        "id": 153862417,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481226196
    },
    {
        "content": "<p>Anyway, @<strong>nicola (RIO)</strong>'s comments were about polymorphic elements, not about standalone primitive values. </p>",
        "id": 153862419,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481226231
    },
    {
        "content": "<p>and fhirpath \"element.date\" vs \"element(type=date).value</p>",
        "id": 153862420,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481226260
    },
    {
        "content": "<p>they're related</p>",
        "id": 153862421,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481226261
    },
    {
        "content": "<p>I think, extending primitives is bad idea by themself :)</p>",
        "id": 153862422,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481226277
    },
    {
        "content": "<p>They could be. But even pre-DSTU1,  we disallowed polymorphic lists, no? </p>",
        "id": 153862423,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481226286
    },
    {
        "content": "<p>I's like OOP of brain :)</p>",
        "id": 153862424,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481226298
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> yes, that's my perspective too. </p>",
        "id": 153862426,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481226307
    },
    {
        "content": "<p>(I mean, about extensions on primitives. I don't know what \"OOP of brain\"  means :)) </p>",
        "id": 153862427,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481226341
    },
    {
        "content": "<p>yes, we never allowed it. But I always knew that we could allow it if we really needed to, but we just had to define our own equivalent of xsi:type (with all the pain that it cases, along with defining something of our own). but once we made the json change, that was no longer an option</p>",
        "id": 153862428,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481226365
    },
    {
        "content": "<p>You could always create custom extension for additional info, instead \"extending primitives\" :)</p>",
        "id": 153862429,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481226379
    },
    {
        "content": "<p>Yeah, I'm thinking about doing that in the use cases I  have. </p>",
        "id": 153862431,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481226442
    },
    {
        "content": "<p>about 5% of our extensions are on primitive types. And in most of those cases, saying to put the extension on the parent not the child would just create confusion. </p>",
        "id": 153862432,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481226518
    },
    {
        "content": "<p>I think the name \"primitive\" means it's not extendable</p>",
        "id": 153862433,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481226537
    },
    {
        "content": "<p>i.e. not complex</p>",
        "id": 153862434,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481226553
    },
    {
        "content": "<p>We have polymorphic lists in Bundle.entry, do we?</p>",
        "id": 153862435,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481226679
    },
    {
        "content": "<p>yes,f or resource type</p>",
        "id": 153862436,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481226710
    },
    {
        "content": "<p>I do not see essential difference with polymorphic lists for elements</p>",
        "id": 153862438,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481226810
    },
    {
        "content": "<p>no, perhaps not. But perhaps you could comment about where in particular the resource content models are wrong because of this rule</p>",
        "id": 153862439,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481226908
    },
    {
        "content": "<p>We just have a lot of bugs and confusion with [x], that's why i've started this discussion :)</p>",
        "id": 153862440,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481227020
    },
    {
        "content": "<p>we'd still have a lot of bugs. That's definitely a case of moving the deckchairs around</p>",
        "id": 153862442,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481227131
    },
    {
        "content": "<p>Usually when concepts are fuzzy - you've got a lot frustration. Simple &amp; concise one always better :)</p>",
        "id": 153862443,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481227293
    },
    {
        "content": "<p>Is the burden of the 'confusion' for 5% of the extensions worth the burden for accomodating extensions on primatives? I'd think not. I think you'd consider an extension in the parent to either add an element or override an existing element.</p>",
        "id": 153862447,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481228360
    },
    {
        "content": "<p>you haven't really considered all of the ways this plays out. if you 'decorate' a primitive with an extension, by putting it somewhere else, you're taken a step back - you're still going to need to consider the extension, but no it's not even in the right place. You stll haven't dealt with the actual problem, which is that there *are* extensions on primitive types</p>",
        "id": 153862449,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481229536
    },
    {
        "content": "<p>Well, it's not in the 'right place' in json and we seem to be coping with that. So your concern is that you have a business need to replace or augment the concept with a different or richer thing - is that really the same concept?</p>",
        "id": 153862452,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481230026
    },
    {
        "content": "<p>If the use case is that normally the concept foo can be represented by a primative but sometimes you need a complex to be used then adding fooComplex as an extension on the parent would not seem confusing.  </p>",
        "id": 153862453,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481230218
    },
    {
        "content": "<p>unless it repeats. And in json it works as well as a millipede with a wooden leg, really. </p>",
        "id": 153862455,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481230306
    },
    {
        "content": "<p>I expect that this would lead to less reuse of purely generic extensions and more element-specific extensions but that would further help reduce confusion.</p>",
        "id": 153862456,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481230320
    },
    {
        "content": "<p>have you looked at the extensions we have on primitives? </p>",
        "id": 153862457,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481230349
    },
    {
        "content": "<p>Unless it repeats, you mean it has a cardinality greater than 1 or that there are several places where the same generic extention may apply?</p>",
        "id": 153862458,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481230404
    },
    {
        "content": "<p>No I was just starting to skim through the extensions. But certainly the 21090 extensions, not sure which may apply to primatives, could be cast as extensions which augment or overide a spcific element.</p>",
        "id": 153862459,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481230492
    },
    {
        "content": "<p>most of them, it would not be very cool to permutate the extension identity with the element identity. </p>",
        "id": 153862460,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481230543
    },
    {
        "content": "<p>Then you could add an optional element to extension to indicate the element being extended: use referencing rather than positioning to provide context. On one level it makes things harder but I think it may slightly increase point complexity while overall reducing complexity.</p>",
        "id": 153862461,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481230742
    },
    {
        "content": "<p>We could explore Tuesday Q1 in ITS in San Antonio. I think we need to stand up some examples to really assess the pros and cons.</p>",
        "id": 153862462,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481230768
    },
    {
        "content": "<p>we could just put all the extensions in the root of the element, and refer to the context by :id. </p>",
        "id": 153862463,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481230867
    },
    {
        "content": "<p>that was my preferred approach for a long time. a bitch to serialise properly</p>",
        "id": 153862464,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481230891
    },
    {
        "content": "<p>root of the resource or at nodes?</p>",
        "id": 153862465,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481230928
    },
    {
        "content": "<p>yes resource, that's what I meant</p>",
        "id": 153862466,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481230946
    },
    {
        "content": "<p>ok, so literally a bag and a map</p>",
        "id": 153862467,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481230970
    },
    {
        "content": "<p>I'm not championing any particular solution, but I think that not extending primatives is important, and if we are going to make that change that we should make it soon - not in haste but soon.</p>",
        "id": 153862468,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481231046
    },
    {
        "content": "<p>well, we aren't making it for STU3. that's for sure. </p>",
        "id": 153862469,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481231088
    },
    {
        "content": "<p>I don't have any extensions I'm using which are applied to primatives so I'd need to refresh on what the impacts are of losing the context. We could point to an id attribute in xml on the primative, but in json what would we do - privide the path? or inject a marker element and point to it?</p>",
        "id": 153862470,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481231331
    },
    {
        "content": "<p>well, this is the cool thing - in json, we'd need an id. So we could change the representation of the primitive to </p>\n<div class=\"codehilite\"><pre>&quot;code&quot; : {\n  &quot;id&quot; : &quot;x2&quot;,\n  &quot;value&quot; : &quot;xxxx&quot;\n}\n</pre></div>",
        "id": 153862471,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481231420
    },
    {
        "content": "<p>it would mean you would need to pre-process to serialize and deserialize but I this we are there already so it is just changing what you are doing.</p>",
        "id": 153862472,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481231433
    },
    {
        "content": "<p>that way, we could move extensions out to the root of the resource so we didn't need to have a complex primitive, and we could just have \"code\": \"xxxx\"</p>",
        "id": 153862473,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481231458
    },
    {
        "content": "<p>;-)</p>",
        "id": 153862474,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481231459
    },
    {
        "content": "<p>honestly, I prefer the json-ld format. it's more verbose, yes, but it's brutally simple. </p>",
        "id": 153862475,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481231482
    },
    {
        "content": "<p>Alternately we could get rid of primatives and make all data types complex which may contain complex or primatives - just a thought.</p>",
        "id": 153862476,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481231503
    },
    {
        "content": "<p>you don't have to pre-process right now</p>",
        "id": 153862477,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481231506
    },
    {
        "content": "<p>in effect, all data types are complex that contain primitive values right now. You're just mocving deck chairs around</p>",
        "id": 153862478,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481231537
    },
    {
        "content": "<p>No, integer is: &lt;foo value=\"int\"/&gt; or foo: int - how is that already complex?</p>",
        "id": 153862479,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481231657
    },
    {
        "content": "<p>Yes we are moving the chairs, but that is what you do with chairs to make them efficient for the purpose</p>",
        "id": 153862480,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481231712
    },
    {
        "content": "<p>integer is already complex because it has an id and extensions. The value is not. This is crystal clear in the structure definitions / typing system, and in the XML,  and RDF. </p>",
        "id": 153862481,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481231852
    },
    {
        "content": "<p>it's only the json format that complicates things by trying to simplify things</p>",
        "id": 153862482,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481231879
    },
    {
        "content": "<p>It's 00:16 so I'm going to crash, but I think a lot of people would appreciate a solution so that we didn't extend primatives directly.</p>",
        "id": 153862483,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481231894
    },
    {
        "content": "<p>a lot of people would appreciate not having extensions. Until they see the alternative</p>",
        "id": 153862484,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481231916
    },
    {
        "content": "<p>Agreed - xml isn't dealing with the same 'primative' as json - and that has ramifications.</p>",
        "id": 153862485,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481231948
    },
    {
        "content": "<p>Actually I think a lot see the need for extensions and for them not to get out-of-hand like Z segments. The 2 pushbacks I hear are them being applied to primatives and their perceived overuse.</p>",
        "id": 153862486,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1481232062
    },
    {
        "content": "<p>I'm not sure the json ld is nearly as simple as you describe. At least: do you expect it to be parsed according to json ld semantics? Should apps know how to parse general json-ld graphs, or is the precise layout in the FHIR examples what's required? Would apps recognize a flattened representation of the same graph (all nodes moved to the top) as equivalent? What about renaming the prefixes to arbitrary new values (as for namespaces in xml)? </p>",
        "id": 153862504,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481233531
    },
    {
        "content": "<p>1. yes, it should be able to be, but I'm suspicious that polymorphism isn't right. <span class=\"user-mention\" data-user-id=\"192267\">@Eric Prud'hommeaux</span> says I shouldn't worry about that<br>\n2. I don't know the answer<br>\n3. I don't whether they would. Should they? I don't know. I think it depends whether they use json-ld pattern for reading it, or just read it directly<br>\n4. what prefixes? I don't think we have any in json-ld</p>",
        "id": 153862506,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481233757
    },
    {
        "content": "<p><a href=\"http://build.fhir.org/observation-example-TPMT-haplotype-two.html\" target=\"_blank\" title=\"http://build.fhir.org/observation-example-TPMT-haplotype-two.html\">http://build.fhir.org/observation-example-TPMT-haplotype-two.html</a> has two \"@context\" properties (!) which is an error </p>",
        "id": 153862523,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481238962
    },
    {
        "content": "<p>no that's very useful is it</p>",
        "id": 153862524,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239081
    },
    {
        "content": "<p>typo. the second is supposed to be @id</p>",
        "id": 153862525,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239109
    },
    {
        "content": "<p>We don't have prefixes but a bunch of properties defined in our contexts like <a href=\"http://build.fhir.org/Observation.jsonld\" target=\"_blank\" title=\"http://build.fhir.org/Observation.jsonld\">http://build.fhir.org/Observation.jsonld</a> and in theory one of could give these fields any name one liked, and client should understand that they mean the same </p>",
        "id": 153862526,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481239127
    },
    {
        "content": "<p>by remapping in the definition? But how, when we publish the definitions, and the @context must refer to our definition?</p>",
        "id": 153862527,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239173
    },
    {
        "content": "<p>Also, the reference to a contact is wrong because this context only to find properties about observation and does not define the rest of the properties that are used</p>",
        "id": 153862528,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481239181
    },
    {
        "content": "<p>In general in a Json LD file, you could change the contact and rename properties. I client would recognize that the file has the same meaning by expanding the properties to full Uris.</p>",
        "id": 153862529,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481239208
    },
    {
        "content": "<p>Something tells me we are not proposing using Json LD in this way.</p>",
        "id": 153862530,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481239219
    },
    {
        "content": "<p>.... no I don't understand that one</p>",
        "id": 153862531,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239224
    },
    {
        "content": "<p>But I'm not sure we have captured a clear explanation of how we are using it.</p>",
        "id": 153862532,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481239233
    },
    {
        "content": "<p>we haven't captured that at all. You won't find any write up of any of this, just the examples and the jsonld definitions</p>",
        "id": 153862533,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239282
    },
    {
        "content": "<p>In theory every property name can be expanded to its full URI by looking things up in the context. You could replace the instance data with a new copy where each property that was a full URI. That file that have the same meaning as the current instance data.</p>",
        "id": 153862534,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481239284
    },
    {
        "content": "<p>yes indeed, but that requires different @context definitions. which we don't provide</p>",
        "id": 153862535,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239317
    },
    {
        "content": "<p>What I am saying is that if we are using Json LD, and we expect clients to understand json-ld semantics, then we should expect clients to understand a payload like the one I just described.</p>",
        "id": 153862536,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481239382
    },
    {
        "content": "<p>If not, we need to explain what we *do* expect </p>",
        "id": 153862537,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481239420
    },
    {
        "content": "<p>umm, I'm not sure how. Perhaps you could explain how that would work with an actual example</p>",
        "id": 153862538,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239440
    },
    {
        "content": "<p>But in any case, this is the kind of thing I mean when we talk about the Simplicity of the format. One variant of the payload might look simple while another might look complex. And they both have the same meaning.</p>",
        "id": 153862539,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481239460
    },
    {
        "content": "<p>and I mean, an actual resource. Cause I understand how that works in principle, but I believe that we eliminate much of this by fixing the value of @context</p>",
        "id": 153862540,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239481
    },
    {
        "content": "<p>If you want to see an example, you can put one of the current resources into the sandbox at <a href=\"http://jsonld.org\" target=\"_blank\" title=\"http://jsonld.org\">jsonld.org</a> and click \"expand\". I will share link when I'm at a computer.</p>",
        "id": 153862541,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481239515
    },
    {
        "content": "<p>I don't believe that will show me an example of what you're talking about</p>",
        "id": 153862542,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239540
    },
    {
        "content": "<p>for a start it doesn't work... I broke something...</p>",
        "id": 153862543,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239616
    },
    {
        "content": "<p>but that will show me the transform from one particular input to a canonical representation. And there could be other inputs that lead to the same canonical representation  - in theory. But by locking down @context, we prohibit that, no?</p>",
        "id": 153862544,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481239708
    },
    {
        "content": "<p>A context is just a way to list a bunch of shortcuts that you are allowed to use. A given document can always expand everything fully and ignore those shortcuts even though they are available.</p>",
        "id": 153862561,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481242106
    },
    {
        "content": "<p>As I understand json-ld it's just json representation of RDF, where attributes are URIs and this approach is similar to what we've discussed for extension with embedded schema and extensions as key/value instead collection. I like it, because there is no difference between FHIR core elements and extensions.</p>",
        "id": 153862648,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481268200
    },
    {
        "content": "<p>umm, no. not quite, I didn't see a way to pull off making them all the same, but happy to talk about ideas there</p>",
        "id": 153862659,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1481275618
    },
    {
        "content": "<p>I mean something like this:</p>\n<div class=\"codehilite\"><pre>{                                                                                                                                               \n  $schema: {      // or @context                                                                                                                                                        \n    race: {url: &quot;http://hl7.org/fhir/StructureDefinition/us-core-race&quot;, type: &#39;CodeableConcept&#39;},                                               \n    name: {url: &quot;fhir&quot;, type: &quot;HumanName&quot;, collection: true}                                               \n  },                                                                                                                                                                                                                                                      \n  race: {coding: ....},  // extension\n  name: [...names....]      // core element                                                                                                                                                                                                                                                                                                                                                               \n}     \n````\n</pre></div>",
        "id": 153862691,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1481288201
    },
    {
        "content": "<p>You could make extensions just the same as regular elements, but you lose your trivial mapping back/forth with FHIR's other serialization formats. Sticking them all behind an \"extension\" property keeps this mapping very straightforward (but gives less idiomatic rdf).</p>",
        "id": 153863200,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1481626851
    }
]