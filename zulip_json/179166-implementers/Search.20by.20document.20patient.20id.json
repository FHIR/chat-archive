[
    {
        "content": "<p>If I have a system with a patient /Patient/123 and a document bundle /Bundle/456 that is about the same person, am I correct that a search of Bundle?composition.patient.id=Patient/123 won't necessarily work, because the patient inside the bundle doesn't have to correspond to any known patient outside the bundle, and even if it is the same person, it doesn't have to have the same patient id? Searching by Bundle?composition.patient.identifier would be more robust?</p>",
        "id": 269320654,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643143228
    },
    {
        "content": "<p>I'll first note that I don't think <code>Bundle?composition.patient.id=Patient/123</code> is quite a valid search.</p>\n<p>You may need <code>Bundle?composition.patient._id=123</code>, which would be brittle if the reference doesn't resolve...  but if instead you write <code>Bundle?composition.patient=Patient/123</code>, I think it should work even if the reference doesn't resolve or is bundle-internal.</p>",
        "id": 269321512,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643143674
    },
    {
        "content": "<p>(That's what I get for trying to compose a search off the top of my head.)</p>\n<p>Sorry, can you clarify the distinction you see between your two searches?</p>",
        "id": 269322269,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643144021
    },
    {
        "content": "<p>One uses chaining syntax, chaining into a referenced Patient; the other evaluates the reference itself without chaining into the target of the reference. The <code>.</code> after \"patient\" indicates chaining into the target.</p>",
        "id": 269324072,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643144721
    },
    {
        "content": "<p>Now, my analysis here is a bit theoretical, based on this spec itself; I'm interested to know if real-world FHIR servers behave differently.</p>",
        "id": 269324253,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643144789
    },
    {
        "content": "<p>So, <code>Bundle?composition.patient._id=123</code> looks for bundles with compositions that have a patient reference with a value of 123; and  <code>Bundle?composition.patient =Patient/123</code> look for bundles with compositions that have a patient that references the known-outside-the bundle patient Patient/123? (Did I somehow come up with the exact opposite conclusion from your original statement?)</p>",
        "id": 269326030,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643145544
    },
    {
        "content": "<p>My real focus here is to confirm that the search is entirely inside the bundle (the document bundle must contain the composition, and the composition requires all \"primary\" resources, such as patient, be included in the bundle as well) and the existence of any patient resource outside the bundle is completely irrelevant to the search.</p>",
        "id": 269326553,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643145758
    },
    {
        "content": "<blockquote>\n<p>Elliot Silver15:19 So, Bundle?composition.patient._id=123 looks for bundles with compositions that have a patient reference with a value of 123; and Bundle?composition.patient =Patient/123</p>\n</blockquote>\n<p>Not quite -- I'm saying</p>\n<ul>\n<li>\n<p><code>Bundle?composition.patient._id=123</code> Looks for a Bundle with a composition in <code>.entry[0]</code> where there's a subject that references a Patient, and where following that link and looking in the target Patient resource (whether the reference resolves to a Bundle-local resource or a resource elsewhere on the server)... you have a patient with an id property of 123. </p>\n</li>\n<li>\n<p><code>Bundle?composition.patient =Patient/123</code> looks  a Bundle with a composition in entry[0] where there's a subject that is a reference to to \"Patient/123\" (where the reference might fail to resolve altogether, or might resolve to a Bundle-local resource, or a resource elsewhere on the server).</p>\n</li>\n</ul>",
        "id": 269327456,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643146117
    },
    {
        "content": "<blockquote>\n<p>the existence of any patient resource outside the bundle is completely irrelevant to the search</p>\n</blockquote>\n<p>Well, this is determined by  the <code>Bundle.entry.fullUrl</code> on the Composition entry -- if that <code>fullUrl</code> indicates a Composition \"based in\" the sever like <code>https://server.example.org/fhir/r4/Composition/123</code>, then any relative reference in the Composition is interpreted as a reference to a resource on the server (see <a href=\"https://build.fhir.org/bundle.html#references\">https://build.fhir.org/bundle.html#references</a>)</p>",
        "id": 269327736,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643146245
    },
    {
        "content": "<p>Those reference resolution rules don't set any expectations that are particular to \"document\"-type Bundles.</p>",
        "id": 269327909,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643146330
    },
    {
        "content": "<blockquote>\n<p>A document Bundle (type = \"document\") consists of a series of entries, the first of which is a Composition. Each entry element SHALL contain a resource.</p>\n</blockquote>\n<p>I read that as the resource must be in the bundle, not referenced.</p>",
        "id": 269328009,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643146391
    },
    {
        "content": "<p>I don't think so, though that may be a rule spelled out elsewhere. The language you quoted above  just means no <code>Bundle.entry</code>  <em>is</em> present that lacks a <code>.resource</code> property.</p>",
        "id": 269328129,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643146451
    },
    {
        "content": "<p>Also, <a href=\"https://build.fhir.org/documents.html#content\">https://build.fhir.org/documents.html#content</a>.</p>",
        "id": 269328197,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643146487
    },
    {
        "content": "<p><a href=\"https://build.fhir.org/documents.html#content\">https://build.fhir.org/documents.html#content</a> states: </p>\n<blockquote>\n<p>Other resources that these referenced resources refer to may also be included in the bundle if the document construction system chooses to do so.</p>\n</blockquote>",
        "id": 269328223,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643146501
    },
    {
        "content": "<p>Yes, after the composition, subject, author, etc. you can do references, but all the \"primary\" resources are in the bundle.</p>",
        "id": 269328303,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643146543
    },
    {
        "content": "<p>So some referenced resources have to be included, and others don't. But this is not actually relevant to your initial question, because when resources <em>are</em> included, they would have their <code>fullUrl</code> populated in a manner consistent with the reference, right?</p>",
        "id": 269328389,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643146566
    },
    {
        "content": "<p>But fullUrl doesn't come into the search, does it?</p>",
        "id": 269328506,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643146635
    },
    {
        "content": "<p>Like, you can find the subject in the bundle but that's just a shortcut -- you can <em>also</em> find it on the server, if the <code>Composition.subject</code> looks like <code>{\"reference\": \"Patient/123\"}</code>. Now, if the <code>Composition.subject</code> used a <code>urn:uuid</code> or something, it might be possible that that the subject is <em>only</em> available in the bundle.</p>",
        "id": 269328512,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643146638
    },
    {
        "content": "<p>Or patient/123 might refer to a patient 123 on a different server that has nothing to do with patient 123 on this server.</p>",
        "id": 269328679,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643146702
    },
    {
        "content": "<p>that would <em>only</em> be possible if the <code>Bundle.entry[0].fullUrl</code> reflected this, like \"<a href=\"https://other-server.example.org/Composition/123\">https://other-server.example.org/Composition/123</a>\", right?</p>",
        "id": 269328951,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643146857
    },
    {
        "content": "<p>And  this is my point about Bundle reference resolution rules: if the server doesn't maintain a copy of the target, chaining will be very hard, but searches that can be evaluated against the <em>reference itself</em> are still easy. And in your example that's all you need.</p>",
        "id": 269329042,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643146918
    },
    {
        "content": "<p>For the sub-case of references to resources that will <em>always</em> be present in the Document bundle, chaining is at least <em>possible</em>, but your use case still doesn't require it, so I would try not to depend on it.</p>",
        "id": 269329133,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643146951
    },
    {
        "content": "<p>If I use Composition/<em>x</em>$document to create a document on one server, save it to disk, and up load it to another server, you're saying fullUrl will point to old-server, and Bundle?composition.patient=Patient/123 won't match because what the server should be doing is trying to match <a href=\"http://this-server.com/Patient/123\">this-server.com/Patient/123</a> against <a href=\"http://old-server.com/Patient/123\">old-server.com/Patient/123</a>?</p>",
        "id": 269329438,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643147132
    },
    {
        "content": "<p>(Anyone else feel like a freshman who's just walked into a grad seminar?)</p>",
        "id": 269330035,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643147420
    },
    {
        "content": "<p>welcome to the wonderful word of resource id resolution in bundles <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 269332358,
        "sender_full_name": "Oliver Egger",
        "timestamp": 1643148558
    },
    {
        "content": "<p>Part of the discussion has to be what happens before the search, i.e. when the bundle is ingested into the server by whatever method, does the reference get rewritten? Would it be accepted at all if it just said Patient/123 and the server didn't have that resource or know how to resolve it?</p>\n<p>I would expect the search to match the bundle if the reference was stored as Patient/123, because it's not a search problem at that point.</p>",
        "id": 269334082,
        "sender_full_name": "Paul Church",
        "timestamp": 1643149299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197072\">Paul Church</span> <a href=\"#narrow/stream/179166-implementers/topic/Search.20by.20document.20patient.20id/near/269334082\">said</a>:</p>\n<blockquote>\n<p>Part of the discussion has to be what happens before the search, i.e. when the bundle is ingested into the server by whatever method, does the reference get rewritten? Would it be accepted at all if it just said Patient/123 and the server didn't have that resource or know how to resolve it?</p>\n</blockquote>\n<p>Yes, but I don't think that doing a rewrite is required (or implied) in the base spec. As an IG author, if I want it done, do I need to specify something here?</p>",
        "id": 269337655,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643151307
    },
    {
        "content": "<p>If you store the exact bytes of a bundle like <a href=\"https://www.hl7.org/fhir/document-example-dischargesummary.json.html\">https://www.hl7.org/fhir/document-example-dischargesummary.json.html</a> in your server ... and then a client retrieves this document and wants to resolve the subject of the Composition as expressed here:</p>\n<div class=\"codehilite\"><pre><span></span><code>        &quot;subject&quot;: {\n          &quot;reference&quot;: &quot;http://fhir.healthintersections.com.au/open/Patient/d1&quot;,\n          &quot;display&quot;: &quot;Eve Everywoman&quot;\n        },\n</code></pre></div>\n<p>... the rules say:</p>\n<ol>\n<li>Look for a bundle-local resolution -- this will succeed because the relative reference is in the same FHIR base as d1; the <code>fullUrl</code> elements are:</li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><code>      &quot;fullUrl&quot;: &quot;http://fhir.healthintersections.com.au/open/Composition/180f219f-97a8-486d-99d9-ed631fe4fc57&quot;,\n      &quot;fullUrl&quot;: &quot;http://fhir.healthintersections.com.au/open/Patient/d1&quot;,\n</code></pre></div>\n<ol start=\"2\">\n<li>If the local resolution had <em>failed</em>, the client would have to go on to querying the origin server. But (1) succeeded and always will succeed for Document bundles when resolving <code>Composition.subject</code>, so we're OK. </li>\n</ol>\n<p>Now, when your server is indexing this document, a whole bunch of questions come into play, as Paul notes. Servers <em>could</em> build support for indexing these in-Bundle resources, but frankly if the server is going to store this bundle at <a href=\"https://newserver.example.org/Bundle/123\">https://newserver.example.org/Bundle/123</a>, then it's <em>already</em> rewriting <code>Bundle.id</code>, and it might choose to rewrite all the references as well. I don't think the FHIR API currently has a good way to store a full document <em>byte-for-byte as it originated from the source</em> and also allow search on top, because of this issue with <code>Bundle.id</code> not being globally unique.</p>",
        "id": 269341549,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643153604
    },
    {
        "content": "<p>I don't know much about document-specific concerns but isn't this similar to having an IG require referential integrity? Whatever the server does, it has to avoid ending up with a relative reference (Patient/123 with no fullUrl) that doesn't resolve.</p>",
        "id": 269352467,
        "sender_full_name": "Paul Church",
        "timestamp": 1643161526
    },
    {
        "content": "<p>I don't see any document specific concerns here. For any references that aren't included in the document Bundle, the receiving server might well be stuck without an ability to resolve.  That needn't prevent the receiving server from storing the Document bundle and supporting search on the content it doesn't have.</p>",
        "id": 269357861,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643167542
    },
    {
        "content": "<p>Re: documents I'm just saying if you want to store/expose the raw source bytes (to support signature algorithms, hashes, etc) you can do so in a Binary, but clients won't be able to run searches like Elliot is asking about. Or you can store a Bundle at the Bundle endpoint and support search, but you won't be serving the original bytes. You can't have both features without storing the Document twice, as it currently stands.</p>",
        "id": 269358082,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643167801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197072\">Paul Church</span> <a href=\"#narrow/stream/179166-implementers/topic/Search.20by.20document.20patient.20id/near/269352467\">said</a>:</p>\n<blockquote>\n<p>I don't know much about document-specific concerns but isn't this similar to having an IG require referential integrity? Whatever the server does, it has to avoid ending up with a relative reference (Patient/123 with no fullUrl) that doesn't resolve.</p>\n</blockquote>\n<p>Even if it isn't technically different, It feels to me qualitatively different. One of the supposed advantages of \"documents\" is that they are self-contained, however, that means that the contents of the document don't need be related to anything known to the server. I'm trying to understand what that translates to in practice.</p>",
        "id": 269363584,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643172881
    },
    {
        "content": "<p>It can differ based on the specific use case, of course, but <em>one</em> of the benefits of a FHIR document bundle (such as an IPS, for example) is that it provides an auditable, nonrepudiable, message exchange of point-in-time context. That said... again with the IPS example... it would be helpful for this exchange to also be able to '<strong>sync</strong>' systems to a common context. <br>\nFollowing along with this idea, a context-syncing pattern could be something like:<br>\n<strong>ENCOUNTER BEGINS</strong></p>\n<ol>\n<li>EMR fetches IPS for Derek from HIE</li>\n<li>EMR compares local content with IPS content</li>\n<li><strong>IF IPS represents a superset of the content in the EMR</strong> update Derek's record in the EMR with new data from the IPS</li>\n</ol>\n<p><strong>EXECUTE ENCOUNTER ACTIVITIES</strong></p>\n<ol start=\"4\">\n<li>update Derek's record in the EMR to reflect encounter data, outcomes, and orders</li>\n<li>create an updated IPS for Derek from the EMR content and submit it to HIE (which would leverage it, as in step 3, to update Derek's shared health record)</li>\n</ol>\n<p><strong>ENCOUNTER ENDS</strong><br>\nI think this valuable pattern could be undermined if it is difficult (or potentially patient-unsafe) to do .id resolution between content in the bundle and the FHIR server that this bundle is trying to sync with.</p>",
        "id": 269435889,
        "sender_full_name": "Derek Ritz",
        "timestamp": 1643213165
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193307\">@Derek Ritz</span> Following up on the IPS context:</p>\n<ul>\n<li>Patient obtains IPS from local (hospital, PCP, national system, etc) which identifies the patient by local identifiers, and uses a local URL for patient id.</li>\n<li>Patient is injured while travelling and goes to foreign hospital where a new patient resource is created in the foreign EMR.</li>\n<li>Patient provides foreign healthcare provider with their IPS which gets uploaded to the foreign EMR.</li>\n</ul>\n<p>Now the question is, does the patient in the IPS get modified to match the foreign patient id? Do we update the patient resource in the EMR to match the content of the patient resource in the IPS? Do we update the patient resource in the IPS to match the patient resource in the EMR? Which changes break the \"point-in-time\" nature of a document? Is there some level of \"tweak\" to the content of a document that is accepted without \"changing\" the document? If we don't change the patient id (and potentially MRN, etc.) how do we later identify this document as belonging to the patient with a given (foreign) id?</p>",
        "id": 269462759,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643223386
    },
    {
        "content": "<p>So... I'm actually not thinking of cross-border use cases, here. I'm actually just thinking about multiple care delivery sites within the same province, and all connected to the same HIE-based shared health record. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 269466245,
        "sender_full_name": "Derek Ritz",
        "timestamp": 1643224678
    },
    {
        "content": "<p>My sense is that the exchange of a bundle <strong><em>within a single governance framework</em></strong>  should be able to benefit from consistency in .identifier (and potentially, in .id) across a federation of FHIR servers... with the bundle being used as the way to do the syncing.</p>",
        "id": 269467656,
        "sender_full_name": "Derek Ritz",
        "timestamp": 1643225249
    },
    {
        "content": "<p>This is part of what I am getting at -- what are the built-in assumptions to using a document bundle? Do we need a common framework for patient id/identity?</p>",
        "id": 269468105,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1643225416
    },
    {
        "content": "<p>In the \"within a province\" scenario, ideally you'd be looking to share the data over a RESTful interface and not creating a plethora of document instances to wade through.</p>",
        "id": 269469802,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1643226111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  maybe... there are useful medico-legal implications of the document exchange... and the evidence trail it operationalizes. (also... documents can be signed... and there are times where this is valuable, too).</p>",
        "id": 269471500,
        "sender_full_name": "Derek Ritz",
        "timestamp": 1643226839
    },
    {
        "content": "<p>even within a province</p>",
        "id": 269472396,
        "sender_full_name": "Derek Ritz",
        "timestamp": 1643227191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191380\">Elliot Silver</span> <a href=\"#narrow/stream/179166-implementers/topic/Search.20by.20document.20patient.20id/near/269468105\">said</a>:</p>\n<blockquote>\n<p>This is part of what I am getting at -- what are the built-in assumptions to using a document bundle? Do we need a common framework for patient id/identity?</p>\n</blockquote>\n<p>I think we will have to expect that master data management of all kinds will be needed. Consistency in patient ids, provider ids, location ids, and even document ids for important things like prescriptions -- will all be the key to successfully being able to operationalize FHIR document exchange within a care delivery network.</p>",
        "id": 269473987,
        "sender_full_name": "Derek Ritz",
        "timestamp": 1643227834
    },
    {
        "content": "<p>I think a strong focus on</p>\n<p>1) ensuring that all (important) related resources are part of a document Bundle and<br>\n2) populating <code>Resource.identifier</code> with cross-org-relevant values where possible</p>\n<p>is going to be the best \"bang for buck\" in the <span class=\"user-mention\" data-user-id=\"193307\">@Derek Ritz</span>  use case. Aligning <code>Resource.id</code> across systems should be a non-goal in my opinion.</p>",
        "id": 269476393,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1643228682
    },
    {
        "content": "<p>in a pure FHIR world... there would be no Resource.identifier values, as nothing exists outside FHIR... right? So the <a href=\"http://Resource.id\">Resource.id</a> at the source is the unique identifier.</p>",
        "id": 269601936,
        "sender_full_name": "John Moehrke",
        "timestamp": 1643302482
    },
    {
        "content": "<p>definitely agree that aligning <a href=\"http://Resource.id\">Resource.id</a> across systems is a non-starter.</p>",
        "id": 269602039,
        "sender_full_name": "John Moehrke",
        "timestamp": 1643302525
    }
]