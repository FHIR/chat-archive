[
    {
        "content": "<p>I have some questions about fluent path based on implementing it </p>",
        "id": 153819676,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459573021
    },
    {
        "content": "<p>when does $this apply? can we say that $this is only available in a function when evaluating parameters, and then only as the proximal value in a parameter, and when you encounter it, it's the object on which the function is being evaluated</p>",
        "id": 153819677,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459573198
    },
    {
        "content": "<p>but that means that it's only the iterator functions (where, select, all)</p>",
        "id": 153819678,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459573230
    },
    {
        "content": "<p>That was my understanding, it would only be available within the iterators.</p>",
        "id": 153819679,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459573251
    },
    {
        "content": "<p>k. I'll implement it so. And I'll try and remember to make a ballot comment that we need to be more specific anbout this</p>",
        "id": 153819680,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459573291
    },
    {
        "content": "<p>I'll make a note as well.</p>",
        "id": 153819681,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459573310
    },
    {
        "content": "<p>another thing I haven't figured out - how can is and as be operators? </p>",
        "id": 153819682,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459573807
    },
    {
        "content": "<p>I've found that I need special handling for the function parameters for is and as because they are evaluated in the type space, not the instance space. </p>",
        "id": 153819683,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459573841
    },
    {
        "content": "<p>but when they'er operators, I don't know how to do that because I process the operands before the operation. </p>",
        "id": 153819684,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459573867
    },
    {
        "content": "<p>thoughts?</p>",
        "id": 153819685,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459573870
    },
    {
        "content": "<p>Yeah, they're more like generic operators in that they have a compile-time resolve.</p>",
        "id": 153819686,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574059
    },
    {
        "content": "<p>What we do in the CQL-to-ELM translator is resolve the type at compile-time and save it in the object model.</p>",
        "id": 153819687,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574143
    },
    {
        "content": "<p>hmm. I hadn't thought of it like that. but that implies that there has to be a compile step</p>",
        "id": 153819688,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459574155
    },
    {
        "content": "<p>Well, either that or your run-time has to have some way to resolve a type.</p>",
        "id": 153819689,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574178
    },
    {
        "content": "<p>I've implemented it both ways.</p>",
        "id": 153819690,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574183
    },
    {
        "content": "<p>Do you have a context you could use at run-time to reach into the type model?</p>",
        "id": 153819691,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574205
    },
    {
        "content": "<p>well, it's not so much that I can resolve a type or not, but that I have to know that I'm in the type space not the instance space </p>",
        "id": 153819692,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459574220
    },
    {
        "content": "<p>Yeah I see that's special case code because of the way the FluentPath grammar is built then.</p>",
        "id": 153819693,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574326
    },
    {
        "content": "<p>should we note that? </p>",
        "id": 153819694,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459574344
    },
    {
        "content": "<p>You basically have to say, if this is an \"is\" or \"as\", remember that the operand is an type.</p>",
        "id": 153819695,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574347
    },
    {
        "content": "<p>So, for the \"is\" and \"as\" expressions (where they are keywords), we do have a different production rule.</p>",
        "id": 153819697,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574412
    },
    {
        "content": "<p>typeSpecifier</p>",
        "id": 153819698,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574422
    },
    {
        "content": "<p>But for \".is()\" and \".as()\", we don't specify those in the grammar at all, so I'm not sure how we would handle that.</p>",
        "id": 153819699,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574450
    },
    {
        "content": "<p>we say that in the definition of the functions. they were easier for me </p>",
        "id": 153819700,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459574481
    },
    {
        "content": "<p>We could introduce specific rules for just those invocations.</p>",
        "id": 153819701,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574489
    },
    {
        "content": "<p>Or....</p>",
        "id": 153819702,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574492
    },
    {
        "content": "<p>we could introduce a typeof keyword...</p>",
        "id": 153819703,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574509
    },
    {
        "content": "<p>Then Type would be a type and you could declare the .is() and .as() operators to take arguments of type Type.</p>",
        "id": 153819704,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574531
    },
    {
        "content": "<p>(formatted for clarity)</p>",
        "id": 153819705,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574577
    },
    {
        "content": "<p>typeof is a keyword in the definitions or the language? it seems retrograde to have to specify it in is() and as() </p>",
        "id": 153819706,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459574593
    },
    {
        "content": "<p>and I can see how to solve it for me - it's similar to the notion of short cut boolean evaluation</p>",
        "id": 153819707,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459574615
    },
    {
        "content": "<p>and I do it a the same point</p>",
        "id": 153819708,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459574624
    },
    {
        "content": "<p>Keyword or method, either way would work.</p>",
        "id": 153819709,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574640
    },
    {
        "content": "<p>well, let's just make sure we ballot about it </p>",
        "id": 153819710,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459574656
    },
    {
        "content": "<p>But if you have a solution, we can just note it as something to add clarifying documentation around.</p>",
        "id": 153819711,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574657
    },
    {
        "content": "<p>Yep.</p>",
        "id": 153819712,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574661
    },
    {
        "content": "<p>no point wasting cycles solving it now. it might be solved with better doco, or it might need something more. we can decide later </p>",
        "id": 153819713,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459574694
    },
    {
        "content": "<p>for now, I know how to implement it, but it is kind of unexpected</p>",
        "id": 153819714,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459574709
    },
    {
        "content": "<p>Agreed.</p>",
        "id": 153819715,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459574782
    },
    {
        "content": "<p>I have a problem with '-'. Take this expression:</p>",
        "id": 153819750,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459657859
    },
    {
        "content": "<p>Patient.name.given.where(substring($this.length()-3) = 'out')</p>",
        "id": 153819751,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459657881
    },
    {
        "content": "<p>here, - is an operator. </p>",
        "id": 153819752,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459657889
    },
    {
        "content": "<p>but take this expression:</p>",
        "id": 153819753,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459657894
    },
    {
        "content": "<p>Patient.name.given.count() &gt; -3</p>",
        "id": 153819754,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459657912
    },
    {
        "content": "<p>- here is part of the constant. </p>",
        "id": 153819755,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459657920
    },
    {
        "content": "<p>I don't know how to tell these apart in my lexer</p>",
        "id": 153819756,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459657929
    },
    {
        "content": "<p>Could be wrong, I didn't do the stuff in the .net implementation, but could have a look over what Ewout did.<br>\n3 tokens at the end of the stream \"&gt;\", \"-\", \"3\"<br>\nSo you have the \"-\" token inbetwen an operator and a constant, so it should merge it into the const token.</p>",
        "id": 153819757,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1459658333
    },
    {
        "content": "<p>see, that breaks the separation between the lexer and the grammar</p>",
        "id": 153819758,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459658367
    },
    {
        "content": "<p>Yes, tokenizer breaks into the words, then the lexer needs to convert the tokens into correct tree for execution. In this case it is merging those 2 tokens into the constant as the substract operator when following a comparison operator.<br>\nI haven't gone that close into the grammar to see how that fits into it.</p>",
        "id": 153819759,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1459658788
    },
    {
        "content": "<p>(I have been meaning to do that to review Ewout's implementation though)</p>",
        "id": 153819760,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1459658806
    },
    {
        "content": "<p>I'll have to figure that out, I guess</p>",
        "id": 153819761,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459659802
    },
    {
        "content": "<p>a question: </p>",
        "id": 153819762,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459659805
    },
    {
        "content": "<p>'12345'.startsWith('') = false</p>",
        "id": 153819763,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459659807
    },
    {
        "content": "<p>true? or false? </p>",
        "id": 153819764,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459659811
    },
    {
        "content": "<p>empty string?</p>",
        "id": 153819765,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1459660224
    },
    {
        "content": "<p>good question, would also be good question for if the string was null/not found</p>",
        "id": 153819766,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1459660275
    },
    {
        "content": "<p>maybe that's something that should be defined by the startswith operator</p>",
        "id": 153819767,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1459660291
    },
    {
        "content": "<p>that's why I'm asking. Clearly, if it's empty for some reason, then the string can't start with it. but the empty string is different.</p>",
        "id": 153819768,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459663265
    },
    {
        "content": "<p>it's not allowed in fhir btw</p>",
        "id": 153819769,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459663271
    },
    {
        "content": "<p>but a null is.</p>",
        "id": 153819770,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1459663333
    },
    {
        "content": "<p>Another problem in the spec: the type datetime should be dateTime</p>",
        "id": 153819773,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459668887
    },
    {
        "content": "<p>the only date functions are today() and now(), I think we need some date manipulation functions also.<br>\nLots of validations have date relative features. But I guess that can be added later e.g. dateAdd(month, 12)</p>",
        "id": 153819780,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1459672119
    },
    {
        "content": "<p>Regarding the unary minus, that should come back from the parser as a unary expression. The Antlr visitor will just do that, are you not using an Antlr generated visitor?</p>",
        "id": 153819802,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459709687
    },
    {
        "content": "<p>Regarding '12345'.startsWith(''), startsWith is usually defined in terms of a substring of the same length, which means startsWith('') would return true.</p>",
        "id": 153819803,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459710022
    },
    {
        "content": "<p>I'll note that we need to clarify the behavior.</p>",
        "id": 153819804,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1459710040
    },
    {
        "content": "<p>I'm not using an Antlr grammar</p>",
        "id": 153819920,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459815582
    },
    {
        "content": "<p>I don't like the way all() is defined. </p>",
        "id": 153819922,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459815592
    },
    {
        "content": "<p>it should take a criteria - does all this collection meet this criteria? </p>",
        "id": 153819923,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459815628
    },
    {
        "content": "<p>as it is, you have to do select(criteria).all() - but the selection does - or could - drop the cases that don't meet the criteria, so .all() will be true. </p>",
        "id": 153819924,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459815667
    },
    {
        "content": "<p>it's a lot easier if it's .all(criteria)</p>",
        "id": 153819925,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459815682
    },
    {
        "content": "<p>consider this invariant: entry.where(fullUrl).select(fullUrl+resource.meta.versionId).distinct()</p>",
        "id": 153820087,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459985459
    },
    {
        "content": "<p>if versionId is present, it contributes to the assessment of null. but it might not be. So this invariant fails because:</p>",
        "id": 153820088,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459985489
    },
    {
        "content": "<p>\"The math operators require each operand to be a single element. Both operands must be of the same type, each operator below specifies which types are supported.\"</p>",
        "id": 153820089,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459985524
    },
    {
        "content": "<p>but resource.meta.versionId might not be present</p>",
        "id": 153820090,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459985540
    },
    {
        "content": "<p>at present the only way I could approach this is:</p>",
        "id": 153820091,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459985551
    },
    {
        "content": "<p>entry.where(fullUrl).select(fullUrl+iif(resource.meta.versionId, resource.meta.versionId, '')).distinct()</p>",
        "id": 153820092,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459985578
    },
    {
        "content": "<p>that's painful. </p>",
        "id": 153820093,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459985584
    },
    {
        "content": "<p>I think I need to bring back &amp; operator</p>",
        "id": 153820094,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1459985598
    },
    {
        "content": "<p>I have brought it back for FHIR. </p>",
        "id": 153820116,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460004995
    },
    {
        "content": "<p>it's just too finicty to deal with the stupid rules aorund plus that make sense for integers, but not strings</p>",
        "id": 153820117,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460005013
    },
    {
        "content": "<p>Not sure I follow this last one, plus for integers, not strings?<br>\nIs the &amp; the concatenation for strings instead of +?</p>",
        "id": 153820448,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1460092031
    },
    {
        "content": "<p>in my implementation, you can do string + String</p>",
        "id": 153820598,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460348388
    },
    {
        "content": "<p>but if either string is missing, it's an error, according to the rules for +, since they are type safe</p>",
        "id": 153820599,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460348406
    },
    {
        "content": "<p>&amp; is not type safe - it simply appends left and right as strings together, and ignores missing parameters</p>",
        "id": 153820601,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460348450
    },
    {
        "content": "<p>I have 2 differences between my implementation  and the spec after ignoring the little details above in this topic:<br>\n- I have the &amp; operator<br>\n- I allow a selector on the .all() operation</p>",
        "id": 153820602,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460348493
    },
    {
        "content": "<p>hopefully I'll be upgrading both my DSTU2 and Montreal servers to use current fluent path in the next few hours - just doing testing now</p>",
        "id": 153820603,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460348530
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-email=\"grahame@healthintersections.com.au\">@Grahame Grieve</span>: \"but if either string is missing, it's an error, according to the rules for +, since they are type safe\" It's not an error, it's just that the result is empty. In CQL we define a _coalesce_ operator that collapses the .iif() logic you have above. So with that operator it would be:</p>",
        "id": 153820805,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460394670
    },
    {
        "content": "<p>entry.where(fullUrl).select(fullUrl + resource.meta.versionId.coalesce('')).distinct()</p>",
        "id": 153820806,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460394692
    },
    {
        "content": "<p>Having said that, I do like the notion of defining a string concatentation operator that is different than +, and having it treat empty differently would simplify things even further. But I would still propose the need for something like a coalesce operator.</p>",
        "id": 153820807,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460394792
    },
    {
        "content": "<p>I'll note the &amp; operator in the FluentPath comments.</p>",
        "id": 153820808,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460394832
    },
    {
        "content": "<p>I've asked Bryn to speak about CQL (using FluentPath) at the upcoming WGM in Montreal. It would be nice to also have a speaker about FluentPath and its implementation aspects. Any volunteers? We need to spread the word about these two topics somewhat, most in the FHIR user comunity won't have heard about them..</p>",
        "id": 153820818,
        "sender_full_name": "Ren√© Spronk",
        "timestamp": 1460397132
    },
    {
        "content": "<p>Looking to see if there has been any progress on date manipulation operations/functions.<br>\nMy use cases are for comparing dates 6 or 12 months in past/future, both for validation and defaulting values (in my case with quesitonnaires)</p>",
        "id": 153821225,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1460469303
    },
    {
        "content": "<p>The current FluentPath specification does not define date/time arithmetic. CQL defines a complete set though, so we have two options 1) incorporate the date/time arithmetic operations, or 2) use full CQL to express your use case.</p>",
        "id": 153821256,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460474518
    },
    {
        "content": "<p>I think that the preference will be 1, but do we need a complete set?</p>",
        "id": 153821289,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460488570
    },
    {
        "content": "<p>We can start with just the date arithmetic definitions to support this particular use case.</p>",
        "id": 153821296,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460490339
    },
    {
        "content": "<p>so +(dateTime, quantity), +(time, quantity), -(dateTime, quantity), -(time, quantity)</p>",
        "id": 153821298,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460490488
    },
    {
        "content": "<p>why would we not use + / - for this? </p>",
        "id": 153821304,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460491335
    },
    {
        "content": "<p>Agreed, that is the syntax CQL uses.</p>",
        "id": 153821310,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460492470
    },
    {
        "content": "<p>Is it documented how to express a const quantity? do I can represent 1d or -6m or +1y</p>",
        "id": 153821315,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1460494894
    },
    {
        "content": "<p>I don't think it is, but given the complexity, I would define a function....</p>",
        "id": 153821316,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460494941
    },
    {
        "content": "<p>something like a Quantity resource constructor?</p>",
        "id": 153821329,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1460496651
    },
    {
        "content": "<p>quantity(value, unit) or quantity(value, unit, system code)</p>",
        "id": 153821342,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460497993
    },
    {
        "content": "<p>CQL defines a quantity selector, but we did not define that in FluentPath. We talked about adding it, but never reached a decision.</p>",
        "id": 153821343,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460498056
    },
    {
        "content": "<p>Nope, I take it back.</p>",
        "id": 153821345,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460498084
    },
    {
        "content": "<p>It's in the grammar, just not documented in the md.</p>",
        "id": 153821347,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460498093
    },
    {
        "content": "<p>The syntax in the grammar is &lt;NUMBER unit?&gt;</p>",
        "id": 153821349,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460498118
    },
    {
        "content": "<p>Where unit is either a singular or plural date time precision (year(s), month(s), day(s), hour(s), minute(s), second(s), millisecond(s)), or a UCUM unit as a string.</p>",
        "id": 153821352,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460498164
    },
    {
        "content": "<p>So you can say:</p>",
        "id": 153821353,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460498169
    },
    {
        "content": "<p>6 months</p>",
        "id": 153821354,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460498171
    },
    {
        "content": "<p>or</p>",
        "id": 153821355,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460498175
    },
    {
        "content": "<p>6 'mo'</p>",
        "id": 153821357,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460498180
    },
    {
        "content": "<p>I'll add a comment to document that in the md.</p>",
        "id": 153821360,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460498204
    },
    {
        "content": "<p>but see, this doesn't deal with questions around the units </p>",
        "id": 153821361,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460498234
    },
    {
        "content": "<p>The simplest implementation is to just require that units be respected. A more sophisticated implementation could do conversion where possible.</p>",
        "id": 153821363,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460499337
    },
    {
        "content": "<p>For date/time arithmetic, it's fairly straightforward, and I imagine most implementations would just pass through to an underlying library to perform the computation.</p>",
        "id": 153821364,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460499379
    },
    {
        "content": "<p>For quantity arithmetic, the implementation just needs to ensure that if the values have units, they're the same, or it's an error.</p>",
        "id": 153821365,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460499404
    },
    {
        "content": "<p>well, which units? we should use ucum units if we're going to have a simple form</p>",
        "id": 153821366,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460499432
    },
    {
        "content": "<p>Yeah, the expectation is UCUM units.</p>",
        "id": 153821367,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460499453
    },
    {
        "content": "<p>that's not what you said above</p>",
        "id": 153821370,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460502822
    },
    {
        "content": "<p>and I don't understand how that's not grammatically ambiguous</p>",
        "id": 153821371,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460502869
    },
    {
        "content": "<p>For the date/time precisions specifically, CQL defines keywords that are synonyms for the UCUM date/time precision.</p>",
        "id": 153821396,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460511395
    },
    {
        "content": "<p>As far as ambiguity, there's no other context where an expression is allowed to be followed by a literal like that. It requires lookahead, but I don't think it's ambiguous.</p>",
        "id": 153821397,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1460511736
    },
    {
        "content": "<p>regrding ambiguity, some ucum codes are ambiguous - e.g. *10</p>",
        "id": 153821408,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460527424
    },
    {
        "content": "<p>So, still working on fluent path quallity....</p>",
        "id": 153822732,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461245937
    },
    {
        "content": "<p>Lloyd has this series of constraints on Questionnaire Extensions:</p>",
        "id": 153822733,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461246041
    },
    {
        "content": "<div class=\"codehilite\"><pre>valueInteger = 0 or $parent.required\nvalueInteger &lt;= 1 or $parent.repeats\n$parent.type!=&#39;display&#39;\n$parent.type!=&#39;display&#39;\n$parent.type=&#39;choice&#39; or $parent.type=&#39;open-choice&#39;\n$parent.type=&#39;choice&#39; or $parent.type=&#39;open-choice&#39;\n$parent.type!=&#39;display&#39;\n$parent.type=&#39;reference&#39;\n$parent.type=&#39;display&#39;\n$parent.type=&#39;reference&#39;\n$parent.type!=&#39;display&#39;\n$parent.type=&#39;reference&#39;\n$parent.type=&#39;integer&#39; or $parent.type=&#39;decimal&#39;\n$parent.type=&#39;integer&#39; or $parent.type=&#39;decimal&#39;\n</pre></div>",
        "id": 153822734,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461246044
    },
    {
        "content": "<p>these are all illegal, and not implementable under the current spec </p>",
        "id": 153822735,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461246071
    },
    {
        "content": "<p>it's not obvious to me how this should be resolved</p>",
        "id": 153822736,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461246087
    },
    {
        "content": "<p>So the general use-case is the need to be able to make assertions about the context in which an extension is allowed to appear</p>",
        "id": 153822740,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1461246460
    },
    {
        "content": "<p>Can they be expressed on the parent node in terms of the children instead of on the children in terms of the parent?</p>",
        "id": 153822744,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461247845
    },
    {
        "content": "<p>No because their defined on the extension - and are trying to further constrain the type of node they're allowed to appear on.</p>",
        "id": 153822750,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1461249424
    },
    {
        "content": "<p>I see, so it's a context invariant. The validation is already doing that with extensions, so it seems like it would work if we had a way to say 'this is a context invariant, evaluate it in terms of the container to which the extension is being applied', rather than 'this is an invariant, evaluate it in terms of the extension'.</p>",
        "id": 153822753,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461249756
    },
    {
        "content": "<p>I think that makes sense</p>",
        "id": 153822766,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461268904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> : according to fluentpath, .length() can only be used for strings. but we have constraints on date lengths - lots of them - and you could imagine lengths being imposed for decimals and integers in some cases. so I think length() should be applicable to primitives, not strings </p>",
        "id": 153822809,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461277605
    },
    {
        "content": "<p>and do uris, codes, etc count as strings? avoid that question....</p>",
        "id": 153822810,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461277621
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  So for length constraints on decimals and integers, why not express it as a value constraint? value between 1 and 1000, e.g.</p>",
        "id": 153822843,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461335170
    },
    {
        "content": "<p>for length constraints on date/times, wouldn't it be better to express it in terms of precision? (i.e. what does date.length() &lt; 4 mean?)</p>",
        "id": 153822845,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461335234
    },
    {
        "content": "<p>And for uris, codes, yes, I think those are treated as strings. In the CQL implementation, I'm defining implicit conversions from the FluentPath/CQL primitives to the FHIR types, that should make it totally transparent to the user.</p>",
        "id": 153822846,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461335312
    },
    {
        "content": "<p>Sometimes you want to enforce a pure length.  So \"-50\" and \"100\" and \"2.3\" all have a length of \"3\".  That said, that's a fairly low frequency use-case.</p>",
        "id": 153822849,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1461335878
    },
    {
        "content": "<p>I think in that case, you could always do a value.toString().length() = 3</p>",
        "id": 153822852,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461336612
    },
    {
        "content": "<p>That works for me</p>",
        "id": 153822866,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1461344458
    },
    {
        "content": "<p>well, ok, we could consider something more direct in terms of dates. Precision of dates is particularly frequent thing in constraints. </p>",
        "id": 153822870,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461353352
    },
    {
        "content": "<p>but what would that look like?</p>",
        "id": 153822871,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461353359
    },
    {
        "content": "<p>Bryn - I didn't join the ballot pool for FluentPath - can you submit all my comments?</p>",
        "id": 153822981,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461610133
    },
    {
        "content": "<p>Sure, I've tracked them, I'll get them submitted.</p>",
        "id": 153823188,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461689163
    },
    {
        "content": "<p>Regarding the constraints on date precision, within CQL, we would say:</p>",
        "id": 153823189,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461689446
    },
    {
        "content": "<p>month from DatetimeValue is null</p>",
        "id": 153823190,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461689456
    },
    {
        "content": "<p>To enforce that a date/time could only be specified to a year, for example.</p>",
        "id": 153823191,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461689475
    },
    {
        "content": "<p>I imagine the FluentPath for that would look like:</p>",
        "id": 153823192,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461689487
    },
    {
        "content": "<p>DateTimeValue.month().isNull()</p>",
        "id": 153823193,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461689495
    },
    {
        "content": "<p>.exists(). but we haven't defined a date time that works like that.</p>",
        "id": 153823195,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461690443
    },
    {
        "content": "<p>it's a lot harder to convert to real world constraints like XPath too</p>",
        "id": 153823196,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461690468
    },
    {
        "content": "<p>So, I missed most of this thread because I must have misclicked in Zulip and it was all marked as read :-(</p>\n<blockquote>\n<p>That was my understanding, it would only be available within the iterators.</p>\n</blockquote>\n<p>I think what is the matter is that in some functions we're not passing VALUES as parameters (like the length into the substring() function), but we're passing functions as parameters, which are lazyly evaluated at the right moment by the function that is called. So, what happens with all() and any() is not that they are iterators, it's that they are functions that are passed (anonymous) functions (or in FP expressions that are lazily evaluated).</p>\n<p>So, internally, in my AST after parsing, these functions receive a parameter that's a lambda expression, with $this as the single parameter. That would be compatible with just allowing $this in these iterators (though currently, $this works everywhere in the expressions on .NET)</p>",
        "id": 153823375,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461764657
    },
    {
        "content": "<p>but it's not definable what $this actually is in any other case</p>",
        "id": 153823376,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461764704
    },
    {
        "content": "<p>Informally, it's the outcome of the last statement before the \".\" invocation. Even if we would not allow it everywhere, it's present everywhere. I have assumed that:</p>\n<p>Patient.name.substring(length()-4,2) is actually Patient.name.substring($this.length()-4,2).  Isn't that equivalent?  So you need to have $this available everywhere anyway?</p>",
        "id": 153823377,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461764905
    },
    {
        "content": "<p>I could only read Patient.name.substring(length()-4,2) to mean that length refers to the collection of names from <a href=\"http://Patient.name\" target=\"_blank\" title=\"http://Patient.name\">Patient.name</a></p>",
        "id": 153823379,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461764979
    },
    {
        "content": "<p>Right. Which in my interpretation means $this refers to the collection of names from <a href=\"http://Patient.name\" target=\"_blank\" title=\"http://Patient.name\">Patient.name</a>.  Removing $this means removing the possibility for the user to refer back to that resultset. Why would we do that?</p>",
        "id": 153823380,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461765555
    },
    {
        "content": "<p>I don't understand. allowing $this implies that there's some other choice</p>",
        "id": 153823381,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461765611
    },
    {
        "content": "<p>and, in fact, that's how I found it being used</p>",
        "id": 153823382,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461765620
    },
    {
        "content": "<p>trying to refer a step further back</p>",
        "id": 153823383,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461765652
    },
    {
        "content": "<blockquote>\n<p>Yeah I see that's special case code because of the way the FluentPath grammar is built then.</p>\n</blockquote>\n<p>It's turned into a separate AST node type indeed, since it's so special. I was reassured when I saw the .NET LINQ compiler treats these kind of nodes as a special case as well: <a href=\"https://msdn.microsoft.com/en-us/library/system.linq.expressions.typebinaryexpression(v=vs.110).aspx\" target=\"_blank\" title=\"https://msdn.microsoft.com/en-us/library/system.linq.expressions.typebinaryexpression(v=vs.110).aspx\">https://msdn.microsoft.com/en-us/library/system.linq.expressions.typebinaryexpression(v=vs.110).aspx</a></p>",
        "id": 153823384,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461765716
    },
    {
        "content": "<p>(from the doc: TypeBinaryExpression Represents an operation between an expression and a type)</p>",
        "id": 153823385,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461765747
    },
    {
        "content": "<blockquote>\n<p>Grahame Grieve: I don't like the way all() is defined.<br>\nGrahame Grieve: it should take a criteria - does all this collection meet this criteria?</p>\n</blockquote>\n<p>Agree. I thought it was defined that way, I even put an example in the text that suggest it does ;-)</p>",
        "id": 153823387,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461766031
    },
    {
        "content": "<p>yeah. Bryn defined it differently, but I just treated it as if it took a criteria throughout the FHIR invariants</p>",
        "id": 153823388,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461766068
    },
    {
        "content": "<blockquote>\n<p>Regarding '12345'.startsWith(''), startsWith is usually defined in terms of a substring of the same length, which means startsWith('') would return true.</p>\n</blockquote>\n<p>For what it's worth, the .NET StartsWith() function would return 'true' in this case.</p>",
        "id": 153823389,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461766132
    },
    {
        "content": "<blockquote>\n<p>I think I need to bring back &amp; operator</p>\n</blockquote>\n<p>So, this would the first case where an operator does NOT propagate empty..I worry that this would be a source of confusion, though I do understand why you'd do it.  Maybe coalesce() would be a better option.</p>",
        "id": 153823390,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461766398
    },
    {
        "content": "<p>that just moves the deck chairs </p>",
        "id": 153823391,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461766425
    },
    {
        "content": "<p>but no, it's not about propgating empty - I don't use it on {}  and expect to get anything but {}</p>",
        "id": 153823392,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461766453
    },
    {
        "content": "<p>But it is about propagating empty. We've defined ALL our operators to propagate empty:  3+{}={}, \"adfadfs\" + {} = {}.  Now we want \"asdfadf\" + {} = \"asdfadf\".  So the new &amp; would NOT propagate empty anymore. Or would convert empty to '' automatically if you want. I think that is confusing.</p>",
        "id": 153823393,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461766612
    },
    {
        "content": "<p>well, ok. but it's absolutely what is needed - to swallow nothing into nothing in the string. You might tihnk it's confusing, but try writing an expression without it - stringing your iif()s together... yuck</p>",
        "id": 153823396,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461767052
    },
    {
        "content": "<p>Ah the joys of timezones.<br>\nWe added the today/now expression in fluentpath (great).<br>\nMy new question is how do we communicate the intended timezone for evaluation?<br>\nThe expected answer is \"the person who is calling the operation\"<br>\nBut what about when the server and client are in different timezones, how is this offset handled? Can we have a standard way to communicate this to the Evaluation engines?<br>\nSet of parameters that can be provided to the evaluator for execution.</p>",
        "id": 153823506,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461793735
    },
    {
        "content": "<p>Brian can you explain to me what the intended timezone for evaluation is? Is that the preferred timezone the datetimes are expressed in?  As longs as each of the instances of dateTime's has a timezone when the hour component is there, what's the use of passing in the \"actual\" timezone?</p>",
        "id": 153823524,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1461810544
    },
    {
        "content": "<p>the today or now functions.</p>",
        "id": 153823527,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461814218
    },
    {
        "content": "<p>rest of them, yes you're right.</p>",
        "id": 153823528,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461814230
    },
    {
        "content": "<p>actually, really only today.</p>",
        "id": 153823529,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461814282
    },
    {
        "content": "<p>comparisons should be ok where there are all timezones. But when only considering the date part, the timezone is important.</p>",
        "id": 153823530,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461814310
    },
    {
        "content": "<p>no I don't follow</p>",
        "id": 153823551,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461824377
    },
    {
        "content": "<p>consider a fhirpath validation rule that says <br>\n<code>Appointment.Start &gt;= today()</code></p>",
        "id": 153823553,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461824540
    },
    {
        "content": "<p>today evaluates to <code>28 April 2016</code> (here in australia) but in USA this might evaulate to <code>27 April 2016</code> and thus rule will fail.</p>",
        "id": 153823555,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461824589
    },
    {
        "content": "<p>So the zone where  the evaluation of the rule occurs makes a difference here.</p>",
        "id": 153823557,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461824645
    },
    {
        "content": "<p>(This is basically the rule that we have failing)</p>",
        "id": 153823559,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461824657
    },
    {
        "content": "<p>this is a question about your pre-conditions. If you're actually running this about Australia, then that's correct. </p>",
        "id": 153823561,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461824746
    },
    {
        "content": "<p>Our deployment is Server in Melbourne, clients in Adelaide and Perth. So part of the day has issues submitting forms.</p>",
        "id": 153823563,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461824802
    },
    {
        "content": "<p>well, you can't make a rule that's so simple as appointment.start &gt; today - the rule itself lacks expressivity</p>",
        "id": 153823564,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461824841
    },
    {
        "content": "<p>appointment.start.universal() &gt;= today().universal()</p>",
        "id": 153823565,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461824872
    },
    {
        "content": "<p>(in the case I'm working with both properties are dates)</p>",
        "id": 153823571,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461825546
    },
    {
        "content": "<p>In the questionnaire</p>",
        "id": 153823572,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461825570
    },
    {
        "content": "<p>so?</p>",
        "id": 153823573,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461825663
    },
    {
        "content": "<p>The complete rule that I can't express is<br>\n<code>today() &lt; date1 &lt; date2 &lt; today().add(6, months)</code></p>",
        "id": 153823574,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461825685
    },
    {
        "content": "<p>why can't you express that? </p>",
        "id": 153823575,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461825709
    },
    {
        "content": "<p>Can't add the months part at the end, and the timezone issue with evaulating today()</p>",
        "id": 153823576,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461825733
    },
    {
        "content": "<p>apart from that, is ok.</p>",
        "id": 153823577,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461825746
    },
    {
        "content": "<p>well, the general issue is: need date and time functions on the date/time class</p>",
        "id": 153823578,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461825778
    },
    {
        "content": "<p>yes, and the zone for evaluating today, and I'd be happy</p>",
        "id": 153823579,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461825807
    },
    {
        "content": "<p>I don't follow about the timezone for today bit, What's that got to do with the expression?</p>",
        "id": 153823580,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461826036
    },
    {
        "content": "<p>if the execution is done in a different timezone to the client, then the value may be different</p>",
        "id": 153823581,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461826467
    },
    {
        "content": "<p>what's that got to do with the expresssion?</p>",
        "id": 153823582,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461826490
    },
    {
        "content": "<p>Expression is correct.</p>",
        "id": 153823583,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461826503
    },
    {
        "content": "<p>evaluation isnt</p>",
        "id": 153823584,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461826560
    },
    {
        "content": "<p>Interesting. We had this same discussion in IHE yesterday related to XDS submission/queries.<br>\nHow do I find encounters handled by the night shift (not necessarily during my night, but during the night where it occured)? Documents submitted in the morning? The TZ offset at the querying client isn't necessarily the same as the offset at the server, or the offset at the system that submitted the resource. And, the time zone in effect at any of those today, isn't necessarily the same as the offset in effect when the resource was submitted.</p>",
        "id": 153823604,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1461867586
    },
    {
        "content": "<p>Has also found a bug in the dotnet fluentpath implementation...<br>\nWe cache the execution tree to reduce the amount of re-parses are required.<br>\nAnd then the first execution turns the today() into the value, and is not exectuted again, even when the value changes - which is worse when implementing the now() function.</p>",
        "id": 153823696,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461903333
    },
    {
        "content": "<p>So, in the CQL definitions of Today() and Now(), we define them to return the same value for a given \"evaluation\", and we define them to return based on the \"evaluation request time\", which is left somewhat open, but would typically be tied to the request date time (or an \"evaluateAsOf\" parameter if you wanted to support evaluation as of a certain point in time).</p>",
        "id": 153823699,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461904564
    },
    {
        "content": "<p>This way the engine can support caching within any given evaluation, but not across them, and the expression result is guaranteed to be deterministic.</p>",
        "id": 153823700,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461904620
    },
    {
        "content": "<p>Question to others that are implementing and/or testing this.<br>\nShould these 2 expressions parse and evaluate correctly?<br>\n<code>1 &lt; 2</code><br>\n<code>1 &lt; -2</code><br>\n<code>+1 &lt; +2</code></p>",
        "id": 153823899,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461976230
    },
    {
        "content": "<p>The dotnet fluentpath evaluator doesn't handle the inclusion of the negative (or positive)</p>",
        "id": 153823900,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461976266
    },
    {
        "content": "<p>or this one<br>\n<code>-1&lt;2</code></p>",
        "id": 153823901,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461976344
    },
    {
        "content": "<p>the notepad++ fhir addin really doesn't like these either.</p>",
        "id": 153823902,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461976505
    },
    {
        "content": "<p>The FluentPath grammar supports them, and the CQL/FluentPath translator I'm working on handles them, but I don't think the other implementations are using the generated Antlr visitors. And IIRC, the initial FhirPath used to treat unary negation as part of the number literal rather than as a separate syntax, so that could be holdover behavior.</p>",
        "id": 153823903,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1461977062
    },
    {
        "content": "<p>the notepad++ plug-in should accept them. I'll add tests for them. I would have thought that negation is ok but not +</p>",
        "id": 153823907,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461977649
    },
    {
        "content": "<p>I wouldn't be fussed by the absense of the +<br>\nI found it testing an implementation of an experimental dateadd('mm', -6) function with the dotnet client</p>",
        "id": 153823911,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461978230
    },
    {
        "content": "<p>fixed in both the java and pascal implemnetations. will release updates to notepad++ and my server soon</p>",
        "id": 153823912,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1461978650
    },
    {
        "content": "<p>Thanks Grahame, I'll look forward to testing it out.</p>",
        "id": 153823917,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1461978737
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span>  is it too late to add ballot comments on fluentpath? </p>",
        "id": 153824091,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462155919
    },
    {
        "content": "<p>Close is tomorrow, so shouldn't be</p>",
        "id": 153824100,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1462157217
    },
    {
        "content": "<p>Hi Grahame, nope, if you get them to me now I can still add them in.</p>",
        "id": 153824107,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1462158106
    },
    {
        "content": "<p>2 FHIR specific additions:<br>\n - we need a concise way to say 'no modifier extensions except for these ones'. Right now I'm not sure how I'd actually do that one<br>\n- we need a .slice(structure, name) operation that allows an author to select a particular slice as defined in the referenced structure definition</p>",
        "id": 153824108,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462158277
    },
    {
        "content": "<p>Captured.</p>",
        "id": 153824112,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1462159604
    },
    {
        "content": "<p>thanks</p>",
        "id": 153824123,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462171084
    },
    {
        "content": "<p>I'd also like to propose a date based function \"dateadd\" that takes 2 parameters<br>\n1. datepart (yy, mm, dd, hh, mi, ss) as a string (happy if other literals are used, pulled these from TSQL)<br>\n2. value (the number of units to add to that part of the date) </p>\n<p>This will then permit the creation of an invariant like:<br>\nvalueDate &lt; today().dateadd(\"mm\", 6)<br>\nTo cover a business rule for things like must be reviewed within 6 months.</p>",
        "id": 153824127,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1462171488
    },
    {
        "content": "<p>we've got - generally - the need for date operations/operators in the ballot comments</p>",
        "id": 153824128,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462171544
    },
    {
        "content": "<p>Just wanted to be sure someone had put in a ballot comment for it.</p>",
        "id": 153824130,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1462171632
    },
    {
        "content": "<p>The above is what I have put in as an experimental while I wait for an official function.</p>",
        "id": 153824131,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1462171658
    },
    {
        "content": "<p>The FP for <code>Patient:deceased</code> seems decidedly wrong: <code>Patient.deceased.exists()</code> since this returns <code>true</code> if the value of Patient.deceased is <code>false</code></p>\n<p>What's the right way to report this? Tracker?</p>",
        "id": 153824160,
        "sender_full_name": "James Agnew",
        "timestamp": 1462202402
    },
    {
        "content": "<p>Hmm, I could swear I posted in this topic already. What's going on here? Oh well, take two.. From the latest SVN trunk:</p>\n<p>Patient:deceased specifies the path <code>Patient.deceased.exists()</code> which seems wrong, since it will evaluate to <code>true</code> if the patient has a populated  value of <code>false</code></p>\n<p>Practitioner:phone specifies the path <code>Practitioner.telecom.where(system='email') or Practitioner.practitionerRole.telecom.where(system='email')</code>, which evaluates to a boolean instead of two separate expressions. Should that <code>or</code> be a <code>|</code> like other \"joined\" expressions use?</p>",
        "id": 153824167,
        "sender_full_name": "James Agnew",
        "timestamp": 1462212579
    },
    {
        "content": "<p>oh... now both posts are here. sorry, Zulip is being flaky on me.</p>",
        "id": 153824168,
        "sender_full_name": "James Agnew",
        "timestamp": 1462213153
    },
    {
        "content": "<p>\"The FP for Patient:deceased \" - what FP? invariant? index? </p>",
        "id": 153824169,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462213446
    },
    {
        "content": "<p>yes the second should be |</p>",
        "id": 153824170,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462213470
    },
    {
        "content": "<p>Oh sorry, for <code>deceased</code> search parameter</p>",
        "id": 153824183,
        "sender_full_name": "James Agnew",
        "timestamp": 1462219279
    },
    {
        "content": "<p>The problem of course being that with the way that FP is written, a search for <code>Patient?deceased=true</code> will match any patient that has a value for Patient.deceased, whether that value is true or false.</p>",
        "id": 153824184,
        "sender_full_name": "James Agnew",
        "timestamp": 1462219533
    },
    {
        "content": "<p>yes that is wrong</p>",
        "id": 153824188,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462221387
    },
    {
        "content": "<p>Would these require a tracker item, or can I just fix them?</p>",
        "id": 153824198,
        "sender_full_name": "James Agnew",
        "timestamp": 1462226369
    },
    {
        "content": "<p>I think you can just fix them and use tracker....</p>",
        "id": 153824211,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462228113
    },
    {
        "content": "<p>nah can't find it</p>",
        "id": 153824215,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462228248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> the comment we have so far is to add +(DateTime, Quantity), -(DateTime, Quantity), +(Time, Quantity) and -(Time, Quantity).</p>",
        "id": 153824275,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1462229108
    },
    {
        "content": "<p>So for your example that would look like valueDate &lt; today().add(6 'mo')</p>",
        "id": 153824277,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1462229196
    },
    {
        "content": "<p>as long as the quantity can be defined/described to cover each of the components in the date, then all good.</p>",
        "id": 153824288,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1462230534
    },
    {
        "content": "<p>(You can tag me as someone interested in that ballot item if there's a way to do that too)</p>",
        "id": 153824289,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1462230582
    },
    {
        "content": "<p>sub-topic: reflection in fluent path</p>",
        "id": 153824930,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462612784
    },
    {
        "content": "<p>one of the issues in the fluent path ballot is that we need to be able to access the definitions of the element in an expression</p>",
        "id": 153824931,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462612833
    },
    {
        "content": "<p>in FHIR, the idea is that you'd do something like:</p>\n<p>Observation.value.definition().max - .definition() would return a handle to an ElementDefinition, which you can navigate like any other object. </p>",
        "id": 153824932,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462612898
    },
    {
        "content": "<p>I'm not sure what you'd get from .definition in non-FHIR contexts </p>",
        "id": 153824933,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462612918
    },
    {
        "content": "<p>but the really interesting thing you want to do here is reason from the semantics in the definition - say, Snomed CT mappings. And to do this in a cross-profile way. E.g. you could define a base (explicit) profile that defines a constraint, and have the constraint refer to a definition that's found in a dictionary rather than an explicit profile (see the  HSPC lab profile for an example of this)</p>",
        "id": 153824934,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462613025
    },
    {
        "content": "<p>so the natural question that follows is, .definition() refers to the base definition of the spec, but that's not the really useful definition to get hold of. I want the one of the definitions in one of the applicable profiles... but how do I ask for that?</p>",
        "id": 153824935,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462613099
    },
    {
        "content": "<p>Maybe the \"as\" operator should take a url, so you can \"cast\" to a specific profile....</p>",
        "id": 153825491,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1462714399
    },
    {
        "content": "<p>By the way, I see this in a lot of examples:</p>\n<p><code>Patient.name.empty().not()</code></p>\n<p>There is however a short-cut in the current version of FP:</p>\n<p><code>Patient.name.exists()</code></p>",
        "id": 153825492,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1462714458
    },
    {
        "content": "<p>where do these come from? I thought I want through and replaced all of those</p>",
        "id": 153825495,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462714524
    },
    {
        "content": "<p>I saw them in an example you showed yesterday, but I also see others use this on the Zulip chats... (so it was not specifically about the fp's in the spec)</p>",
        "id": 153825500,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1462714575
    },
    {
        "content": "<p>ok</p>",
        "id": 153825501,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462714593
    },
    {
        "content": "<p>From <a href=\"http://hl7-fhir.github.io/fluentpath\" target=\"_blank\" title=\"http://hl7-fhir.github.io/fluentpath\">http://hl7-fhir.github.io/fluentpath</a></p>\n<blockquote>\n<p>Patient.contained.all($this is Patient implies age &gt; 10)</p>\n</blockquote>\n<p>Is <code>age</code> a thing?</p>",
        "id": 153827331,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1463066577
    },
    {
        "content": "<blockquote>\n<p>repeat(projection: expression) : collection</p>\n</blockquote>\n<p>Does repeat here  mean something like \"recurse\" (i.e. repeat the procedure on its own output)?</p>",
        "id": 153827336,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1463066904
    },
    {
        "content": "<p>age is not a thing. where did you get that from? </p>",
        "id": 153827338,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463067003
    },
    {
        "content": "<p>and yes, that's what it means</p>",
        "id": 153827339,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463067008
    },
    {
        "content": "<p>I got that from the URL I cited before my quotation :p</p>",
        "id": 153827340,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1463067033
    },
    {
        "content": "<p>Does fluentpath express data math enough to say \"Patients over 20 years old\"? I assume yes but I couldn't figure out how.</p>",
        "id": 153827341,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1463067062
    },
    {
        "content": "<p><code>now()</code> seems useful... but without date subtraction I can't put it together.</p>",
        "id": 153827343,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1463067076
    },
    {
        "content": "<p>not right now - ballot comment that we need date operations, and then the answer will be yes</p>",
        "id": 153827345,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463067131
    },
    {
        "content": "<p>adding.</p>",
        "id": 153827346,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1463067140
    },
    {
        "content": "<p>This is an example Bryn added, so I guess this is something that's there in the CQM, but not in FHIR. Remember, the examples are not necessarily FHIR anymore ;-)</p>",
        "id": 153827627,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1463099202
    },
    {
        "content": "<p>That's not a great answer for whatever documentation is published <strong>in the FHIR build </strong>. </p>",
        "id": 153827632,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1463104386
    },
    {
        "content": "<p>Yeah. I have to get used to that myself too. But that's also the reason for the name change (no more FHIR in the name).</p>\n<p>As to publishing, what's the alternative? We've thought a bit about that at HIMSS...an external website with a publishing cycle not connected to the FHIR spec would be one option.</p>",
        "id": 153827640,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1463107120
    },
    {
        "content": "<p>we already noted the date addition logic</p>",
        "id": 153827659,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1463113715
    },
    {
        "content": "<p>Sorry, that was simple manipulation, not diffs of dates (which can return a timespan)</p>",
        "id": 153827660,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1463113870
    },
    {
        "content": "<p>well, we have to sort out the publication issue</p>",
        "id": 153827669,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463125990
    },
    {
        "content": "<p>Is the XHTML accessable from within fluentpath?  I'm trying to figure out how to write a constraint that says \"narrative must be a single string node with no mark-up\"</p>",
        "id": 153830432,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1464562300
    },
    {
        "content": "<p>we haven't said anything about this, but there's no object model for xhtml, and I'm not keen to make one up.  This constraint would be easy if we said the xhtml was a string, and you could use a regex (.matches())</p>",
        "id": 153830435,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464563060
    },
    {
        "content": "<p>So a regex that prohibited tags greater-than?  That might work here.  It's not going to work well for other use-cases we'd talked about, for example \"this element needs to appear in the third row of the first table\".  There are lots of use-cases for wanting to have fairly strict control over what the narrative looks like.  I'd hate to have that go away in the transition from xpath to fluentpath.  When you say there's no object model, why not?  We have a schema.  My impression was that fluentpath would work for anything you could express by schema.</p>",
        "id": 153830441,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1464564807
    },
    {
        "content": "<p>schema is not quite the same as object model because of... you guessed it.... mixed content</p>",
        "id": 153830443,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464565829
    },
    {
        "content": "<p>Mixed content isn't really an issue.  That's just a \"text node\".  My guess is what really causes grief is there are some parts that are non-ordered - you can specify repeating properties interspersed with other properties.</p>",
        "id": 153830444,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1464566330
    },
    {
        "content": "<p>Following up on the discussion about reflection in FluentPath, I think the use of .as() to get at the profile information is the right approach, but what structure should be returned in non-FHIR contexts? The documentation says FluentPath works on a \"MOF-equivalent type system\", so in general we would need to expose a structure that provided that information, yes? </p>",
        "id": 153831840,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1465227825
    },
    {
        "content": "<p>CQL has a generic \"model info\" structure that supports this, it's just a simple exposure of classes, could we use that in the general case and then for FHIR specifically, provide a way to access the elementDefinition using the proposed .definition() operator?</p>",
        "id": 153831841,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1465227904
    },
    {
        "content": "<p>Looking to check if my understanding of using fluentpath with extensions is correct (and I'm not missing something)<br>\n<code>Patient.extension.where(url='http://hl7.org/fhir/StructureDefinition/patient-mothersMaidenName').valueString</code></p>\n<p>Is how I should read the Mothers maiden name for a patient in a fluentpath expression (for a custom search parameter)</p>",
        "id": 153833718,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1466401122
    },
    {
        "content": "<p>yes, but there's a short cut in the FHIR appendix:</p>",
        "id": 153833723,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466403579
    },
    {
        "content": "<div class=\"codehilite\"><pre>Patient.extension(&#39;http://hl7.org/fhir/StructureDefinition/patient-mothersMaidenName&#39;).value\n</pre></div>",
        "id": 153833724,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466403599
    },
    {
        "content": "<p>actually, your first bit was wrong - it's value, not valueString</p>",
        "id": 153833725,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466403612
    },
    {
        "content": "<p>And it will work out that it needs to skip the valueString part, and go to @value<br>\nxpath fhir:extension[@url='...']/fhir:valueString/@value</p>",
        "id": 153833726,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1466403723
    },
    {
        "content": "<p>Is that defined in fluentpath, or the localized fhir version?<br>\nThat's pretty fhir specific.</p>",
        "id": 153833727,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1466403759
    },
    {
        "content": "<p>yes, the @value is implicit. The String itself is the value. Think about the json alternative...</p>",
        "id": 153833731,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466403837
    },
    {
        "content": "<p>Still seems kinda fhir specific. (happy with that, but appears like a fhir localization)</p>",
        "id": 153833735,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1466404336
    },
    {
        "content": "<p>which bit? the extension() bit is for sure </p>",
        "id": 153833742,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466405280
    },
    {
        "content": "<p>it's documented as a FHIR specific thing</p>",
        "id": 153833743,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466405301
    },
    {
        "content": "<p>Thanks, will recheck.</p>",
        "id": 153833745,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1466405384
    },
    {
        "content": "<p>does this mean that extension is a reserved word in the fluentpath for fhir?<br>\nand thus the syntax/format that I used wouldn't work (as extension is a reserved word)?</p>",
        "id": 153833778,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1466429500
    },
    {
        "content": "<p>.extension() is different to .extension</p>",
        "id": 153833836,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1466461809
    },
    {
        "content": "<p>Question about the fluentpath invariant sdf-12.</p>\n<p>Currently it is written as <code>snapshot.element.base implies baseType</code></p>\n<p>Believe it should say <code>snapshot.element.select(base) implies baseType</code></p>\n<p>Can any of the fluentpath experts chime in?</p>",
        "id": 153835874,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1467290825
    },
    {
        "content": "<p>Those should both work to enforce that invariant, if there are base elements, then there must be a baseType. The first one will give a list of base elements, the second one will give a list of list of base elements, either way, interpreting that list as a boolean is effectively an exists.</p>",
        "id": 153835881,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1467293340
    },
    {
        "content": "<p>The fluentpath expression <code>today().toString().length() = 10</code> that is in the unit tests uses toString on a date. The toString defined here <code>http://hl7-fhir.github.io/fluentpath.html#1.32.4.4</code> doesn't say what to do with dates.</p>",
        "id": 153836419,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1467723355
    },
    {
        "content": "<p>they have an innate string representation</p>",
        "id": 153836420,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1467723495
    },
    {
        "content": "<p>given the others were explicitly called out what to do for them, should it also be explicitly stated?</p>",
        "id": 153836422,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1467723831
    },
    {
        "content": "<p>(Yes, I've updated it to return the string representation too)</p>",
        "id": 153836423,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1467723850
    },
    {
        "content": "<p>One more query language with implementation: <a href=\"https://stedolan.github.io/jq/manual/\" target=\"_blank\" title=\"https://stedolan.github.io/jq/manual/\">https://stedolan.github.io/jq/manual/</a>.</p>",
        "id": 153847136,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1473721583
    },
    {
        "content": "<div class=\"codehilite\"><pre>curl http://spark.furore.com/fhir/Patient?_format=json | jq &#39;.entry[].resource| {lastName: .name[0].family[0], firstName: .name[0].given[0], id: .id}&#39;\n</pre></div>",
        "id": 153847139,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1473722232
    }
]