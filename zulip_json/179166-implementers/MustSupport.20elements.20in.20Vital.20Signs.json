[
    {
        "content": "<p>In our project we use a derived profile. This profile is based on Vital Signs from HL7. The Vital Sign profile contains 'MustSupport' elements and according to the guidelines you must indicate what this means exactly. This is not specified in the Vital Signs profile and we wonder if is this specified somewhere?</p>\n<p>MustSupport page: <a href=\"https://hl7.org/fhir/STU3/profiling.html#mustsupport\">https://hl7.org/fhir/STU3/profiling.html#mustsupport</a></p>\n<p>Derived profile: <a href=\"https://simplifier.net/NictizSTU3-Zib2017/zib-VitalSigns\">https://simplifier.net/NictizSTU3-Zib2017/zib-VitalSigns</a></p>\n<p>Base resource: <a href=\"https://hl7.org/fhir/STU3/vitalsigns.html\">https://hl7.org/fhir/STU3/vitalsigns.html</a></p>",
        "id": 224178095,
        "sender_full_name": "Ashwin Djorai",
        "timestamp": 1611753176
    },
    {
        "content": "<p>The summary tab of vital sign profile has some information</p>",
        "id": 224187105,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1611757334
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308644\">@Ashwin Djorai</span>  you are correct,  must supports  are defined in implementation guides not on the base specification.   I think there is a tracker to fix this for FHIR R5.  The latest draft version of USCORE vital signs  is derived from them and defines what it means.</p>",
        "id": 224190000,
        "sender_full_name": "Eric Haas",
        "timestamp": 1611758459
    },
    {
        "content": "<p>The Nictiz project (author of the derived profile mentioned above) also has documented what they mean by MustSupport.</p>",
        "id": 224191559,
        "sender_full_name": "René Spronk",
        "timestamp": 1611759073
    },
    {
        "content": "<p>The vital signs profiles are defined in the core spec and declare mustSupport there - therefore the meaning of mustSupport <em>must</em> be defined in the core spec.</p>",
        "id": 224196556,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1611760980
    },
    {
        "content": "<p>They are not. and \"The meaning of \"support\" is not defined by the base FHIR specification, \"  So  are these profiles not part of the core spec?  I authored these profiles a while back a was not careful with regards to making a bunch of element must support.  Surprisingly no one objected (until recently), most folks were focusing on why we used LOINC which probably distracted them from this issue.   I were to author the profiles today, my leaning would be not have MS tags at all.</p>",
        "id": 224217561,
        "sender_full_name": "Eric Haas",
        "timestamp": 1611769006
    },
    {
        "content": "<p>I think having MS is reasonable.  Having Observation.value is 0..1.  Not flagging and saying that it must be supported - and sending narrative only or some extension instead with just a string or something isn't sufficient is reasonable (and necessary if we want base computable interoperability).  The mustSupport expectation documentation should be relatively light - and allow for a variety of uses, including systems that don't care about value at all.  Key thing is that if you want data that would typically appear in value and you're sending, you must express the value data you have in that element and if receiving, you must be capable of extracting the value data you need from that element.</p>",
        "id": 224269099,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1611793612
    },
    {
        "content": "<p>I think I created the task to remove MS from the core profiles, but I'm ok if they are retained with an explanation, though this will require minor wording changes elsewhere in the specification (where must-support is defined and documentated)</p>",
        "id": 224942898,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612303003
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> can you provide a link to the tracker? I have done some searching but can't find it. We can then see if we can pre-adopt the change in our STU3 profiles.</p>",
        "id": 225276003,
        "sender_full_name": "Niek van Galen",
        "timestamp": 1612516929
    },
    {
        "content": "<p>I'm not in favor of removing MS in the profiles, but I'm certainly happy for us to clarify what it means</p>",
        "id": 225310031,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612537798
    },
    {
        "content": "<p>apparently I did not. So #J30934</p>",
        "id": 225345396,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612553528
    },
    {
        "content": "<p><a href=\"http://jira.hl7.org/browse/FHIR-30934\">J#30934</a></p>",
        "id": 225347471,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612554519
    },
    {
        "content": "<p>In considering the meaning of MS, I think it is helpful to consider that MS flag on an element does not necessarily mean the element must be implemented. Separate the \"Obligation to Implement\" (OTI) from the appearance of a MS flag (MS). There is not a 1-to-1 relationship and when people say \"interpretation of MS\" they might be talking about what must be implemented, and _assuming_ the MS flag means the same as OTI.</p>\n<p>Let me explain by giving some examples -- some of which may be hard to understand or controversial:</p>\n<ul>\n<li>Profiles with top-level MS flags are OTI. Implementation of other profiles is elective.</li>\n<li>If a profile is not implemented, then none of the elements of that profile must be implemented, regardless of MS flags in that profile.</li>\n<li>An element with an MS flag is OTI if it is a top-level element, or a a second-level or lower element whose parents all have MS flags. </li>\n<li>If an implementation elects to implement the non-MS elements in the nested element’s hierarchy, and the nested element is MS, then the nested element becomes OTI.</li>\n<li>An element with an MS flag whose cardinality is 0..0 is not OTI (yes, this can happen)</li>\n<li>For Data Senders, a required element is OTI, regardless of whether that element has an MS flag. This is because Data Senders must populate required elements.</li>\n<li>For Data Receivers, a required element without an MS flag is not OTI. This is because Receivers have the option of ignoring an element passed to them if they have elected to not support that element.</li>\n</ul>\n<p>Then there are cases of complex elements, data type choices, and reference choices, which US Core attempted to work out in more detail. This is where things get really interesting, because adding an MS flag can actually reduce what must be implemented. </p>\n<ul>\n<li>For an complex element that is MS and OTI:<ul>\n<li>If there is no MS flag on any subelement:<ul>\n<li>A data sender must implement at least one sub-element, and SHOULD implement every sub-element for which the server might possess data</li>\n<li>A data receiver should (must?) implement all sub-elements, since the Receiver cannot anticipate which sub-elements might be populated</li>\n</ul>\n</li>\n<li>If there is an MS on one or  more subelements:<ul>\n<li>Data senders must implement only the sub-elements that are explicitly flagged</li>\n<li>Same for receivers</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>For a choice [x] type:<ul>\n<li>If there is no MS flag on any choice:<ul>\n<li>A data sender must implement at least one datatype choice, and SHOULD implement every datatype for which the server might possess data</li>\n<li>A data receiver should (must?) implement all choice types, since the Receiver cannot anticipate which datatype s might be populated</li>\n</ul>\n</li>\n<li>If there are MS flag(s) on certain choice types:<ul>\n<li>Data senders must implement only the sub-elements that are explicitly flagged</li>\n<li>Same for receivers</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>This is getting long, so I'll stop here. Other cases we've looked at include sliced arrays, references with multiple profiles or resource types, and more.</p>",
        "id": 235190310,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1618842765
    },
    {
        "content": "<p>There are 'degrees' of 'implement'.  While it's true that mandatory elements must be present, there's a difference between \"my system hardcodes a value\" vs. \"my system allows a user to capture a value and transmits it\" - so min=1 with mustSupport=false and min=1 with mustSupport=true can drive considerably different amounts of implementation effort.  Also, there's some degree of implementation effort for \"modifier\" elements, whether mandatory or mustSupport - systems are required to check for them and check that they recognize the values.  So I'm not sure that the notion of OTI as a boolean would be terribly useful.</p>",
        "id": 235198972,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1618845486
    },
    {
        "content": "<p>I agree there are different degrees of implement. Also that modifier elements are always \"must implement\" in the sense of checking for them. But the key point I'm trying to make is that Must Support flags are not the same as \"you must implement\" (to whatever degree that may be).</p>",
        "id": 235200577,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1618846193
    },
    {
        "content": "<p>It's a \"you must implement if you implement the parent\".  I'm not aware of any situation where that's not true.</p>",
        "id": 235203455,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1618847295
    },
    {
        "content": "<p>That is a good generalization (not always true, but almost). Is there a similarly powerful generalization about choice[x], sliced arrays, and references with multiple targets?</p>",
        "id": 235206807,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1618848543
    },
    {
        "content": "<p>If there are slices, you must implement each slice marked as mustSupport.  For the other two, we've talked about adding extensions that would allow you to flag specific types and target types as mustSupport, though I'm not sure where we're at with that.  In the absence of an extension or text giving more specific guidance, the expectation is \"at least one\".  There's a similar expectation for children of mustSupport elements where none of the children are mustSupport, with the inferred expectation of 'reasonable' - i.e. a mustSupport of <a href=\"http://Patient.name\">Patient.name</a> wouldn't be well satisfied by a system that only supported Patient.name.use.</p>",
        "id": 235278650,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1618885819
    },
    {
        "content": "<blockquote>\n<p>For the other two, we've talked about adding extensions that would allow you to flag specific types and target types as mustSupport,</p>\n</blockquote>\n<p>This is implemented and described in US Core : see for example <a href=\"http://build.fhir.org/ig/HL7/US-Core/StructureDefinition-us-core-medicationrequest.html#profile\">here:</a><br>\nand is discussed <a href=\"http://build.fhir.org/ig/HL7/US-Core//conformance-expectations.html#must-support---resource-references\">here</a> and <a href=\"http://build.fhir.org/ig/HL7/US-Core/conformance-expectations.html#must-support---choice-of-data-types\">here</a></p>",
        "id": 235287189,
        "sender_full_name": "Eric Haas",
        "timestamp": 1618894235
    },
    {
        "content": "<p>Related question (I hope) if a national profile defines a field as MS 0..1, can a derived profile mark it as 0..0?</p>",
        "id": 236137186,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1619425447
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> I don't think this would be valid, the <a href=\"https://www.hl7.org/fhir/profiling.html#mustsupport\">spec</a> says: </p>\n<blockquote>\n<p>If creating a profile based on another profile, Must Support can be changed from false to true, but cannot be changed from true to false.  </p>\n</blockquote>\n<p>setting the cardinality to zero would violate that indirectly (the element would be removed from the snaphsot), or not?</p>",
        "id": 236139333,
        "sender_full_name": "Oliver Egger",
        "timestamp": 1619426584
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191478\">@Oliver Egger</span>  that is my struggle.<br>\nWith our MS we roughly indicate: \"Receivers must support it if sent, and must send it if available and adequate (e.g. for relevancy or privacy reasons)\"<br>\nand now we want to say \"in this specific case we want to not send it, so we profile it out\"</p>",
        "id": 236139496,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1619426696
    },
    {
        "content": "<p>mechanically it seems possible. From a conformance profile I think it would be sensibe depending on the meaning of MustSupport.<br>\nI'm interested in thought.<br>\nI don't think however that changing cardinality to 0..0 also implies removing MustSupport..</p>",
        "id": 236139657,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1619426774
    },
    {
        "content": "<p>for that usescase it sounds reasonable to put 0..0</p>",
        "id": 236142952,
        "sender_full_name": "Oliver Egger",
        "timestamp": 1619428577
    },
    {
        "content": "<p>Given that MS is defined at an IG level, I don't see how FHIR core could have any declaration on ability for derived profiles to set 0..0.    It does feel like it is similar to going from true to false, but it is not really. It is eliminating the element. One might even say it is eliminated in the MS = true state.</p>",
        "id": 236169927,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619442475
    },
    {
        "content": "<p>Note I am also not sure I would agree that a derived profile should not be able to change a MS true to false. A derived profile is, in theory, a more refined use-case with tighter conformance needs. Of which in that use-case the element might still not be forbidden (your use-case), but for which the original IG definition of MS does not apply in the derived profile. I am not against that this being discouraged.    Is the \"cannot\" word being used in the spec intended to be an informative word? Or was it intended to be \"shall not\"?</p>",
        "id": 236170591,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619442735
    },
    {
        "content": "<p>In general, I thought making any element 0..0 in a profile was heavily discouraged since it makes it very incompatible/hard to implement. EG: a server or client that works with several profiles must somehow know not to set it (vs just indicating the field is not required for the specific use case, which is fine if a field is optional and cardinality is 0..1). I understand that must support makes this specific situation more difficult.</p>",
        "id": 236171435,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1619443042
    },
    {
        "content": "<p>I agree that is a need for our profiles.. a \"ShouldNotSendButWeKnowSomeneWill\"</p>",
        "id": 236173702,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619443779
    },
    {
        "content": "<p>I think that is more of an application of Postel's Law... be specific in what you send, liberal in consuming from others. I fear we are too often setting one profile for an interaction, and setting it to the most restrictive. When the receiver should really be informed that it might receive stuff that is not as strictly conformant.</p>",
        "id": 236174072,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619443899
    },
    {
        "content": "<p>Based on <a href=\"http://build.fhir.org/profiling.html#cardinality\">this</a> it is technically conformant but you pay a big price as Jenni points out.  This is certainly not a good \"loophole\" to get out of supporting 0..1 MS elements.</p>",
        "id": 236181580,
        "sender_full_name": "Eric Haas",
        "timestamp": 1619446733
    },
    {
        "content": "<p>First, be very cautious about 0..0.  It should only be used when it's an error if the data is present.  That said, an inherited MS=true and 0..0 aren't strictly in conflict.  As an example, you might say that Patient.deceasedDate is \"mustSupport\" in a general profile, but in a more restrictive profile declare that the element is prohibted because the use-case doesn't allow deceased patients.  Part of the issue is that inheriting \"mustSupport\" is a very tricky business.</p>",
        "id": 236211205,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1619457577
    },
    {
        "content": "<p>right, so what alternative is there for that use-case? The only one I can think of is to not derive from the profile that set the MS flag. Which seems like a bad solution too.</p>",
        "id": 236226431,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619463780
    },
    {
        "content": "<p>this would drive people to copy a predicate profile, rather than inherit it... because the predicate profile had one constraint that they disagreed with.</p>",
        "id": 236226570,
        "sender_full_name": "John Moehrke",
        "timestamp": 1619463818
    },
    {
        "content": "<p>I'm saying you <em>can</em> constrain to 0..0 in the case described, just that it's going to feel a bit confusing.</p>",
        "id": 236240479,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1619470228
    }
]