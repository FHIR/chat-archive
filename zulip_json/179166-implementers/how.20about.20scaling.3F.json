[
    {
        "content": "<p>I would like to start a discussion about how to make FHIR scale. It's not related to any specific use case - it is simply about horizontal hardcore scaling and shipping events instead of just using queries like crazy, hitting the RESTful servers constantly (we don't want stale clients, right?). If FHIR is to scale, event mechanisms (like using subscription with web sockets, mq, server sent events rest/web-hooks and what not) must be in use - notifying clients about changes in data. Clients will need to set up subscriptions dynamically and needs to be notified whenever that initial set of data changes - when stuff enters (currently supported) and when stuff leaves.</p>\n<p>Also, if clients are to detect whether they in fact are stale or not versioning is of paramount importance - and should be used as lamports (<a href=\"https://en.wikipedia.org/wiki/Lamport_timestamps\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Lamport_timestamps\">https://en.wikipedia.org/wiki/Lamport_timestamps</a>) or alike. We also need to establish the fact that data cannot change without having its version bumped (this is currently not the case for metadata) because it makes it impossible to detect if data has changed.</p>\n<p>I've created two tickets that points towards some requests that seems necessary to me, in order to get closer to something that can eventually offer consistency and scalability.</p>\n<p><a href=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14197\" target=\"_blank\" title=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14197\">https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14197</a><br>\n<a href=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14198\" target=\"_blank\" title=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14198\">https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=14198</a></p>\n<p>Please, join in on this discussion if you would like FHIR to scale and using eventing mechanisms.</p>",
        "id": 153920204,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1510923414
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191521\">@Michael Christensen</span> please join me on this crusade</p>",
        "id": 153920205,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1510923463
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191363\">@Vadim Peretokin</span> you're welcome to chip in :)</p>",
        "id": 153920207,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1510924212
    },
    {
        "content": "<p>Hi..<br>\nI have c# code in that I created patient with  pat.Id = \"12345\";<br>\nI want to give this patient reference for observation how i can achieve same..<br>\nAlso in search how i can get the patient related all resource information...<br>\nhelp is greatly appreciated !!</p>",
        "id": 153920208,
        "sender_full_name": "shivnath shelake",
        "timestamp": 1510924242
    },
    {
        "content": "<p>hmmm .... I need to look into <a href=\"http://build.fhir.org/eventdefinition.html\" target=\"_blank\" title=\"http://build.fhir.org/eventdefinition.html\">http://build.fhir.org/eventdefinition.html</a> it seems</p>",
        "id": 153920225,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1510931049
    },
    {
        "content": "<p>Very interested in this topic, as well as the Bulk Data Access proposal. I've run into scaling challenges alongside flexibility challenges--using the query API to its full flexibility (or beyond!) isn't performant at scale, but it's also hard to run performant enough to get less filtered data and handle client-side. Subscriptions seem very promising if developed carefully and implemented widely.</p>",
        "id": 153920230,
        "sender_full_name": "John Calvin Young",
        "timestamp": 1510936154
    },
    {
        "content": "<p>+1 to this, while some systems will fit in one server and database, we need to account for horizontal scalability as well</p>",
        "id": 153920509,
        "sender_full_name": "Vadim Peretokin",
        "timestamp": 1511247651
    },
    {
        "content": "<p>I think, transaction level (or consistency level) can be different and specified for each server.</p>",
        "id": 153920987,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1511346766
    },
    {
        "content": "<p>Interested. <br>\nI may help to define a few different use cases:<br>\n1. scaling out to multiple instances of the same FHIR Server ( / RESTful API implementation) on a single database<br>\n2. scaling out to multiple database instances (like sharding or replication), still using multiple instances of the same FHIR Server<br>\n3. scaling out across different FHIR Servers (or even clients)<br>\nI think 1 and 2 can be often be handled by the storage mechanisms underlying the FHIR Server, and at least Vonk keeps no state in the web API layer, so that can be scaled independently. Also, the FHIR Server implementation may assure that changes on metadata don't go unnoticed (Vonk will assign a new version upon an update-interaction no matter what you changed).<br>\nWith 3 it becomes important to 'replay transactions' somehow as we discussed at the BoF at DevDays. And in this case you cannot rely on all parties detecting changes to metadata that you might want to know about. Or even support versioning at all. How to communicate about the capabilities in this respect? Should that be computable?</p>",
        "id": 153920988,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1511346784
    },
    {
        "content": "<p>The $meta-add operations can be performed on older versions of the resource (often to put a security/privacy tag on them to prevent future access)<br>\nThis is not replicated through the history mechanism.</p>",
        "id": 153921120,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1511386692
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> - the fact that you can add metadata without bumping the version of the resource as well makes my skin crawl</p>",
        "id": 153921130,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511390398
    },
    {
        "content": "<p>Unfortunately, for this use-case, its the only way.<br>\nand it's the only thing like it in the FHIR spec too.</p>",
        "id": 153921131,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1511390650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> regarding the fact that Vonk does not keep state ... does that also go for the subscription resource? does it mean that if I set up two Vonk servers up against the same database, that they automatically vote on who is to ship out the notification to a client</p>",
        "id": 153921132,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511390688
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> well lets just hope that no-one finds it important to track changes or handle concurrency when messing with metadata ...<span class=\"emoji emoji-1f612\" title=\"unamused\">:unamused:</span></p>",
        "id": 153921133,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511390946
    },
    {
        "content": "<p>I guess that was not part of the use case ... <span class=\"emoji emoji-1f632\" title=\"astonished\">:astonished:</span></p>",
        "id": 153921134,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511390989
    },
    {
        "content": "<p>Should we add a \"lastMetaUpdated\" to meta (including as a search criteria when querying history)?  That way there'd be a way to retrieve past versions that have been tweaked since the last time you looked.</p>",
        "id": 153921137,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511393081
    },
    {
        "content": "<p>Or just a note on how to represent the meta change for the history representation</p>",
        "id": 153921139,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1511393477
    },
    {
        "content": "<p>Well, if you don't track when the meta changed - or expose it, it's going to be hard for other systems to figure out what happened.</p>",
        "id": 153921140,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511393538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191427\">@Jens Villadsen</span> Currently the subscription evaluation process is part of the Vonk server process, so the notification would be handled by the server that processes the request  triggering it. But I expect the implementation will have several makeovers in the future (since the spec will change on this subject and we will gain experience).</p>",
        "id": 153921241,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1511428459
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> <span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> - I'd would favor a logical clock - like Meta.metaVersionId ... for concurrency reasons</p>",
        "id": 153921257,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511432152
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> - ... I get what you are saying, but the my question relates to parallel Vonk servers against the same db. If a client submits a subscription to one Vonk server and that server goes down, does the other Vonk server then take over the responsibility to send notifications automatically?</p>",
        "id": 153921258,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511432376
    },
    {
        "content": "<p>Note that versionId isn't necessarily sequential - it can easily be a random GUID or something like that.  The only rule is that it's unique within the scope of the resource id.</p>",
        "id": 153921322,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511466227
    },
    {
        "content": "<p>what happened to using a sound well proven concept such as lamports?</p>",
        "id": 153921338,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511473050
    },
    {
        "content": "<p>FHIR systems aren't necessarily built using FHIR-based persistence technologies.  Systems can expose whatever version id they have - in some cases it might even be a generated hash.  The sequential element is lastUpdated, not versionId</p>",
        "id": 153921345,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511481181
    },
    {
        "content": "<p><span class=\"emoji emoji-1f914\" title=\"thinking face\">:thinking_face:</span></p>",
        "id": 153921453,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511523018
    },
    {
        "content": "<p>that sounds like a bet on true distributed time ... it however requires that all systems are in total sync regarding time and that no two updates arrive at the same time (especially if versionId) - then again ... none of it is required, right?</p>",
        "id": 153921480,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511531530
    },
    {
        "content": "<p>Versioning is always specific to a single server instance - because that's the scope of the resource id.  If you synchronize data across multiple servers, the version ids could be totally distinct - integers on one server, timestamps on another, guids on another.  There's no time synchronization issues involved.</p>",
        "id": 153921482,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511532501
    },
    {
        "content": "<p>Well the time used is always the server time. My past results had a time that I use in my next query...</p>",
        "id": 153921519,
        "sender_full_name": "John Moehrke",
        "timestamp": 1511547408
    },
    {
        "content": "<p>my understanding of the lastUpdated behavior is that we allow servers to have policy on what kind of a change can be excluded. Thus it is policy on if a metadata change will update lastUpdated. right?  There are realistic policies that could exist where almost any element change might be considered a non-change. Less so with clinical data vs metadata. But reasonable policy expectations do exist.  If this is the case then the theoretical problem mentioned here can be 'managed' in an implementation guide or deployment policy.  right?</p>",
        "id": 153921520,
        "sender_full_name": "John Moehrke",
        "timestamp": 1511547645
    },
    {
        "content": "<p>I think lastUpdated can't change when meta changes because doing so would cause history to become out-of-order.  lastUpdated is the only way to reliably sort history records</p>",
        "id": 153921522,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511547952
    },
    {
        "content": "<p>Where is it stated that lastUpdated can't change when meta changes?</p>",
        "id": 153921579,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511645758
    },
    {
        "content": "<blockquote>\n<p>my understanding of the lastUpdated behavior is that we allow servers to have policy on what kind of a change can be excluded. Thus it is policy on if a metadata change will update lastUpdated. right?  There are realistic policies that could exist where almost any element change might be considered a non-change. Less so with clinical data vs metadata. But reasonable policy expectations do exist.  If this is the case then the theoretical problem mentioned here can be 'managed' in an implementation guide or deployment policy.  right?</p>\n</blockquote>\n<p>I agree - I think it might be worth mentioning that the doc could be more clear on some topics here (<a href=\"http://build.fhir.org/resource.html#Meta\" target=\"_blank\" title=\"http://build.fhir.org/resource.html#Meta\">http://build.fhir.org/resource.html#Meta</a>) like what fields are <strong>encouraged</strong> to be updated only by the server (<span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>) like versionId and lastUpdated.</p>",
        "id": 153921624,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511769422
    },
    {
        "content": "<p>sure you can make a task for that</p>",
        "id": 153921625,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511772038
    },
    {
        "content": "<blockquote>\n<p>sure you can make a task for that</p>\n</blockquote>\n<p>Nevermind ... I found it reading a combination of <a href=\"http://build.fhir.org/http.html#create\" target=\"_blank\" title=\"http://build.fhir.org/http.html#create\">http://build.fhir.org/http.html#create</a> , <a href=\"http://build.fhir.org/http.html#update\" target=\"_blank\" title=\"http://build.fhir.org/http.html#update\">http://build.fhir.org/http.html#update</a> ,  <a href=\"http://build.fhir.org/http.html#versionaware\" target=\"_blank\" title=\"http://build.fhir.org/http.html#versionaware\">http://build.fhir.org/http.html#versionaware</a> and <a href=\"http://build.fhir.org/resource.html#Meta\" target=\"_blank\" title=\"http://build.fhir.org/resource.html#Meta\">http://build.fhir.org/resource.html#Meta</a></p>",
        "id": 153921638,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511786475
    },
    {
        "content": "<blockquote>\n<p>Where is it stated that lastUpdated can't change when meta changes?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> found it: <a href=\"http://build.fhir.org/http.html#update\" target=\"_blank\" title=\"http://build.fhir.org/http.html#update\">http://build.fhir.org/http.html#update</a></p>",
        "id": 153921642,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1511788006
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Do yo usee utility in adding metaLastUpdated?  I'm not sure how else client systems would know when to grab old history records that have had their meta tweaked.</p>",
        "id": 153921669,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511802180
    },
    {
        "content": "<p>no there's no way to get them. And I really don't see much value in it. If anything, we should remove the special case $meta operations on old records. I've never heard of anyone using them, only complaints around the special case that they resporesent</p>",
        "id": 153921715,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1511822568
    },
    {
        "content": "<p>Couldn't you query for _history and filter on the history entries whose meta has changed since you last looked?</p>",
        "id": 153921756,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511841904
    },
    {
        "content": "<p>The only time changing historical records has any use-case is for history and I agree it's unlikely anyone will do that.  Should we say that the security tags on the current record should apply to all historical versions?</p>",
        "id": 153921757,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1511841994
    },
    {
        "content": "<p>That is a policy decision. The tag may have been applied for a version specific reason. The tag may have been applied for a broad reason. It is better with security tags to never have implied conduction. But that is a policy, not a model thing. The FHIR model lets you do either policy. Yet if you put a policy into FHIR model, then you forbid the other reasonable policy from being done.</p>",
        "id": 153921828,
        "sender_full_name": "John Moehrke",
        "timestamp": 1511875931
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191427\">@Jens Villadsen</span> I never tried it, but it should. Subscriptions are shared through the Administration database in Vonk, so all instances have access to them.</p>",
        "id": 153922721,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1512334903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span>  let me know if you are sure on this part</p>",
        "id": 153922726,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1512341149
    }
]