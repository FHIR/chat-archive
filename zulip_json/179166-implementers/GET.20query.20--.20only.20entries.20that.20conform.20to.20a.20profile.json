[
    {
        "content": "<p>Is there a way in a GET to indicate to the server that the client wants only entries that conform to a named profile?</p>",
        "id": 153885762,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493053537
    },
    {
        "content": "<p>I recognize the _profile query parameter... but how does the fact that the resources on the server 'are' compliant with that profile known? </p>",
        "id": 153885763,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493054108
    },
    {
        "content": "<p>Supplying an explicit parameter presumably only returns resources that include the specified profile annotation -- but how that annotation got there is a  server dependent phenomenon (so some servers could faithfully pass through all client-originated annotations even if they were lies; other servers could validate client annotations; and still other servers could proactively apply new annotations based on analysis of a given resource)</p>",
        "id": 153885765,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1493055572
    },
    {
        "content": "<p>yes, that is the non-deterministic problem we are struggling with... that and how do we specify that the server MUST validate all Create/Update actions against our profile.</p>",
        "id": 153885767,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493055665
    },
    {
        "content": "<p>You can do all sorts of things with ImplementationGuide text.  But it's not something you can currently express in a CapabilityStatement</p>",
        "id": 153885771,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1493056452
    },
    {
        "content": "<p>Im not even sure how to express this need in narrative business requirement. Take the case where a profile on Location wants to assure that the <a href=\"http://Location.name\" target=\"_blank\" title=\"http://Location.name\">Location.name</a> must be filled. How do I represent that a Server shall not return entries that have <a href=\"http://Location.name\" target=\"_blank\" title=\"http://Location.name\">Location.name</a> empty? That is to say, how does a client indicate that they don't want Locations that have no <a href=\"http://Location.name\" target=\"_blank\" title=\"http://Location.name\">Location.name</a> value?</p>",
        "id": 153885775,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493059238
    },
    {
        "content": "<p>The normal HTTP GET expectation is that the server returns results that match the query parameters that it understood. These results might or might not have profile conformance. These results might even be more than the client wanted, due to the server not implementing the query prameters provided.</p>",
        "id": 153885777,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493059867
    },
    {
        "content": "<p>location:missing=false</p>",
        "id": 153885780,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493060055
    },
    {
        "content": "<p>interesting.. but are you serious? A client that wants this needs to include each parameter cardionality requirement? What about elements that don't have a parameter?</p>",
        "id": 153885782,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493060447
    },
    {
        "content": "<p>I don't know whether I'm serious. What you are asking is.... difficult. Does the client really want to ignore locations that have no name? </p>",
        "id": 153885783,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493060524
    },
    {
        "content": "<p>every time I've gamed this out in reality, it's always come back to, the application wishes to live in a reality where all locations have a name. </p>",
        "id": 153885784,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493060562
    },
    {
        "content": "<p>sometimes, that's achievable, and we have a conformance mechanism to deal with that. </p>",
        "id": 153885785,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493060580
    },
    {
        "content": "<p>the xample of name is an example of a constraint... I could have been more persuasive on the need for the constraint... but ultimetly there is a general solution needed</p>",
        "id": 153885786,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493060595
    },
    {
        "content": "<p>but simply naming a profile, and expecting the server to magically figure out how to filter records for conformance to the profile... it's always seem computationally unfeasible to us </p>",
        "id": 153885787,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493060629
    },
    {
        "content": "<p>I don't like that either... I have tried to argue that the constaints are not something one applys to a Query; they are rules you apply on Create/Update.</p>",
        "id": 153885788,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493060691
    },
    {
        "content": "<p>but... I needed to ask if there was a solution... because right now we are profiling only the GET side, not Create/Update.... </p>",
        "id": 153885789,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493060738
    },
    {
        "content": "<p>And for the location resource, there are some types of locations where a name just doesn't make sense, specifically where they are only recording the geo-code co-ordinates. So the constraint to force a name would result in it being filled with junk.</p>",
        "id": 153886108,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1493196873
    },
    {
        "content": "<p>The question is not specific to Location  resource... it is a question about any Resource... It is not specific to <a href=\"http://Location.name\" target=\"_blank\" title=\"http://Location.name\">Location.name</a>, that was just an example of a string that some application may want not empty. The question is, is there a way a client can ask that results be constrained to only results that are compliant to a specified Profile? -- It seems not, and I am not thinking this is an important need. I just didn't want to ignore a capability that exists when there was moderate interest in using that capability, if it existed.</p>",
        "id": 153886132,
        "sender_full_name": "John Moehrke",
        "timestamp": 1493209035
    },
    {
        "content": "<p>(I have a similar use case where I want to filter the returned with a profile, to get a similar effect to _elements or _summary, where the profile is used to mask the properties - I believe some others have done something similar)</p>",
        "id": 153886230,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1493239972
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> We implemented this (partially) as part of our profile governed API system.  <code>GET /patient?_profile:evaluate=http://example.com/fhir/some-profile</code> asks the server to ensure that returned resources meet the profile. We implemented by parsing the profile and pulling out \"limiting\" parts of the profile such as max=0, fixed[x], minValue[x], etc. and converting those parts to persistence layer queries (ElasticSearch in our case).  The resulting candidates are then washed thru the validator if needed (additional expressions to evaluate).</p>",
        "id": 153887511,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1494066377
    },
    {
        "content": "<p>It's smart enough to \"build\" on pre-validated content.  E.g. since all Patients already conform to the standard profile, no expressions from that profile are loaded.  In our case, they already conform to the enterprise profile as well, so that's even fewer checks.</p>",
        "id": 153887513,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1494066444
    },
    {
        "content": "<p>I think we should use this as an example of a more common need. Is this a need that is best served by breaking the resource into more 'right sized' Resource? Is this need that should be built into a more reusable pattern? etc. Seems like a job for FHIR-I and Security to work together.</p>",
        "id": 153887514,
        "sender_full_name": "John Moehrke",
        "timestamp": 1494066665
    },
    {
        "content": "<p>Our use case is more about semantic definition - we create sets of profiles for integrated contexts, usually a clinical specialty, and use those profiles to govern communication with the FHIR server for app access and ultimately for analytics.</p>",
        "id": 153887516,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1494067270
    }
]