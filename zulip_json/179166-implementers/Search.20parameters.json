[
    {
        "content": "<p>I'm using HAPI FHIR server with DSTU2, and it provides a set of search parameters that do not always match the name of the resource element. For example, if I want to query the Observations of a specific patient, I use \"?patient=...\", while the field is actually named \"subject\". Are the names of search parameters fixed in the FHIR standard? If not, how do I know which names to use when querying by a certain field, and how do I know which fields can be searched?</p>",
        "id": 153857299,
        "sender_full_name": "Shlomy Reinstein",
        "timestamp": 1479311856
    },
    {
        "content": "<p>If you look at the bottom of each resource page, you'll see the list of available search parameters, including maps that identify the paths within the resource that correspond to each parameter name.  Do note that the names on a particular server can be different still (generally to address name collisions) - you need to look at the Conformance/CapabilityStatement of the server to see what search parameters it actually supports and what names it uses for them.</p>",
        "id": 153857301,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1479312227
    },
    {
        "content": "<p>Thanks! I somehow missed this part in the FHIR specification.</p>",
        "id": 153857317,
        "sender_full_name": "Shlomy Reinstein",
        "timestamp": 1479315657
    },
    {
        "content": "<p>However, the fact that each server may support a different subset of search parameters, means that apps that use specific search parameters may need to take into account that they may work with some servers but not with others, unless they support both cases. If I want to search all Observations of a specific patient ordered by date, but the server does not support the date parameter, then the application must read all the Observations and sort the list on its own. It's a lot of overhead on the application, if it's intended for use with different servers. Is there a platform / library that creates this abstraction, so you can search by the full set of parameters even if the server does not support it?</p>",
        "id": 153857319,
        "sender_full_name": "Shlomy Reinstein",
        "timestamp": 1479315857
    },
    {
        "content": "<p>Yes.  However, keep in mind that servers can also choose which elements to support in resources (both what core elements and what extensions).   They can also choose what resources they'll support, what operations they support, whether they support chaining, includes, sorting and a whole raft of other things.  There are no guarantees that an arbitrary server will do *anything* a given client needs.  There are several possible client design strategies:<br>\n1. Assume support for whatever functionality you need and only function with those servers that provide it.  (Simplest, limits what servers you'll work with)<br>\n2. Assume bare minimum server support and take on everything else internally (less efficient, slower)<br>\n3. Query to find out what a given server supports, make them do as much of the work as they're capable of, then handle the rest internally.  (most efficient, maximizes interoperability, much more effort to write and test)<br>\n4. Look to implementation guides to set expectations for servers in a particular interoperability space and develop clients according to those expectations.  (Ideal if all the servers you need to talk to support the implementation guide and the implementation guide covers your needs.)</p>",
        "id": 153857349,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1479325722
    },
    {
        "content": "<p>Hi, have we merged SearchParameters for several resources into one:</p>\n<div class=\"codehilite\"><pre> 1332         &quot;base&quot;: [\n 1333           &quot;FamilyMemberHistory&quot;,\n 1334           &quot;AllergyIntolerance&quot;,\n 1335           &quot;Procedure&quot;,\n 1336           &quot;List&quot;,\n 1337           &quot;DiagnosticRequest&quot;,\n 1338           &quot;DeviceUseRequest&quot;,\n 1339           &quot;Observation&quot;,\n 1340           &quot;DiagnosticReport&quot;,\n 1341           &quot;Condition&quot;\n 1342         ],\n 1343         &quot;type&quot;: &quot;token&quot;,\n 1344         &quot;description&quot;: &quot;Multiple Resources: \\r\\n\\r\\n* [FamilyMemberHistory](familymemberhistory.html): A search by a condition code\\r\\n* [Allergy\n 1345         &quot;expression&quot;: &quot;FamilyMemberHistory.condition.code | AllergyIntolerance.code | AllergyIntolerance.reaction.substance | Procedure.code | Li\n 1346         &quot;xpath&quot;: &quot;f:FamilyMemberHistory/f:condition/f:code | f:AllergyIntolerance/f:code | f:AllergyIntolerance/f:reaction/f:substance | f:Proced\n 1347         &quot;xpathUsage&quot;: &quot;normal&quot;\n 1348       }\n</pre></div>\n\n\n<p>for disk space economy? It looks little bit messy :(</p>",
        "id": 153874985,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488809261
    },
    {
        "content": "<p>What is the reason for such change? Why many to many Resource*-*SearchParam, why not clear and granular Resource-*SearchParam?</p>",
        "id": 153874987,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488809437
    },
    {
        "content": "<p>I was wondering about this too.</p>\n<p>Also, does the xpath part still serve any purpose? Are there any paths that can only be expressed with xpath and not with fhirpath?</p>",
        "id": 153875023,
        "sender_full_name": "James Agnew",
        "timestamp": 1488814306
    },
    {
        "content": "<p>Now we have to split it back by hands :( parsing expression and/or xpath</p>",
        "id": 153875025,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488814385
    },
    {
        "content": "<p>My initial perseption was, that SearchParameters  with multiple base and complex expressions was introduced for global searches :)</p>",
        "id": 153875027,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488814552
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> That's exactly why - these are the parameters you can use for searching against the base endpoint to bring back resources of different types.</p>",
        "id": 153875075,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1488828535
    },
    {
        "content": "<p>Xpaths are redundant if you support fhirpath. But we are maintaining xpaths as a convenience for implementers who do not have a implementation of FHIRPath and want to use xpath</p>",
        "id": 153875088,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488830459
    },
    {
        "content": "<p>But I do not see specific searchparams like patient-given - or we have to deduce it from group search?</p>",
        "id": 153875098,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488831172
    },
    {
        "content": "<div class=\"codehilite\"><pre> {\n        &quot;resourceType&quot;: &quot;SearchParameter&quot;,\n        &quot;id&quot;: &quot;individual-given&quot;,\n        &quot;url&quot;: &quot;http://hl7.org/fhir/SearchParameter/individual-given&quot;,\n        &quot;name&quot;: &quot;given&quot;,\n        &quot;status&quot;: &quot;draft&quot;,\n        &quot;experimental&quot;: false,\n        &quot;date&quot;: &quot;2017-03-06T17:39:13+11:00&quot;,\n        &quot;publisher&quot;: &quot;Health Level Seven International (Patient Administration)&quot;,\n        &quot;contact&quot;: [\n          {\n            &quot;telecom&quot;: [\n              {\n                &quot;system&quot;: &quot;url&quot;,\n                &quot;value&quot;: &quot;http://hl7.org/fhir&quot;\n              }\n            ]\n          },\n          {\n            &quot;telecom&quot;: [\n              {\n                &quot;system&quot;: &quot;url&quot;,\n                &quot;value&quot;: &quot;http://www.hl7.org/Special/committees/pafm/index.cfm&quot;\n              }\n            ]\n          }\n        ],\n        &quot;code&quot;: &quot;given&quot;,\n        &quot;base&quot;: [\n          &quot;Practitioner&quot;,\n          &quot;Patient&quot;\n        ],\n        &quot;type&quot;: &quot;string&quot;,\n        &quot;description&quot;: &quot;Multiple Resources: \\r\\n\\r\\n* [Practitioner](practitioner.html): A portion of the given name\\r\\n* [Patient](patient.html): A portion of the given name of the patient\\r\\n&quot;,\n        &quot;expression&quot;: &quot;Practitioner.name.given | Patient.name.given&quot;,\n        &quot;xpath&quot;: &quot;f:Practitioner/f:name/f:given | f:Patient/f:name/f:given&quot;,\n        &quot;xpathUsage&quot;: &quot;normal&quot;\n      }\n</pre></div>",
        "id": 153875100,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488832443
    },
    {
        "content": "<p>deduce from the fact that given is defined for both Practitioner and Patient</p>",
        "id": 153875101,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1488832470
    },
    {
        "content": "<p>Sounds strange ;( may be I am only one, who don't like it. Specific search is more important for me, then multi-resource search. Granularity of control for specific parameter also sacrificed.</p>",
        "id": 153875102,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488834092
    },
    {
        "content": "<p>We have \"Compartment\" simplification. Grouping beyond those compartments seems might be more trouble. right?</p>",
        "id": 153875119,
        "sender_full_name": "John Moehrke",
        "timestamp": 1488837297
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> You should still have granularity in your CapabilityStatement as you can declare support (or not) for each SearchParameter on a per-resource basis.</p>",
        "id": 153875121,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1488838409
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  i am afraid, that such changes  complicate standard perception - FHIR becoming more and more complicated - it's very uneasy to explain mixed concepts, like group search parameter which also describe specific search  - let's look for simplicity :)</p>",
        "id": 153875188,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1488876968
    },
    {
        "content": "<p>The declaration of support for a given search parameter for a given resource has always been in the Conformance/CapabilityStatement - that's not a change.   I believe support for cross-resource search was part of the ballot.  The community can (and should) speak out against functionality they don't want in the spec/excessive complexity.  And it's certainly possible to request reversal in the next release if implementer experience suggests the current design is too painful.</p>",
        "id": 153875247,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1488910189
    },
    {
        "content": "<p>We have a use case where we have a set of Condition resources bound by a List kept on a FHIR server. There can be new Conditions attached to the List, and Conditions may become inactive.  When we GET the conditions for a given List, it would be useful to get just the active conditions. Active conditions are those with a Condition.clinicalStatus of \"active\", when Conditions become inactive, the Condition.clinicalStatus is set to \"inactive (as well as the List.entry.deleted flag set to \"true\").<br>\nIt would be really useful if we could query the server to GET a specified List, and just the active Conditions associated with the List. So a query like<br>\nGET [serverReference]List?_id=[myList]&amp;_include=List:item&amp;item:Condition.clinical-status=active</p>\n<p>However, this doesn't work (you get back ALL conditions associated with the List regardless of their clinical-status). I'm assuming that <br>\n<strong>_id=[myList]</strong> works OK as I just get [myList] back<br>\n<strong>_include=List:item</strong> works OK as I get back all the resources (Conditions) referenced by item<br>\n<strong>item:Condition.clinical-status=active</strong> doesn't work as a chaining statement is all about influencing which resources being queried (in this case List) are returned and not about influencing the referenced resources (in this case Condition).</p>\n<p>Is there a GET statement that would get the List and ONLY active  Condition referenced by the List? Or is it just a client side activity to filter out the inactive Conditions?</p>",
        "id": 153973663,
        "sender_full_name": "Dave Barnet",
        "timestamp": 1530784340
    },
    {
        "content": "<p>you'd have to use _filter for that</p>",
        "id": 153973676,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1530792278
    },
    {
        "content": "<p>Do you know of a test server that has implemented _filter (the vonk server says \"Parameter _filter is not implemented\"? Is there some open source code that implements _filter?</p>",
        "id": 153974000,
        "sender_full_name": "Dave Barnet",
        "timestamp": 1530874862
    },
    {
        "content": "<p><a href=\"http://test.fhir.org\" target=\"_blank\" title=\"http://test.fhir.org\">test.fhir.org</a> does. and I think I convinced James to add it to HAPI but it's not done yet</p>",
        "id": 153974010,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1530876043
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> is this on your roadmap?</p>",
        "id": 153974011,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1530876054
    },
    {
        "content": "<p>We've just had a look at <a href=\"http://test.fhir.org\" target=\"_blank\" title=\"http://test.fhir.org\">test.fhir.org</a> &amp; it looks like you haven't implemented the _include parameter, so that makes testing of _filter for our use case difficult.</p>",
        "id": 153974038,
        "sender_full_name": "Dave Barnet",
        "timestamp": 1530882730
    },
    {
        "content": "<p>i definitely have implemented _include</p>",
        "id": 153974042,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1530883173
    },
    {
        "content": "<p>Sorry - yes you have</p>",
        "id": 153974048,
        "sender_full_name": "Dave Barnet",
        "timestamp": 1530886816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> : It is, but not on the short term that I hoped for. But if a customer has a special request for this, it may move closer.</p>",
        "id": 153974429,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1531204929
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192158\">@Dave Barnet</span> :As for the original query. I think you can do without _filter:<br>\nGET <a href=\"https://vonk.fire.ly/Condition?_list=02b9f75f-6a2e-494f-a504-539abc59c611&amp;clinical-status=active\" target=\"_blank\" title=\"https://vonk.fire.ly/Condition?_list=02b9f75f-6a2e-494f-a504-539abc59c611&amp;clinical-status=active\">https://vonk.fire.ly/Condition?_list=02b9f75f-6a2e-494f-a504-539abc59c611&amp;clinical-status=active</a><br>\nThis just does not give you the List itself, but you can:<br>\n- get that in a separate GET &lt;base&gt;/List/&lt;id&gt;, <br>\n- get it together in a Batch with the two GETs<br>\n- get it with a _revinclude (but that may include other Lists that the same Condition is an item of): &amp;_revinclude=List:item</p>\n<p>Note: I used a specific List id, that will not exist on the demo server forever.</p>",
        "id": 153974432,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1531206245
    }
]