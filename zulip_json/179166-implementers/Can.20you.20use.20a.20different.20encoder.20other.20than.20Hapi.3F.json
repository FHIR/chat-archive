[
    {
        "content": "<p>I would like to know if there are any special scenarios that the Hapi encoder handles that a just any old encoder wouldn't. For example the Java to JSON encoder, would we just be able to use a library like Jackson or something. I would also like to know if there are any metrics for speed performance between the two, is the Hapi encoder slower, and if so, what makes it so?</p>",
        "id": 154010190,
        "sender_full_name": "Jake",
        "timestamp": 1539872097
    },
    {
        "content": "<p>Jackson and similar libraries are unable to handle HAPI's structures to produce valid FHIR. There are lots of rules in FHIR's encoding that don't get handled properly without using the right parser.</p>",
        "id": 154010192,
        "sender_full_name": "James Agnew",
        "timestamp": 1539872939
    },
    {
        "content": "<p>Thanks James,</p>\n<p>Is it that Jackson and similar libraries don't produce valid FHIR JSON (for example), or that those libraries wouldn't be able to handle parsing the FHIR classes at all and would fail to produce any JSON?</p>",
        "id": 154010193,
        "sender_full_name": "Jake",
        "timestamp": 1539873660
    },
    {
        "content": "<p>I guess basically it's that the HAPI FHIR structures aren't designed for something like Jackson. You could probably create structures that Jackson would be able to turn into FHIR but they would have subtle differences from the HAPI FHIR ones. </p>\n<p>E.g. as one simple example: HAPI FHIR knows that a field annotated with @Extension should put the extension URL in an attribute called <code>url</code> on the extension element. Jackson doesn't know anything about FHIR so it creates invalid extensions. I'm sure someone with enough time could work through all of these issues, but I think it's just easier to use the HAPI FHIR parser personally.</p>",
        "id": 154010272,
        "sender_full_name": "James Agnew",
        "timestamp": 1539897149
    },
    {
        "content": "<p>cardinality issues, polymorphism. And the structures for native java json libraries would be incompatible with the structures for native java xml libraries</p>",
        "id": 154010297,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1539902362
    },
    {
        "content": "<p>and you don't get all the useful decorations in the java classes.</p>",
        "id": 154010298,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1539902376
    }
]