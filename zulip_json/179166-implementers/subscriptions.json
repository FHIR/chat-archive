[
    {
        "content": "<p>What is the conceptual difference between messaging &amp; rest hook? Where is http long-polling, most used &amp; robust technology for event driven notifications in web?  For web-sockets and long-polling  - creation of subscription could be part of communication (i.e. first phase), so we do not need to coordinate two operations on servers.</p>",
        "id": 153858673,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480340853
    },
    {
        "content": "<p>For REST hooks additional security configuration &amp; workflow should be specified (like signatures or message verification).</p>",
        "id": 153858674,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480341136
    },
    {
        "content": "<p>The main difference in my understanding is that in the case of Messaging, the configuration of the trigger events is out-of-band... Where in rest hook they are inline. -- Security should be considered equally for both, risk based.</p>",
        "id": 153858677,
        "sender_full_name": "John Moehrke",
        "timestamp": 1480341555
    },
    {
        "content": "<p>do we need to specify anything for long-polling? I think not...?<br>\nas for additinoal things about REST hooks.... what else do you think we need to specify?</p>",
        "id": 153858716,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480358628
    },
    {
        "content": "<p>For example, for long-polling it could be like this - POST with subscription resource will be kept until new event with update message response or timeout. Ephemeral Subscription resource will be created during long-polling request.</p>",
        "id": 153858752,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480369085
    },
    {
        "content": "<p>Or post with long-polling subscription will return long-polling url with offset.</p>",
        "id": 153858754,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480369359
    },
    {
        "content": "<p>For REST hook - secret token could be added to subscription.</p>",
        "id": 153858757,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480369495
    },
    {
        "content": "<p>but why not just make the query?</p>",
        "id": 153858758,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480369572
    },
    {
        "content": "<p>as for secret token, how would that work? be part of the URL? a header?  - already both supported</p>",
        "id": 153858759,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480369602
    },
    {
        "content": "<p>Looks like I missed getting the refactoring of the endpoint resource into it too. (don't recall if I created a task)</p>",
        "id": 153858760,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1480369606
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, do you mean just do read, search or history with long-polling parameter?</p>",
        "id": 153858836,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480398526
    },
    {
        "content": "<p>For REST hook, I think, secret should not be exposed for read/search i.e. masked or hidden.</p>",
        "id": 153858839,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480398677
    },
    {
        "content": "<p>yes that's what I meant. </p>",
        "id": 153858846,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480400392
    },
    {
        "content": "<p>does it work&gt; </p>",
        "id": 153858847,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480400397
    },
    {
        "content": "<p>for rest hook, how not to expose it? don't understand?</p>",
        "id": 153858848,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480400411
    },
    {
        "content": "<p>Then we need new parameter to say it's \"long-polling\" request and some capability in conformance, and markers for search parameters (could be used in \"long-polling\")</p>",
        "id": 153858856,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480403577
    },
    {
        "content": "<p>how would you typically use long polling? </p>",
        "id": 153858875,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480411179
    },
    {
        "content": "<p>We've implemented secure messaging using long-polling: for every subscriber there is current offset (stream) in event/message log, client (subscriber) do long-polling request with current offset, if server offset is bigger, then it respond instantly with new data or hangs this request until incoming  events (messages), respond includes next offset.  Client is responsible to reconnect and manage offset. (this pattern comes from popular kafka message queue pattern - <a href=\"https://kafka.apache.org/documentation\" target=\"_blank\" title=\"https://kafka.apache.org/documentation\">https://kafka.apache.org/documentation</a>). Looks like the same pattern could be used for robust subscription stream.</p>",
        "id": 153858913,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480415692
    },
    {
        "content": "<p>well, how would you imagine that? A history operation with a wait=true parameter?</p>",
        "id": 153858916,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480415882
    },
    {
        "content": "<p>Yes</p>",
        "id": 153858917,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480415919
    },
    {
        "content": "<p>so that's kind of a useful thing to add, but not equivalent because it doesn't have the search. </p>",
        "id": 153858920,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480416119
    },
    {
        "content": "<p>harder for me to imagine it on a search. a parameter future=true. - ignore what you could find now, and return a new resource next time it matches...?</p>",
        "id": 153858921,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480416164
    },
    {
        "content": "<p>We need to identify from which point in time we want to subscribe - it should be something like offset, etag or link in search bundle like paging  -   updates_url. Internally we gonna use transaction id as version id for resources and as natural offset for subscriptions (singular operations  will be transaction with one operation).</p>",
        "id": 153858926,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480416513
    },
    {
        "content": "<p>Another concern that not all search queries could be efficiently implemented as reactive, so may be some restrictions on search parameters for subscriptions are required.</p>",
        "id": 153858929,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480416619
    },
    {
        "content": "<p>Also long-polling often fall back to just request if server has something to response</p>",
        "id": 153858931,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480416738
    },
    {
        "content": "<p>Note that with long-polling; the socket needs to be created with keep-alive enabled. This allows for detection of a broken connection, thus allowing cleanup of resources.</p>",
        "id": 153858964,
        "sender_full_name": "John Moehrke",
        "timestamp": 1480427711
    },
    {
        "content": "<p>Probably going to need a SubscriptionCapability resource so clients can introspect the subscription capability of the server. that'd be an STU4 thing. In the meantime, I'm still not clear on how search would / should work. Maybe </p>\n<p>GET [base]/Observation?code=[LN]&amp;_future=true</p>\n<p>Then, every time there's a match, the server sends a chunked budle, with trunk for each entry. Client has to read each chunk individually. Well, can, at least</p>",
        "id": 153858985,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480442201
    },
    {
        "content": "<p>Hope, we will prototype and evaluate this approach soon. In most cases notifying client  - that something has changed - even more valuable, than deliver this changes, because client could just retrieve changed data with ordinary REST request.</p>",
        "id": 153858989,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480442594
    },
    {
        "content": "<p>ok, well let us know...</p>",
        "id": 153858995,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480444000
    },
    {
        "content": "<p>As for not exposing secrets: @<strong>nicola (RIO)</strong> are your concerns not addressed by the use of TLS?  I usually see these schemes for things like GitHub web Hooks where they need to be able to deliver over regular http.</p>",
        "id": 153859245,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480511005
    },
    {
        "content": "<p>I just followed analogy with password :) It's good practice never expose password.</p>",
        "id": 153859246,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480511145
    },
    {
        "content": "<p>Typically during a sign-in flow (like, for a web app), clients do send a password to a server (protected via TLS). Then the password is hashed and checked on the server side against a stored hashed/salted password.</p>",
        "id": 153859322,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480540906
    },
    {
        "content": "<p>Josh, that would be true for some forms based authentication. I thought we were recommending OpenID Connect authentication flows. For which there might be a forms based interaction between the client and the OpenID Connect authority; but that communication does not involve the Client-Server communication. It is orthogonal, yet results in OAuth credential used in Client-Server communications. Yes that form is covered by https. But the most important part is that the authentication step is independent. Thus that authentication step can leverage any authentication methods that the authentication authority wants to use (smart-card, id-token, biometrics, etc). And none of that is exposed to the Client or Server.</p>",
        "id": 153859324,
        "sender_full_name": "John Moehrke",
        "timestamp": 1480541187
    },
    {
        "content": "<p>an OAuth token can be used in a subscription. It is important to recognize expirations of the token. Often this is managed through the long-polling resulting in only a notification that something has changed, requiring the client to try again. That try again might need a refreshed token... All the kinds of Security-Risks one needs to think about and manage.</p>",
        "id": 153859326,
        "sender_full_name": "John Moehrke",
        "timestamp": 1480541356
    },
    {
        "content": "<p>Hence the Apple model of simply holding the TCP in FIN-WAIT; with the server closing when it has something to say.</p>",
        "id": 153859327,
        "sender_full_name": "John Moehrke",
        "timestamp": 1480541531
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> Sorry, we're talking past each other. @<strong>nicola (RIO)</strong> was using an analogy and I was replying in kind.</p>",
        "id": 153859331,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480542184
    },
    {
        "content": "<p>Certainly SMART on FHIR uses OpenID Connect for authentication, and a user should not be entering their EHR or portal password directly into an app.</p>",
        "id": 153859332,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480542222
    },
    {
        "content": "<p>understood. I was mostly trying to get details into the thread, not so much worried about responding to you.  It is hard to get people to use  'good practices', with the hope that someday we have a 'best practice' :-)</p>",
        "id": 153859333,
        "sender_full_name": "John Moehrke",
        "timestamp": 1480542296
    },
    {
        "content": "<p>I'm just saying that when you sign into a web site, like your bank or whatever... when you fill in a password box, that password is sent directly as a form param to the bank (not hashed client-side, or whatever).</p>",
        "id": 153859334,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1480542310
    },
    {
        "content": "<p>Yes, with Forms based (authentication), like any form, the result is sent to the server. In authentication it is hoped that the server uses hashes (salted), rather than non-secure comparison mechanisms.</p>",
        "id": 153859337,
        "sender_full_name": "John Moehrke",
        "timestamp": 1480542389
    },
    {
        "content": "<p>the 'good practice' I want to encourage is the use of 'off-the-shelf' OpenID Connect solutions where ALL of this is not re-invented by healthcare developers.</p>",
        "id": 153859338,
        "sender_full_name": "John Moehrke",
        "timestamp": 1480542459
    },
    {
        "content": "<p>....</p>",
        "id": 153859580,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480580463
    },
    {
        "content": "<p>I mean, if we have subscription as resource - so we could list &amp; search subscriptions, it looks more secure do not show sensitive information like secret (access_token or whatever) as result of search/read operations, because this is  vulnerability for recipient - i.e. when attacker will get access to list of subscriptions, she will get access to REST hook or message endpoint of subscriber.</p>",
        "id": 153859585,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1480589308
    },
    {
        "content": "<p>Regarding the text on subsciptions on <a href=\"http://build.fhir.org/subscription.html\" target=\"_blank\" title=\"http://build.fhir.org/subscription.html\">http://build.fhir.org/subscription.html</a> - section \"\"2.47.2\" - <em>As an alternative to subscriptions, the RESTful API describes a polling-based subscription method using bundles and the history operation. This method of polling allows for a much tighter relationship between the client and the server that doesn't involve missing updates and/or deletes.</em></p>",
        "id": 153904378,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1504511418
    },
    {
        "content": "<p>What does polling a REST service has to do with subscriptions?</p>",
        "id": 153904379,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1504511450
    },
    {
        "content": "<p>I can't see how polling a server is any guarantee that updates are missed. Actually, it more or less guarantees the opposite.</p>",
        "id": 153904380,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1504511535
    },
    {
        "content": "<p>With polling you are guaranteed to become stale right after you as a client has polled. So the sentence makes little sense</p>",
        "id": 153904381,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1504511641
    },
    {
        "content": "<p>The polling based approach allows you to see what's changed since you last looked.  If things have changed more than once - and you care about interim changes - you'd need to do a subsequent \"history\" query to get the remainder or your polling query would itself need to be a history query.</p>",
        "id": 153904391,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1504539141
    },
    {
        "content": "<p>polling with any filter creates problems where a resource changes to not meet the filter</p>",
        "id": 153904411,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1504574953
    },
    {
        "content": "<p>it silently falls out</p>",
        "id": 153904412,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1504574964
    },
    {
        "content": "<p>Regarding the phrase - 'The consequence of this is that there is no notification when a resource is deleted, or when a resource is updated so that it no longer meets the criteria.'</p>",
        "id": 153904426,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1504604231
    },
    {
        "content": "<p>Imagine the following flow:<br>\nWhen the client issues a subscription, the server acknowledges the subscription and returns a bundle including the subscription as well as the evaluated result of the criteria (initial result set). now, whenever a change occurs that would result in a different result set, the change is sent - this could be either an update, create or delete. To my understanding there is no such mechanism defined currently within this spec. Does this sound out of scope to you?</p>",
        "id": 153904432,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1504609604
    },
    {
        "content": "<p>It probably requires versioned bundles ...</p>",
        "id": 153904433,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1504609787
    },
    {
        "content": "<p>I don't think we've talked about returning the initial set. the rest is ok. Are you on the subscription stream here?</p>",
        "id": 153904434,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1504610541
    },
    {
        "content": "<p>I now subscribe to the subscription channel ;)</p>",
        "id": 153904436,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1504611735
    },
    {
        "content": "<p>Hi<br>\nMy system handles appointments and I am working with the business need: Notify external systems when a patient with an appointment arrives.<br>\nWe only have appointments with one patient - not many patients.<br>\nMy system has a high volume of appointments, an appointment is updated around every second.</p>\n<p>Initially my approach was to go with the subscription&amp;rest-hook pattern with a pooling done by the subscrieber.<br>\nThe frequency of patients arrivals is assumed to be low enough for this pattern to make sense, it could also make sense to narrow the criteria into specific organizations/locations.</p>\n<p>However I can see some issues with this:<br>\n1) One would naively think that you should use the criteria: \"&amp;status=arrived\".<br>\nBut the subscrieber is probably looking for something like \"&amp;previousStatus!=arrived&amp;status=arrived\" (where previousStatus is a homemade representation for \"the status of the previous version of this appointment\")<br>\n2) using the pooling pattern will possible hide updates for you<br>\nEg. if the appointment has already changed to status=fulfilled when the pooling-search \"&amp;status=arrived&amp;_lastUpdated=gt&lt;lastQueryTime&gt;\" is done by the subscrieber</p>\n<p>Issue 1) could be handled by introducing a criteria like \"&amp;patientDidArrive=true\" to cover \"&amp;previousStatus!=arrived&amp;status=arrived\" (I haven't seen any standard for querying with criteria on previous version of a resource)</p>\n<p>In fact we could (and probaly also will) introduce an patientArrived (Date) extension which could solve problem 2. But then we go against the description at FHIR and assume that that the subscrieber will do a different search than the subscription criteria, because the pooling will be:<br>\n\"&amp;patientArrived:missing=false&amp;_lastUpdated=gt&lt;lastQueryTime&gt;\"  (I assume that that the _since parameter is a typo at FHIR)<br>\nThis will remove the possibility of loosing updates but will widening the search results to changes at appointments for already arrived patients.</p>\n<p>Alternative the subscrieber should use a different criteria narrowing down \"the appoitments of my interest\" and just subscriebe to &amp;patientArrived:missing).<br>\nOr maybe I should look for a different mechanism altogether.</p>\n<p>Any thoughts on this?</p>",
        "id": 153914032,
        "sender_full_name": "Allan Bro Hansen",
        "timestamp": 1508145035
    },
    {
        "content": "<p>you should look at the last connectathon stream on subscriptions:</p>",
        "id": 153914033,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508145245
    },
    {
        "content": "<p><a href=\"http://wiki.hl7.org/index.php?title=201709_FHIR_Subscriptions\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=201709_FHIR_Subscriptions\">http://wiki.hl7.org/index.php?title=201709_FHIR_Subscriptions</a></p>",
        "id": 153914034,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508145281
    },
    {
        "content": "<p>and see here:</p>",
        "id": 153914035,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508145294
    },
    {
        "content": "<p><a href=\"https://chat.fhir.org/#narrow/stream/subscriptions\" target=\"_blank\" title=\"https://chat.fhir.org/#narrow/stream/subscriptions\">https://chat.fhir.org/#narrow/stream/subscriptions</a></p>",
        "id": 153914036,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508145300
    },
    {
        "content": "<p>Thanks- I'll have a look and maybe repost the question in the core \"subscriptions\"-stream</p>",
        "id": 153914038,
        "sender_full_name": "Allan Bro Hansen",
        "timestamp": 1508145982
    },
    {
        "content": "<p>My conclusion after reading at the main-subscriptions stream (if others are reading along): <br>\n1) The connectathon introduces a extension \"topics\" with a reference to an eventDefinition.<br>\nFor my scenario this would be something like:<br>\n{<br>\n\"criteria\": \"Appointment\", -- could include filtering of appointments - if subscrieber only wants to hear of specific appointments<br>\n\"extension\": {[<br>\n    \"url\": \"<a href=\"http://hl7.org/fhir/subscription/topics\" target=\"_blank\" title=\"http://hl7.org/fhir/subscription/topics\">http://hl7.org/fhir/subscription/topics</a>\",<br>\n    \"valueReference\": {<br>\n    \"reference\": \"<a href=\"https://example.com/EventDefinition/123\" target=\"_blank\" title=\"https://example.com/EventDefinition/123\">https://example.com/EventDefinition/123</a>\",<br>\n    \"display\": \"Patient with appointment arrived\",<br>\n}<br>\n]</p>\n<p>2) the connectathon mainly addresses pushing the updated resource(s), no pooling mechanism.</p>",
        "id": 153914064,
        "sender_full_name": "Allan Bro Hansen",
        "timestamp": 1508150793
    },
    {
        "content": "<p>we didn't focus on polling, no. The subscription stream addressed event based subscriptions rather than than search based subscriptions - so you can do before and after comparison</p>",
        "id": 153914065,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508151272
    },
    {
        "content": "<p>I just mentioned polling as an alternative to using Subscriptions, since not every FHIR server will implement Subscriptions.</p>",
        "id": 153914083,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1508152415
    },
    {
        "content": "<p>It is not polling as an alternative to Subscriptions, it is rather Subscription with polling (as opposed to Subscription with pushing (adding a payload))</p>",
        "id": 153914087,
        "sender_full_name": "Allan Bro Hansen",
        "timestamp": 1508152665
    },
    {
        "content": "<p>subscription with polling?</p>",
        "id": 153914091,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508152935
    },
    {
        "content": "<p>yes, a rest-hook subscription with a notification with no payload, and a subsequent polling of data by the subscriber.</p>",
        "id": 153914093,
        "sender_full_name": "Allan Bro Hansen",
        "timestamp": 1508153064
    },
    {
        "content": "<p>oh - so that's just how it works</p>",
        "id": 153914094,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508153134
    },
    {
        "content": "<p>To avoid confusion I would say 'subsequent GETting the data by the subscriber', since 'polling' is often understood as 'periodically querying the server to see whether there is any data of interest'.</p>",
        "id": 153914095,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1508153216
    },
    {
        "content": "<p>I agree but still I think polling is the correct term: With the POST of the no-payload-Subscription, the subscriber just knows that there is a big chance of getting data of interest. <br>\nAnyways: sorry for the confusion :-)</p>",
        "id": 153914096,
        "sender_full_name": "Allan Bro Hansen",
        "timestamp": 1508153554
    },
    {
        "content": "<blockquote>\n<p>What does polling a REST service has to do with subscriptions?<br>\nWith polling you are guaranteed to become stale right after you as a client has polled. So the sentence makes little sense</p>\n</blockquote>\n<p>Correct.  There are pull based subscriptions (GET polling), and there are push based subscriptions (database hooks/triggers).   Much of the FHIR spec is designed around REST based architectures, so most people think of GET polling by default.  But messaging and other architectures are supported; and the Meteor community has been using push-based FHIR subscriptions over websockets for nearly 2 years now; with at least a half-dozen production implementations.</p>",
        "id": 153914168,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1508184937
    },
    {
        "content": "<p>The current spec of subscription needs some TLC and I agree with <span class=\"user-mention\" data-user-id=\"192120\">@Allan Bro Hansen</span> . IMHO, the scheme defined with an empty body sent from the server to which a client subscribes more sounds like a notification to me - as in: you as a client is notified about that stuff has changed. It then forces the client to poll for the information - AND - in the mean time the state COULD have changed. This design can however be justified by means of security</p>",
        "id": 153916161,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1508970912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> I agree - polling is polling, IMHO. Polling by design is not determined by time - it is determined by initiative.</p>",
        "id": 153916163,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1508971070
    },
    {
        "content": "<p>And also - once a subscription is created, the server ought to send all the data matching the criteria. Otherwise, events can be lost in the timespan as stated currently where the client 1) is encouraged to do the search 2) submit the subscription</p>",
        "id": 153916165,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1508971268
    },
    {
        "content": "<p>between step 1 and 2 all kinds of stuff can happen</p>",
        "id": 153916166,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1508971307
    },
    {
        "content": "<p>Also, why is the following <strong>mandatory behaviour</strong>: \"<em>The consequence of this is that there is no notification when a resource is deleted, or when a resource is updated so that it no longer meets the criteria</em>.\". I would say it undermines the idea of an event based channel of data if only a selected part of the updates are sent. I could understand if such limitation was scoped by a given vendor by eg. being able to state this in the subscription resource,  but I do not understand why such limitation is the baseline</p>",
        "id": 153916167,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1508971748
    },
    {
        "content": "<p>A scenario would be the following: I as a client have an idea of the current state. I would now like to get notified if that idea of the current state changes - be that additions, updates or deletes. Omitting a notification of either one of those means that no matter how many events I'll ever receive, my idea of the state will never be complete and it will be (I guess) impossible to say how the state is not correct - without doing additional work</p>",
        "id": 153916172,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1508972450
    },
    {
        "content": "<p>That is why there is a discussion of event based vs search based criteria. Is currently defined as a search based criteria.  I think that would make the delete be discoverable</p>",
        "id": 153916184,
        "sender_full_name": "Eric Haas",
        "timestamp": 1508974912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> - the case where a resource changes so that it no longer matches a given criteria is just as important</p>",
        "id": 153916231,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1509000479
    },
    {
        "content": "<p>I know why it is very hard to implement reporting deletes, but I agree that it should not be prohibited to do so.</p>",
        "id": 153917909,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1510037626
    },
    {
        "content": "<p>In the case where the item no longer matches the criteria, what would you expect to be reported?<br>\nIf you receive the resource do you assume that the server knew that it _was_ in the scope previously, or now is, or is the server to fake a delete?</p>",
        "id": 153918959,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1510359746
    },
    {
        "content": "<p>Lets talk about it in amsterdam ;)</p>",
        "id": 153919226,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1510578262
    },
    {
        "content": "<p>link to Nikko's subscriptions issue: <a href=\"https://gist.github.com/jkiddo/e773d033c245c2c4fdef6d35cbe1a75b\" target=\"_blank\" title=\"https://gist.github.com/jkiddo/e773d033c245c2c4fdef6d35cbe1a75b\">https://gist.github.com/jkiddo/e773d033c245c2c4fdef6d35cbe1a75b</a></p>",
        "id": 153919752,
        "sender_full_name": "Kevin Marks",
        "timestamp": 1510759068
    },
    {
        "content": "<p>Subscription.reason ... why's that mandatory ... wouldn't the reason of the subscription be kind of obvious given its criteria? It seems a bit weird ...</p>",
        "id": 153968527,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1528748964
    },
    {
        "content": "<p>and would eg. GET [base]/?_type=Observation,Patient…[and so on]&amp;_lastUpdated=gt2018-10-01 as Subscription.criteria effectively be a way of specifying that all resources must be sent [except when deleting]</p>",
        "id": 153968529,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1528749122
    },
    {
        "content": "<p>reason... a human can provide additional context... 'this subscription is for the clinician ward round app' - says things that are useful that the technical query does not</p>",
        "id": 153968577,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528758916
    },
    {
        "content": "<p>and yes</p>",
        "id": 153968578,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528758918
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> </p>\n<blockquote>\n<p>reason... a human can provide additional context... 'this subscription is for the clinician ward round app' - says things that are useful that the technical query does not</p>\n</blockquote>\n<p>actually not ... with the current modelling a human/bot/whatever SHALL provide additional context - that is what I don't get. Why is that modelled as 1..1? Why this hard requirement? Why would one mandate a field where the content is mainly a narrative/unstructured data?</p>",
        "id": 153968778,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1528840089
    },
    {
        "content": "<p>pretty much the reason for that is that any resource design, we make as much as we can 1..1 to find out whether that's supportable. It's very hard to ever go the other way. In this case, is is it a problem to have some reason?</p>",
        "id": 153968788,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528844109
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, Umm, that's not the normal design rule.  The normal design rule is make things minOccurs=0 unless:<br>\na) you believe they're essential to be able to use the resource instance for pretty much every conceivable use-case<br>\nb) you believe almost all implementation should be able to populate the element all the time</p>",
        "id": 153968790,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1528844286
    },
    {
        "content": "<p>well, ok, within the framework of (b), if you think they should, it's better to try for 1.1 at the start than to try to elevate to that later</p>",
        "id": 153968796,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528844572
    },
    {
        "content": "<p>Sure.  But it's hard to make a case for (a) here...</p>",
        "id": 153968797,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1528844618
    },
    {
        "content": "<p>I am being able to create the subscription using Vonk server, rest-hook, through proper channel endpoint but the notifications are not being seen.</p>",
        "id": 153971722,
        "sender_full_name": "Sanjay Karmakar",
        "timestamp": 1529993210
    },
    {
        "content": "<p>How do you match the search criteria/pattern against a resource in memory? I can see two options: </p>\n<ol>\n<li><code>FhirPathEngine</code>: but I need to evaluate each criterion, and multiplied by all Fhir Versions, it is very cumbersome</li>\n<li><code>IGenericClient + InMemoryResourceMatcher</code>: but it needs a Fhir Server with SearchParameter capability. I do not have such a server.</li>\n</ol>\n<p>Has anyone efficiently tried matching a resource against a search pattern using the HAPI FHIR library?</p>",
        "id": 197653719,
        "sender_full_name": "A K Azad",
        "timestamp": 1589525952
    },
    {
        "content": "<p>I'm building a system for taking FHIR data and mastering (MDM) certain elements, and pushing certain elements to a data lake. The data we get (mostly practitioner/practitionerRole resources) can come in massive batches at times (1000s of resource entries). If that happens, and if we have a SubscriptionTopic and Subscription set up with a rest hook, how will that data be pushed. I know during the querying process, bundles are limited to 200 resource 'pages'. Will the subscription post multiple bundles in that case of 200 resources? Or Would it post a larger bundle? Or would it fail? Any guidance here would be super helpful. Thank you so much.</p>",
        "id": 213805700,
        "sender_full_name": "OS",
        "timestamp": 1603122453
    },
    {
        "content": "<p>You might want to raise this on <a class=\"stream\" data-stream-id=\"179229\" href=\"/#narrow/stream/179229-subscriptions\">#subscriptions</a></p>",
        "id": 213805840,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1603122511
    },
    {
        "content": "<p>Hello everyone, I would like to ask if there are already solutions for FHIR R4 that can be used as an alternative to subscriptions to notify applications as soon as certain resources are deleted.<br>\nIf it's possible, the method should not be polling-based.<br>\nIf I am properly informed, the SubscriptionTopic resource from Version 4.5.0: R5 Draft should allow the notification by deletion.<br>\nStill, I'm looking for a solution for R4.</p>",
        "id": 234189194,
        "sender_full_name": "Martin Hoffmann",
        "timestamp": 1618244899
    },
    {
        "content": "<p>if the r5 subscription changes work for you there is an IG to backport them into R4: <a href=\"https://build.fhir.org/ig/HL7/fhir-subscription-backport-ig/\">https://build.fhir.org/ig/HL7/fhir-subscription-backport-ig/</a></p>",
        "id": 234192830,
        "sender_full_name": "ryan moehrke",
        "timestamp": 1618246335
    },
    {
        "content": "<p>My current framework does not yet have the option to use the functionality of R5.<br>\nI am rather looking for a short-term possibility to implement a deletion notification in R4.</p>",
        "id": 234198314,
        "sender_full_name": "Martin Hoffmann",
        "timestamp": 1618248537
    },
    {
        "content": "<p>The backport is your best option, the backport = R4. You will need to configure your server somehow to detect deletes. If you can't do that, then you'll have to use a client side solution based on history and/or polling.</p>",
        "id": 234276402,
        "sender_full_name": "René Spronk",
        "timestamp": 1618296531
    }
]