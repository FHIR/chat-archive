[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> I'm looking at implementing the $lastN operation in my server. I'm feeling that it's a little underspecified. All your examples include a category parameter, but it doesn't say that the category parameter is mandatory. But what would you return with a category? maybe you could list a set of codes instead of a category? but you must do one or other (and not both?)</p>",
        "id": 153897609,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1500633636
    },
    {
        "content": "<p>the specification also says nothing about whether the last n observations is the last n good observations, or whether errors are included as well</p>",
        "id": 153897688,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1500646345
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> ping</p>",
        "id": 153898498,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501107985
    },
    {
        "content": "<p>\"But what would you return with a category\" should have been \"But what would you return without a category\"</p>",
        "id": 153898499,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501108017
    },
    {
        "content": "<p>\"All your examples include a category parameter, but it doesn't say that the category parameter is mandatory. But what would you return with a category? maybe you could list a set of codes instead of a category? but you must do one or other (and not both?)\"  ?  </p>\n<p>do you mean \"But what would you return without a category?\"</p>\n<p>I don't think a category should be mandatory since is not mandatory in underlying resource....</p>",
        "id": 153898527,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501112696
    },
    {
        "content": "<p>if the client asks for lastN without a category, what's the server supposed to return?</p>",
        "id": 153898530,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501112773
    },
    {
        "content": "<p>the last N observations across all categories - essentially ignoring the category as a filter.</p>",
        "id": 153898532,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501113272
    },
    {
        "content": "<p>all kinds of observations? 1000s of them?</p>",
        "id": 153898533,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501113293
    },
    {
        "content": "<p>I agree without a code or a category is confusing.  <span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span> ?</p>",
        "id": 153898534,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501113360
    },
    {
        "content": "<p>I don't think there are 1000s of categories.  More than likely &lt;20</p>",
        "id": 153898535,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501113582
    },
    {
        "content": "<p>there's 1000s of observation codes</p>",
        "id": 153898536,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501113642
    },
    {
        "content": "<p>I think the client should have to specify a list of codes or a category</p>",
        "id": 153898537,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501113666
    },
    {
        "content": "<p>but there will be 1000s within a single category too?</p>",
        "id": 153898538,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501113695
    },
    {
        "content": "<p>well, that's a different problem. What should happen? I don't think it's useful to fetch the last 5 results for each kind of lab result. that's kind of a lot of results</p>",
        "id": 153898539,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501113751
    },
    {
        "content": "<p>I think is unlikely a single patient will have that many unique labs done.  maybe dozens.   I should make it clear that a subject is required though.</p>",
        "id": 153898540,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501113995
    },
    {
        "content": "<p>Will add restriction that</p>\n<p>a) Subject required<br>\nb) code(s) or category(s) required.</p>",
        "id": 153898541,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501114193
    },
    {
        "content": "<p>And see how works in Connectathon</p>",
        "id": 153898542,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501114213
    },
    {
        "content": "<p>dozens? take an ICU patient.... (likely substrate for lastN operation)</p>",
        "id": 153898543,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501114336
    },
    {
        "content": "<p>E&amp;Us, LFTS, calcium, full blood screen, blood gases, glucose, infection control monitoring... we're already out past 50 tests before we get to anything really disease specific</p>",
        "id": 153898544,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501114424
    },
    {
        "content": "<blockquote>\n<p>the specification also says nothing about whether the last n observations is the last n good observations, or whether errors are included as well</p>\n</blockquote>\n<p>What do you mean status = \"entered in error\"   If so I would say yes include those will ask at connectathon</p>",
        "id": 153898545,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501114431
    },
    {
        "content": "<p>and likely they'll have extensive work ups for enodocrine or cardiac stuff...</p>",
        "id": 153898546,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501114446
    },
    {
        "content": "<p>I'll include entered in error etc</p>",
        "id": 153898547,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501114485
    },
    {
        "content": "<p>Agree that the sickest will have hundreds of tests... but the consumer isn't being picky they want to scan the results for what they need and they won't know a priori what tests to ask for...</p>",
        "id": 153898548,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501114814
    },
    {
        "content": "<p>If you're worried about volume, set N to 1 and constrain the timeframe to the last year or so.  That should be a manageable set.  You can then probe deeper on the ones of interest.</p>",
        "id": 153898594,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1501118604
    },
    {
        "content": "<p>i'm back looking at this. this is hard.</p>",
        "id": 153899561,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501395407
    },
    {
        "content": "<p>According to the operation definition:</p>",
        "id": 153899562,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501395421
    },
    {
        "content": "<p>The response from a lastn query is a set of observations:<br>\n- filtered by additional parameters<br>\n- 'GROUP BY' Observation.code<br>\n- sorted from most recent to the oldest</p>",
        "id": 153899563,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501395448
    },
    {
        "content": "<p>what does it mean to group by a <em>CodeableConcept</em>?</p>",
        "id": 153899564,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501395472
    },
    {
        "content": "<p>what happens if there's more than one coding in there? What happens if the codings differ? are they in the group?</p>",
        "id": 153899565,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501395502
    },
    {
        "content": "<p>what if there's no codings, and just a text?</p>",
        "id": 153899566,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501395516
    },
    {
        "content": "<p>Is there a definition of equality for CodeableConcept? For CQL, we defined it as the intersection of codings is non-empty, though it should probably be tweaked a bit to take the text into account when there are no codings.</p>",
        "id": 153899572,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501402799
    },
    {
        "content": "<p>it's not clear to me that you want to group by the 'intersection is non-empty'</p>",
        "id": 153899573,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501402887
    },
    {
        "content": "<p>Isn't that what it would mean for two CodeableConcepts to be equal?</p>",
        "id": 153899574,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501402941
    },
    {
        "content": "<p>I think for the group by case it might be useful to aggregate all the codings into the resulting CodeableConcept, but that would just be a nice-to-have.</p>",
        "id": 153899575,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501403007
    },
    {
        "content": "<p>\"'GROUP BY' Observation.code  \"  When I wrote that I was thinking  that you would  consider all codings to be equals so.</p>",
        "id": 153899596,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501444228
    },
    {
        "content": "<p>So maybe we need to have to nominate a code system to group by?</p>",
        "id": 153899597,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501444259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span> ?</p>",
        "id": 153899600,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501444584
    },
    {
        "content": "<p>even nominating a code system doesn't solve it - observations might have more than one LOINC code, for example</p>",
        "id": 153899603,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501445668
    },
    {
        "content": "<p>But in that case they would be different CodeableConcepts, right?</p>",
        "id": 153899605,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501446829
    },
    {
        "content": "<p>no you might translate a more specific LOINC to a general one.</p>",
        "id": 153899607,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501447888
    },
    {
        "content": "<p>I assume we are  talking about when there  are no codes given in the input query.    In that case, I think Bryn's approach make's sense from the consumer aspect.  I don't want to be looking at duplicate results just because one set is LOINC and the other a local code system.   If there a codings then they are translations and can group the results based their 'translational equivalence'.</p>",
        "id": 153899608,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501448604
    },
    {
        "content": "<p>In re to text only -   they are grouped based on exact string matches.   no way to get around that one.</p>",
        "id": 153899609,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501448670
    },
    {
        "content": "<p>Hope to hear from Jenni</p>",
        "id": 153899610,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501448692
    },
    {
        "content": "<p>well, from my perspective, this operation is too hard to implement. I figure that server implementers are going to be in one of 2 situations<br>\n- a server like mine, that is purely based on FHIR. I don't know how to group consistently, unless the client specifically nominates a group=code,code,code that defines how they want the grouping to work<br>\n- an existing EHR that already has grouping capability, based on their own internal structures. This EHR can group however they can already group, but they'll have little capability to vary their grouping or filtering as envisaged in the operation</p>",
        "id": 153899616,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501452550
    },
    {
        "content": "<p>the combination of 'any search parameter' + group by a repeating element is a lethal combination in terms of semantics and engineering efficiency</p>",
        "id": 153899617,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501452582
    },
    {
        "content": "<p>There's a real simple way for me to implement this functionality but it's loosely controlled and I don't know whether the fact that it's easy is an accident of my implementation, but:</p>",
        "id": 153899621,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501454380
    },
    {
        "content": "<ul>\n<li>we already document that sort works this way: \"A search parameter can refer to an element that repeats, and therefore there can be multiple values for a given search parameter for a single resource. In this case, the sort is based on the item in the set of multiple parameters that comes earliest in the specified sort order when ordering the returned resources\"</li>\n<li>I can group by the sort parameter very easily, and return the top N results per group. It's a walk in the park....</li>\n<li>but: sort order earliest is not defined for Codings, and it's just random in my system</li>\n</ul>",
        "id": 153899622,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501454581
    },
    {
        "content": "<p>I agree that we should define equality for a codeable concept. I'll dig into what this is in my system right now, but I'm betting it's by the \"user chosen\" code. In our case, proprietary.</p>",
        "id": 153899723,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1501534035
    },
    {
        "content": "<p>However, we could implement in FHIR in other ways, most likely (eg: via intersection?)</p>",
        "id": 153899724,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1501534061
    },
    {
        "content": "<p>We do support either category or code essentially in our system, as the filter. You would need one of those. We haven't defined how it would work for SHx yet in our system, that was something I was looking forward to playing with/discussing at the connectathon.</p>",
        "id": 153899725,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1501534121
    },
    {
        "content": "<p>I think it's important to figure out how to do this, it's probably one of the most asked for pieces of functionality we have been waiting on, and one of the most used within our system</p>",
        "id": 153899727,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1501534190
    },
    {
        "content": "<p>For viewing things qualified as \"observations\" :)</p>",
        "id": 153899729,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1501534204
    },
    {
        "content": "<p>I would be surprised if we're the only system that has something like this. If that's true... very important to know</p>",
        "id": 153899730,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1501534234
    },
    {
        "content": "<p>but do you support other filters than that? could I cross patients? could I filter out to a data range? the lastN operation as it is applies over the top of an observation search. It's the combination that bites - I can't prepare a special table for it, because it applies to the outcomes of a special search. And I don't know how to generate it on the fly</p>",
        "id": 153899744,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501537769
    },
    {
        "content": "<p>and i'm not sure the definition of equality helps - if some observations are coded with a LOINC code and an MDC code, and some just have the LOINC code, do you want them separate in the groups  even though they are the same LOINC code? but in other cases, the presence of an MDC code very definitely makes a difference</p>",
        "id": 153899746,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501537850
    },
    {
        "content": "<p>I'd say yes to that last question.  Like I said before the consumer of the information doesn't want to have to look at repeats for the same information and have to figure it out.  That is the purpose of the whole operation and  why the grouping is key to the operation.   I think the Category element  or device filter would be used if that is important.</p>",
        "id": 153899747,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501538195
    },
    {
        "content": "<p>yes to which option? and I don't see how your comment clarifies</p>",
        "id": 153899749,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501538504
    },
    {
        "content": "<p>To answer some of the filters: I will say that in our system, you can't cross patients for most clinical queries. This is true for  this \"operation\" within our EHR as well</p>",
        "id": 153899754,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1501538863
    },
    {
        "content": "<p>oops I misread the question </p>\n<p>\" i'm not sure the definition of equality helps - if some observations are coded with a LOINC code and an MDC code, and some just have the LOINC code, do you want them separate in the groups even though they are the same LOINC code?\"</p>\n<p>answer is NO  -  they should be  in same group and  that is what I think Bryn meant \"intersection of codings is non-empty\"</p>",
        "id": 153899756,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501539568
    },
    {
        "content": "<p>Was never intended for multiple subjects so don't know why you are asking about cross patient searches.  I  updated the definition to say 'A subject using either the patient or subject search parameter'.</p>",
        "id": 153899757,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501539830
    },
    {
        "content": "<p>ok. I shouldn't have asked about cross-patient searches. Wasn't paying enough attention. Still, the grouping is problematic If the same MDC code appears on paired with 2 different LOINC codes, then what?</p>",
        "id": 153899758,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501540062
    },
    {
        "content": "<p>I think additional query  filters would need to be used by client the if that is important.(category, device, code)   That is a tricky mapping question even if I was sitting there doing it myself and I think its out of scope of what we expect the operation to do.</p>",
        "id": 153899759,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501540349
    },
    {
        "content": "<p>what do you expect the operation to do? because that question arises naturally out of the data the operation is applied to</p>",
        "id": 153899760,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501540395
    },
    {
        "content": "<p>as a server, I don't have the choice of ignoring that situation</p>",
        "id": 153899761,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501540426
    },
    {
        "content": "<p>I'd say that the CodeableConcept for the result group would include both MDC codes and the LOINC code, that way you at least get deterministic behavior.</p>",
        "id": 153899762,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501540673
    },
    {
        "content": "<p>Its a crude method of  fetching N related things.</p>",
        "id": 153899763,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501540694
    },
    {
        "content": "<p>umm, what?</p>",
        "id": 153899764,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501540700
    },
    {
        "content": "<p>Who's that what for?</p>",
        "id": 153899765,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501540712
    },
    {
        "content": "<p>:)</p>",
        "id": 153899766,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501540713
    },
    {
        "content": "<p>you'll just keep aggregating as long as there's implicit joins?</p>",
        "id": 153899767,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501540716
    },
    {
        "content": "<p>because of combined MDC and LOINC codes</p>",
        "id": 153899768,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501540741
    },
    {
        "content": "<p>If a given CodeableConcept has both an MDC code and a LOINC code, it implies that they mean the same thing, right?</p>",
        "id": 153899769,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501540762
    },
    {
        "content": "<p>well, for that context. it's tricky because granualarity differs</p>",
        "id": 153899770,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501540796
    },
    {
        "content": "<p>More or less.  One concpet may be wider.</p>",
        "id": 153899771,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501540804
    },
    {
        "content": "<p>Well, I'm proposing we rely on that in this case to get a consistent and deterministic result. If Obs A has MDC code 1 and LOINC code X, and Obs B has MDC code 2 and LOINC code X, then the result group key would be a CodeableConcept with MDC code 1, MDC code 2, and LOINC code X, and the group would contain both Observations.</p>",
        "id": 153899772,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501540901
    },
    {
        "content": "<p>Well.... we could add a switch for group grossly and group finely.</p>",
        "id": 153899774,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501540924
    },
    {
        "content": "<p>If the definition of equality for this scenario for a CodeableConcept is \"the intersection of codes is not empty\", then it works.</p>",
        "id": 153899775,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501540946
    },
    {
        "content": "<p>and if Obs C has Loinc Code Y and MDC code 1?</p>",
        "id": 153899776,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501540990
    },
    {
        "content": "<p>but for starters I think Bryn's suggestion makes the most sense.</p>",
        "id": 153899777,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501540991
    },
    {
        "content": "<p>Then the group key would expand to include LOINC Code Y.</p>",
        "id": 153899779,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501541081
    },
    {
        "content": "<p>still group 1 right?</p>",
        "id": 153899780,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501541094
    },
    {
        "content": "<p>Yes</p>",
        "id": 153899781,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501541102
    },
    {
        "content": "<p>And yes, now we have a situation where we're asserting LOINC Code X = LOINC Code Y, but isn't that assertion implicit in the data anyway? This is just manifesting it because of how we're processing it.</p>",
        "id": 153899782,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501541120
    },
    {
        "content": "<p>so to implement this, I have to scan all the observations in the selection (potentially 100000s), determine the groupings in the this set of data, and then group</p>",
        "id": 153899783,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501541231
    },
    {
        "content": "<p>if somebody has translation of :</p>\n<ul>\n<li>animal, mammal, dog</li>\n<li>animal, mammal ,cat</li>\n<li>animal,bird,crow</li>\n<li>bird, rock</li>\n</ul>\n<p>They all get grouped together, warts and all.  Unless the clients filter by code.</p>",
        "id": 153899784,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501541319
    },
    {
        "content": "<p>No, you implement it generically just like you implement any group by. For each element in the list, determine the key, see if the key is a group you've encountered, if it is, the element goes in that group, if it's not, create a new group. The only difference in this case is that the comparison for \"is this a group I've encountered\" has the potential to update the key, but that's okay because the way equality is defined that doesn't change the semantics.</p>",
        "id": 153899785,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501541331
    },
    {
        "content": "<p>At least, that's how I'd implement it. :)</p>",
        "id": 153899786,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501541375
    },
    {
        "content": "<p>I would like to think that you are off by a couple of order of magnitude for &gt; 96% of patients.</p>",
        "id": 153899787,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501541416
    },
    {
        "content": "<p>uh? the problem is that according to your algorithm, I have to revisit the previous groupings because encountering a new combination changes the previous keys</p>",
        "id": 153899788,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501541430
    },
    {
        "content": "<p>I don't know, we're looking at use cases with device feeds that would quickly get there.</p>",
        "id": 153899789,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501541458
    },
    {
        "content": "<p>yes</p>",
        "id": 153899790,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501541466
    },
    {
        "content": "<p>Right, so if you encounter a code in the current group that has the potential to \"merge\" other groups. So index all the codes you've encountered and the groups they're part of, then it's still single-pass, you just may have to merge groups as you go.</p>",
        "id": 153899791,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1501541660
    },
    {
        "content": "<p>ok, so I figured out a really easy way to implement it if the equality is based on all codings. So here you go:</p>\n<div class=\"codehilite\"><pre><span></span>http://test.fhir.org/r3/Observation/$lastN?status=final&amp;category=vital-signs&amp;subject=Patient/123\n</pre></div>",
        "id": 153899873,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1501589636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span>  What is SHx?   <span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span>  can you share your grouping algorithm in pseudocode.</p>",
        "id": 153903436,
        "sender_full_name": "Eric Haas",
        "timestamp": 1503528743
    },
    {
        "content": "<p>I may be speaking out of turn, but clinically, in my experience and in the general clinical community, SHx is shorthand for \"Social History\"</p>",
        "id": 153903437,
        "sender_full_name": "Michael Hosking",
        "timestamp": 1503528818
    },
    {
        "content": "<p>Yes, we use SHx to mean Social History, too.</p>",
        "id": 153903560,
        "sender_full_name": "Michelle (Moseman) Miller",
        "timestamp": 1503579474
    },
    {
        "content": "<p>I was thinking something along the lines of:</p>",
        "id": 153903598,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1503593389
    },
    {
        "content": "<p>Operations:</p>\n<div class=\"codehilite\"><pre><span></span>  =(Coding, Coding) =&gt; That the Codings are equal for system, code, and version\n  =(CodeableConcept, CodeableConcept) =&gt; That the CodeableConcepts contain the same Codings\n  ~(CodeableConcept, CodeableConcept) =&gt; That the intersection of Codings in the CodeableConcepts is not empty\n</pre></div>\n\n\n<p>Structures:  </p>\n<div class=\"codehilite\"><pre><span></span>results Map&lt;CodeableConcept, List&lt;Observation&gt;&gt; // Using ~(CodeableConcept, CodeableConcept)\ncodeIndex Map&lt;Coding, List&lt;CodeableConcept&gt;&gt; // Using =(Coding, Coding)\n</pre></div>\n\n\n<p>Logic:</p>\n<div class=\"codehilite\"><pre><span></span>foreach obs in Observations\n  foreach code in obs.Code\n    key = results.key(code) // Get the current key for the observation\n    newKey = key == null ? code ? combine(key, code) // Create a new key with the combined codes\n    results.add(newKey, obs) // Add the observation to the newKey\n    if (key != newKey) // If the key is different (meaning there was a new coding introduced)\n      // collapse all the results that have any of the new codings into the new key\n      foreach newCoding in (newKey.coding minus key.coding)\n        foreach mergeKey in codeIndex[newCoding]\n          results.merge(mergeKey, newKey) // Merge the observations from the old key into the new key\n        codeIndex.remove(newCoding) // remove the codeIndex entry for the merged coding\n    foreach coding in newKey.coding\n      codeIndex.add(coding, newKey)\n</pre></div>",
        "id": 153903599,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1503593391
    },
    {
        "content": "<p>Now, to get that to work with the lastN, you'd have to either have an index on Observations by Code and Date, or you'd have to run it through the entire set and then apply the lastN to each resulting group.</p>",
        "id": 153903600,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1503593587
    },
    {
        "content": "<p>thanks!</p>",
        "id": 153903605,
        "sender_full_name": "Eric Haas",
        "timestamp": 1503597986
    },
    {
        "content": "<p>I have some questions about the LastN idea. </p>\n<p>The first one is: what is the problem this is trying to solve? Is there a clear requirement? It seems to me there isn't a clear purpose. Having said that...</p>\n<p>Searching for the \"last n\" is not limited to observations. As an application developer, whenever there is a many-one time series relationship between two resources, a way to find the last n of those will likely be useful. For example: MedicationAdministration, ImagingStudy, Procedure, Immunization, NutritionOrder, and Claim could all use \"last n\" search.</p>\n<p>It isn't clear that \"last n\" is needed, though. Search already allows for restricting the number of results (per page) using _count, and using _sort on issued ensures that the desired results are all on the first page, in order.</p>\n<p>The stipulation that the results should \"not [include] the same observation with changes in status or versions\" is reasonable, but this seems like a general requrement as an option for search on any resource.</p>\n<p>The request to group the results seems reasonable, but is more generally applicable to search for any Resource.</p>\n<p>The talk of a \"server algorithm of some kind\" appears to be</p>",
        "id": 153905450,
        "sender_full_name": "Jonathan Shultlis",
        "timestamp": 1504990976
    },
    {
        "content": "<p>The imaginary server algorithm is fuzzy. If there is need for some kind of client-specified filter or predicate, could that be packaged as a script (in a limited language)? Scary shades of proprietary server plugins, or client-supplied scripts...</p>",
        "id": 153905452,
        "sender_full_name": "Jonathan Shultlis",
        "timestamp": 1504991348
    }
]