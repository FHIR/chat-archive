[
    {
        "content": "<p>Hello all, code generation XSD schemas for the FHIR base profiles are available <a href=\"https://www.hl7.org/fhir/downloads.html\">for download</a>. How were these XSD schemas generated? Is there a way to generate XSD schemas programmatically for custom FHIR profiles? Thanks in advance, Marcus.</p>",
        "id": 224740883,
        "sender_full_name": "Marcus Wurlitzer",
        "timestamp": 1612193005
    },
    {
        "content": "<p>The schemas for FHIR core are generated by custom code that's part of the FHIR publication process.  There are no schemas published for profiles, largely because such schemas are generally unhelpful.  Schema has no ability to support 'slicing', which is a key aspect of profile design (setting different constraints on different repetitions in an instance).  Good profiles generally don't constrain overall cardinality much because that interferes with interoperability.  (A profile shouldn't say \"Patient can only have one name\", but instead \"Patient should have one name that meets these constraints\" - and XML schema has no ability to enforce the latter.)</p>",
        "id": 224751630,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612196777
    },
    {
        "content": "<p>Thanks a lot for your answer. So, while the complexity FHIR profiling allows for cannot be covered by XSD schemas, I am still thinking about whether they might be a useful tool for us to implement a specific FHIR profile. For instance, say we can safely assume that the resources we will create from our data source will always conform to a certain slicing variant of a profile; then a corresponding XSD schema might help us with code generation and avoid manual implementation of classes that conform to that profile variant. Or am I on the wrong track here?</p>",
        "id": 224753465,
        "sender_full_name": "Marcus Wurlitzer",
        "timestamp": 1612197537
    },
    {
        "content": "<p>XSD can't enforce slices - it just doesn't have the technical capacity for multiple elements with the same name to have different constraints.</p>",
        "id": 224754553,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612197970
    },
    {
        "content": "<p>But one XSD could reflect a single slicing variant?</p>",
        "id": 224755924,
        "sender_full_name": "Marcus Wurlitzer",
        "timestamp": 1612198453
    },
    {
        "content": "<p>You should not generate custom classes corresponding to a profile, class structure cannot capture the important things that profile specifies (slicing, binding)</p>",
        "id": 224757758,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612199095
    },
    {
        "content": "<p>Schematron can do some of that however, if the intention is validation rather than say code generation</p>",
        "id": 224758228,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1612199272
    },
    {
        "content": "<p>Slicing means different rules for different repetitions.  Schema can't define rules for one repetition unless you prohibit all other repetitions.</p>",
        "id": 224758522,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612199391
    },
    {
        "content": "<p>So how is profile slicing and binding handled programmatically then? is it all \"soft-coded\" and not backed by any structures native to the language of implementation (e. g. classes)?</p>",
        "id": 224759108,
        "sender_full_name": "Marcus Wurlitzer",
        "timestamp": 1612199605
    },
    {
        "content": "<p>(note that I am viewing from the perspective of a \"data owner\" so to say. we have medical data that we want to represent as FHIR resources which should conform to national profiles.)</p>",
        "id": 224759486,
        "sender_full_name": "Marcus Wurlitzer",
        "timestamp": 1612199740
    },
    {
        "content": "<p>All 'soft coded'. Most of the work is in mapping codes</p>",
        "id": 224759788,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612199838
    },
    {
        "content": "<p>That's the part where profiles are more relevant, the rest of the work is mostly just to generate FHIR structures, that do not really depend on profiles (and for which classes matching the general FHIR structure are very useful)</p>",
        "id": 224760146,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612199968
    },
    {
        "content": "<p>Hmm. So, for example, when the German FHIR profile for Patient defines several custom fields as extensions - you would advise against creating a derived class that contains these fields so I can map them just like any other regular field?</p>",
        "id": 224761206,
        "sender_full_name": "Marcus Wurlitzer",
        "timestamp": 1612200400
    },
    {
        "content": "<p>What you do with your internal software is totally up to you.  However, the XML and JSON are going to represent extensions as all one element and there's no chance of having a schema that will differentiate different extension requirements.</p>",
        "id": 224761712,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612200636
    },
    {
        "content": "<p>Right. I better understand the limitations now. Thank you. :)</p>",
        "id": 224762702,
        "sender_full_name": "Marcus Wurlitzer",
        "timestamp": 1612201044
    },
    {
        "content": "<blockquote>\n<p>would advise against creating a derived class that contains these fields</p>\n</blockquote>\n<p>Yes, I advise against it, because if you do that you will also have to write custom serializer / de-serializer for your derived class</p>",
        "id": 224762949,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612201133
    },
    {
        "content": "<p>@Marcus I guess that is a different question :-) That seems reasonable to me, but whether the best route to that is via XSD, I am not so sure. </p>\n<p>But at any rate, in general, there are not XSDs created for profiles. The reason is that they can only cover some aspects of profiles. But there is nothing to stop you manually extending your XSD to add these extensions, and then code generating. You just cannot currently get the XSDs from the profiles automatically.</p>\n<p>If you want code generation then a better route is perhaps to use the FHIR base structure definitions, plus the profile structure definitions. All the information is there. But I don't know of code generation that works directly from those. Some of the existing code frameworks (e.g. C#, java) have code generation from the base structure defs, but I don't know about from profiles. I have not heard of that existing but it seems plausible. </p>\n<p>Yet another route is to change the base FHIR structures to add the extensions, as if they were normal named elements (cheat, basically), and then run that as a new custom build. Then you would get XSDs generated with the extra elements. Just don't check it back in :-)</p>",
        "id": 224763291,
        "sender_full_name": "Rik Smithies",
        "timestamp": 1612201286
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191651\">@Rik Smithies</span> Yes, these are very much my thoughts. Actually I have been thinking about a \"canonical\" way to generate code (such as a classes) from FHIR profiles. The XSD route was one approach, but due to its limitation it seems as though it will never become canonical anyway.</p>\n<p>So I might go the 'cheat' route, but probably class-based rather than XSD-based – I still have to work out the implications of that approach (such as possibly the need for custom serialization routines as Michele pointed out, for instance).</p>",
        "id": 224765329,
        "sender_full_name": "Marcus Wurlitzer",
        "timestamp": 1612202126
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263785\">@Marcus Wurlitzer</span> it's on my todo list to write a generator for HAPI that takes a profile and generates a series of facade classes that provide an interface to the underlying FHIR POJOs but express the semantics of the profile </p>\n<p>e.g. extensions get native accessors, there's no accessor for things that aren't allowed, and slices become named accessors. </p>\n<p>it hasn't happened because the last item - which is necessary to make it work - is super hard.</p>",
        "id": 224939362,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612301330
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> great to know, thanks. I agree it is a sophisticated task, like building a compiler, basically.</p>",
        "id": 224988336,
        "sender_full_name": "Marcus Wurlitzer",
        "timestamp": 1612342464
    },
    {
        "content": "<p>This is very interesting.</p>\n<p>I am currently looking for exactly this, how to create Resources for custom Profiles:</p>\n<ul>\n<li><a href=\"#narrow/stream/179167-hapi/topic/dynamic.20creation.20of.20resources\">https://chat.fhir.org/#narrow/stream/179167-hapi/topic/dynamic.20creation.20of.20resources</a></li>\n</ul>\n<p>One idea was to implement a code generator, which takes the profiles and outputs all the necessary accessor methods to create resources on the fly. Or preferably not even code generation, but at least some dynamic way to create Resources for a given Profile, without hardcoding every special case.</p>\n<p>Apparently, this has never been done before, and described here as \"super hard\". So I guess the manual hardcoding is the way to go?</p>",
        "id": 225549623,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612793771
    },
    {
        "content": "<p>Be aware that if you're using custom resources, you're not FHIR conformant and won't be interoperable with FHIR systems.  The interoperable approach is to use Basic.</p>",
        "id": 225570974,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612802300
    },
    {
        "content": "<p>that wasn't what <span class=\"user-mention\" data-user-id=\"381442\">@Marc Günther</span> meant. He was talking about \"resources\" as custom generated POJOs in a HAPI framework</p>",
        "id": 225620252,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612824053
    },
    {
        "content": "<p>the attraction of doing it manually is that you can pick and choose how much complexity to get involved with</p>",
        "id": 225620287,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612824077
    },
    {
        "content": "<p>I do think it's possible, if you have a good FHIRPath engine, and a solid fast terminology server supporting you, to do it entirely automatically, but I'm not sure it's possible to do it fast enough for production without being able to pick and choose</p>",
        "id": 225620400,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612824128
    },
    {
        "content": "<p>Sorry, I don't want to hijack this thread, but this sounded at least somewhat related to my problem...</p>\n<p>I am currently looking for a way to dynamically create Resources that conform to the _German Corona Consensus Data Set_ (Gecco), as I would like to avoid writing 68 Methods like the following example:</p>\n<ul>\n<li><a href=\"https://groups.google.com/g/hapi-fhir/c/3Aydx6uAOWs\">https://groups.google.com/g/hapi-fhir/c/3Aydx6uAOWs</a></li>\n</ul>\n<p>Apparently, no one has ever done this before, and given that I am very new to this entire FHIR thing (for example I do not have the slightest idea what is  a terminology server,  why I would need one, nor why it would need to be fast), I guess I need to bite the bullet, and write custom code for all 68 Profiles by hand...</p>\n<p>Regarding FHIRPath, I found a <em>FHIRPathResourceGenerator</em>, that has just recently been merged into HAPI, which sounded very interesting:</p>\n<ul>\n<li><a href=\"https://github.com/hapifhir/hapi-fhir/pull/2310/commits/5b3975df145b4cd0776230168d2603afc0172176\">https://github.com/hapifhir/hapi-fhir/pull/2310/commits/5b3975df145b4cd0776230168d2603afc0172176</a></li>\n</ul>\n<p>Unfortunately, it doesn't seem to support lists of values (slicing?).</p>",
        "id": 225675033,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612870222
    },
    {
        "content": "<p>My suggestion would be _not_ to create any custom class, just use the standard FHIR classes for the resources in whatever library you are using. Not worth the trouble</p>",
        "id": 225697106,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612880972
    },
    {
        "content": "<p>Yes, that's what I did in the example I posted above. I use normal _Observation_ class from HAPI library. But I still need to write 68 of these methods, and I would like to avoid that...</p>",
        "id": 225698057,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612881289
    },
    {
        "content": "<p>You have to code the mapping rules _somewhere_. If you have the mapping rules in some sort of standard format that is not code you could write mapping code that use them - just creating the standard FHIR classes</p>",
        "id": 225698643,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612881520
    },
    {
        "content": "<p>But in my experience as soon as you get in the details of each individual mapping you'll find that a general approach is hard to use - because mappings vary depending on different values, terminology mismatch etc</p>",
        "id": 225699236,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612881781
    },
    {
        "content": "<p>(our server implementation has 47K lines of code handling the mapping to / from FHIR of our data model)</p>",
        "id": 225700294,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612882191
    },
    {
        "content": "<p>Well, I have no control over the format of the source data. It could be anything.</p>\n<p>As I wrote in that other thread (sorry for hijacking this one), other people (with the neccessary domain knowledge) will define the mapping from their specific set of source data into FHIR.</p>\n<p>My task is to provide the system (a UI to configure the mapping, and a process to execute it), which allows those other people to define their mappings.</p>\n<p>I was hoping that the StructureDefinitions are enough to implement this in some generic way, without hardcoding the Gecco Profiles into my source code. This would allow us to support other profiles later, by simply uploading their StructureDefinitions.</p>\n<p>But, unfortunately, it seems that this is not possible, or at least very hard. So, I guess I have to implement 68 different methods (one for each Gecco Resource), with a huge switch/case statement in front.</p>\n<p>Is this really the way to go about this? It feels so wrong in every possible way.</p>",
        "id": 225703859,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612883543
    },
    {
        "content": "<p>If you're talking about mappings, that's StructureMap, not StructureDefinition.</p>",
        "id": 225714756,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612887573
    },
    {
        "content": "<p>From the Gecco Downloads page, I can download a zip file which contains lots of StructureDefinitions:</p>\n<ul>\n<li><a href=\"https://simplifier.net/forschungsnetzcovid-19/\">https://simplifier.net/forschungsnetzcovid-19/</a></li>\n</ul>\n<p>I have nowhere seen a download that does contain a StructureMap.</p>",
        "id": 225728757,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612892896
    },
    {
        "content": "<p>There won't be any standard StructureMaps.  The StructureMaps need to be created based on what you're mapping to or from - and of course that's not \"standard\" and can't be published as part of the spec.</p>",
        "id": 225735337,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612895536
    },
    {
        "content": "<p>Well, as I said, I don't know from what I'm mapping from.</p>\n<p>I need to implement a mechanism that allows others to define some mapping from their arbitrary data structure to FHIR/Gecco.</p>\n<p>For that, the question was, if there is some generic way to generate the FHIR Resources based on the Gecco StructureDefinitions, without reimplementing and hardcoding entire of Gecco in Java. The answer seems to be, it has never been done, at least not with HAPI, it's not clear that it can be done, and if it is, it probably is super hard to implement.</p>\n<p>Which sounds strange, as there seems to be a Validation mechanism in Hapi, which can read StructureDefinitions and validate Resources against them (at least that's what I understood from the docs?). So if there is enough information to validate resources, there should be enough information to generate them, no? And the code which does all the heavy lifting of understanding those StructureDefinitions (eg. applying differentials) could be easily adapted to that use case.</p>\n<p>The reason I wrote here, is because of Grahame's comment:</p>\n<blockquote>\n<p>it's on my todo list to write a generator for HAPI that takes a profile and generates a series of facade classes that provide an interface to the underlying FHIR POJOs but express the semantics of the profile</p>\n</blockquote>\n<p>which sounds very much like what I am looking for.</p>",
        "id": 225748840,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612901012
    },
    {
        "content": "<p>I don't really understand what you are trying to do</p>",
        "id": 225749133,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901128
    },
    {
        "content": "<p>yes, the HAPI code includes a validator that uses the structure definitions to validate json or xml and see that it conforms to the definitions.</p>",
        "id": 225749244,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901165
    },
    {
        "content": "<p>Oh ;)</p>",
        "id": 225749263,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612901172
    },
    {
        "content": "<p>but it doesn't inject any content from anywhere. It just knows what should be in the resources</p>",
        "id": 225749299,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901187
    },
    {
        "content": "<p>Also, the hapi code includes the code generator that creates the classes in org.hl7.fhir.r4.model etc</p>",
        "id": 225749367,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901219
    },
    {
        "content": "<blockquote>\n<p>So if there is enough information to validate resources, there should be enough information to generate them, no</p>\n</blockquote>\n<p>Definitely not</p>",
        "id": 225749382,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612901221
    },
    {
        "content": "<p>this knows how to create java classes that read and write the base FHIR resource classes.</p>",
        "id": 225749428,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901246
    },
    {
        "content": "<p>Ah</p>",
        "id": 225749432,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612901247
    },
    {
        "content": "<p>the dotnet stack has equivalent code</p>",
        "id": 225749450,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901255
    },
    {
        "content": "<p>the gecco structure definitions are a statement of additional rules over the top of these underlying definitions. They are a set of invariants on other class definitions, not a set of class definitions.</p>",
        "id": 225749590,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901305
    },
    {
        "content": "<p>Yes, they specify various differentials over stuff that is in FHIR Core, eg. Gecco-BodyWeight has some constraints on Core-BodyWeight.</p>",
        "id": 225749926,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612901433
    },
    {
        "content": "<p>so generating 'classes' that represent them isn't simple transform. The code generator doesn't know how to do that. (That's what on my todo list). But if you want a sense of the challenges involved in class generation, you could look at the validator code. Maybe, say, here:  <a href=\"https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.validation/src/main/java/org/hl7/fhir/validation/instance/InstanceValidator.java#L3457\">https://github.com/hapifhir/org.hl7.fhir.core/blob/master/org.hl7.fhir.validation/src/main/java/org/hl7/fhir/validation/instance/InstanceValidator.java#L3457</a></p>",
        "id": 225749967,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901449
    },
    {
        "content": "<p>but even if you had solved all that, and had a working class generator, I still don't know how that would \"implement a mechanism that allows others to define some mapping from their arbitrary data structure\"</p>",
        "id": 225750076,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901503
    },
    {
        "content": "<p>No, that part I can do.</p>",
        "id": 225750169,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612901530
    },
    {
        "content": "<p>so you could implement that on the base Resources, such as Observation, instead of on generated classes for the profiles themselves. Most of the challenges are in the mapping part, and generating the classes is low yield.</p>",
        "id": 225750521,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901670
    },
    {
        "content": "<p>I can say, ok, this field corresponds to BodyWeight, that field corresponds to BloodPressure.systolic, etc... And I need to take care of conversion of codings and units...</p>\n<p>The thing I don't know is how to create Gecco conformant FHIR Resources.</p>",
        "id": 225750534,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612901675
    },
    {
        "content": "<p>I'm not understanding this question. You just use the FHIR resources in the hapi classes, e.g. Observation, and make sure they follow the rules</p>",
        "id": 225750832,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612901814
    },
    {
        "content": "<p>Yes, I did an example of BodyWeight by creating an Observation, it's in that Google group posting:</p>\n<ul>\n<li><a href=\"https://groups.google.com/g/hapi-fhir/c/3Aydx6uAOWs\">https://groups.google.com/g/hapi-fhir/c/3Aydx6uAOWs</a></li>\n</ul>\n<p>But what I did there is basically just taking the BodyWeight example provided, and convert that into Java code.</p>",
        "id": 225750876,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612901835
    },
    {
        "content": "<p>So I need to write methods like this for all the 68 Gecco Resources?</p>",
        "id": 225751019,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612901900
    },
    {
        "content": "<p>so this is mostly about the fixed values, and not manually coding them?</p>",
        "id": 225751305,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612902048
    },
    {
        "content": "<p>Well, the fixed stuff, but also of course the values that come from the source data. BloodPressure for example has two, systolic and diastiolic.</p>",
        "id": 225751496,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612902127
    },
    {
        "content": "<p>And, of course, getting the information, that there ARE two values for BloodPressure. Which also is information that is available in the StructureDefinitions, that I don't want to replicate into Java.</p>",
        "id": 225751816,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612902266
    },
    {
        "content": "<p>the thing about the values that come from the source data is that the data acquisition is so variable...</p>\n<p>Here's how I've seen people handle this:</p>\n<ul>\n<li>\n<p>create a json/xml template that uses something like ST.template to fill out the content (xml is actually easier than json here, because of stinking commas, but the json parser in hapi can ignore commas) (also, much more sophisticated libraries that ST.template can be used - .e.g I've seen liquid, full blown PHP, etc)</p>\n</li>\n<li>\n<p>create a template with doesn't contain the empty elements, load it in hapi, fill out the missing bits with your actual data, and then you're done </p>\n</li>\n<li>\n<p>use a code generator to generate a factory the spits up the constructed resources/parts of resources, and then you orchestrate that from your code that is providing the data</p>\n</li>\n<li>\n<p>just build it manually as you do in your example there, on the basis that mostly, the boilerplate is less than the code that matters anyway</p>\n</li>\n</ul>",
        "id": 225752173,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612902435
    },
    {
        "content": "<p>Yea, point 3 is basically what I had in mind. Either a code generator, or just something that reads and understands the StructureDefinitions at runtime and acts accordingly.</p>",
        "id": 225752473,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612902574
    },
    {
        "content": "<p>But, it seems, this is super complicated to implement, so I probably will have to figure out something else.</p>",
        "id": 225752727,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612902678
    },
    {
        "content": "<p>well, it has to be interactive - the code generator doesn't know which slices or optional elements you're going to want, based on which data you have at hand.</p>",
        "id": 225752787,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612902702
    },
    {
        "content": "<p>I was even thinking of cheating, and just take all the examples they provide, and put wildcards in the appropriate places... :o</p>",
        "id": 225752904,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612902737
    },
    {
        "content": "<p>Yes</p>",
        "id": 225752924,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612902745
    },
    {
        "content": "<p>I have the guts of a code generator for HAPI, but it's aimed at making examples, uses all slices etc, and is implemented in pascal, so probably not useful for you</p>",
        "id": 225753519,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612903025
    },
    {
        "content": "<p>Pascal :)</p>",
        "id": 225753555,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612903051
    },
    {
        "content": "<p>Well, wow, I have a lot to think about now. Seems this is harder than I expected.</p>\n<p>Thanks Grahame for taking the time to answer all my questions, and sorry again for hijacking this topic! Hope I finally made sense in the end... ;)</p>",
        "id": 225754002,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612903242
    },
    {
        "content": "<blockquote>\n<p>this is harder than I expected.</p>\n</blockquote>\n<p>Everything is harder than expected. Especially when you decide to abstract</p>",
        "id": 225754327,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612903418
    },
    {
        "content": "<p>Well, I like generic solutions. I absolutely hate to duplicate code or hardcode stuff. It's a maintenance nightmare.</p>",
        "id": 225754472,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612903493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191912\">Michele Mottini</span> <a href=\"#narrow/stream/179166-implementers/topic/XSD.20Schemas.20from.20FHIR.20Profiles.20for.20Code.20Generation/near/225749382\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>So if there is enough information to validate resources, there should be enough information to generate them, no</p>\n</blockquote>\n<p>Definitely not</p>\n</blockquote>\n<p>Ah, I missed that yesterday.</p>\n<p>So which information is missing from the StructureDefinitions?</p>",
        "id": 225809561,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612948079
    },
    {
        "content": "<p>Where to get the data from, how to transform it</p>",
        "id": 225835184,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612963765
    },
    {
        "content": "<p>But I have the data.</p>",
        "id": 225848850,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612969462
    },
    {
        "content": "<p>For example, I have:</p>\n<ul>\n<li>two data values: 120 and 80</li>\n<li>a patient: c786ac3c-0579-4aa2-adda-db784b214ad6</li>\n<li>a date: 2020-09-25</li>\n</ul>\n<p>and I know that these two values correspond to the systolic/diastolic Bloodpressure values from this StructureDefinition:</p>\n<ul>\n<li><a href=\"https://simplifier.net/ForschungsnetzCovid-19/BloodPressure/~json\">https://simplifier.net/ForschungsnetzCovid-19/BloodPressure/~json</a></li>\n</ul>",
        "id": 225850212,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612970023
    },
    {
        "content": "<p>So I would think that this is enough information to produce this output:</p>\n<ul>\n<li><a href=\"https://simplifier.net/ForschungsnetzCovid-19/Observation-example-blood-pressure/~json\">https://simplifier.net/ForschungsnetzCovid-19/Observation-example-blood-pressure/~json</a></li>\n</ul>",
        "id": 225850342,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612970063
    },
    {
        "content": "<p>Yes, but the information on where those two values are and what they correspond to is not inside the StructureDefinition, it is  something _you_ know</p>",
        "id": 225850507,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612970144
    },
    {
        "content": "<p>I'm a software developer, so I don't want to hardcode that BloodPressure Profile in Java Code (along with all the 68 others from Gecco). Instead I would like to read the existing StructureDefinition, and then produce the result.</p>",
        "id": 225850535,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612970154
    },
    {
        "content": "<p>You need to have also something else that describe where the data is and where it goes to</p>",
        "id": 225850649,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612970192
    },
    {
        "content": "<p>Yes, that's what I wrote, I know that these two values correspond to systolic/diastolic bloodpressure</p>",
        "id": 225850683,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612970211
    },
    {
        "content": "<p>Yes, I have that</p>",
        "id": 225850694,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612970216
    },
    {
        "content": "<p>OK, I give up</p>",
        "id": 225850732,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1612970240
    },
    {
        "content": "<p>Sorry, I don't understand</p>",
        "id": 225850802,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612970270
    },
    {
        "content": "<p>I'm aware that years ago some Danes worked on a profile-based code generator, a variation of HAPI. But AFAIK we don't have this anymore, so you're stuck with HAPI itself. Which is as good as its gets. <br>\nIf you need something else, then you may have to create it - and please share whatever it is you'll be creating!</p>",
        "id": 225851038,
        "sender_full_name": "René Spronk",
        "timestamp": 1612970354
    },
    {
        "content": "<p>I would be glad to! :)</p>",
        "id": 225851103,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612970382
    },
    {
        "content": "<p>But I have the feeling that no one really understands what I'm talking about?</p>",
        "id": 225851179,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612970403
    },
    {
        "content": "<p>And for me, knowing not a lot about FHIR, StructureDefinitions seem super hard to understand.</p>",
        "id": 225851371,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612970473
    },
    {
        "content": "<p>For example, I wouldn't know how to apply a differential to a baseDefinition to get the actual snapshot in Hapi.</p>",
        "id": 225851419,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612970499
    },
    {
        "content": "<p>That's a good question for the #hapi stream..</p>",
        "id": 225852066,
        "sender_full_name": "René Spronk",
        "timestamp": 1612970732
    },
    {
        "content": "<p>(not to discourage you, but that's where the hapi experts hang out)</p>",
        "id": 225852128,
        "sender_full_name": "René Spronk",
        "timestamp": 1612970758
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> said before you need some sort of mapping information on how to get the data values (e.g., your two data values: 120 and 80) to the correct element. You would need to have the information from where you can get that information in your source data and where to place it. That can be generically represented in a StructureMap (not SteructureDefinition!) resource.</p>",
        "id": 225852306,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1612970822
    },
    {
        "content": "<p>Just based on the information present in the StructureDefinition there is no way of generically build a mapping and thus generate the wanted output.</p>",
        "id": 225852430,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1612970869
    },
    {
        "content": "<p>And if you have that information present, there is no real added value in having generated classes...</p>",
        "id": 225852812,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1612971007
    },
    {
        "content": "<p>Yea, I'm sorry, I think my questions didn't belong here in the first place...</p>",
        "id": 225853174,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612971158
    },
    {
        "content": "<p>You need to know what LOINC codes for blood pressure, systolic and diastolic and you need to know that the systolic and diastolic values go in Observation.component.value rather than separate Observation instances.  The only ways to capture that are to write custom code for each type of measurement (or perhaps a generic set of code that uses a table or something to map) or to write your own StructureMaps.  FHIR can't know what your values mean and map them for you.</p>",
        "id": 225854437,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612971649
    },
    {
        "content": "<blockquote>\n<p>You need to know what LOINC codes for blood pressure, systolic and diastolic</p>\n</blockquote>\n<p>Aren't these available in the StructureDefinition in:</p>\n<ul>\n<li>Observation.code.coding:loinc.code</li>\n<li>Observation.component:systolicBloodPressure.code.coding:loinc.code</li>\n<li>Observation.component:diastolicBloodPressure.code.coding:loinc.code</li>\n</ul>\n<p>?</p>\n<blockquote>\n<p>and you need to know that the systolic and diastolic values go in Observation.component.value rather than separate Observation instances.</p>\n</blockquote>\n<p>That I hoped would be apparent from the cardinality of the Observation.component which is 2..* and the slicing information in:</p>\n<ul>\n<li>Observation.component:systolicBloodPressure.value[x]</li>\n<li>Observation.component:diastolicBloodPressure.value[x]</li>\n</ul>\n<p>in the StructureDefinition.</p>\n<blockquote>\n<p>The only ways to capture that are to write custom code for each type of measurement (or perhaps a generic set of code that uses a table or something to map) or to write your own StructureMaps. </p>\n</blockquote>\n<p>Yes, that's what I hear. It seems rather unfortunate.</p>\n<blockquote>\n<p>FHIR can't know what your values mean and map them for you.</p>\n</blockquote>\n<p>Yes, of course it doesn't know that, and cannot map them for me automagically. I'm a little bit at a loss as to why this topic is brought up all the time, as I never asked about it.</p>\n<p>The system I'm currently writing will allow the source data owner to specify that:</p>\n<ul>\n<li>this source data value X will map to BloodPressure Profile with element path Observation.component:systolicBloodPressure.value[x], and</li>\n<li>that source data value Y will map to BodyWeight Profile with element path Observation.value[x]\"</li>\n</ul>\n<p>etc... </p>\n<p>That mapping mechanism is easy to implement, and will be completely generic. What I don't understand, how to generate the FHIR Resources in a generic way, without hardcoding/reimplementing entire of Gecco in Java.</p>",
        "id": 225870926,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612976230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"193430\">Alexander Zautke</span> <a href=\"#narrow/stream/179166-implementers/topic/XSD.20Schemas.20from.20FHIR.20Profiles.20for.20Code.20Generation/near/225852430\">said</a>:</p>\n<blockquote>\n<p>Just based on the information present in the StructureDefinition there is no way of generically build a mapping and thus generate the wanted output.</p>\n</blockquote>\n<p>I don't want to build a mapping automatically out of the StructureDefinitions. Of course this is not possible. They have no knowledge of the source data.</p>\n<p>What I need is:</p>\n<ul>\n<li>given a mapping that someone already defined (see above, that mapping knows everything about the source data, and where each value should end up in which Gecco Resource),</li>\n<li>to create the desired resources in a generic way.</li>\n</ul>",
        "id": 225873811,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612977374
    },
    {
        "content": "<p>Sorry, I don't really know how to explain this any better. I feel there is some fundamental misunderstanding here, which might entirely my fault, as I don't know FHIR and its use cases very much...</p>",
        "id": 225873937,
        "sender_full_name": "Marc Günther",
        "timestamp": 1612977428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"381442\">Marc Günther</span> <a href=\"#narrow/stream/179166-implementers/topic/XSD.20Schemas.20from.20FHIR.20Profiles.20for.20Code.20Generation/near/225870926\">said</a>:</p>\n<blockquote>\n<p>That mapping mechanism is easy to implement, and will be completely generic. What I don't understand, how to generate the FHIR Resources in a generic way, without hardcoding/reimplementing entire of Gecco in Java.</p>\n</blockquote>\n<p>You could allow the source data owner to look at the Gecco profiles and define a mapping between the source data elements and the final path to the corresponding element in FHIR. That's a manually process where the StructureDefinition doesn't help you a lot in the sense that you can't extract such information out of the profiles. Such a mapping can be captured and interpreted in a StructureMap resource. A StructureMap can be used if your source data elements can be uniquely identified and accessed in some way. The path of the target where you want to map to is not required to be bound to the profile. The slices and other details defined in the profile are important for validation but <strong>not</strong> for creating the profiles. It's sufficient to use the base classes. It's only necessary to look into the profile to see what elements are \"hard-coded\" like Observation.code.</p>",
        "id": 225877133,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1612978687
    },
    {
        "content": "<p>So the idea would be to go through the StructureDefinition, look for fixed values or patterns. Otherwise look up your mapping from the source to the target.</p>",
        "id": 225877259,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1612978747
    },
    {
        "content": "<p>If StructureMaps are too hard to generate or to interpret you can of course go with any other sort of mapping table</p>",
        "id": 225877959,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1612979013
    },
    {
        "content": "<p>And as an extra workaround you could also add the fixed elements from the profiles into your mapping table as well, so you only need to look at one source.</p>",
        "id": 225878192,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1612979092
    },
    {
        "content": "<p>Typically mappings are done to Observation, not to a particular profile.  Profiles, instead, simply guide where you choose to map.  So you won't map to an element called \"systolicValue\", instead, you'll map to Observation.component and assert that the code needs to have a specific LOINC coding and then map to the Observation.component.value.</p>",
        "id": 225887933,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1612982882
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"381442\">@Marc Günther</span> you can generate the snapshot using org.hl7.fhir.r5.conformance.ProfileUtilities. </p>\n<p>I could certainly write a resource generator that takes a profile and map of name / value pairs. It would construct the resource as specified in the profile, and marge in the data from the map, where the map name is the element id in the profile (in the snapshot).</p>\n<p>Here's the problems I would anticipate:</p>\n<ul>\n<li>the generator wouldn't know how to decide whether to include an optional complex element or not (unless there was an arbitrary rule that it's only included if there's matching data elements)</li>\n<li>for any repeating complex, you'd need to somehow match the data elements in the sub-elements to their matching pairs </li>\n<li>the values would have to be complex values, in some cases, but you wouldn't know how to generate the complex values (because the profiles don't always profile down to primitive elements). That's both a java typing problem, and a more fundamental problem that the generating code has to understand the profiles inherently.</li>\n<li>many profiles (don't know about the gecco)  still leave elements unspecified, elements you'd need to populate them. A profile based generator wouldn't be able to generate them</li>\n</ul>",
        "id": 225902382,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612988917
    },
    {
        "content": "<p>Thanks Grahame, <code>ProfileUtilities.generateSnapshot()</code> looks exactly like what I would need. That <code>processPaths()</code> method in there, which does the real work, looks like some serious piece of programming, there is absolutely no way I could understand how it works.</p>\n<p>I fear, what I had in mind (which is exactly what you describe, thanks, I'm glad someone finally understands what I'm talking about), requires some similar complexity, even without the problems you mentioned, so while I have no doubt that you could write something like this, I guess this is out of my league.</p>\n<p>So for now, I will try to hardcode Gecco in Java, I hope it should be possible without replicating too much code. Maybe later, when I got a better understanding of all the little details, I can try a more generic approach. That <code>generateSnapshot()</code> will definitely be very helpful.</p>\n<p>Thanks all for your help, I hope I didn't steal too much of your time.</p>",
        "id": 226018462,
        "sender_full_name": "Marc Günther",
        "timestamp": 1613061148
    },
    {
        "content": "<p>no problems. processPaths has grown slowly over the years. I wish I had taken a different approach but it's never got to the 'let's rewrite from scratch' point.</p>",
        "id": 226045740,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1613072035
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"381442\">@Marc Günther</span>  Integration/interface engines such as Mirth connect might provide some inspirations for your design of a generator and its UI.</p>",
        "id": 226461095,
        "sender_full_name": "Lin Zhang",
        "timestamp": 1613437950
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"381442\">@Marc Günther</span>  Seems like we're in the same boat stumbling to get into FHIR.<br>\nA few days ago I found <a href=\"https://simplifier.net/downloads/firely-terminal\">https://simplifier.net/downloads/firely-terminal</a>. This can be used to create snapshots from CLI.</p>\n<p>Snapshot generation is described at <a href=\"https://docs.fire.ly/projects/Firely-Terminal/CommonScenarios/SnapshotGeneration.html\">https://docs.fire.ly/projects/Firely-Terminal/CommonScenarios/SnapshotGeneration.html</a>.<br>\nMaybe this helps you.</p>",
        "id": 226488060,
        "sender_full_name": "Timo Rosenblatt",
        "timestamp": 1613466384
    }
]