[
    {
        "content": "<p>We are communicating observations between two systems, where both systems will have their unique instance of each observation, each with it's own internal id. </p>\n<p>What is the best way of communicating the ids across the systems? Should we only use <a href=\"http://resource.id\" title=\"http://resource.id\">resource.id</a>, or should we in addition also use observation.identifier? Each system will need to know the other systems internal id for mapping purposes I guess. But is it better to always communicate the internal id  also as an identifier so we get the identifier.system so it is possible to know from which system the id comes?</p>\n<p>This seems like a common situation, so looking for some  general strategy. Any recommendations?</p>",
        "id": 191710081,
        "sender_full_name": "Martin Grundberg",
        "timestamp": 1585123449
    },
    {
        "content": "<p><a href=\"http://Resource.id\" title=\"http://Resource.id\">Resource.id</a> is for the RESTful 'key'.  If the instance isn't exposed RESTfully, then use [resource].identifier.</p>",
        "id": 191757907,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1585148373
    },
    {
        "content": "<p><a href=\"http://Resource.id\" title=\"http://Resource.id\">Resource.id</a> is only unique in the context of a known base URL - and if you're not using REST, you don't know the base URL.</p>",
        "id": 191758081,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1585148424
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 191759906,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1585149100
    },
    {
        "content": "<p>The draft $import spec handles this by putting the source system in meta.source, but doesn't have a good place to put the ID so it adds an identifier extension on meta with system=[input source URI] and identifier=[resource type]/[ID on other system].</p>\n<p>There are lots of things not yet resolved with this idea, for example should it track multiple sources? How to represent source systems that aren't fhir, like the output of an ETL from a non-fhir source? Do we need a field on meta in R5 and if so should it replace or extend meta.source?</p>",
        "id": 191760023,
        "sender_full_name": "Paul Church",
        "timestamp": 1585149131
    },
    {
        "content": "<blockquote>\n<p><a href=\"http://Resource.id\" title=\"http://Resource.id\">Resource.id</a> is for the RESTful 'key'. If the instance isn't exposed RESTfully, then use [resource].identifier.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> this advice doesn't match what I would have said. Have we published it as guidance somewhere?</p>",
        "id": 191760193,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1585149195
    },
    {
        "content": "<p>(Er, I'm thinking primarily about reference.value vs reference.identifier when pointing from one resource to another -- the question is closely related)</p>",
        "id": 191760299,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1585149229
    },
    {
        "content": "<p>Seems when there are multiple sources, this is a use-case where Provenance should be brought in.</p>",
        "id": 191760995,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585149440
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> I don't know - what would you have said?</p>",
        "id": 191761023,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1585149448
    },
    {
        "content": "<p>it would be good to have a consistent way for someone importing original data from somewhere else, so that someone downstream knows that the copy they are looking at is not original and can easily find the original id. Otherwise we will be creating a de-duplication problem</p>",
        "id": 191761212,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585149505
    },
    {
        "content": "<p>This de-duplication problem was one of my thoughts with the proposals from DaVinci for providing a patient copies of the data that the payer has, while the provider is also providing that very same data. The app the patient is using should have a deterministic way to de-duplicate</p>",
        "id": 191761524,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585149589
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> This came up in discussion on the \"saner ig\" and I wrote: <a href=\"https://github.com/AudaciousInquiry/saner-ig/issues/14\" title=\"https://github.com/AudaciousInquiry/saner-ig/issues/14\">https://github.com/AudaciousInquiry/saner-ig/issues/14</a> (basically: I think using reference.value is the best, most general practice)</p>",
        "id": 191761708,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1585149634
    },
    {
        "content": "<p>The question wasn't about referencing, it was about the identity of the instance itself.  If you're referencing another resource, you can only use reference.value if the resource either has a URL where it can be reached usefully or if it's in the same Bundle as the referencing resource (and if not RESTfully available, you're stuck using urn:uuid:)</p>",
        "id": 191763465,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1585150175
    },
    {
        "content": "<p>(Or you can use Reference.identifier, but in that case, there's no expectation for resolution of the references when querying or performing other operations)</p>",
        "id": 191763642,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1585150229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197072\">Paul Church</span> <a href=\"#narrow/stream/179166-implementers/topic/Use.20of.20id.20and.20identifier/near/191760023\" title=\"#narrow/stream/179166-implementers/topic/Use.20of.20id.20and.20identifier/near/191760023\">said</a>:</p>\n<blockquote>\n<p>The draft $import spec handles this by putting the source system in meta.source, but doesn't have a good place to put the ID so it adds an identifier extension on meta with system=[input source URI] and identifier=[resource type]/[ID on other system].</p>\n<p>There are lots of things not yet resolved with this idea, for example should it track multiple sources? How to represent source systems that aren't fhir, like the output of an ETL from a non-fhir source? Do we need a field on meta in R5 and if so should it replace or extend meta.source?</p>\n</blockquote>\n<p>I understood the use of meta.source was to put the original root URI here, and keep the same id value within the importing system. If you keep the same id value, then you only need to know the original root URI to be able to re-discover the original. This however means an importing system must be able to use the original id value.</p>",
        "id": 191764037,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585150374
    },
    {
        "content": "<p>My point here is that any time you're able to populate <code>Reference.identifier</code> you could instead populate <code>Reference.value</code> with a contained resource (that conveys the identifier, and maybe extra details too. So IGs that require Reference.identifier are going to lead to more brittle exchange (since you just have to cross your fingers and assume that the receiving party knows what to do with this thing).</p>",
        "id": 191764077,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1585150384
    },
    {
        "content": "<blockquote>\n<p>I understood the use of meta.source was to put the original root URI here, and keep the same id value within the importing system. </p>\n</blockquote>\n<p>Unfortunately (in my view) we discussed and decided to leave the meaning/interpretation of Meta.source pretty wide open. Which means different IGs can establish different (and conflicting) conventions.</p>",
        "id": 191764192,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1585150428
    },
    {
        "content": "<p>(It is <code>Reference.reference</code>)</p>",
        "id": 191764313,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1585150464
    },
    {
        "content": "<p>yup, hence why I am concerned about the proliferation of de-duplication problem</p>",
        "id": 191764329,
        "sender_full_name": "John Moehrke",
        "timestamp": 1585150470
    },
    {
        "content": "<p><a href=\"http://jira.hl7.org/browse/FHIR-20906\" title=\"http://jira.hl7.org/browse/FHIR-20906\">FHIR#20906</a> is the context here, for those who didn't follow.</p>",
        "id": 191764362,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1585150483
    },
    {
        "content": "<p>And <a href=\"http://jira.hl7.org/browse/FHIR-20688\" title=\"http://jira.hl7.org/browse/FHIR-20688\">FHIR#20688</a>.</p>",
        "id": 191764485,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1585150523
    },
    {
        "content": "<p>A contained resource is appropriate if you're dealing with something that's not stand-alone.  Otherwise, no reason to make it contained.  (There's no expectation that receivers will un-contain on receipt).  If you want linkages retained and you don't have REST, you either need to transmit all the linked content in a single bundle or you're relying on non-standard processing to resolve identifiers</p>",
        "id": 191765890,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1585150997
    },
    {
        "content": "<p>.identifier is intended to convey business identifiers (site-independent identifiers) while .id is intended to convey a site-dependent identifier. So for the original question on this thread, if the originating system can also assign a .identifier then both systems would have their own .id and the same .identifier on their resource instances.</p>\n<p>.reference.value refers to a .id while .reference.identifier refers to a .identifier.</p>",
        "id": 191774700,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1585154102
    },
    {
        "content": "<p>.reference.value refers to a <em>URI</em> (of which a component is the .id).  The URI must either be a RESTful URL or a urn:uuid: in the context of a Bundle</p>",
        "id": 191781049,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1585156607
    },
    {
        "content": "<p>site-dependent identifiers can still be sent using .identifier</p>",
        "id": 191781137,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1585156645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191430\">Paul Knapp</span> <a href=\"#narrow/stream/179166-implementers/topic/Use.20of.20id.20and.20identifier/near/191774700\" title=\"#narrow/stream/179166-implementers/topic/Use.20of.20id.20and.20identifier/near/191774700\">said</a>:</p>\n<blockquote>\n<p>.identifier is intended to convey business identifiers (site-independent identifiers) while .id is intended to convey a site-dependent identifier. So for the original question on this thread, if the originating system can also assign a .identifier then both systems would have their own .id and the same .identifier on their resource instances.</p>\n<p>.reference.value refers to a .id while .reference.identifier refers to a .identifier.</p>\n</blockquote>\n<p>Would you say it is good practice to always include .identifier in addition to the .id, e.g. by having your own system namespace?. Then if it is persisted in another system, they could also persist that .identifier with their instance, and if they expose the same logical resource (their instance), they would include their .id, plus their .identifier and the original systems .identifier? Or is it only the originating system's .identifier that should be populated? The latter comes with the benefit of knowing where the \"master\" (which I assume could be useful).</p>",
        "id": 192008546,
        "sender_full_name": "Martin Grundberg",
        "timestamp": 1585311322
    },
    {
        "content": "<ol>\n<li>It's always good practice to include .identifier in a resource instance.</li>\n<li>If a resource is persisted in another system, it becomes it's own instance. Unless you have some specific business rules that keep the two instances of the resource in sync, they will diverge and are not the same thing. In such cases it is probably better for the \"second\" instance to use a \".basedOn\" or \".partOf\" reference to the original resource (when possible).</li>\n<li>using the same .identifier on two different instances of a resource needs to be considered on a case-by-case basis. Using it as an indication of where the original resource originated is overloading the meaning of .identifier, there are probably better ways to indicate that.</li>\n</ol>",
        "id": 192020441,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1585317545
    },
    {
        "content": "<p>\"basedOn\" and \"partOf\" would be appropriate if the record represents a distinct business object.  If you have 3 different systems tracking a given prescription, they shouldn't use 'basedOn' to point to each other unless one of them is clearly a distinct object (e.g. a pharmacy 'encoded' representation of the original order).  If you have multiple copies of an encounter, order, allergy, etc. on different systems they typically won't have any relationships to each other - though Provenance and/or Linkage might be used to indicate derivation relationships or assertions as to which is primary/source-of-truth.</p>",
        "id": 192024533,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1585319180
    }
]