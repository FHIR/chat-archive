[
    {
        "content": "<p>In the FHIR Connectathon Clinical Notes track (discussion here: <a href=\"#narrow/stream/58-connectathon-mgmt/subject/Clinical.20Notes.20Track\" title=\"#narrow/stream/58-connectathon-mgmt/subject/Clinical.20Notes.20Track\">https://chat.fhir.org/#narrow/stream/58-connectathon-mgmt/subject/Clinical.20Notes.20Track</a>), we wrestled with an issue that we think will become more prevalent the more common FHIR writes become.</p>",
        "id": 153961092,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526391521
    },
    {
        "content": "<p>If a client reads a resource, and an element in the resource has a code the client doesn't know, the client still got the resource.</p>",
        "id": 153961093,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526391562
    },
    {
        "content": "<p>This isn't ideal, but the client can work on mapping after the fact or can use the other elements of the resource if that's all the client needs.</p>",
        "id": 153961094,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526391620
    },
    {
        "content": "<p>But if a client attempts to write to a server and includes an element with a value the server doesn't know, the server is likely to refuse to file the resource.</p>",
        "id": 153961097,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526391659
    },
    {
        "content": "<p>So it's important that a client be able to discover what values the server will accept.</p>",
        "id": 153961099,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526391683
    },
    {
        "content": "<p>The two elements we struggled with in the Clinical Notes track were DocumentReference.type and DocumentReference.content.attachment.contentType.</p>",
        "id": 153961103,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526391796
    },
    {
        "content": "<p>We could profile our systems, and a client could get the CapabilityStatement to find the StructureDefinition to find the ElementDefinition to find the ValueSet.</p>",
        "id": 153961105,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526391919
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> mentioned something like an operation to ask <code>GET /ValueSet/$supported-at?element=DocumentReference.type</code> -- is this a real thing that's been defined before, or just an idea? (And if the latter... did I get the idea right?)</p>",
        "id": 153961106,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526392099
    },
    {
        "content": "<p>This approach poses two challenges:<br>\n1. Both of the EHRs in the Clinical Notes FHIR Connectathon track support different subsets of MIME for contentType incoming and outgoing. <br>\n2. This approach is <em>heavy</em>.  A client needs to hit multiple endpoints just to find out where the ValueSet it needs is.  I fear this would be burdensome to client developers.</p>",
        "id": 153961107,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392124
    },
    {
        "content": "<p>Sorry, comments out of order.</p>",
        "id": 153961108,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392138
    },
    {
        "content": "<p>Yes, <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> , that would work perfectly.</p>",
        "id": 153961109,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392152
    },
    {
        "content": "<p>It would also need to accept a direction or interaction type, since the incoming and outgoing ValueSet might not match.</p>",
        "id": 153961110,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392175
    },
    {
        "content": "<p>Do other people like <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span>'s idea?</p>",
        "id": 153961111,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392204
    },
    {
        "content": "<p>I think it'd need context, like </p>\n<div class=\"codehilite\"><pre><span></span>GET /ValueSet/$supported-at?element=DocumentReference.type&amp;action=note.write\n</pre></div>\n\n\n<p>... in the general case, since the same elements will be be used in different contexts/activities</p>",
        "id": 153961113,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526392276
    },
    {
        "content": "<p>Hmmm.</p>",
        "id": 153961114,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392314
    },
    {
        "content": "<p>True.</p>",
        "id": 153961115,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392334
    },
    {
        "content": "<p>I mean, maybe not -- but even for reading vs writing notes I'm imagining different types might be supported.</p>",
        "id": 153961116,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526392347
    },
    {
        "content": "<p>No, I think you're right.</p>",
        "id": 153961117,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392358
    },
    {
        "content": "<p>If someone is posting an Observation, different codes will be valid for labs or vitals.</p>",
        "id": 153961118,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392379
    },
    {
        "content": "<p>Sure. Pretty quickly we get into a pseudo-profiling language though.</p>",
        "id": 153961120,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526392408
    },
    {
        "content": "<p>Would it make sense to have a query parameter for <a href=\"http://hl7.org/fhir/valueset-type-restful-interaction.html\" target=\"_blank\" title=\"http://hl7.org/fhir/valueset-type-restful-interaction.html\">http://hl7.org/fhir/valueset-type-restful-interaction.html</a> and, as needed, another for category or whatever&gt;</p>",
        "id": 153961121,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392415
    },
    {
        "content": "<p>?</p>",
        "id": 153961122,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392416
    },
    {
        "content": "<p>Yeah, I think so.</p>",
        "id": 153961123,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526392437
    },
    {
        "content": "<p>I think most of the time, all creates for a resource will accept the same ValueSet all the time for a given element.</p>",
        "id": 153961124,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392450
    },
    {
        "content": "<p>We could start with that and expand it if and when someone needs it.</p>",
        "id": 153961126,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392463
    },
    {
        "content": "<p>Yup.</p>",
        "id": 153961127,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526392474
    },
    {
        "content": "<p>I started roughing something out over the weekend: <a href=\"https://simplifier.net/supportedvalueset/unnamedoperationdefinition\" target=\"_blank\" title=\"https://simplifier.net/supportedvalueset/unnamedoperationdefinition\">https://simplifier.net/supportedvalueset/unnamedoperationdefinition</a></p>",
        "id": 153961128,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392488
    },
    {
        "content": "<p>Oh, cool!</p>",
        "id": 153961134,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526392709
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191410\">@Brett Marquard</span> <span class=\"user-mention\" data-user-id=\"191358\">@Dennis Patterson</span> <span class=\"user-mention\" data-user-id=\"191914\">@Danielle Friend</span> <span class=\"user-mention\" data-user-id=\"191357\">@Andrew Torres</span></p>",
        "id": 153961135,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392718
    },
    {
        "content": "<p>What can I do to make it better?</p>",
        "id": 153961137,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392736
    },
    {
        "content": "<p>Does it make more sense to put the Resource and the element path into the same query parameter?</p>",
        "id": 153961139,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392838
    },
    {
        "content": "<p>Two quick things </p>\n<ul>\n<li>Deliver on your promise of \"Example to come\" :-) </li>\n<li>Figure out how to make the url not say <code>unnamedoperationdefinition</code></li>\n</ul>",
        "id": 153961140,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526392841
    },
    {
        "content": "<p>I think combining resource and element path isn't bad, given how pervasively <code>ElementDefinition</code> does this.</p>",
        "id": 153961141,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526392873
    },
    {
        "content": "<ul>\n<li>Done</li>\n<li>Ugh, I know.  I need to figure that out.</li>\n</ul>",
        "id": 153961142,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526392888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> do you know how to adjust the <code>unnamedoperationdefinition</code> path segment of <a href=\"https://simplifier.net/supportedValueSet/unnamedoperationdefinition/~overview\" target=\"_blank\" title=\"https://simplifier.net/supportedValueSet/unnamedoperationdefinition/~overview\">https://simplifier.net/supportedValueSet/unnamedoperationdefinition/~overview</a> ?</p>",
        "id": 153961143,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526393044
    },
    {
        "content": "<p><a href=\"https://simplifier.net/supportedvalueset/supported-at\" target=\"_blank\" title=\"https://simplifier.net/supportedvalueset/supported-at\">https://simplifier.net/supportedvalueset/supported-at</a></p>",
        "id": 153961144,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393060
    },
    {
        "content": "<p>Figured it out. :)</p>",
        "id": 153961145,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393066
    },
    {
        "content": "<p>Sweet!</p>",
        "id": 153961146,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526393069
    },
    {
        "content": "<p>Good that it apparently is discoverable how to do that.</p>",
        "id": 153961147,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1526393111
    },
    {
        "content": "<p>How do we model the response so that it can support scenarios where there are 0 valuesets found or more than 1 valuesets found?</p>",
        "id": 153961148,
        "sender_full_name": "Danielle Friend",
        "timestamp": 1526393173
    },
    {
        "content": "<p>Hmm. <span class=\"user-mention\" data-user-id=\"191914\">@Danielle Friend</span> one answer is that you always get one, which may be (in term) composed-of others. But I'd just as soon return a Bundle of 'em.</p>",
        "id": 153961150,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526393238
    },
    {
        "content": "<p>I thought about this more, <span class=\"user-mention\" data-user-id=\"191914\">@Danielle Friend</span> .</p>",
        "id": 153961151,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393270
    },
    {
        "content": "<p>Would it be better to return a Bundle or to allow the client to scope the request to make it clear which ValueSet it needs?</p>",
        "id": 153961152,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393305
    },
    {
        "content": "<p>But the answer even for a very specific request could still be \"none\", or \"these two are both good in your context\".</p>",
        "id": 153961153,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526393348
    },
    {
        "content": "<p>If we accept different values for Observation.code depending on the value in Observation.category, should there be a category parameter?</p>",
        "id": 153961154,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393363
    },
    {
        "content": "<p>I think it would also be valuable to support - give me all valuesets you could return for x resource - not specified by path.</p>",
        "id": 153961155,
        "sender_full_name": "Danielle Friend",
        "timestamp": 1526393380
    },
    {
        "content": "<p>If two are good in the same context, wouldn't that be one ValueSet?</p>",
        "id": 153961156,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393386
    },
    {
        "content": "<p>The compose can have multiple includes.</p>",
        "id": 153961157,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393423
    },
    {
        "content": "<p>That's what I meant about composed-of -- you can always do that.</p>",
        "id": 153961158,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526393427
    },
    {
        "content": "<p>But it may not be the easiest thing to consume.</p>",
        "id": 153961159,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526393434
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 153961160,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393439
    },
    {
        "content": "<p>Good point.</p>",
        "id": 153961161,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393445
    },
    {
        "content": "<p>Okay, I'm willing to accept that even <em>if</em> I could dismiss this case, there may be others.  And it's easier to make it return a Bundle now than to change it later.</p>",
        "id": 153961162,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393476
    },
    {
        "content": "<p>I think that would be great to try out at a connectathon and get feedback on - all in one valueset of composed of, or separate value sets</p>",
        "id": 153961164,
        "sender_full_name": "Danielle Friend",
        "timestamp": 1526393483
    },
    {
        "content": "<p>Also, having no results definitely seems likely. I asked for Medication Create.. well thats not supported, we have no valuesets to return. It'd be nice to have this work like a search where you'd get an operation explaining why</p>",
        "id": 153961166,
        "sender_full_name": "Danielle Friend",
        "timestamp": 1526393530
    },
    {
        "content": "<p>Sounds good.</p>",
        "id": 153961170,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393575
    },
    {
        "content": "<p>I'll change it.</p>",
        "id": 153961171,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526393579
    },
    {
        "content": "<p>Would we say something about whether the valuesets should (or shouldn't) be returned in expanded form? (I kind of think we shouldn't say anything -- but it's worth thinking through.)</p>",
        "id": 153961174,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526393641
    },
    {
        "content": "<p>Is it true that the client often already knows the few codes it could provide, and thus would just like to check whether any of those codes is acceptable? So add a parameter for a list of codes to check, and not return an entire (possibly large) valueset?</p>",
        "id": 153961175,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1526393789
    },
    {
        "content": "<p>Yeah -- that almost feels like a different operation though (e.g., <code>$code-supported-at?code=123&amp;element=DocumentReference.type</code> --&gt; Boolean)</p>",
        "id": 153961176,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526393852
    },
    {
        "content": "<p>That would feel like a variant of <a href=\"http://build.fhir.org/valueset-operation-validate-code.html\" target=\"_blank\" title=\"http://build.fhir.org/valueset-operation-validate-code.html\">$validate-code</a></p>",
        "id": 153961177,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1526393995
    },
    {
        "content": "<p>And I meant multiple inputs / outputs: <br>\n<code>$code-supported-at?code=123,xyz,bar,foo&amp;element=DocumentReference.type</code> -&gt; <code>xyz,foo</code></p>",
        "id": 153961180,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1526394115
    },
    {
        "content": "<p>That's an interesting angle <span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span>.  We hadn't thought of that.</p>",
        "id": 153961182,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526394213
    },
    {
        "content": "<p>But I think it's valid.</p>",
        "id": 153961183,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526394233
    },
    {
        "content": "<p>There are two use cases I envision for this:</p>",
        "id": 153961184,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526394247
    },
    {
        "content": "<p>A. Someone wants to configure a client to work with a given server.  For this, getting the whole ValueSet makes sense.</p>",
        "id": 153961185,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526394283
    },
    {
        "content": "<p>B. The client wants to confirm that the server will do what it needs.  For this, your idea makes more sense.</p>",
        "id": 153961186,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526394305
    },
    {
        "content": "<p>Variant of B: an early step in automated testing.</p>",
        "id": 153961187,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526394324
    },
    {
        "content": "<p>Mmm.  And now I'm thinking of more cases (or variants) for it.  Yeah, I think that's good.</p>",
        "id": 153961191,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526394361
    },
    {
        "content": "<p>Loosely connecting to the conversation in the room: is A also doable by specifying a specialized valueset in a profile that the server conforms to?</p>",
        "id": 153961194,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1526394397
    },
    {
        "content": "<p>Currently, I don't believe so without extensions.</p>",
        "id": 153961195,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526394459
    },
    {
        "content": "<p>If a server has two profiles that each define a ValueSet for the same element, the allowed values for that element are the intersection of the ValueSets.</p>",
        "id": 153961196,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526394507
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191358\">@Dennis Patterson</span>, you found that rule, right?</p>",
        "id": 153961197,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526394519
    },
    {
        "content": "<p>\"Server has two profiles\" or resource.meta.profile mentions 2 profiles?<br>\nServer may host 100 profiles for the same resourcetype, and then it would be useful if it could host the superset of the valuesets in the various profiles.</p>",
        "id": 153961199,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1526394635
    },
    {
        "content": "<p>I do agree btw that calling an operation for A is probably a lot easier for a client.</p>",
        "id": 153961200,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1526394698
    },
    {
        "content": "<p>And not for (B) ?</p>",
        "id": 153961201,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526394719
    },
    {
        "content": "<p>Yes, also for B, I did not even suggest an alternative for B :-)</p>",
        "id": 153961202,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1526394751
    },
    {
        "content": "<p>If the valueset has 32k concepts (e.g. observation, or some other really large valueset - we have a valuset with employer names that's 88k long) and as such wouldn't want that returned complete from the query.<br>\nFrom a client perspective if I'm trying to render some form of control with this, I'd need to have some form of indication that the potential results size.<br>\nAnd I'd want to know if I should be using $expand to dynamically get my values in a lookahead style interface, or a radio button set, or combo etc.</p>",
        "id": 153961205,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1526395153
    },
    {
        "content": "<p>That's true. And in other contexts (offline db-populating), full expansion is fine.</p>",
        "id": 153961213,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526395638
    },
    {
        "content": "<p><a href=\"https://simplifier.net/supportedvalueset/code-supported-at\" target=\"_blank\" title=\"https://simplifier.net/supportedvalueset/code-supported-at\">https://simplifier.net/supportedvalueset/code-supported-at</a></p>",
        "id": 153961214,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526395644
    },
    {
        "content": "<p>That's clever (taking a set in, returning the valid subset). I think you may need support for <code>Coding</code> in addition to <code>Code</code>, for the use cases we've been discussing (e.g. <code>Observation.code</code>, <code>DocumentReference.type</code>).</p>",
        "id": 153961217,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526395702
    },
    {
        "content": "<p>It was Christiaan's idea.  :)</p>",
        "id": 153961222,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526395762
    },
    {
        "content": "<p>What's the most elegant way to do that, Josh?</p>",
        "id": 153961226,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526395879
    },
    {
        "content": "<p>Might take a list of codes in, and a list of codings in... Then put a list of codes out and a list of codings out?</p>",
        "id": 153961227,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526395917
    },
    {
        "content": "<p>But then you have to back the input cardinalities off to <code>0..*</code> (from <code>1..*</code>).</p>",
        "id": 153961229,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526395946
    },
    {
        "content": "<p>What do we lose by changing it to a string?</p>",
        "id": 153961231,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526395975
    },
    {
        "content": "<p>Strings like <code>http://loinc.org|123-4</code> ?</p>",
        "id": 153961235,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526396008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191936\">@Michael Donnelly</span>  (to your earlier question)  if you want to have separate profiles to dictate input vs output ValueSets for a field, I came across two issues with specifying this w/conformance.</p>\n<p><em>One</em>, if you wanted your CapabilityStatement to list two rest.resource structures for the same resource type (e.g. one for DocumentReference create and one for DocumentReference search/read), the <a href=\"https://www.hl7.org/fhir/2018May/capabilitystatement-definitions.html#CapabilityStatement.rest.resource\" target=\"_blank\" title=\"https://www.hl7.org/fhir/2018May/capabilitystatement-definitions.html#CapabilityStatement.rest.resource\">comment</a> on CapabilityStatement.rest.resource says \"Max of one repetition per resource type.\"</p>\n<p><em>Two</em>, <a href=\"https://www.hl7.org/fhir/2018May/profiling.html#mixing\" target=\"_blank\" title=\"https://www.hl7.org/fhir/2018May/profiling.html#mixing\">documentation</a> on supporting multiple profiles says \"The impact of supporting two sets of profiles depends on whether resources are being created or consumed. When an application is creating content, it must create content that conforms to both sets of profiles - that is, the intersection of the profiles.\".  We're talking about two ValueSets that are currently non-intersecting, so this kind of thing doesn't seem supported.</p>",
        "id": 153961236,
        "sender_full_name": "Dennis Patterson",
        "timestamp": 1526396010
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191358\">@Dennis Patterson</span> I don't think these considerations apply to <a href=\"http://build.fhir.org/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.supportedProfile\" target=\"_blank\" title=\"http://build.fhir.org/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.supportedProfile\">CapabilityStatement.rest.resource.supportedProfile</a> though</p>",
        "id": 153961247,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526396127
    },
    {
        "content": "<p>What about the first limitation?  Is it valid to express separate profiles for separate actions?</p>",
        "id": 153961249,
        "sender_full_name": "Dennis Patterson",
        "timestamp": 1526396185
    },
    {
        "content": "<p>You can list a set of profiles (e.g. for <code>Observation</code>: vitals + labs) in a single list, in a single <code>CapabilityStatement.rest.resource</code> entry.</p>",
        "id": 153961251,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526396212
    },
    {
        "content": "<p>What's the point of having an element that's a code instead of a string in any Resource?  Because in the definition of the Resource you can specify the binding, and clients and servers will know what's supposed to be in there.\\</p>",
        "id": 153961252,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526396229
    },
    {
        "content": "<p>Yes you can link to multiple StructureDefinitions, but can you specify that they are for different actions?</p>",
        "id": 153961253,
        "sender_full_name": "Dennis Patterson",
        "timestamp": 1526396285
    },
    {
        "content": "<p>In this case, <br>\n1. We can't specify a binding in the definition, since it could be anything.<br>\n2. The whole purpose of the operation is that we know the code/coding might be wrong.</p>",
        "id": 153961255,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526396301
    },
    {
        "content": "<p>Practically that seems fine --  though technically FHIR OperationDefinitions don't provide a way to convey a <code>Coding</code> in a GET parameter, I <em>think</em>.</p>",
        "id": 153961257,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526396334
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 153961260,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526396378
    },
    {
        "content": "<p>It's like a token search parameter.</p>",
        "id": 153961261,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526396384
    },
    {
        "content": "<p>It totally could be like that. I  just don't think we've specified it.</p>",
        "id": 153961265,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526396406
    },
    {
        "content": "<p>Yes, we want simple ways to be able to allow consumers to identify what codes are supported for specific fields (for different contexts such as an action).  I'm just trying to find out whether it's possible to advertise this (tell, not just answer).</p>",
        "id": 153961270,
        "sender_full_name": "Dennis Patterson",
        "timestamp": 1526396440
    },
    {
        "content": "<p>Looks like OperationDefinition.parameter.searchType can be token.</p>",
        "id": 153961278,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526396722
    },
    {
        "content": "<p>So I changed the type for the \"code\" parameter to string and added a searchType of token.</p>",
        "id": 153961286,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526396861
    },
    {
        "content": "<p>There isn't a way to do that in the value returned, though.</p>",
        "id": 153961287,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526396943
    },
    {
        "content": "<p>Should it just have code and coding elements in the response?</p>",
        "id": 153961288,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526396978
    },
    {
        "content": "<p>Like this? <a href=\"https://simplifier.net/supportedvalueset/code-supported-at\" target=\"_blank\" title=\"https://simplifier.net/supportedvalueset/code-supported-at\">https://simplifier.net/supportedvalueset/code-supported-at</a></p>",
        "id": 153961289,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526397091
    },
    {
        "content": "<p>Sounds to me like the original ask could be defined in the Profile with an read/write extension on the valueset elements.  Hey  <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span>  have you looked at this issue ... isn't this what the <a href=\"http://build.fhir.org/terminologycapabilities.html\" target=\"_blank\" title=\"http://build.fhir.org/terminologycapabilities.html\">TerminologyCapabilities</a>  supposed to address?</p>",
        "id": 153961327,
        "sender_full_name": "Eric Haas",
        "timestamp": 1526402000
    },
    {
        "content": "<p>so, this thread jumped ahead a long without me.</p>",
        "id": 153961375,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526419142
    },
    {
        "content": "<p>the existing operation that <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> originally referred to is</p>",
        "id": 153961377,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526419187
    },
    {
        "content": "<p>GET [base]/ValueSet/$expand?context=DocumentReference.type</p>\n<p>That is - give me the value set expansion for the value set you use in the context DocumentReference.type</p>",
        "id": 153961378,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526419243
    },
    {
        "content": "<p>the idea that there are different value sets for reading or writing is foreign to FHIR so far; neither this operation nor CapabilityStatement considers this as a possibility. And I'm still not sure that I fully understand why the value sets are different</p>",
        "id": 153961379,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526419297
    },
    {
        "content": "<p>As I understand For Binary, Server A accepts mimetype x,y and z on a POST but only displays mimetype x on a GET.</p>",
        "id": 153961382,
        "sender_full_name": "Eric Haas",
        "timestamp": 1526419483
    },
    {
        "content": "<p>so why is it important to know that it only returns x?</p>",
        "id": 153961383,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526419544
    },
    {
        "content": "<p>does the server allow you to ask for a particular format?</p>",
        "id": 153961384,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526419557
    },
    {
        "content": "<p>Good question.  Knowing what incoming values a server will accept is crucial.  Knowing what values it might return is not as important.</p>",
        "id": 153961402,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526423035
    },
    {
        "content": "<p>We've encountered client vendors who want to know all the values they might need to map - all the outgoing values from the server - so they can do the work ahead of time to make sure they'll all work well.</p>",
        "id": 153961403,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526423119
    },
    {
        "content": "<p>I'd like to be able to meet that desire of theirs, and I really don't want to mislead them into thinking there's a different set of values they might receive than what they actually could.</p>",
        "id": 153961404,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526423158
    },
    {
        "content": "<p>I know you all considered an 'in/out/both' extension on the <code>valueset.concept</code>.  why was that idea discarded?   Cause then is baked into the profile.</p>",
        "id": 153961406,
        "sender_full_name": "Eric Haas",
        "timestamp": 1526423406
    },
    {
        "content": "<p>I think both angles are useful.  A way to make it from CapabilityStatement all the way down to the ValueSet, and a way to go back up from an element to the ValueSet.</p>",
        "id": 153961408,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526425891
    },
    {
        "content": "<p>so Michael, your operation goes way beyond in/out - is that neecssary?</p>",
        "id": 153961419,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526445572
    },
    {
        "content": "<p>GET [base]/ValueSet/$expand?context=DocumentReference.type&amp;operation=read</p>",
        "id": 153961420,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526445610
    },
    {
        "content": "<p>we could do that. And default to the superset, I supppose.</p>",
        "id": 153961421,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526445628
    },
    {
        "content": "<p>No, I don't think so.  I think we could have incoming (for update, patch, create, and search-type) and outgoing (for read, vread, history-instance, and history-type).  Anyone thing we need more granularity than incoming/outgoing?  <span class=\"user-mention\" data-user-id=\"191358\">@Dennis Patterson</span> <span class=\"user-mention\" data-user-id=\"191914\">@Danielle Friend</span> <span class=\"user-mention\" data-user-id=\"191410\">@Brett Marquard</span> <span class=\"user-mention\" data-user-id=\"191357\">@Andrew Torres</span> <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> <span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span> ?</p>",
        "id": 153961463,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526455121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, is there an existing ValueSet we can use for incoming/outgoing?</p>",
        "id": 153961470,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526455466
    },
    {
        "content": "<p>I think inbound vs outbound would meet the need.</p>",
        "id": 153961471,
        "sender_full_name": "Drew Torres",
        "timestamp": 1526455508
    },
    {
        "content": "<p>But as discussed above... do we actually want to <em>expand</em> in this use case?</p>",
        "id": 153961472,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526455602
    },
    {
        "content": "<p>If so, then this operation looks like a good fit.</p>",
        "id": 153961473,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526455616
    },
    {
        "content": "<p>I can't think of a reason we'd need more than in/out.</p>",
        "id": 153961474,
        "sender_full_name": "Danielle Friend",
        "timestamp": 1526455628
    },
    {
        "content": "<p>Could ValueSet/$expand handle <span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span>'s case by passing in the value you want to check as a filter?</p>",
        "id": 153961479,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526456386
    },
    {
        "content": "<p>No, that would be more like $validate-code but with a context provided I think. But that only allows for 1 input, and essentially true/false as return.</p>",
        "id": 153961533,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1526461696
    },
    {
        "content": "<p>Ah, makes sense.</p>",
        "id": 153961535,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526461720
    },
    {
        "content": "<p>sure $expand does that. You definitely want an expand for this</p>",
        "id": 153961550,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526462364
    },
    {
        "content": "<p>there's no an existing value set. I'll see if I can implement this on my server tonight</p>",
        "id": 153961551,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526462364
    },
    {
        "content": "<p>TL;DR Patient vs Provider or API limitations may scope inputs narrower than outputs.  Can this be more holistically supported by allowing CapabilityStatement.rest.resource to have separate profiles for inputs vs outputs?</p>\n<p>Thought it would be helpful to provide some additional use-case details:</p>\n<ul>\n<li><em>Patients</em> will usually have a narrower scope of what can be created than <em>Providers</em>.</li>\n<li>Providers may have narrower scope of what can be created through FHIR than by native means</li>\n</ul>\n<p>This can factor in resources such as...<br>\n- DocumentReference.content.attachment.contentType - only create documents of certain types.  Cerner and Epic systems transform the content into another type for storage<br>\n- Appointment.appointmentType - only support creation of certain appointment types<br>\n- Patient race extension - only allow certain races/ethnicities to be written (e.g. clients/customers may only want certain races to be written in their systems going forward)</p>\n<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> stated \"the idea that there are different value sets for reading or writing is foreign to FHIR so far; neither this operation nor CapabilityStatement considers this as a possibility.\"  So, the Conformance resources as a whole do not support this.  Since that's the underlying reality, it causes problems when trying to expose this through $expand.</p>\n<p>First, introducing an interaction/operation parameter to $expand doesn't agree with the fundamental assumptions of FHIR and creates a mismatch.</p>\n<p>Second, from what I've read on $expand, context is <em>recommended</em> to include a StructureDefinition.  The proposal so far removes that in favor of just an element path.  This seems to avoid the issue that separate profiles for inputs/outputs are discouraged.</p>\n<p>All in all, we (Cerner and Epic) are wrestling with identifying the best solution, as well.  And, if this is supported first-hand, wanting to be aware of what other implications this has to the spec.  Are there any reasons not to change CapabilityStatement.rest.resource uniqueness from resource type only, to type + interaction?</p>",
        "id": 153961755,
        "sender_full_name": "Dennis Patterson",
        "timestamp": 1526466470
    },
    {
        "content": "<p>Or type+direction.</p>",
        "id": 153961783,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526471137
    },
    {
        "content": "<p>well, for those interested, we'll be talking about capability statement this evening. contact me if you're interested.</p>",
        "id": 153961815,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526473280
    },
    {
        "content": "<p>I think type+direction is better than type+interaction, but I'm interested to know whether anyone would propose that delete is special again (e.g. I only delete cancelled things...)</p>",
        "id": 153961818,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526473375
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191358\">@Dennis Patterson</span>:</p>\n<blockquote>\n<p>First, introducing an interaction/operation parameter to $expand doesn't <br>\nagree with the fundamental assumptions of FHIR and creates a mismatch.</p>\n</blockquote>\n<p>not sure whether you are echoing me or not, and not sure whether you are agreeing or not. I was making a statement about the past, but not necessarily proposing a rule for the future.</p>\n<blockquote>\n<p>Second, from what I've read on $expand, context is recommended to include <br>\na StructureDefinition. </p>\n</blockquote>\n<p>You're right; I ducked that part for this purpose, though to be closely following the documentation, I'd have to add an argonaut specification profile url - but I don't know what that is.</p>\n<blockquote>\n<p>This seems to avoid the issue that separate profiles for inputs/outputs <br>\nare discouraged.</p>\n</blockquote>\n<p>I'm not saying they are discouraged. Just foreign to our work to this point. We'll be talking about this amongst other things tonight</p>",
        "id": 153961920,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526479421
    },
    {
        "content": "<p>Delete might well have differences, but that's in the business logic behind it rather than code mapping.  I think we're okay there.</p>",
        "id": 153961925,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526479647
    },
    {
        "content": "<p>ok, working... just have to upgrade soon</p>",
        "id": 153961973,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526483095
    },
    {
        "content": "<p>The profile won't be an Argonaut profile, it'll be for the specific organization in question.  The list of note types, for example, is owned by each organization using Epic or Cerner.</p>",
        "id": 153962016,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526486550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191936\">@Michael Donnelly</span> : <a href=\"http://test.fhir.org/r3/ValueSet/$expand?context=DocumentReference.type&amp;operation=read\" target=\"_blank\" title=\"http://test.fhir.org/r3/ValueSet/$expand?context=DocumentReference.type&amp;operation=read\">http://test.fhir.org/r3/ValueSet/$expand?context=DocumentReference.type&amp;operation=read</a></p>",
        "id": 153962088,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526495389
    },
    {
        "content": "<p>can't ask the client to figure out the profile URL - they can, but they might as well use the long path to that value set</p>",
        "id": 153962089,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526495418
    },
    {
        "content": "<p>and also <a href=\"http://test.fhir.org/r3/ValueSet/$expand?context=DocumentReference.type&amp;operation=write\" target=\"_blank\" title=\"http://test.fhir.org/r3/ValueSet/$expand?context=DocumentReference.type&amp;operation=write\">http://test.fhir.org/r3/ValueSet/$expand?context=DocumentReference.type&amp;operation=write</a></p>",
        "id": 153962093,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526496058
    },
    {
        "content": "<p>That looks great, Grahame.</p>",
        "id": 153962894,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526512604
    },
    {
        "content": "<p>My remaining concerns are totally nitpicky - functionally this does what we need.</p>",
        "id": 153962895,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526512634
    },
    {
        "content": "<p>Should we have a name other than \"operation\" for the search parameter, since Operator means something in FHIR?  And should we have a ValueSet that doesn't include \"read\" since that's a thing in REST?  (And also because when you pass a value in for a search, that's incoming but isn't actually writing.)</p>",
        "id": 153962897,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526512725
    },
    {
        "content": "<p>I think \"incoming\" and \"outgoing\" make sense for the values, but I have no idea for the parameter.</p>",
        "id": 153962898,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526512748
    },
    {
        "content": "<p>I considered: mode, interaction, operation, verb, scope</p>",
        "id": 153962924,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526531327
    },
    {
        "content": "<p>I'm ok with in/out or incoming/outgoing</p>",
        "id": 153962925,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526531364
    },
    {
        "content": "<p>but thinking more generally about this... it's about what you are doing with the element that you named in the context... I'm... searching on it? (context = search parameter?)</p>",
        "id": 153962926,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526531413
    },
    {
        "content": "<p>Context feels right.  Is there a way we can use \"context\" without blowing up the scope of this?</p>",
        "id": 153962954,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526541357
    },
    {
        "content": "<p>well, for this, we can scope it exactly how we want... not sure I've understood your question correctly</p>",
        "id": 153962961,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526541519
    },
    {
        "content": "<p>I think you've got it right.</p>",
        "id": 153962965,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526541583
    },
    {
        "content": "<p>I wouldn't want to take the time now to define every sort of context.  But if we can define context of \"incoming\" and \"outgoing\" now and add additional context later as needed, that sounds perfect.</p>",
        "id": 153962971,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526541665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191358\">@Dennis Patterson</span> how does this work for you?  <span class=\"user-mention\" data-user-id=\"191914\">@Danielle Friend</span> and I were more concerned about the lookup, and Grahame's $expand works great for that.</p>",
        "id": 153962973,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526541767
    },
    {
        "content": "<p>What would this look like?  <code>http://fhir.example.org/r3/ValueSet/$expand?context=DocumentReference.type&amp;context=incoming</code> ?</p>",
        "id": 153962974,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526541903
    },
    {
        "content": "<p>ValueSet's $expand operation is typically expanding a specific ValueSet, yes? By removing profile from the context parameter, is there ever any ambiguity of what ValueSet should be expanded?  I'm thinking through specific, narrow use-cases, but just trying to make sure the operation holds up for others</p>",
        "id": 153963024,
        "sender_full_name": "Dennis Patterson",
        "timestamp": 1526544993
    },
    {
        "content": "<p>If there's ambiguity, should the server return an error indicating that the client should specify additional context?</p>",
        "id": 153963029,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1526545512
    },
    {
        "content": "<p>server has to return an error, yes</p>",
        "id": 153963076,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526548473
    },
    {
        "content": "<p>we omitted profile, yes. I did that because, in fact, there's no prefixed value that the client could know in advance that they could use, and because if they had to find it, they might as well look up by the long path we first laid out (CapabilityStatement -&gt; StructureDefinition -&gt; ValueSet). Also, none of you indicated that there was any reason to think about different profiles in play on these elements. Hence, just easier to leave it out</p>",
        "id": 153963088,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526548970
    },
    {
        "content": "<p>Do we care about a use case where the EHR has a large value set, like \"any valid LOINC code\" for <code>Observation.code</code>? If so, forcing an expand operation may be undesirable.</p>",
        "id": 153963113,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1526550374
    },
    {
        "content": "<p>Or type+profile.<br>\nuse case would be to have a profile stating a narrower input than the output (example read certain Document types from cerner, convert them internally and offer profile specifying which content types are possible (broader output ))</p>\n<p>if incoming[CREATE] and outcoming[READ] would be used, what about the use cases update/delete?</p>",
        "id": 153963676,
        "sender_full_name": "Harald Aamot",
        "timestamp": 1526640370
    },
    {
        "content": "<p>Just to clarify, this discussion is about operation on EHR server, not on Terminology Server.</p>",
        "id": 153963712,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1526655733
    },
    {
        "content": "<p>well, the EHR has the discretion to return that the operation is too costly. The terminology servers routinely do this when the value set exceeds a certain cut-off size.</p>",
        "id": 153963738,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526669114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191506\">@Yunwei Wang</span> it's an API; the terminology server could support that on behalf of the EHR</p>",
        "id": 153963742,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526669422
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  I am worrying that if one terminology server serves multiple EHR servers, how the terminology server knows the correct context.</p>",
        "id": 153963973,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1526946537
    },
    {
        "content": "<p>it wouldn't, from that call. that would have to be established in the context.</p>",
        "id": 153963975,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526946602
    },
    {
        "content": "<p>I don't think it should be the client's problem....</p>",
        "id": 153963976,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526946614
    },
    {
        "content": "<p>I don't think this is a client's problem either. Instead, EHR server should be able to map the context to valueset ID and redirect the query to terminology server to expand with the correct id.</p>",
        "id": 153963996,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1526954728
    },
    {
        "content": "<p>which is exactly how my server resolves this one internally</p>",
        "id": 153964017,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1526962568
    },
    {
        "content": "<p>This is a great discussion I am only a few weeks late to -- <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, Acceptable to create a tracker to update the $expand operation? Do we need an indicator on the value set on whether a value set is incoming vs outgoing? I am a little fuzzy how we expect servers to keep track</p>",
        "id": 153967014,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1528192240
    },
    {
        "content": "<p>It would probably be good to discuss this on the terminology stream.  I'm not sure if we want/need an incoming vs outgoing indicator, but it is something that we should consider.</p>",
        "id": 153967027,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528204337
    },
    {
        "content": "<p>definitely need it for this use case. It would be associated with the element property, not more generally with the value set expansion framework</p>",
        "id": 153967037,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528206544
    },
    {
        "content": "<p>and yes please create ta task</p>",
        "id": 153967038,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528206551
    },
    {
        "content": "<p>can you say more about how it would be associated with the element property?</p>",
        "id": 153967162,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1528231061
    },
    {
        "content": "<p>see <a href=\"http://build.fhir.org/valueset-operation-expand.html\" target=\"_blank\" title=\"http://build.fhir.org/valueset-operation-expand.html\">http://build.fhir.org/valueset-operation-expand.html</a> - the context parameter.</p>",
        "id": 153967215,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528254200
    },
    {
        "content": "<p>would be another parameter that would be used with that parameter</p>",
        "id": 153967216,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528254215
    },
    {
        "content": "<p>Thanks, I am a little stumped is how a client knows to even ask the question about available write/read options. <a href=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=17321\" target=\"_blank\" title=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=17321\">#GF17321</a></p>",
        "id": 153967369,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1528294964
    },
    {
        "content": "<p>I don't think a client will ask for a valueset at runtime (or, really, workflow time).  Rather, the administrator who sets up a client will use it to configure the client to do what the server needs.</p>",
        "id": 153967406,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1528299023
    },
    {
        "content": "<p>Grahame, did you mean to implement at DocumentReference.context.attachement.contentType instead of DocumentReference.type?</p>",
        "id": 153967520,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1528309835
    },
    {
        "content": "<p>yes my mistake.</p>",
        "id": 153967535,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528315195
    },
    {
        "content": "<p>not sure about the client knowing to ask?</p>",
        "id": 153967536,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528315205
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> it looks you documented the Resolution text of <a href=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=17321\" target=\"_blank\" title=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=17321\">#GF17321</a> from the Vocab meeting yesterday but not the Ballot Resolution.  Should this be Persuasive?  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  <span class=\"user-mention\" data-user-id=\"191410\">@Brett Marquard</span></p>",
        "id": 153968720,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1528812973
    },
    {
        "content": "<p>I didn't get to that on the call yesterday, but was going to do that when I included it in the block for the main vocab call - done.</p>",
        "id": 153968736,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1528820766
    },
    {
        "content": "<p>There seem to be two reasonable ways to return the list of codes in the ValueSet Resource: under the <strong>compose</strong> element, and under the <strong>expansion</strong> element. </p>\n<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> , in your example $expand query, the response ValueSet used the <strong>expansion</strong> element (and elements under the expansion)  to return the supported codes <a href=\"http://test.fhir.org/r3/ValueSet/$expand?context=DocumentReference.type&amp;operation=read\" target=\"_blank\" title=\"http://test.fhir.org/r3/ValueSet/$expand?context=DocumentReference.type&amp;operation=read\">http://test.fhir.org/r3/ValueSet/$expand?context=DocumentReference.type&amp;operation=read</a></p>\n<p><strong> Is it also reasonable to use the compose element, where you would get a response like this: <a href=\"/user_uploads/10155/2US7AoM0SsgWCacOaxuxcpyy/valueSetResponse.txt\" target=\"_blank\" title=\"valueSetResponse.txt\">valueSetResponse.txt</a>   ?</strong></p>\n<p>I wanted to get you guys' opinion because it seemed like the expansion element was made specifically for this operation, however I was not sure if it was necessary. </p>\n<p>The ValueSet.Read interaction would return the same resource as the $expand in this case.</p>",
        "id": 153983936,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1533771056
    },
    {
        "content": "<p>compose may or may not contain a list of codes, and the list may or may not be correct in any given context.</p>",
        "id": 153983938,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1533771834
    },
    {
        "content": "<p>it's the definition of what should be in the value set, given a set of additional rules about context</p>",
        "id": 153983939,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1533771855
    },
    {
        "content": "<p>to actually figure out what is in the value set under the applicable rules, some engine evaluates them, and creates a value set with the expansion populated that contains the actual list. So: you should only use the compose element if you're dealing with the rules, not the actual outcome. Sounds to me like you want expansion</p>",
        "id": 153983940,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1533771928
    },
    {
        "content": "<p>I didn't realize that is what compose meant, and don't really understand how it is useful, but I've updated the response to use the expansion element: <a href=\"/user_uploads/10155/cWJRySWU1xwf2IuDtNW1kCc3/valueSetResponse2.txt\" target=\"_blank\" title=\"valueSetResponse2.txt\">valueSetResponse2.txt</a> </p>\n<p>Thanks for clearing that up.</p>",
        "id": 153984316,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1533835722
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Following up on this. For the response to an $expand query, I'd return the list of codes/systems under the \"expand\" element. From your comment above, I am inferring that I would also want to use the \"expand\" element when doing a read on the ValueSet resource to get a list of codes. Is that correct, or in the case of a Read interaction, would it be appropriate to return the codes under the \"compose\" element?</p>",
        "id": 157033469,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1548689729
    },
    {
        "content": "<p>if you want to get the list of code in a value set, you should always use $expand</p>",
        "id": 157050729,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1548703509
    },
    {
        "content": "<p>Read ValueSet returns ValueSet definition. $expand operation returns ValueSet expansion.</p>",
        "id": 157146616,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1548802982
    },
    {
        "content": "<p>Makes sense. Another question that affects FHIR more broadly, but is encountered with a ValueSet Expansion: <strong>What do we do if there are too many values in an expansion to return them all at once?</strong> </p>\n<p>FHIR has a through guide to paging when the response is a bundle of many resources. But if there is a single resource with thousands of repeating elements, how can we return them all in a single response? This could be an issue for ValueSet.$expand, and we've also seen it with the List resource.</p>",
        "id": 157317677,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1548978420
    },
    {
        "content": "<p>you can page through an expansion - check the $expand parameters</p>",
        "id": 157317830,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1548978585
    },
    {
        "content": "<p>Ohh, I see; that is convenient. It seems a little weird to pass an integer as the offset as opposed to just using a session ID to just start where you left off from, since the contains elements don't seem like they are supposed to be in any particular order. </p>\n<p>I guess the offset could be nice if you are just looking for the last few codes? Is the idea that the client would do a $expand with count=0 to find out if there are any new codes...</p>",
        "id": 157319087,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1548979983
    },
    {
        "content": "<p>wait, nvm, because even if they do the $expand?count=0 and find out that there are new codes, it doesn't mean they are added to the end (since they arent ordered), so they will have to expand the whole valueset from the beginning to get the missing codes.</p>",
        "id": 157319158,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1548980072
    },
    {
        "content": "<p>The \"total\" element is the number of codes the server has, not the number of codes returned with this $expand request, right?</p>",
        "id": 157319161,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1548980087
    },
    {
        "content": "<p>yes to all that</p>",
        "id": 157320803,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1548982192
    },
    {
        "content": "<p>If count = 0, the client is asking how large the expansion is. My understanding is that server returns only the total number.</p>",
        "id": 157360531,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1549034673
    },
    {
        "content": "<p>why do we make the client keep track of the count and offset to do paging? It seems like it just adds a level of complexity (sure addition and keeping track of a number is pretty simple, but I'd think it is not needed). </p>\n<p>Is there a use case that is not \"just give me all the codes\" which would benefit from having the offset relate to the number of codes not the number of pages?</p>",
        "id": 157383663,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1549053318
    },
    {
        "content": "<p>doing it by page count would force the page count itself to be a reliable agreement. And feedback was that clients to not necessarily want a consistent size for the page. (particularly first to second apge size)</p>",
        "id": 157384001,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1549053611
    },
    {
        "content": "<p>What if instead of a page count, you just had a reference to the \"next\" page, like how other paging works? That would be the easiest because you don't have to keep track of anything. The next URL is just right there in the response. And page size doesn't matter anymore either.</p>",
        "id": 157385125,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1549054542
    },
    {
        "content": "<p>well, there's quite some complications here. the server has to keep quite a lot of state for the search based mechanism, in order to get it right. Not all servers do, in fact. We wanted to avoid the need for state in this case</p>",
        "id": 157385242,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1549054652
    },
    {
        "content": "<p>What do you mean by <em>the server has to keep quite a bit of state</em>? The server just hasto keep track of the count and the offset. If we expect clients to be able to keep track of these two integers, a server should be able to as well. </p>\n<p>Does this make it harder to page with ValueSet than it is to page with any other resource?</p>",
        "id": 157387284,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1549056380
    },
    {
        "content": "<p>not only does the server have to keep track of count and offset, the server has to reproduce the same result set to apply the offset to. In search, that can be quite problematic. We decided to duck that in value set expansion, and make the client specify the whole search each time, and a window into it</p>",
        "id": 157387868,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1549056853
    },
    {
        "content": "<blockquote>\n<p>not only does the server have to keep track of count and offset, the server has to reproduce the same result set to apply the offset to. </p>\n</blockquote>\n<p>The rate-determining step here is producing the result set. Keeping track of an extra integer seems super trivial. </p>\n<p>Why not just allow the client to pass a parameter that will let the server look up all of the state from the previous complex result set generation instead of just the offset? This could save the server a bunch of time, especially for a potentially costly operation.</p>",
        "id": 158387938,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1550006020
    },
    {
        "content": "<p>$expand returns one ValueSet resource. Search returns a bundle of resources.</p>",
        "id": 158390813,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1550008313
    },
    {
        "content": "<p>Right, well $expand returns <em>part of</em> a resource. If there are too many codes in the valueSet, the server can return the first 100 codes and then the Client will have to expand the ValueSet again to see codes 101 through 200. </p>\n<p>The debate is: How should this paging of codes within a single ValueSet resource be done. I think we should just have a pointer to the next page of results so we can save the state from the previous expansions. </p>\n<p>If the client only passes an \"Offset\" integer N, (unless the server stores all of the codes in a static table), the server may have to enumerate over the first N codes just to get to the offset spot where they will start. So when the client just wants the 1,000,001st code, the server has to enumerate over the first 1,000,000 codes to get to the last one.</p>",
        "id": 158398410,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1550014836
    },
    {
        "content": "<p>We save expansion in database. So it is much easier for us if client specifies offset and count.</p>",
        "id": 158409666,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1550028490
    },
    {
        "content": "<p>but if you do that, you can also add a state parameter that refers to the database record.</p>",
        "id": 158431471,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550056121
    },
    {
        "content": "<p>I don't feel strongly about this. I only cache these things transiently, not in the database, but I could use a state parameter. However the technical specification for search paging (using links) doesn't seem so obviously applicable to $expand, since there's no bundle. Probably further discussion on this should be on the terminology stream with the other terminology server authors</p>",
        "id": 158431567,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550056208
    },
    {
        "content": "<blockquote>\n<p>We save expansion in database. So it is much easier for us if client specifies offset and count.</p>\n</blockquote>\n<p>I agree that <strong>if</strong> the expansion is stored in an <em>index-able</em> format in the database, or if we cached the whole expansion, it makes sense to just use the offset param. However, not all servers work that way, and the given $expand parameters should not dictate how the server has to store the expansion in their system. We could just cache the entire expansion too, but it could be pretty large, so it'd be cleaner for us to just iterate over codes in the DB.</p>\n<p>I'm not suggesting using the \"link\" in a bundle, since that doesn't make sense for our non-bundle scenario. There should just be a sessionID-esque parameter instead of mandating paging by offset param. This \"session ID\" (or <em>paging ID</em>)  param could just literally be the offset integer for servers like Yunwei's that are indexed, so nothing would change for them. And it could be a state identifier code for servers that want to iterate from where they last left off (as opposed to from a specific integer index).</p>",
        "id": 158650189,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1550265379
    },
    {
        "content": "<p>The <em>key</em> difference is that a state parameter encodes <em>all</em> the $expand parameters, not just offset &amp; count</p>",
        "id": 159317821,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1551078645
    },
    {
        "content": "<p>Isn't that even easier? When would the client want to use a different value for one of the other parameters?</p>",
        "id": 159349980,
        "sender_full_name": "Colby Seyferth",
        "timestamp": 1551111721
    },
    {
        "content": "<p>can we have this discussion just on the terminology stream?</p>",
        "id": 159382265,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1551137199
    }
]