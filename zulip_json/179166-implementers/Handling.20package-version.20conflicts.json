[
    {
        "content": "<p>I have the following FHIR packages: <code>fhoo</code> and <code>bar</code>. Note that they depend on different package-versions of some base-package:</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span>\n <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"tld.name.fhoo\"</span><span class=\"p\">,</span>\n <span class=\"nt\">\"version\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"1.0.0\"</span><span class=\"p\">,</span>\n <span class=\"nt\">\"canonical\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"http://name.tld/fhoo\"</span><span class=\"p\">,</span>\n <span class=\"err\">...</span>\n <span class=\"nt\">\"dependencies\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">\"tld.name.base\"</span><span class=\"p\">:</span> <span class=\"s2\">\"1.1.1\"</span><span class=\"p\">,</span>\n <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span>\n <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"tld.name.bar\"</span><span class=\"p\">,</span>\n <span class=\"nt\">\"version\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"1.0.0\"</span><span class=\"p\">,</span>\n <span class=\"nt\">\"canonical\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"http://name.tld/bar\"</span><span class=\"p\">,</span>\n <span class=\"err\">...</span>\n <span class=\"nt\">\"dependencies\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">\"tld.name.base\"</span><span class=\"p\">:</span> <span class=\"s2\">\"1.2.2\"</span><span class=\"p\">,</span>\n <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>How is this version conflict resolved when I use <code>fhoo</code> and <code>bar</code> in a \"child\"-package?</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span>\n <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"tld.name.child\"</span><span class=\"p\">,</span>\n <span class=\"err\">...</span>\n <span class=\"nt\">\"dependencies\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">\"tld.name.fhoo\"</span><span class=\"p\">:</span> <span class=\"s2\">\"1.0.0\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"tld.name.bar\"</span><span class=\"p\">:</span> <span class=\"s2\">\"1.0.0\"</span><span class=\"p\">,</span>\n <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>The strategy used by npm is to allow for <a href=\"https://stackoverflow.com/questions/42147243/how-does-npm-handle-version-conflicts\">both versions of the base-package to be used simultaneously</a>, but I'm not sure if that works well for me. For example, even if the package-version is different, the business-version of the individual resources might still be the same as before. In this case, the content of those resources <em>should</em> be the same, but this is not guaranteed (technical corrections that don't change the business-content might still be applied). </p>\n<p>To be safe, I would probably err on the side of caution and use a maven-like version resolution strategy, where automatically the latest version is used (and a warning is emitted to the implementer). Would this be a suitable approach to the problem?</p>",
        "id": 235197630,
        "sender_full_name": "Martin Höcker",
        "timestamp": 1618845067
    },
    {
        "content": "<p>I don't know how that's resolved. And I don't even know what the current tooling would do</p>",
        "id": 235265351,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1618874906
    },
    {
        "content": "<p>I experimented a bit with SUSHI. It looks like SUSHI circumvents this problem by not automatically resolving transitive package dependencies. If you want to use profiles or other resources that are defined in a transitive dependency, you have to explicitly list this dependency in the <code>sushi-config.yaml</code>. If you don't, then there is a simple \"not found\"-error for the resource you are trying to use. </p>\n<p>But I'm not sure how deliberate this choice in conflict-resolution-strategy was. Could you weigh in, <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> ? </p>\n<p>I have not yet tried it with firely terminal.</p>",
        "id": 235556350,
        "sender_full_name": "Martin Höcker",
        "timestamp": 1619028602
    },
    {
        "content": "<p>So... you're right.  SUSHI requires you to explicitly list transitive dependencies if you will be using anything from them.  I don't think this was intentional; it was probably more of an oversight.  The thing that NPM has that we don't is wildcard versioning -- which allows more flexibility to find a single version of a transitive dependency that satisfies all requirements (if requirements don't require an explicit exact version).  But... we don't have that so... I see two potential approaches:  If there are conflicting versions of a transitive dependency,</p>\n<ul>\n<li>Use the most recent version (of the specified transitive dependencies), OR</li>\n<li>Require the user to explicitly specify what version to use by including it as a direct dependency (like SUSHI unintentionally requires now)</li>\n</ul>\n<p>Of course there are still all sorts of fun things that can happen since parts of dependency StructureDefinitions can be embedded in other profile definitions (due to traversing into the structure).  So, just because we might have a way to choose a version to use does not mean we are out of the woods!  I guess the only way to solve that problem is to allow each dependency to have access to its own sub-dependencies (without choosing a \"common\" version) -- but that gets pretty complex and I'm not really sure what it means for interoperability either...</p>",
        "id": 235563113,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1619031566
    },
    {
        "content": "<p>I think requiring explicitly listing dependencies that should be inherited through an existing dependency is going to result in maintenance pain (at some point the version references are going to get out of sync).</p>",
        "id": 235590550,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1619043102
    }
]