[
    {
        "content": "<p>Quick ? - only HL7 can use StructureDefintion.derivation = specialization, correct?  <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> What are you doing with this in Forge?</p>",
        "id": 153820292,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460041998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> Forge is still based on FHIR DSTU2, whereas StructureDefinition.derivation was introduced in DSTU3. For new profiles, Forge currently initializes StructureDefinition.constrainedType to the selected base resource type.</p>",
        "id": 153820293,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042313
    },
    {
        "content": "<p>specialization seems intended for logical models (and core resources?)</p>",
        "id": 153820294,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042399
    },
    {
        "content": "<p>Seems like there's a lot of churn in that part of the SD with changed in kind/type/contextType etc.</p>",
        "id": 153820295,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042402
    },
    {
        "content": "<p>I'm struggling a bit to keep my tooling current!  Right now, we're supporting 0.5, 1.0.x, and (soon) 1.4.</p>",
        "id": 153820296,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042435
    },
    {
        "content": "<p>Yes, we discussed some of these changes in Atlanta. in STU3 it should be more regular.</p>",
        "id": 153820297,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042440
    },
    {
        "content": "<p>Must've missed that discussion...</p>",
        "id": 153820298,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042460
    },
    {
        "content": "<p>We will upgrade all our tools (incl. Forge) to STU3 after the Montreal balloting rounds. Until then, we will stick to DSTU2.</p>",
        "id": 153820299,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042497
    },
    {
        "content": "<p>Also, really struggling with the benefit of elementdefintion.base.  What was the motivation there?</p>",
        "id": 153820300,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042534
    },
    {
        "content": "<p>It allows tooling to quickly determine the original path of the associated base element.</p>",
        "id": 153820301,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042579
    },
    {
        "content": "<p>When would base.path != path?</p>",
        "id": 153820302,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042641
    },
    {
        "content": "<p>And cardinality, e.g. if base resource defines an element as 0...* then a code generator would generate a List property. If a derived profile constrains the element to 0..1, then a code generator would still need to generate a List property, in order for the derived class to be compatible with the base class. The ElementDefinition.base component specifically solves this problem.</p>",
        "id": 153820303,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042655
    },
    {
        "content": "<p>e.g. for choice elements, base path ends with \"value[x]\" where actual path ends with \"valueString\".</p>",
        "id": 153820304,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042680
    },
    {
        "content": "<p>OK...nice for XML to JSON for sure.  That could just be a single flag though...</p>",
        "id": 153820305,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042684
    },
    {
        "content": "<p>So path=\"valueString\" and base.path = \"value[x]\"?</p>",
        "id": 153820307,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042706
    },
    {
        "content": "<p>This information could be calculated by resolving the base resource profile or expanding the snapshot, but this is a costly operation.</p>",
        "id": 153820308,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042724
    },
    {
        "content": "<p>e.g. path = \"Observation.value[x]\", base.path = \"Observation.valueString\"</p>",
        "id": 153820309,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042749
    },
    {
        "content": "<p>Does base just go back one generation, or all the way back to the first appearance of the element?</p>",
        "id": 153820310,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042768
    },
    {
        "content": "<p>In Forge, I currently initialize all the element base components while opening/loading the resource. This ensures that other business logic can safely assume the information is present and correct.</p>",
        "id": 153820311,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042805
    },
    {
        "content": "<p>Good question... I'd have to think about that. I assume element.base refers to the path in the root profile, but I'm not sure - need to carefully look at an example.</p>",
        "id": 153820312,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042861
    },
    {
        "content": "<p>So Patient baseDefinition of Acme-Patient baseDefinition of Acme-Neuro-Patient.  </p>\n<ul>\n<li>Acme-Patient has path = \"Patient.deceasedDatetime\" (base.path = \"Patient.deceased[x]\")</li>\n<li>Acme-Neuro-Patient as path=\"Patient.deceasedDatetime\" for further constraint.  What is base.path?</li>\n</ul>",
        "id": 153820313,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042917
    },
    {
        "content": "<p>According to the description, element.base.path always refers to a core structuredefinition without a StructureDefinition.base component.</p>",
        "id": 153820314,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042930
    },
    {
        "content": "<p>ElementDefinition.base.path: \"The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a StructureDefinition without a StructureDefinition.base.\"</p>",
        "id": 153820315,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042950
    },
    {
        "content": "<p>So Acme-Neuro-Patient has the same base.path = \"Patient.deceased[x]\"</p>",
        "id": 153820316,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042978
    },
    {
        "content": "<p>OK...so the \"most base\" element definition.  And element[x] is always \"more base\" than elementType.</p>",
        "id": 153820317,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042985
    },
    {
        "content": "<p>ok...fair enough!</p>",
        "id": 153820318,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460042994
    },
    {
        "content": "<p>This makes sense, as this is the information that is useful in application logic.</p>",
        "id": 153820319,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460042997
    },
    {
        "content": "<p>thanks!</p>",
        "id": 153820320,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460043020
    },
    {
        "content": "<p>np. FHIR should be crystal clear on these concepts, so it's important we discuss this.</p>",
        "id": 153820321,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1460043145
    },
    {
        "content": "<p>Part of this is that there's getting to be some mental \"inertia\" for some of us! \"Now what happened there?\" frequently crosses my mind!</p>",
        "id": 153820322,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1460043220
    },
    {
        "content": "<p>base is really useful if a structure definition profiles a data type inline - just walks straight into it </p>",
        "id": 153820618,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460352048
    },
    {
        "content": "<p>path = Observation.valueQuantity.unit, base = Quantity.unit</p>",
        "id": 153820619,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460352066
    },
    {
        "content": "<p>It's on my task list to write up how the FHIR typing system works formally for the current build. </p>",
        "id": 153820620,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460352097
    },
    {
        "content": "<p>or we can work through it when I come visit you ;-)</p>",
        "id": 153820621,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1460352110
    },
    {
        "content": "<p>Right now, I think the general understanding is that snapshot and differential should be calculable from each other (round trip-able).  Maybe should be a little clearer on this.  Consider the need for a profiler to define a profile that includes only a particular set of extensions from an enterprise set (the profile uses the enterprise profile as its baseDefintion).  For instance, a cardio service may define a profile of encounter that uses 5 of the 25 extensions defined by the enterprise.</p>\n<p>Question is: how does the profiler enforce the limitation of only 5 extensions (not cardinality, 5 urls)? He can close the slicing and max=0 the 20 to be disallowed.  But if/when the enterprise defines the 26th, it will appear in the cardio profile.</p>\n<p>IF we allow definition by snapshot, it would be possible to explicitly limit the slices that appear, but the machinery gets a little wonky (snapshot is always a superset of all elements/sliced defined in the baseDefinition lineage).  Is there a mechanism to meet this use case I'm missing?</p>",
        "id": 153828165,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463507340
    },
    {
        "content": "<p>if you allow 5 and close, then why does it matter if another is defined somewhere else?</p>",
        "id": 153828196,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463513881
    },
    {
        "content": "<p>If it's added to your baseDefinition, you'll (forcibly) inherit it.</p>",
        "id": 153828198,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463513929
    },
    {
        "content": "<p>why? you said, these 5, and closed it. </p>",
        "id": 153828201,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463513948
    },
    {
        "content": "<p>The base has extension.slicing.rule=\"open\" and defines 25 extensions.  My profile closes the extensions (extension.slicing.rule=\"closed\") and max=0 all the ones I want to exclude.  But if another appears in the base (the 26th), it will already be part of my closed slicing (by inheritance).  There's no way to block that...</p>",
        "id": 153828218,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463518225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> how about if the derived profile defines another extension slice with max = 0 and no url property. Since the extension slice discriminator is always the url (per definition), this \"catch-all\" constraint would match any remaining extensions that do not match any of the other extension slices, at least conceptually. If this constraint then specifies max = 0, it would explicitly suppress any implicitly inherited extensions from the base profile not matched by any of the other slices. Do you think this could work?</p>",
        "id": 153828605,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1463668853
    },
    {
        "content": "<p>Yes, that would work.  Do we state what happens when a discriminator isn't set?  I think it should work as you describe...</p>",
        "id": 153828606,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463669036
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> maybe not now that I think about it.  Only _one_ slice may apply to any instance.  I don't think this means that a \"catch all\" is valid since both the catch all and the specific version would apply to an instance with a related slice definition.  In other words, an extension slice with no fixedUri for @url would apply to all extension instances and therefore disallow any other slices.</p>",
        "id": 153828699,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463682810
    },
    {
        "content": "<p>What you *could* do though would be to define a type profile of extension where max=0 for the url element.  But that would require slicing extension by @profile and not url.</p>",
        "id": 153828700,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463682871
    },
    {
        "content": "<p>And the discriminator for extension is fixed to url.</p>",
        "id": 153828701,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463682889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> yes, that seems to be correct. My suggestion would require a change to the standard, in order to define the proposed interpretation and behavior as such. I was just thinking out loud about how to cover your use case. Your suggestion of using a type profile might also work, but slicing by profile can be (very) computationally intensive and might not be supported by many FHIR servers. So personally, I consider this to be an advanced technique that you should use only if there are not simple alternative ways to express the intended constraints.</p>",
        "id": 153828847,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1463744078
    },
    {
        "content": "<p>Seems like the expressive power of SlicingRules are too limited to express the desired constraints of your use case. It somewhat resembles binding strength, through wich a profile author can limit binding overrides in a derived profile. Maybe we can expand the SlicingRules?</p>",
        "id": 153828849,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1463744432
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 153828863,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463751741
    },
    {
        "content": "<p>Would really like to come up with a way to express this without a major breaking change....</p>",
        "id": 153828864,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463751822
    },
    {
        "content": "<p>I may be that what I'm trying to do breaks the concept of polymorphic inheritance and shouldn't actually be allowed.  There's no way in most object oriented languages for a sub-type to constrain changes on the super-type or, more precisely, for the sub-type to selectively decide what to inherit from the super-type.</p>",
        "id": 153828867,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463752392
    },
    {
        "content": "<p>But that's not exactly how the FHIR type system works either....</p>",
        "id": 153828869,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463752420
    },
    {
        "content": "<p>I like your suggestion of a \"everything else\" slice...a notation for that might be the least disruptive.</p>",
        "id": 153828870,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463752501
    },
    {
        "content": "<p>It makes parsing somewhat harder though since all other slices have to be exhausted before it would match...similar to evaluating the \"closed\" rule.</p>",
        "id": 153828871,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463752584
    },
    {
        "content": "<p>Sorry for the rambling....that won't actually work either since the slices actually *are* defined in the baseDefinition and would just inherit intact.</p>",
        "id": 153828872,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463752655
    },
    {
        "content": "<p>Hmm... you always come up with these interesting cases ;p I definitely agree that it is preferred to find a compatible solution that doesn't introduce any breaking changes. Just having a hard time to find one. In this case, if I understand correctly, you need to suppress the inheritance of (yet) unknown information from the base profile. However SliningRule = closed on your derived profile only applies to profiles that derive from the derived profile, i.e. downstream 3rd+ level profiles. It does not lImit the inheritance from the original base profile and therefore cannot protect against future additions to the base profile, right? Hence my feeling that in order to express this behavior, we might have to expand SlicingRule with yet another option, e.g. sealed or something.</p>",
        "id": 153828876,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1463757331
    },
    {
        "content": "<p>The primary issue is that we define by differential. We can only define how the profile is different from the base.  So, we'd need to be able to re-generalize base specializations, e.g. create a slice that encompasses a set (an open ended set!) of base slices.  While my use case is real, it really feels like an architecturally unsound thing to do within the profile hierarchy.</p>",
        "id": 153828880,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463763537
    },
    {
        "content": "<p>An alternate might be a profile that requires conformance to another profile but doesn't inherit from it.  Unfortunately I think I accidentally removed this possibility with <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=9814\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=9814\">GF#9814</a> when we removed type from the root element.  While I don't *think* anyone was enforcing this, it would have been possible for a profile to set type.profile on the root element and therefore force conformance with another profile.</p>",
        "id": 153828881,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463763755
    },
    {
        "content": "<p>With this, I could create a profile that required conformance to anther profile (e.g. an enterprise Patient profile) without using that as a base.</p>",
        "id": 153828882,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1463763853
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191351\">@Chris Grenz</span> There has been some discussion on supporting (the union of) multiple profiles. I specifically remember that Claude Nanjo would has requested support for this functionality. The idea being that instead of having a single-inheritance chain of profiles, you can combine/overlay/aggregate multiple separate profiles into one. This would allow a more composition-based / aspect-oriented profiling approach. However because of the complexity and calculation costs, we haven't even started to implement any of this (yet...). Note that in Forge, the element type profile textbox actually allows you to enter multiple profile urls (press enter to add another line), however Forge currently only validates the first type profile and ignores any remaining type profiles. And Grahame informed me that he is not about to implement support for this in his server.</p>",
        "id": 153829283,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1464013105
    },
    {
        "content": "<p>I've thought about multiple inheritance as well and found it to be as distasteful as it was in programming languages.  I would differentiate though between multiple inheritance and additional conformance constraints: each profile must only inherit from one profile, but they could state conformance to other profiles.  This wouldn't cause the other profiles' content to be included.  It would just state an additional (complex) constraint.</p>",
        "id": 153829285,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1464013838
    },
    {
        "content": "<p>we can calculate whether a profile is a constraint on another or whether it's consistent with another</p>",
        "id": 153829365,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464037253
    },
    {
        "content": "<p>Yes, but we can't use another profile as a constraint (such as we can do with individual element type profiles) to the whole profiled type.</p>",
        "id": 153829367,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1464037329
    },
    {
        "content": "<p>the first is - all instances that conform t profile A conform to profile B</p>",
        "id": 153829368,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464037931
    },
    {
        "content": "<p>the second is - there are some instances that conform to both profiles</p>",
        "id": 153829369,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464037953
    },
    {
        "content": "<p>agree that we should only try to deal with one explicit parent</p>",
        "id": 153829371,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464037976
    },
    {
        "content": "<p>So if I define an \"Enterprise Patient\" profile, could I (without inheriting from it) say that a conformant resource MUST also be DAF-Patient conformant?</p>",
        "id": 153829374,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1464038022
    },
    {
        "content": "<p>yes, by explicitly requiring that in your meta.profile. but not implicitly no</p>",
        "id": 153829377,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464038108
    },
    {
        "content": "<p>How can we pass our own structure definition(In JSON or XML) to Hl7.Fhir.Specification (.net package provided by <a href=\"http://fire.ly\" target=\"_blank\" title=\"http://fire.ly\">fire.ly</a>) so that it can validate against the object?<br>\nThanks</p>",
        "id": 187882596,
        "sender_full_name": "PS",
        "timestamp": 1581395331
    },
    {
        "content": "<p>you might get a quicker answer if you post this question to <a class=\"stream\" data-stream-id=\"179171\" href=\"/#narrow/stream/179171-dotnet\">#dotnet</a></p>",
        "id": 187885021,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1581399110
    },
    {
        "content": "<p>Will do. Thanks</p>",
        "id": 187885608,
        "sender_full_name": "PS",
        "timestamp": 1581400019
    },
    {
        "content": "<p>Hello all, </p>\n<p>Can anyone please share structure definition examples with minValue and maxValue ?<br>\nThese fields are choice of datatype, so could not find the exact key name for this fields .</p>",
        "id": 233627796,
        "sender_full_name": "Radha Rajendran",
        "timestamp": 1617875533
    },
    {
        "content": "<p>Already asked and answered here: <a href=\"#narrow/stream/179166-implementers/topic/StructureDefinition.20.20and.20unknown.20properties\">https://chat.fhir.org/#narrow/stream/179166-implementers/topic/StructureDefinition.20.20and.20unknown.20properties</a></p>",
        "id": 233674355,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1617895667
    }
]