[
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> <span class=\"user-mention\" data-user-id=\"192166\">@Jean Duteau</span>  <br>\nWe are requesting that the <a href=\"http://hl7.org/fhir/datatypes-definitions.html#Period\">http://hl7.org/fhir/datatypes-definitions.html#Period</a> invariant text is changed to match the expression like \"If present, start SHALL have a lower or equal value than end\".  We have real world same day encounters with a date only where period.start = period.end.<br>\nWe have logged FHIR-29268.  We are hoping to hear that you agree and will approve our change request.</p>",
        "id": 213817371,
        "sender_full_name": "Kathy Pickering",
        "timestamp": 1603127869
    },
    {
        "content": "<p>yes that sounds like a very good idea</p>",
        "id": 213873392,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1603166610
    },
    {
        "content": "<p>Resurrecting this, but I just submitted <a href=\"http://jira.hl7.org/browse/FHIR-34417\">FHIR#34417</a>.  We have Encounters that have periods like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>{\n         &quot;start&quot;: &quot;2023-06-21&quot;,\n         &quot;end&quot;: &quot;2023-06-21T06:20:00Z&quot;\n }\n</code></pre></div>\n<p>This is invalid per the per-1 invariant, given the FHIRPath rules for comparing dates with differing precision.  When <a href=\"http://jira.hl7.org/browse/FHIR-29268\">FHIR#29268</a> was approved, was that intended to allow periods like the example I gave?</p>",
        "id": 263626747,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638559877
    },
    {
        "content": "<p>Related chat.fhir topic on <a href=\"#narrow/stream/179266-fhirpath/topic/Date.2FTime.20comparison\">FHIRPath datatime comparison</a>.</p>",
        "id": 263626843,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638559922
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span></p>",
        "id": 263628064,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638560549
    },
    {
        "content": "<p>If a comparison has different levels of precision, and the result is an empty set, then as an invariant that is considered a pass, not a false.</p>",
        "id": 263807006,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1638763745
    },
    {
        "content": "<p>Hmm... I wonder if this is an Inferno or HAPI validator issue then.  The <a href=\"https://inferno.healthit.gov/validator/\">Inferno validator</a> is failing this resource:</p>\n<div class=\"codehilite\"><pre><span></span><code>{\n  &quot;resourceType&quot;: &quot;Encounter&quot;,\n  &quot;id&quot;: &quot;e1ROhluOalPIMvQ6iOXOINQ40Te8Rfz.3DCjEkUpKtpc3&quot;,\n  &quot;identifier&quot;: [\n    {\n      &quot;use&quot;: &quot;usual&quot;,\n      &quot;system&quot;: &quot;urn:oid:1.2.840.114350.1.13.5325.1.7.3.698084.8&quot;,\n      &quot;value&quot;: &quot;10001466261&quot;\n    }\n  ],\n  &quot;status&quot;: &quot;unknown&quot;,\n  &quot;class&quot;: {\n    &quot;system&quot;: &quot;urn:oid:1.2.840.114350.1.72.1.7.7.10.696784.13260&quot;,\n    &quot;code&quot;: &quot;1&quot;,\n    &quot;display&quot;: &quot;Surgery Case&quot;\n  },\n  &quot;subject&quot;: {\n    &quot;reference&quot;: &quot;Patient/eNO3wqOfAltfnWMfWBQ1WmQ3&quot;,\n    &quot;display&quot;: &quot;Test, Emily FHIR&quot;\n  },\n  &quot;period&quot;: {\n    &quot;start&quot;: &quot;2023-06-21&quot;,\n    &quot;end&quot;: &quot;2023-06-21T06:20:00Z&quot;\n  },\n  &quot;location&quot;: [\n    {\n      &quot;location&quot;: {\n        &quot;reference&quot;: &quot;Location/eZq-E51GdFzpYxmfoRNU8pRvm2xL.sTjR8Beh3hPnIBE3&quot;,\n        &quot;display&quot;: &quot;OR LOCATION&quot;\n      }\n    }\n  ]\n}\n</code></pre></div>\n<p><a href=\"/user_uploads/10155/MVqrhDmrqQkdyuEiKxZtAZQV/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/MVqrhDmrqQkdyuEiKxZtAZQV/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/MVqrhDmrqQkdyuEiKxZtAZQV/image.png\"></a></div>",
        "id": 263876023,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638808095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191506\">@Yunwei Wang</span>  - does Inferno use the HAPI validator for BDGV-18 and <a href=\"https://inferno.healthit.gov/validator/\">https://inferno.healthit.gov/validator/</a>?</p>",
        "id": 263876093,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638808124
    },
    {
        "content": "<p>Comparing dates where one one of them has a time (w/offset) to one that doesn't is always going to be problematic. What time do you associate with \"start\" in this case? Midnight, 1 min before midnight tomorrow, noon? What offset? Zulu, local, same offset as the other value (end in this case)? How do you know the exact minute the encounter ended but don't know the hour/minute of when it started? Maybe you should ignore the time on end if you don't have time on start? There are no good answerers here.</p>",
        "id": 263878845,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1638809210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191764\">@Cooper Thompson</span> Yes. Inferno validator (<a href=\"https://inferno.healthit.gov/validator/\">https://inferno.healthit.gov/validator/</a>) uses Inferno Validator Service v2.0.0 which depends on HL7 FHIR validator v5.3.14. <br>\nInferno Program uses Inferno Validator Service v1.2.0 which depends on HL7 FHIR validator v5.2.10</p>",
        "id": 263893690,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1638815039
    },
    {
        "content": "<p>Based on the FHIR date search (<a href=\"http://build.fhir.org/search.html#date\">http://build.fhir.org/search.html#date</a>),  <code>2023-06-21</code> is a range [2023-06-21T00:00:00, 2023-06-22T00:00:00). This range is not less than (or below) the range [2023-06-21T06:20:00, 2023-06-21T06:20:01). So I think the validation result is correct.</p>",
        "id": 263896691,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1638816120
    },
    {
        "content": "<p>I think FHIRPath has different date comparison semantics than the range comparison from the date searching.  My understanding is that FHIRPath comparison will return empty set if dates have different precisions.</p>",
        "id": 263900487,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638817773
    },
    {
        "content": "<p>So for per-1:</p>\n<div class=\"codehilite\"><pre><span></span><code>start.hasValue().not() or end.hasValue().not() or (start &lt;= end)\n</code></pre></div>\n<p>This should evaluate to:  false or false or empty set.  The FHIRPath Tester does evaluate (start &lt;=end) to True, so Brian's claim that it should pass checks out, at least in terms of the FHIRPath Tester implementation (I'm still a noob on the FHIRPath spec, and haven't found the rules define there for handling empty set conversion to Boolean values for expressions).</p>",
        "id": 263901851,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638818424
    },
    {
        "content": "<p>I got the same error from validator_cli.jar v5.6.4</p>",
        "id": 263904419,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1638819153
    },
    {
        "content": "<p>So is the validator not using the FHIRPath semantics for invariant validation?  I.e. this is a bug in the validator instead of the spec?</p>",
        "id": 263905843,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638819439
    },
    {
        "content": "<p>I tried using <code>-version 4.0.1</code>. I cannot run validator_cli against R5, I got \"unable to resolve package id null#4.6.0\" or \"Unknown FHIRVersion code 4.6.0\" depending on what parameter I provided.</p>",
        "id": 263910666,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1638820342
    },
    {
        "content": "<p>I don't know if it would make any difference, but the <a href=\"https://github.com/hapifhir/org.hl7.fhir.core/releases\">latest validator is 5.6.7</a></p>",
        "id": 263936156,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1638831047
    },
    {
        "content": "<p>I think that the FHIRPath tester is wrong here. The FHIRPath specification says:</p>\n<blockquote>\n<p>For partial Date, DateTime, and Time values, the comparison is performed by comparing the values at each precision, beginning with years, and proceeding to the finest precision specified in either input, and respecting timezone offsets. If one value is specified to a different level of precision than the other, the result is empty ({ }) to indicate that the result of the comparison is unknown.</p>\n</blockquote>\n<p>The validator rule is that this SHALL be true, and it's not known to be true, so all versions of the validator will fail this encounter</p>",
        "id": 263943676,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638836429
    },
    {
        "content": "<p>and to me, this makes sense. A start period of sometime on the day is not known to be less than a particular time during that day. If you mean, 00:00:00, then say so.</p>",
        "id": 263943722,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638836480
    },
    {
        "content": "<p>then an invariant on patient for <code>birthDate &lt; today()</code> would fail in the event that the patient doesn't have a date.</p>",
        "id": 263950416,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1638842648
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> can you look into this one too - it's pointing at a difference between the dotnet validator too (or at least my understanding of it)</p>",
        "id": 263950482,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1638842760
    },
    {
        "content": "<p>yes it would fail. If you wanted it not to fail then you'd say <code>birthDate.exists().not() or (birthDate &lt; today())</code></p>",
        "id": 263950829,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638843112
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> <a href=\"#narrow/stream/179166-implementers/topic/Period.20Datatype.20Invariant/near/263950829\">said</a>:</p>\n<blockquote>\n<p>yes it would fail. If you wanted it not to fail then you'd say <code>birthDate.exists().not() or (birthDate &lt; today())</code></p>\n</blockquote>\n<p>Wouldn't you have to handle all the different possible date precisions separately for this evaluate intuitively?  I.e. you'd need to independently handle a birthDate that is null vs. YYYY vs. YYYYMM vs. YYYYMMDD?    YYYY &lt; today() would resolve to empty set (false), same with YYYYMM &lt; today() (false).</p>",
        "id": 264176167,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638979074
    },
    {
        "content": "<p>For example, if today() is 20211208, and you have a birthDate with a precision of YYYY like 2020, then birthDate &lt; today() would be empty set which would eval to false.</p>",
        "id": 264176532,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638979210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> this is a very good point, and I bet no one writing CQL is catering for this. We need a function/operator for difference between dates (can't do date - date -&gt; quantity right now) and also some way to do greater than / less than for dates that's precision robust - right now the FHIRPath specification is clear that comparison of dates with different precision is <code>{}</code></p>\n<p><span class=\"user-mention\" data-user-id=\"191764\">@Cooper Thompson</span> what would you do for birthdate of YYYY-MM where they match the today's y and m?</p>",
        "id": 264202142,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638989514
    },
    {
        "content": "<p>If you are asking what I think would be intuitive, I'd think YYYYMM &lt; today() would be false, but YYYYMM =&lt; today() would be true.  So as long as the precision you have matches, then the equality check would pass.  Though that implies that YYYYMM = today(), which sometimes feels right, but I'm not sure it always does.  Maybe we need another comparison operator, where = will be true as long as the precision you have matches, and == returns true only if you have matching precision?</p>",
        "id": 264212747,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638994025
    },
    {
        "content": "<p>I think making a new operator be the full precision check and changing the semantics of the existing = operator would mean that the existing invariants that I know of would work \"as expected\".  But that has all sorts of implications I'm sure.</p>",
        "id": 264212948,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638994106
    },
    {
        "content": "<p>well, we do have the <code>~</code> operator</p>",
        "id": 264213060,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638994179
    },
    {
        "content": "<p>Ah yeah.  I should probably read the FHIRPath spec top to bottom instead of skimming and Ctrl+F'ing.  </p>\n<p>~ seems like the opposite of what we want though right?  We want an operator that returns true when the dates have different precision, but the precision that does exist is equal.</p>",
        "id": 264223002,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638998884
    },
    {
        "content": "<p>Note that there is a difference between the empty set <code>{}</code> and <code>false</code>.  In the context of date comparison, empty set (<code>{}</code>) basically means <em>maybe</em> (i.e., not enough information to return a concrete answer), vs. <code>false</code> (which means definitively false).</p>\n<p>So, YYYYMM &lt; today() is true if YYYYMM is before today's year and month, false if YYYYMM is after today's year and month, and empty {} if YYYYMM matches today's year and month.  This gives you flexibility because you can decide if you want empty {} treated as true or false for your use case.  E.g.:</p>\n<ul>\n<li>If you want YYYYMM &lt; today() to be true when the year and month match today's year and month, then write it as <code>(birthDate &lt; today()).allTrue()</code> (since <code>allTrue()</code> returns true for empty sets).</li>\n<li>If you want YYYMM &lt; today() to be false when the year and month match today's year and month, then write it as <del><code>birthDate &lt; today()</code> (since an empty set will be treated as false in that case)</del> (edit: <code>(birthDate &lt; today()).anyTrue()</code> since <code>anyTrue</code> returns false for empty sets).</li>\n</ul>\n<p>Note that while I used YYYYMM as an example, the logic works the same way if the birthdate way only specified to years (YYYY).  I don't think there is a way in FHIRPath to easily switch logic based on the exact precision of the input.</p>",
        "id": 264226385,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1639000501
    },
    {
        "content": "<blockquote>\n<p>@Ewout Kramer can you look into this one too - it's pointing at a difference between the dotnet validator too (or at least my understanding of it)</p>\n</blockquote>\n<p>Yes, there is a difference. The validator is running invariants as predicates, which means that the empty result evaluates to true, not false.  It's been like that for years, and probably never led to problems because of the fully quantified invariants using <code>... exists().not()  or .....</code>.</p>",
        "id": 264290153,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1639051012
    },
    {
        "content": "<p>Sounds like a big change....</p>",
        "id": 264290400,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1639051202
    },
    {
        "content": "<p>Actually, that's a good point, <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span>.  Somewhere I got the impression that <code>{}</code> defaults to false when a true boolean is expected, but I actually don't see anywhere in the spec that indicates this.  Since <code>{}</code> generally means \"I don't know\" in the context of boolean logic, it may make sense that you <em>don't</em> treat that as a violation of an invariant.</p>",
        "id": 264311111,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1639061110
    },
    {
        "content": "<p>I've updated my suggestion above to explicitly return true/false rather than potentially return empty set.</p>",
        "id": 264311557,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1639061313
    },
    {
        "content": "<p>It seems odd folks haven't run into this before.  While we've been using birthDate as the example, my actual issue is with the per-1 invariant, which is on the Period data type.  And the Period data type is used all over.</p>",
        "id": 264313409,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1639062172
    },
    {
        "content": "<p><a href=\"http://jira.hl7.org/browse/FHIR-34417\">FHIR#34417</a> is the tracker I'm interested in.  And if we take <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span>'s suggestion, then we'd be updating the invariant on that normative data type. <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 264313533,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1639062238
    },
    {
        "content": "<p>I think the spec is quite clear on this: A constraint is defined as:</p>\n<blockquote>\n<p>Condition that must evaluate to true</p>\n</blockquote>\n<p>So that's quite clear: if the result of the expression is unknown, it's cannot evaluate to true.</p>",
        "id": 264349417,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1639076180
    },
    {
        "content": "<p>a validator that treats <code>{}</code> as true is a validator that is not enforcing the constraints as stated</p>",
        "id": 264349497,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1639076223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> <span class=\"user-mention\" data-user-id=\"191764\">@Cooper Thompson</span> <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> , the comparison operators are precision robust in that they proceed from years down. It's not that comparisons with different precisions always return null, they return null if that difference means the answer is unknown. In this case, for example:<br>\n<code>@2021-12-08 &lt; @2020</code><br>\nThis evaluates to false because 2021 is greater than 2020, so we're safe to return false, not null. On the other hand,<br>\n<code>@2020-12-08 &lt; @2020</code><br>\nThis evaluates to null because we don't know the actual month or day on the right-hand side.</p>",
        "id": 264757817,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1639423879
    },
    {
        "content": "<p>For calculating difference and duration, we have those operators defined in CQL, it would be straightforward to promote those definitions to FHIRPath as part of the next version.</p>",
        "id": 264758319,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1639424115
    },
    {
        "content": "<p>we should do that, yes</p>",
        "id": 264759171,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1639424518
    },
    {
        "content": "<p>This will mean a whole tonne of my fhirpath expressions need heaps more null checks in them. <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span></p>",
        "id": 265538982,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1639992523
    },
    {
        "content": "<p>Probably not just yours.  I think we probably need to review most of the date-based invariants in the whole spec, since the intuitive thing isn't what happens.</p>",
        "id": 265568111,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1640009583
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span>  While reading this thread I notes some related problems with the FHIRPath tester. <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> <a href=\"https://github.com/brianpos/FhirPathTester/issues/10\">https://github.com/brianpos/FhirPathTester/issues/10</a></p>",
        "id": 265639005,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1640052003
    },
    {
        "content": "<blockquote>\n<p>This will mean a whole tonne of my fhirpath expressions need heaps more null checks in them.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> , it really shouldn't, the intent is to provide the intuitive behavior. Can you provide some specific examples where you would need it? We have been using this approach in CQL for years with temporal comparisons and we haven't had to use null checks.</p>",
        "id": 266732268,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1641241137
    },
    {
        "content": "<p>And there is already a FHIRPath issue related to this, so I've added a proposed disposition to it: <a href=\"https://jira.hl7.org/browse/FHIR-19896\">https://jira.hl7.org/browse/FHIR-19896</a></p>",
        "id": 266732802,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1641241480
    },
    {
        "content": "<p>Sort of related to this, but what should a system do if they have data that is not compliant with the (new/future updated) expression?  For example, if we have a start date of 1/2/2022 and an end date of 1/1/2022  (i.e. startDate &gt; endDate).  This of course doesn't make sense, but if we got that data from a legacy system that has been retired, there isn't really much we can do.  </p>\n<p>The options I can think of:</p>\n<ol>\n<li>Don't send the data at all.  But this isn't really great, since it means that callers of the API will just be unable to access data that we have.</li>\n<li>Send it in Period anyway, ignoring the constraint, and ignore Lloyd when he yells at us for being non-conformant :D.</li>\n<li>Check every set of start/end timestamps, and if they pass the invariant, send them in Period, and if not, send them in extensions.</li>\n</ol>",
        "id": 266855781,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641326531
    },
    {
        "content": "<p>I'm really starting to struggle with FHIR invariants, must-support, and 1..x cardinalities.  It seems like they really are a representation of what the community <em>hopes</em> is true in the real world.  But if real-world data doesn't align with those hopes, then systems are really SOL if they want to use FHIR.  We can always add data validation (if we don't have it already) for new data entered in the system.  But legacy data is just something we have to deal with.</p>",
        "id": 266855847,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641326591
    },
    {
        "content": "<p>Sending garbage data doesn't really help the recipient.  One of the two values must, by definition, be wrong.  If you don't know which, then you can't really trust either.  So sending it as text where at least a human can look and hopefully infer reality is your best/safest thing to do.</p>",
        "id": 266868345,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641332814
    },
    {
        "content": "<p>I say that conformance is a goal. And it's a fine achievable goal with data collection and recording going forward. But whenever you say, \"historical data\", conformance becomes a whole lot more challenging. In the case of the official chart says, start day 2 end day 1... clearly wrong. But that is what is in the chart. You have the choice of including the data doing your option 2. (This is often my choice) You can say I know the data is wrong so I won't transfer the data to the FHIR resource copy of the chart (option 1). As you say, now the consumer doesn't have the data at all. Sending them in extensions is fine, but does your consumers know what the extensions are and what do they do with the data that still says, \"start day 2, end day 1?\" Sure it didn't violate a conformance rule, but it's still wonky. You can put the values in just the .text it's not machine readable and if it's a research project with millions of rows it's unlikely that anybody is going to read them and update with their best guess. This is the problem with historical data, 4 years ago a code/date/etc. was assigned. Today the IG says that code is not allowed. Who goes back and updates 4 year old chart entries so they conform to current rules? Especially if the Dr that wrote the item no longer works there or that was the last time the patient was seen at the facility.</p>\n<p>100% conformance with new going forward data is achievable, historical not so much. You can certainly patch it by ignoring non-conformant rows/attributes but are you doing more harm by making the resources conformant?</p>",
        "id": 266870153,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1641333785
    },
    {
        "content": "<p>This isn't about \"conformance\" so much as \"don't send garbage\".  If something is clearly wrong, yes you can send it, but that puts the work of dealing with it on all recipient systems.  If everyone downstream needs to make allowances for garbage data, that gets really expensive.  The system that acquired the garbage data in the first place is in the best position to clean it - and so the responsibility should rest on them to do so.</p>",
        "id": 266878545,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641338833
    },
    {
        "content": "<p>Certainly you can choose to transmit non-conformant instances.  However, you'll quite often find that other systems will reject or choke on the data.  (And if there are certification requirements, you'll find that you won't pass.)</p>",
        "id": 266878657,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641338892
    },
    {
        "content": "<p>I agree, the people that own the data are in the best position to clean the data. But who has time/money to \"clean\" potentially millions of historical records. And if those bad data points require a Dr to asses the patient in order to determine the new correct code, do you call the patient in for a free consult in order to do records maintenance? Is it better to send the Condition of Diabetes with an old obsolete code or not tell the consumer about the diabetes at all (or in a non-machine processable form)? </p>\n<p>When it comes to certification, in my experience, you are dealing with current data collection, it's never about \"let's pull up data from 4 years ago and see if those are compliant with today's rules.\"</p>",
        "id": 266934753,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1641389121
    },
    {
        "content": "<p>The problem with the \"don't send garbage\" approach is that a lot of useful data <em>is</em> garbage.  In fact, the motto of my team for a while was \"Garbage in, Miracle out\", since we spent so much time handling garbage we got from other systems and trying to make it useful.  </p>\n<p>In reality, a LOT of data IS garbage, or has parts of it that are garbage.  But that doesn't mean it isn't valuable.   The question is:  should the server be paternalistic and \"decide\" that the non-conformant data we have isn't useful for any consumer?  Or should we expose the data we have, and let the recipient decide if the non-conformant data is useful to them or not?</p>\n<p>And of course in the US, the EHRs <em>can't</em> decide that garbage data shouldn't be shared.   Info Blocking regulations don't have a direct exception for garbage data (infeasibility <em>might</em> apply, but that feels really extreme and not desirable).  So are we supposed to share conformant data using FHIR, and non-conformant data using some other method?  That'd be annoying.</p>",
        "id": 266940131,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641392095
    },
    {
        "content": "<p>Unclean/non-conformant data breaks systems.  The rules that FHIR sets are rules that systems are expected to be able to count on when processing FHIR instances.  If the data violates those rules, bad things can (and often will) happen.  Certainly systems are free to expose whatever data they wish in whatever shape it happens to be in.  However, they can't call that data FHIR conformant and they can't count on it being safely processed by downstream systems.</p>",
        "id": 266978054,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641410242
    },
    {
        "content": "<p>And draft status commits should be able to ig ore that type of invariant too.</p>",
        "id": 266989167,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1641415778
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 267136250,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1641515938
    },
    {
        "content": "<p>I'm not clear on that <span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span>.  It might make sense for mandatory information to be missing for a draft.  But clearly nonsensical data doesn't make any more sense for a draft than for something that's final.</p>",
        "id": 267220907,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641578487
    },
    {
        "content": "<p>Our server only draws the line at data type level value, and I think that's it. Invariants are definitely off.<br>\nAs expressions could be checking conditional  mandatory fields (very often) or cross field in which case either side could be wrong, and intent is to write an in progress draft.</p>",
        "id": 267233911,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1641584765
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191764\">@Cooper Thompson</span> I really like \"Garbage in, Miracle out\"</p>\n<p>but I don't have any good solution to this problem at all.</p>",
        "id": 267385936,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1641774649
    },
    {
        "content": "<p>Have there been any discussions about having different invariants for POST/PUT vs GET? Or legacy data exceptions?</p>",
        "id": 267389810,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1641780845
    },
    {
        "content": "<p>We could consider introducing a standard Resource.implicitRules element that says \"legacy data, quality rules may not hold\" and possibly have the validator turn errors into warnings when it's set.</p>",
        "id": 267390550,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641782061
    },
    {
        "content": "<p>I do like the idea of letting the server explicitly declare that it knows the resource isn't fully conformant, and possibly with a reason why.  The only downside is that the server needs to do validation so that it knows to declare that, and running validation can have a performance impact.  I wonder if we could have \"strict\" and \"lax\" modes, and have a way for the client to specify which it wants.  In lax mode, the server can just send what it has (possibly fudging some conformance constraints), but in strict mode it would need to explicitly declare if something it is sending is non-conformant.</p>",
        "id": 267445829,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641825226
    },
    {
        "content": "<p>We can't relax the expectation to be fully conformant.  If you spit out v2 vertical bar data or a CSV file in a FHIR interface, that's not valid - end stop.  What we <em>could</em> potentially do is define a set of constraints that are 'tolerable' if violated by legacy data and - if specifically asked for - invalid data could be sent.  The default would have to be that the data must be strictly valid because that's the requirement now.</p>",
        "id": 267455309,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641829530
    },
    {
        "content": "<p>I think that could really just be part of the definition of \"lax\" mode.  If \"lax\" mode only allows you to skip stuff like invariants, cardinalities, must support, value set bindings, etc., but the rest of the FHIR structure still needs to be valid, I think that'd be about right.</p>",
        "id": 267456983,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641830126
    },
    {
        "content": "<p>If were to introduce \"garbage mode\" I'm pretty sure it'd be used far and wide, and mostly without a good reason, which is a reason not to go there. If relevant in your specific context, you could use a meta flag to indicate such a mode. No need for any new functionality, I'd say.</p>",
        "id": 267457567,
        "sender_full_name": "René Spronk",
        "timestamp": 1641830342
    },
    {
        "content": "<p>You'd still need to include a modifier extension to highlight the fact that the instance contained garbage.</p>",
        "id": 267458265,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641830538
    },
    {
        "content": "<p>Just for the purposes of this  conversation, let's define \"garbage\" as \"useful, possibly clinically relevant data that doesn't conform to the optimistic hopes of the FHIR spec (or relevant IG)\".</p>",
        "id": 267461578,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641831837
    },
    {
        "content": "<p>Which means \"garbage mode\" == \"best option in the industry to send useful clinical data\".</p>",
        "id": 267462124,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641832066
    },
    {
        "content": "<p>A start that's after an end is \"garbage\".  At least one of the two values is definitively <em>wrong</em> and there's no way to tell which.  It's not about optimism and, with properly defined input constraints, it's a situation that should not ever happen.  It's like a date of Feb. 30 or an age of -10 years.  Some things just don't make sense and there's no way for an electronic system to reliably do anything with the data.</p>",
        "id": 267463292,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641832531
    },
    {
        "content": "<p>I.e. it's not \"useful clinical data\".</p>",
        "id": 267463316,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641832540
    },
    {
        "content": "<p>Once you start populating modifierExtension, I think you are guaranteeing that the data will be ignored unless this customization is understood by all consumers.</p>",
        "id": 267464109,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1641832801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179166-implementers/topic/Period.20Datatype.20Invariant/near/267463316\">said</a>:</p>\n<blockquote>\n<p>I.e. it's not \"useful clinical data\".</p>\n</blockquote>\n<p>But if the period is invalid, and that is required in the resource, then we can't send the entire resource.  The rest of the resource might be useful.</p>",
        "id": 267464338,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641832872
    },
    {
        "content": "<p>Right.  Well, in this case, the data isn't safe to be consumed unless the consuming system is prepared to handle non-compliant data, so rejecting/ignoring the data if the modifier isn't understood/accepted is probably the correct thing for systems to do.</p>",
        "id": 267464349,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641832876
    },
    {
        "content": "<p>And in R4, since per-1 is kinda busted, the data actually <em>is</em> useful.  The flaw is in the FHIR spec.</p>",
        "id": 267464437,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641832919
    },
    {
        "content": "<p>Having working FHIR servers to connect to that spit out syntactically correct FHIR is very very useful, a big improvement on having to implement a load of custom interfaces. Having the FHIR you get from those servers conformant to some implementation guide is a nice to have</p>",
        "id": 267464606,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1641832985
    },
    {
        "content": "<p>If the period is mandatory, it could potentially be handled with a data-absent-reason.  And if there are situations where it's reasonable for the period to not be known, then the cardinality should certainly be relaxed in the core spec.  It would only be appropriate for period to be mandatory if the belief was that the resource couldn't possibly be useful if the period was unknown.</p>",
        "id": 267464662,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641833005
    },
    {
        "content": "<p>(where  syntactically correct = can be loaded with standard libraries)</p>",
        "id": 267464844,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1641833056
    },
    {
        "content": "<p>I'm also considering IGs here.  A large part of my concern is is due to all the 1..1 and MS tags I saw in IGs this ballot cycle.  Either we need to explain to IG authors that anytime they make something 1..1 they are blocking information sharing, or we need an industry-wide solution to handle real-world data.</p>",
        "id": 267465237,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641833215
    },
    {
        "content": "<p>Complying with an IG is always optional.  It's up to an IG whether it wants to allow legacy data or non-'clean' data.  Some IGs only care about net-new data or want to protect systems from atypical content.  Others need to be able to handle everything.  It <em>would</em> be useful though for each IG to have a section that specifically discusses its strategy around legacy, external or other data of potentially poor quality.</p>",
        "id": 267465611,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641833359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191372\">René Spronk</span> <a href=\"#narrow/stream/179166-implementers/topic/Period.20Datatype.20Invariant/near/267457567\">said</a>:</p>\n<blockquote>\n<p>If were to introduce \"garbage mode\" I'm pretty sure it'd be used far and wide, and mostly without a good reason, which is a reason not to go there. If relevant in your specific context, you could use a meta flag to indicate such a mode. No need for any new functionality, I'd say.</p>\n</blockquote>\n<p>The .NET library has a SkipConstraintValidation setting.  So there already is a lax mode. It just is up to the client to set that in their handling.  In the real world, I think clients MUST set that setting if they want to get the data they care about.  So I'm just saying we need this to be a FHIR thing not just something all the FHIR <em>libraries</em> do.</p>",
        "id": 267465628,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641833366
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191764\">Cooper Thompson</span> <a href=\"#narrow/stream/179166-implementers/topic/Period.20Datatype.20Invariant/near/267465237\">said</a>:</p>\n<blockquote>\n<p>I'm also considering IGs here.  A large part of my concern is is due to all the 1..1 and MS tags I saw in IGs this ballot cycle.  Either we need to explain to IG authors that anytime they make something 1..1 they are blocking information sharing, or we need an industry-wide solution to handle real-world data.</p>\n</blockquote>\n<p>If an IG makes a field 1..1 where base is 0..1, I wouldn't think that the IG is saying all X resources must have that data. Instead only resources that do have that value are for the use case that the IG describes. Making profile a filter. GET base/X?_profile=IGX.... Server would say, all X where field not null.</p>",
        "id": 267469905,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1641835078
    },
    {
        "content": "<p>Right.  Not all instances that a server has will necessarily meet the requirements of a given IG - and that shouldn't be a problem.</p>",
        "id": 267470134,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641835203
    },
    {
        "content": "<p>That requires server to support _profile search parameter. I don't know which sever actually supports that.</p>",
        "id": 267478340,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1641838608
    },
    {
        "content": "<p>And even the ones that do, will probably only look for claims in meta.profile</p>",
        "id": 267479165,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1641839037
    },
    {
        "content": "<p>I wonder if IG authors really understand this.  Is it intuitive that doing a Patient?_profile=IPS will automatically filter out all patients that don't have a birthDate or gender or an associated DAR (<a href=\"http://hl7.org/fhir/uv/ips/StructureDefinition-Patient-uv-ips.html\">IPS Patient Profile</a>)?  I've seen adding 1..1 be a common pattern in other IGs too, where I don't think the IG authors are using that to intentionally exclude data from their profile use cases.   I don't think we're currently set up for success to kick this to IG authors.  Either we need a lot of education with IG authors on what adding requirements actually means (it means they are filtering data), or we need a more formal \"out\" (lax mode).  Or we just do nothing and force everyone to be non-compliant in order achieve real-world use cases.</p>",
        "id": 267480694,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641839726
    },
    {
        "content": "<p>This is a very interesting discussion that I've been following.  Almost all of my IGs are taking existing specifications and replicating them in FHIR, so when I'm making something mandatory, it is because the underlying business process (i.e. the existing spec) has it as mandatory.  I do understand how this can make interoperability harder, but when the server requires that piece of data -birth date or gender, as an example - my IG and profile saying that those elements are 1..1 is making it clear to the client that they need this or they can't communicate.</p>\n<p>I wonder if most IGs and IG authors are like this - \"this is mandatory because we need it for the business process we are describing\".  For IGs that are not about a specific process, the guidance around \"don't make things mandatory unless you have to!\" is obviously very important.</p>",
        "id": 267481152,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1641839936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191506\">Yunwei Wang</span> <a href=\"#narrow/stream/179166-implementers/topic/Period.20Datatype.20Invariant/near/267478340\">said</a>:</p>\n<blockquote>\n<p>That requires server to support _profile search parameter. I don't know which sever actually supports that.</p>\n</blockquote>\n<p>Or which IGs actually require that the server support it.</p>",
        "id": 267483011,
        "sender_full_name": "Stephen MacVicar",
        "timestamp": 1641840847
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191764\">@Cooper Thompson</span> you complained about \"garbage in\". But when you propose a \"lax mode\", isn't that a \"garbage in\" for down stream systems. \"lax mode\" is not a solution but just kicking can down the road.</p>",
        "id": 267485715,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1641842016
    },
    {
        "content": "<p>The tricky thing about relying on _profile search is that it's only going to work if the server has actually tagged every resource with all of the profiles you care about - it's entirely possible that a resource meets the requirements for profile X, but is not tagged with that in meta.profile because the server didn't validate profile X.</p>",
        "id": 267486133,
        "sender_full_name": "Paul Church",
        "timestamp": 1641842193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191506\">Yunwei Wang</span> <a href=\"#narrow/stream/179166-implementers/topic/Period.20Datatype.20Invariant/near/267485715\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"191764\">Cooper Thompson</span> you complained about \"garbage in\". But when you propose a \"lax mode\", isn't that a \"garbage in\" for down stream systems. \"lax mode\" is not a solution but just kicking can down the road.</p>\n</blockquote>\n<p>Kinda.  But once you have garbage, what else would you do?  You either need to propagate the garbage, or you don't.    And if you don't propagate it, are you Info Blocking?</p>",
        "id": 267486515,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641842376
    },
    {
        "content": "<p>(or you invoke Content and Manner exception and use something other than FHIR since FHIR can't handle it)</p>",
        "id": 267486610,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1641842404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197072\">Paul Church</span> <a href=\"#narrow/stream/179166-implementers/topic/Period.20Datatype.20Invariant/near/267486133\">said</a>:</p>\n<blockquote>\n<p>The tricky thing about relying on _profile search is that it's only going to work if the server has actually tagged every resource with all of the profiles you care about - it's entirely possible that a resource meets the requirements for profile X, but is not tagged with that in meta.profile because the server didn't validate profile X.</p>\n</blockquote>\n<p>You don't have to have tagged every resource. You could tag every resource if that is how your search works. Say I do a query /Observation?_profile=XYZ.<br>\nIf the server is SQL and the query is \"SELECT * FROM Observations where profile contains (XYZ)\" - then yes you need them tagged<br>\nBut if the server converted that _profile parameter \"SELECT * FROM Observations where code = 123 and status = complete and value &gt; 10\" - then they don't need to be tagged.</p>\n<p>But to <span class=\"user-mention\" data-user-id=\"191506\">@Yunwei Wang</span> point, who has time to implement every different _profile search value and the matching data values into their servers?</p>",
        "id": 267488386,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1641843194
    },
    {
        "content": "<p>I have mixed feelings about the whole \"propagating garbage\" issue because it gets to the heart of whether we're propagating data with the intent that it's actually machine-readable to a standard where you can do ML, decision support, visualizations, applications on top of it, or whether it's good enough that a human can maybe guess what it's supposed to mean if they're lucky. I don't want to deny people their records but I would rather they were meaningfully machine-readable or having those records in your possession is kind of a dead end.</p>\n<p>Ironically, the Google FHIR implementation has options to disable required fields, disable referent type validation (i.e. a Reference(Patient) field referring to something that isn't a Patient), and disable FHIRPath constraints from the base spec - because for better or worse, some customers want to do these things.</p>",
        "id": 267496119,
        "sender_full_name": "Paul Church",
        "timestamp": 1641847028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191764\">Cooper Thompson</span> <a href=\"#narrow/stream/179166-implementers/topic/Period.20Datatype.20Invariant/near/266855781\">said</a>:</p>\n<blockquote>\n<p>Sort of related to this, but what should a system do if they have data that is not compliant with the (new/future updated) expression?  For example, if we have a start date of 1/2/2022 and an end date of 1/1/2022  (i.e. startDate &gt; endDate).  This of course doesn't make sense, but if we got that data from a legacy system that has been retired, there isn't really much we can do.  </p>\n<p>The options I can think of:</p>\n<ol>\n<li>Don't send the data at all.  But this isn't really great, since it means that callers of the API will just be unable to access data that we have.</li>\n<li>Send it in Period anyway, ignoring the constraint, and ignore Lloyd when he yells at us for being non-conformant :D.</li>\n<li>Check every set of start/end timestamps, and if they pass the invariant, send them in Period, and if not, send them in extensions.</li>\n</ol>\n</blockquote>\n<p>Another option is to use an extension in Period to carry the garbage, say<br>\nperiodAsString: it can carry the start and end in a format useful for humans and there will be no validation problems. Of course it will not be searchable, but it is garbage. And the rest of the resource will be usable.</p>",
        "id": 267525435,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1641864063
    },
    {
        "content": "<p>I definitely prefer options that stick non-conformant data in narrative, extensions, or something else that conveys the \"potentially relevant\" data that is not computably useful.</p>",
        "id": 267535628,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641875611
    },
    {
        "content": "<p>I'd forgotten this was discussed previously in this <a href=\"#narrow/stream/179175-argonaut/topic/US.20Core.3AExtensible.20and.20Required.20bindings.20for.20historical.20data\">argonaut historical data thread</a>.</p>",
        "id": 269117601,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1643036494
    }
]