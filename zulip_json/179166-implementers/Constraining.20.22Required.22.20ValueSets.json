[
    {
        "content": "<p>If an element within a Resource is bound to a \"Required\" ValueSet, is it legal to restrict (constrain) that ValueSet or does it have to be used in its entirety?</p>",
        "id": 153846673,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1473255142
    },
    {
        "content": "<p>You may constrain (logical subset) in profiles or in use but not exchange with a valueset containing other values or extend.</p>",
        "id": 153846674,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1473255250
    },
    {
        "content": "<p>Hi Richard. You can use any codes from that ValueSet as per your requirement and can constraint or create subset from the values given in ValueSet. Required means, you cannot extend (with your own codes) the ValueSet codes. It is like HL7 Defined tables (data type ID) in V2. </p>",
        "id": 153846675,
        "sender_full_name": "Aditya Joshi",
        "timestamp": 1473255332
    },
    {
        "content": "<p>Thanks</p>",
        "id": 153846678,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1473256159
    },
    {
        "content": "<p>RIchard, If you see a need, now is a good time to express that need. You might have a use-case that has not yet been considered.</p>",
        "id": 153846679,
        "sender_full_name": "John Moehrke",
        "timestamp": 1473256359
    },
    {
        "content": "<p>In this case our use case is a very local one. Within the NHS in England we have national standards for such things as gender, marital status, language, country codes etc. Unfortunately in places FHIR chooses to provide \"required\" valueSets for these which causes us a world of pain. Where our national valueset can be mapped to a subset of the FHIR valueset then we can get by.</p>\n<p>We have other issues where this is not possible and we are raising changes which may or may not be picked up in STU3. For now we are having to do some relatively clunky modifier extensions to get around these.</p>",
        "id": 153846684,
        "sender_full_name": "Richard Kavanagh",
        "timestamp": 1473263991
    },
    {
        "content": "<p>In HL7 Core Principles, we have the concept of both \"minimum\" and \"maximum\" bindings - maximum bindings identify the complete set of what's permitted to be used and minimum bindings identify what must be supported (and can't be later constrained out).  At the moment FHIR only deals with maximum bindings - it's generally hard enough to get agreement there.  I suspect at some point we'll add extensions to let implementers define \"minimum\" bindings when they want to say \"and by the way, systems must be able to handle at least all of this subset and can't constrain them out.</p>",
        "id": 153846711,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1473277514
    },
    {
        "content": "<p>Those extensions have already been defined:<br>\n<a href=\"https://simplifier.net/core-extensions/elementdefinition-minValueSet\" target=\"_blank\" title=\"https://simplifier.net/core-extensions/elementdefinition-minValueSet\">https://simplifier.net/core-extensions/elementdefinition-minValueSet</a><br>\n<a href=\"https://simplifier.net/core-extensions/elementdefinition-maxValueSet\" target=\"_blank\" title=\"https://simplifier.net/core-extensions/elementdefinition-maxValueSet\">https://simplifier.net/core-extensions/elementdefinition-maxValueSet</a></p>",
        "id": 153846713,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1473278865
    },
    {
        "content": "<p>Why do you have an extension for maxValueSet?</p>",
        "id": 153846715,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1473279984
    },
    {
        "content": "<p>I defined it. From the description: The maximum allowable value set, for use when the binding strength is 'extensible'. This value set is the value set from which extensions can be taken from</p>",
        "id": 153846723,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1473285428
    },
    {
        "content": "<p>But how is that different from \"required\"?</p>",
        "id": 153846729,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1473291393
    },
    {
        "content": "<p>You're saying \"only codes from this value set are permitted\" - which is what required does . . .</p>",
        "id": 153846730,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1473291410
    },
    {
        "content": "<p>if the binding strength is extensible,</p>",
        "id": 153846731,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1473292923
    },
    {
        "content": "<p>If the binding strength is extensible, that means you can use any code from any system if your concept is outside the specified value set.  If you want to say \"you must use only this set of codes\" - which is what you're doing with your \"max\", then that's a required binding</p>",
        "id": 153846737,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1473305009
    },
    {
        "content": "<p>what you are saying is that the value set is extensible, *but* if your concept is outside the speciifed value set, it still must be drawn from a bigger value set</p>",
        "id": 153846738,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1473307564
    },
    {
        "content": "<p>Then it's not extensible.  Instead, the value set is the larger value set.  Because there's no requirement to support any of the codes in the small value set, there's no point mentioning it at all - you just have a required binding to the larger value set.  Extensible means you can use any code you like - or no codes at all - for concepts outside the value set.</p>",
        "id": 153846741,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1473314486
    },
    {
        "content": "<p>not so. Extensible means that if one of these codes is correct, you must use it. Simply going with the max value set loses that. </p>",
        "id": 153846744,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1473321008
    },
    {
        "content": "<p>But if you have a required value set, you haven't lost anything unless your \"big\" value set includes duplicate concepts - which would be poor design.  With the big value set, you'd be saying \"you must use whichever one of these big value set codes applies\".  With small extensible value set plus big value set, you'd still be saying \"you must use whichever one of these big value set codes applies\" - adding \"and by the way if one of this subset of the big value set applies, you must use that\" is redundant.</p>",
        "id": 153846791,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1473366149
    },
    {
        "content": "<p>the use case I was given - one that's come up in more than one context is 'this SCT value set', but if you can't, it still must be a SCT concept. </p>",
        "id": 153846808,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1473369203
    },
    {
        "content": "<p>So, from a validation perspective, how is the behaviour different than simply saying \"the value set is any SNOMED CT code\"?  Do you agree that your max binding is essentially doing a required binding to all of SNOMED?  If not, how would it be different?</p>",
        "id": 153846814,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1473370441
    },
    {
        "content": "<p>yes, the max binding is doing a required binding to all of snomed. but providing a extensible binding to a snomed ct subset, and a required binding to snomed, that's different than just providing a required binding to snomed</p>",
        "id": 153846815,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1473370567
    },
    {
        "content": "<p>What's the difference from a validation/conformance testing perspective?  Is it the fact that SNOMED allows you to say the same thing multiple ways (and thus, a value set of \"all of SNOMED\" is, automatically, a poorly designed value set)?</p>",
        "id": 153846816,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1473370939
    },
    {
        "content": "<p>I don't know that any computable testing can test the difference. But manual inspection could. </p>",
        "id": 153846817,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1473371005
    },
    {
        "content": "<p>and I don't think 'all of snomed' is a poorly designed value set. It might be eay to use it poorly</p>",
        "id": 153846818,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1473371029
    },
    {
        "content": "<p>From a good vocabulary practice perspective, it's a \"questionable\" value set because there are multiple ways to convey the same concept, but I guess it wouldn't qualify as \"poorly designed\" because it's still a single code system.  If the intention is to say \"you must send this concept as pre-coordinated, but other concepts can be whatever you like\", then I guess that works.  To me, this is actually an example of multiple bindings - you have both a required binding and an extensible binding that tightens down how you're allowed to send certain concepts.</p>",
        "id": 153846895,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1473445591
    }
]