[
    {
        "content": "<p>I'm still trying to wrap my head around what TestScript is designed to do. Can a TestScript say \"run this query and ensure that all references in the returned resources are resolvable to existing resource\"? </p>",
        "id": 153824601,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462401165
    },
    {
        "content": "<p>Yes. This is a common type of test. For example, your TestScript defines the following series of operations: create resource, search for resource. After the search operation, you define asserts; one of which is a verification that the searchset Bundle contains the just created resource.</p>",
        "id": 153824604,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1462412904
    },
    {
        "content": "<p>There are a couple of ways you could write that assert - using the minimumId test where you reference a known external version of the resource to compare against the response, or a series of asserts that explicitly test the response for known expected values referenced via path expressions (currently xpath or jsonpath, fluentpath in the near future).</p>",
        "id": 153824605,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1462413107
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span>! Let me rephrase my question: I'm interested in TestScripts that don't/can't create new data on a server; I just want to perform consistency tests on whatever data a server exposes. </p>",
        "id": 153824625,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462450034
    },
    {
        "content": "<p>So, you should be able to do a READ and then check values in the response, or compare to a known fixture (aka example)</p>",
        "id": 153824646,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462457088
    },
    {
        "content": "<p>or validate against a given profile, for example</p>",
        "id": 153824647,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462457182
    },
    {
        "content": "<p>But for example is possible to say:</p>\n<p>1. Get me all the MedicationOrders<br>\n2. For each, resolve the <code>MedicationOrder.medication</code> and make sure it exists</p>\n<p>... with no preconception about what prescriptions and meds will actually be on the server?</p>",
        "id": 153824648,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462457210
    },
    {
        "content": "<p>The context here is conformance testing for projects like Argonaut or Sync for Science where the servers represent real EHR products exposing read-only interfaces on top of existing patient records. We can ask them to synthesize some specific records for testing, but ultimately we want to test systems \"in the wild\" to make sure references <strong>actually</strong> resolve (vs. testing that in carefully curated sample data they <strong>can</strong> resolve).</p>",
        "id": 153824649,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462457319
    },
    {
        "content": "<p>I think this is out of scope for <code>TestScript</code>, but I don't want to assume too much since I see a lot defined there and I don't understand all of it.</p>",
        "id": 153824650,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462457346
    },
    {
        "content": "<p>Yeah, you can't do that with <code>TestScript</code> today... unless you use a <code>ruleset</code></p>",
        "id": 153824651,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462457551
    },
    {
        "content": "<p>Which is new and not supported outside of AEGIS</p>",
        "id": 153824652,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462457573
    },
    {
        "content": "<p>All the Argonaut tests in Crucible are hand written. And I anticipate we'll do the same for S4S.</p>",
        "id": 153824653,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462457602
    },
    {
        "content": "<p>We (Crucible) likely won't use <code>TestScript</code> for those.</p>",
        "id": 153824654,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462457624
    },
    {
        "content": "<p>Ah, OK. That lines up with my expectations, but I wanted to double-check. Thanks <span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span>!</p>",
        "id": 153824655,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462457839
    },
    {
        "content": "<p>@Josh, through the use of TestScript.variables that point to expected reference values in a retrieved resource; e.g. read or search, we can then perform a subsequent read based on the reference value to determine if the referenced resource does exist.</p>",
        "id": 153824715,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1462476995
    },
    {
        "content": "<p>The new TestScript <code>rule</code> and <code>ruleset</code> elements are something we [AEGIS] are proposing for STU3 and we'll be trying them out at the Connectathon this weekend.</p>",
        "id": 153824716,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1462477331
    },
    {
        "content": "<p>I'll be happy to write a TestScript that demonstrate what your example for <code>MedicationOrder.medication</code> defines and we can review it in Montreal.</p>",
        "id": 153824717,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1462477490
    },
    {
        "content": "<p>Well, he wants to do it for every single MedicationOrder, so I'm interested to see how you do that. I'd like to see that in Montreal as well.</p>",
        "id": 153824773,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462534382
    },
    {
        "content": "<p>Sure, it would be great to see how this works <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span>! </p>",
        "id": 153824776,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1462536540
    },
    {
        "content": "<p>Josh, Jason is correct regarding the TestScript's current ability to not iterate through the search results. When we started working on the TestScript definition, this wasn't something we thought to initially include based on the use cases we had at the time. The proposed <code>rule</code> and <code>ruleset</code> enhancements might work but there are some security concerns I have around providing that kind of functionality in a rules engine and rule scripts. Based on your use case, I would recommend a potential enhancement to TestScript that would allow for variables to contain a collection of elements and/or values along with corresponding assert constructs to handle iterating though that collection. In any case, I will have an example TestScript ready of your use case using the current TestScript capabilities that we can review in Montreal. Looking forward to the discussion. -Thanks.</p>",
        "id": 153824797,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1462545043
    },
    {
        "content": "<p>Montreal Connectathon 12 Breakout recap:</p>\n<ul>\n<li>Grahame is interested in optimizing TestScript for the ImplementationGuide use-case, and making API technical conformance testing an infrastructure thing each TestScript inherits</li>\n<li>This would mean breaking out things like \"verifying presence of headers\" and very fine-grained assertions into a computable format for the base specification</li>\n<li>There was also discussion of replacing various assertions and rules/rulesets with FluentPath.</li>\n</ul>\n<p>Did I miss anything else?</p>",
        "id": 153825210,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462643779
    },
    {
        "content": "<p>I wouldn't have said this: <br>\n\"Grahame is interested in confining TestScript to ImplementationGuide use-cases\"</p>",
        "id": 153825211,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462643816
    },
    {
        "content": "<p>I am interested in optimising it for that use case, and making API technical conformance testing an infrastructural thing you can inherit into a normal test script, and one that's maintained by only a few of us</p>",
        "id": 153825214,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462643859
    },
    {
        "content": "<p>and that probably means re-organising the rules part of the spec somewhat </p>",
        "id": 153825215,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462643903
    },
    {
        "content": "<p>OK, I edited my previous post to reflect some of that.</p>",
        "id": 153825216,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462643938
    },
    {
        "content": "<p>I think that a summary would cover some of our scope discussions</p>",
        "id": 153825218,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462644057
    },
    {
        "content": "<p>- security is out of scope </p>",
        "id": 153825219,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462644065
    },
    {
        "content": "<p>- whether orchestration/choreography in scope is undecided </p>",
        "id": 153825223,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462644092
    },
    {
        "content": "<p>- we're all concerned that Test Script doesn't get too complex, and most of us think that we're already there</p>",
        "id": 153825231,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462644141
    },
    {
        "content": "<p>- Josh's specific need is specifically out of current scope</p>",
        "id": 153825234,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462644162
    },
    {
        "content": "<p>- but we do want to able have interoperable test specifications</p>",
        "id": 153825236,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462644179
    },
    {
        "content": "<p>Good adds.</p>",
        "id": 153825260,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462644623
    },
    {
        "content": "<p>So, I've been thinking about the concept that was raised during the TestScript breakout on Saturday regarding pulling some assertions outside of TestScript.</p>\n<p>What if we encoded the two tables here (<a href=\"http://hl7.org/fhir/2016May/http.html#summary\" target=\"_blank\" title=\"http://hl7.org/fhir/2016May/http.html#summary\">http://hl7.org/fhir/2016May/http.html#summary</a>) as structured XML/JSON -- perhaps with some more metadata in there -- as part of the build. An execution engine could then use that template for validating all client/server RESTful interactions. We'd be able to omit those from TestScripts since they would be implicitly verified, and the TestScript can focus on logic associated with the business rules of the test itself.</p>\n<p>Thoughts?</p>",
        "id": 153826454,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462907569
    },
    {
        "content": "<p>I think those are good thoughts. Do you want to make the json, or do you want me to make it?</p>",
        "id": 153826464,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462909084
    },
    {
        "content": "<p>So is the intent that if I defined the following operation that the 'base' asserts from these tables would already be defined and executed by the test engine?</p>\n<div class=\"codehilite\"><pre>&lt;operation&gt;\n    &lt;type&gt;\n            &lt;system value=&quot;http://hl7.org/fhir/testscript-operation-codes&quot;/&gt;\n            &lt;code value=&quot;create&quot;/&gt;\n    &lt;/type&gt;\n    &lt;resource value=&quot;Patient&quot;/&gt;\n    &lt;accept value=&quot;xml&quot;/&gt;\n    &lt;contentType value=&quot;xml&quot;/&gt;\n    &lt;sourceId value=&quot;patient-create&quot;/&gt;\n&lt;/operation&gt;\n</pre></div>\n\n\n<p>And, therefore, eliminate the need for explict asserts like this?</p>\n<div class=\"codehilite\"><pre>&lt;assert&gt;\n    &lt;description value=&quot;Confirm that the returned HTTP status is 200(OK).&quot;/&gt;\n    &lt;response value=&quot;okay&quot;/&gt;\n&lt;/assert&gt;\n</pre></div>",
        "id": 153826587,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1462913788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I'm on vacation the next few days, but I can create it after that. <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> Yes.</p>",
        "id": 153826608,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1462916088
    },
    {
        "content": "<p>yes. After all, this assert is always enforceable whether specified in the test script or not </p>",
        "id": 153826736,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1462962541
    },
    {
        "content": "<p>This is an extremely interesting discussion, and it dovetails nicely with the work that I have been doing around ONC DAF profile testing. Basically, I am seeking to create automated test coverage for as much of the DAF profile functionality as possible, while not adding to problems of tool proliferation/duplication, and TestScripts seem the ideal solution. During my analysis of the existing coverage in both Crucible-FHIR and Aegis' Touchstone, and just looking at the FHIR TestScript resource definition itself, I have noticed some things that could be improved, and wonder what you all think: &lt;more to come, didn't realize enter would post&gt;</p>",
        "id": 153827829,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463163722
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191537\">@Douglas Harley</span> Yes. Any suggestions and recommendations are very welcome. I do need to re-visit the TestScripts currently deployed in Touchstone and your input would definitely help.</p>",
        "id": 153827830,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1463163877
    },
    {
        "content": "<p>1) Coming primarily from the Java world, and a deep appreciation for the junit framework, it seems that it would be useful for purposes of aggregation that TestScript could optionally refer to children TestScripts. Additionally, it would be beneficial if there were downward-visible variable scoping, such that a child TestScript would have visibility of variables defined \"above it\" in the hierarchy. Aggregating TestScripts would greatly ease the burden of TestScript organization for test clients, and implementors too.</p>",
        "id": 153827831,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463164023
    },
    {
        "content": "<p>2) Currently, TestScript is really a great concept without a home, since it isn't referred-to by any other resources. It seems that it would be beneficial for the community to be able to define \"official\" TestScripts, and associated fixture data along with other profile resources. So, a profile would have an implementation guide, and conformance statement(s), and TestScripts/fixtures, which can be used to verify correct implementation of the putative conformance statement(s).</p>",
        "id": 153827832,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463164241
    },
    {
        "content": "<p>I had initially purposed within our team that the Conformance resource might be a good home for TestScript(s), but others on my team thought not, and I can see their point. Still, we all think it would be useful if there were some way to associate official DAF profile TestScripts and data with the DAF profile.</p>",
        "id": 153827833,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463164334
    },
    {
        "content": "<p>3) The current TestScript operation codes (<a href=\"https://www.hl7.org/fhir/valueset-testscript-operation-codes.html\" target=\"_blank\" title=\"https://www.hl7.org/fhir/valueset-testscript-operation-codes.html\">https://www.hl7.org/fhir/valueset-testscript-operation-codes.html</a>) while defining the r̶e̶a̶d̶ search operation, do not allow for the specification of POST HTTP method, and that is an explicit requirement of FHIR, so I don't see how to test it, and it seems that the value set needs to expanded.</p>",
        "id": 153827834,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463164460
    },
    {
        "content": "<p>&lt;edit&gt; adding: <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span>&lt;/edit&gt; Hi Richard, thanks for your great work with the existing DAF TestScripts! They are excellent, and cover already the most important aspects of DAF functionality. :)</p>",
        "id": 153827836,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463164569
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191537\">@Douglas Harley</span> You're very welcome.  I know that there have been some recent updates regarding supported search pardigms that would remove the compartment search from the Argonaut requirements.  I'll be updating the DAF TestScripts at some point based on this.</p>",
        "id": 153827837,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1463165049
    },
    {
        "content": "<p>That should be an Argonaut-only change I think...as far as I know there is no move to remove the Patient compartment search requirements from DAF Patient. However, I am relatively new to the project, so I will discuss with our team.</p>",
        "id": 153827838,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463165312
    },
    {
        "content": "<p>Visibility of variables defined elsewhere is a bit challenging from a methodology perspective.  We try hard to ensure that each resource instance can be interpreted/used on its own.</p>",
        "id": 153827839,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463165488
    },
    {
        "content": "<p>I think that the ability to abstract-out a lot of the lower-level validation out of TestScript is a great idea...indeed, it seems to suggest a need for a TestScript engine RI. Without a single reference implementation, it is quite possible to have a single TestScript that operates differently, and gives different results, when executed within 2 different engines.</p>",
        "id": 153827840,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463165571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> That makes sense...to clarify, I think that is the least-useful aspect of a potential self-referential TestScript, the aggregation and organizational abilities are more interesting.</p>",
        "id": 153827841,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463165759
    },
    {
        "content": "<p>all the above just my $0.02 from when I was thinking about this stuff...please feel free to shoot holes in all of it :)</p>",
        "id": 153827842,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463165884
    },
    {
        "content": "<p>Abstracting the lower-level validation is something we (FHIR Core, AEGIS and MITRE) discussed in Montreal during the FHIR Connectathon and some of the WGM sessions. The idea is that a FHIR TestScript test engine would always execute the base assertions for a given operation as defined on the RESTful API page (bottom two tables) <a href=\"http://hl7-fhir.github.io/http.html#summary\" target=\"_blank\" title=\"http://hl7-fhir.github.io/http.html#summary\">http://hl7-fhir.github.io/http.html#summary</a></p>",
        "id": 153827843,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1463165884
    },
    {
        "content": "<p>yes, i saw that, and it is a great idea. (unfortunately, the DAF team was not able to travel to Montreal for the connect-a-thon.)</p>",
        "id": 153827844,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463166246
    },
    {
        "content": "<p>No worries. This thread will be the place to collaborate and share ideas.</p>",
        "id": 153827845,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1463166447
    },
    {
        "content": "<p>Regarding your 3rd point, each of the operations define how they are executed; i.e. read via GET, create via POST, update via PUT and so on. A TestScript test engine will know which HTTP operation to perform for each FHIR operation.</p>",
        "id": 153827846,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1463166539
    },
    {
        "content": "<p>...but it ultimately depends upon the reach/depth/correctness of the implementation, which can be assumed to vary between engines. in an ideal world, there would be a single implementation of TestScript engine, that way the only differences between TestScript results for 2 different FHIR servers would be completely due to differences in server implementations, but that cannot be the case with multiple engine implementations.</p>",
        "id": 153827847,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463166603
    },
    {
        "content": "<p>argh!...i accidentally wrote \"read\" when i meant \"search\"</p>",
        "id": 153827848,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463166706
    },
    {
        "content": "<p>the search interaction can be either GET, or POST</p>",
        "id": 153827849,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463166737
    },
    {
        "content": "<p><a href=\"https://www.hl7.org/fhir/http.html#search\" target=\"_blank\" title=\"https://www.hl7.org/fhir/http.html#search\">https://www.hl7.org/fhir/http.html#search</a> \"...in addition to the get based search method above, servers that support search SHALL also support a POST based search...\"</p>",
        "id": 153827850,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463166821
    },
    {
        "content": "<p>Currently, we control this in the the Touchstone test engine by whether the source is set in the operation where if source points to a fixture to be sent we issue a POST; if the source is empty/not defined, then a GET.</p>",
        "id": 153827851,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1463168117
    },
    {
        "content": "<p>nice, that is a good workaround. i wasn't able to look inside Touchstone code to see how things were implemented...again though, this behavior is not specified in the TestScript standard, and other implementations (e.g., Crucible-FHIR) are not like this.</p>",
        "id": 153827852,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463168453
    },
    {
        "content": "<p>...at least not that i gathered, i am a relative ruby newby. ;)</p>",
        "id": 153827853,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463168500
    },
    {
        "content": "<p>Yes, this behavior needs to be defined and documented for TestScript.  The current TestScript definition page also needs to be updated based on some recent modifications.  I am also going to be authoring a new \"testing\" page in the spec to offload a good chunk of the TestScript page text to a new home.</p>",
        "id": 153827854,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1463168663
    },
    {
        "content": "<p>cool...that sounds like a good idea too</p>",
        "id": 153827855,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463168753
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> I spoke with the DAF technical lead, and you are completely correct: DAF is following Argonaut, and we are also removing the compartment search requirements for DAF Patient.</p>",
        "id": 153827867,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463202887
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191537\">@Douglas Harley</span> interesting discussion. I've talked to Richard at the WGM about some of this, esp. how the community could provide some form of \"official\" or vetted Testscripts. One of the ideas that came up is to publish approved TestScript packages on the FHIR registry at <a href=\"http://simplifier.net\" target=\"_blank\" title=\"http://simplifier.net\">simplifier.net</a>. This could also enable links between official IG's/profiles on the registry and associated TestScripts. If the community finds this helpful, we could try and implement some basic TestScript support in the simplifier platform. Looking forward to feedback on this.</p>",
        "id": 153827868,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1463231389
    },
    {
        "content": "<p>So there's a daf implementation guide resource - this is where a day test script should be referenced </p>",
        "id": 153827878,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463267387
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> thanks for the clarification.</p>",
        "id": 153827931,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463365328
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> Thanks for the suggestions, that all sounds intriguing...but I must confess that I am fairly new to the ONC DAF project, and FHIR itself, and so am not familiar with <a href=\"http://simplifier.net\" target=\"_blank\" title=\"http://simplifier.net\">simplifier.net</a> and its role in the FHIR ecosystem. I have passed-along this conversation to our technical lead to get his thoughts, and I will be able to respond further after we speak. cheers :)</p>",
        "id": 153827936,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463365717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> DAF profile TestScripts, along with all other profile resources, are free for anyone to use, and will be made available through the usual FHIR release mechanisms. Right now though, I am just starting the process of seeing what's already out there in terms of DAF testing, what needs to get done, and ultimately where things are going to live. With regards to a \"reference implementation\" of a TestScript engine, I was speaking only conceptually. As a software developer who fully-embraces automated testing, I see the lack of a single common community TestScript execution engine as a weakness in the ultimate practicality and usefulness of TestScripts, and was just stating my technical opinion explicitly.</p>",
        "id": 153827986,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463413709
    },
    {
        "content": "<p>but having more than one is a different kind of strength</p>",
        "id": 153827999,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463420049
    },
    {
        "content": "<p>Interesting.... I came up with a few potential strengths: 1) more people working on implementations means \"more eyes\", and so the spec can be worked-over iteratively, and innovation might occur faster; 2) potential issues discovered in one implementation might be circumvented via use of a different implementation; 3) having multiple implementations lends a kind of tacit approval of the specification, in that \"the more implementers, the better the spec must be\". All certainly well-and-good at this stage, but as the platform matures, uniformity of correctness, breadth-and-depth of spec coverage, and stability seems like they would become of overriding importance for a TestScript engine.</p>",
        "id": 153828136,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463492307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> any thoughts on my proposal to add reference to child TestScripts to TestScript? it seems that it would be much easier for test tool implementers to just \"point-to\" 2 DAF-related tests (i.e., DAF query requester, and DAF query responder), and get all the TestScripts referred-to therein automatically via a resolution process. During my process I might create for example 20 different TestScripts in total, and organizing them without this proposed self-referential enhancement seems like a real headache, and a potential source of errors/ommissions</p>",
        "id": 153828142,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463493180
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191537\">@Douglas Harley</span> I do like the concept in general; however, I have to agree with Lloyd's position here where he stated earlier in this thread \"We try hard to ensure that each resource instance can be interpreted/used on its own\". The dependencies this would introduce into the TestScript definition goes against this philosophy. I would also be concerned of potential circular references.</p>",
        "id": 153828169,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1463508783
    },
    {
        "content": "<p>In Touchstone we currently provide a grouping mechanism using an appropriate folder structure. This isn't part of the specification but still a useful organizational mechanism for our environment.</p>",
        "id": 153828170,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1463508792
    },
    {
        "content": "<p>Fair enough...if it isn't an organizational problem for you guys, then it isn't a problem. :)</p>",
        "id": 153828171,
        "sender_full_name": "Douglas Harley",
        "timestamp": 1463509206
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> I've made an attempt to move the HTTP Table (<a href=\"http://hl7.org/fhir/2016May/http.html#summary\" target=\"_blank\" title=\"http://hl7.org/fhir/2016May/http.html#summary\">http://hl7.org/fhir/2016May/http.html#summary</a>) into JSON. You can see the proposal here: </p>\n<ul>\n<li><a href=\"https://github.com/fhir-crucible/fhir_client/blob/stu3/lib/fhir_api_validation.json\" target=\"_blank\" title=\"https://github.com/fhir-crucible/fhir_client/blob/stu3/lib/fhir_api_validation.json\">https://github.com/fhir-crucible/fhir_client/blob/stu3/lib/fhir_api_validation.json</a></li>\n</ul>\n<p>Example code that uses these JSON rules to validate the structure of the HTTP request/responses is here: </p>\n<ul>\n<li><a href=\"https://github.com/fhir-crucible/fhir_client/commit/31a434eb57354f241879642823da8cbbc65a1fde#diff-68edf999a120d604d2b47800ed1a3377\" target=\"_blank\" title=\"https://github.com/fhir-crucible/fhir_client/commit/31a434eb57354f241879642823da8cbbc65a1fde#diff-68edf999a120d604d2b47800ed1a3377\">https://github.com/fhir-crucible/fhir_client/commit/31a434eb57354f241879642823da8cbbc65a1fde#diff-68edf999a120d604d2b47800ed1a3377</a></li>\n</ul>\n<p>Let me know what you think. The JSON (or something similar) could be used to generate the HTTP Table in the specification HTML, and could be used to validate the API calls, replacing a boat-load of TestScript assertions.</p>",
        "id": 153829673,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1464115085
    },
    {
        "content": "<p>that's the kind of thing I was thinking of, yes. We could generate conformance statements from that as well, right? </p>",
        "id": 153829681,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464125483
    },
    {
        "content": "<p>I do think we need support for 5xx as a code, and generally, 3xx codes are always allowed...</p>",
        "id": 153829682,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464125508
    },
    {
        "content": "<p>could make some more detailed comment, but I think it would be good to build that into the spec itself and generate conformance statements from it,</p>",
        "id": 153829683,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464125531
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span> I like the initial structure. I'll have to wait until later this week to do a more detailed review.  Thanks.</p>",
        "id": 153829698,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464131905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> My thinking was that 4XX errors were valid responses... but a 5XX errors was something really bad (internal server error) so the response should not validate. As for 3XX, a redirect, the client should follow it and eventually get a different status code and server response which can be validated, therefore it didn't need to be included.</p>\n<p>As for generating conformance statements... I'm not sure where it fits to be honest.</p>\n<p>Do you want me to move it into the svn build, or submit a change request, or take no action?</p>\n<p><span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span>  OK, thanks.</p>",
        "id": 153829750,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1464178595
    },
    {
        "content": "<p>a number of the public servers have trouble separating client and server errors. I don't how to do that is very often you shouldn't have asked for that, but differentiating this is above the level of the code. </p>",
        "id": 153829837,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464211815
    },
    {
        "content": "<p>I think we shouldn't require a server to get this right in conformance testing. </p>",
        "id": 153829838,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464211839
    },
    {
        "content": "<p>here's an example: if a client sends me a json with duplicate properties, my json parser throws an exception. </p>",
        "id": 153829839,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464211872
    },
    {
        "content": "<p>it throws the same exception if it's out of resources</p>",
        "id": 153829840,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464211884
    },
    {
        "content": "<p>as for 3xx - A production client doesn't always follow that. and it's not clear that a conformance testing client will either. 304 not modified is a valid response under some circumstances. </p>",
        "id": 153829841,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464211961
    },
    {
        "content": "<p>Well, I follow you in how it can be used to identify both client and server errors in conformance testing -- just not how it would be used in generating conformance statements... unless it is a statement like \"your client (or server) doesn't conform to history interactions properly.\"</p>",
        "id": 153829977,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1464264728
    },
    {
        "content": "<p>At any rate, I'm going to use this JSON in the Crucible FHIR client. Let me know if you'd like me to contribute it to the SVN repo.</p>",
        "id": 153829978,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1464264779
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, <span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span> Here are my current thoughts regarding the computable structured format of the http.html summary tables.</p>",
        "id": 153830223,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364753
    },
    {
        "content": "<p>I agree that having this structure is good as it provides a way to generate and maintain the http.html summary tables.</p>",
        "id": 153830224,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364762
    },
    {
        "content": "<p>I am with Jason regarding not quite understanding how this structure would be used to generate conformance statements. I do see it working in relation with a FHIR client's or server's conformance statement as it applies to testing that client and/or server.</p>",
        "id": 153830225,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364775
    },
    {
        "content": "<p>While I do agree that this structure could be used by a test engine as a set of pre-defined test conditions, I have some questions and concerns:</p>",
        "id": 153830226,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364789
    },
    {
        "content": "<p>- The http.html summary tables contain a value 'N/A' for many entries. Is the 'N/A' to be interpreted as a hard MUST not be present, or as an optional SHOULD not be present?</p>",
        "id": 153830228,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364802
    },
    {
        "content": "<p>- There are other aspects of the API that are not represented in the summary tables. A few examples:</p>",
        "id": 153830229,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364815
    },
    {
        "content": "<p>-- Under the Support for Versions, <a href=\"http://hl7-fhir.github.io/http.html#versioning\" target=\"_blank\" title=\"http://hl7-fhir.github.io/http.html#versioning\">http://hl7-fhir.github.io/http.html#versioning</a>, section is the statement \"Server should always return the default timezone for date searches in the HTTP Response headers using the Date header.\" The HTTP Date header is not shown in the response summary table.</p>",
        "id": 153830230,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364825
    },
    {
        "content": "<p>-- Under the Content Types and encoding, <a href=\"http://hl7-fhir.github.io/http.html#mime-type\" target=\"_blank\" title=\"http://hl7-fhir.github.io/http.html#mime-type\">http://hl7-fhir.github.io/http.html#mime-type</a>, section is the description of the _format parameter that every operation/interaction SHOULD support.</p>",
        "id": 153830231,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364839
    },
    {
        "content": "<p>-- Under the Content Types and encoding, <a href=\"http://hl7-fhir.github.io/http.html#mime-type\" target=\"_blank\" title=\"http://hl7-fhir.github.io/http.html#mime-type\">http://hl7-fhir.github.io/http.html#mime-type</a>, section is the statement \"Requests MAY also specify this charset parameter in the Accept header and/or use the Accept-Charset header.\" The HTTP Accept-Charset header is not shown in the request summary table.</p>",
        "id": 153830232,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364849
    },
    {
        "content": "<p>- The structure derived from the http.html summary tables lack many features that should be explicitly defined. These features are what we as a Testing Group (FHIR Core Team, MITRE, AEGIS and a few others) worked through last summer when defining and refining the TestScript definition; i.e.:<br>\n-- Descriptions for interactions/operations and assertions. These inform the tester of what the expected behavior of a test execution should be.<br>\n-- Ability to group operations/assertions into specific tests.<br>\n-- Ability to validate against profiles.<br>\n-- Ability to check conformance of a test system for successful execution via metadata elements.<br>\n-- Sophisticated assertions based on XPath/JasonPath (FluentPath/FHIRPath in the near future).<br>\n-- Explicit checks for request/response header values.<br>\n-- Setup procedures to prepare a system under test for repeatable test execution outcomes.<br>\n-- Teardown procedures to return a system under test to its state prior to the test execution.<br>\n-- Constructs to allow client-side/peer-to-peer testing including support for multiple origins.<br>\n-- Constructs to support multiple destinations for interactions.</p>",
        "id": 153830233,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364863
    },
    {
        "content": "<p>I understand the desire to simplify what I sense is the perceived complexity of the TestScript resource. However, based on my experience, implementing a robust testing platform and environment is inherently complex. I'm sure you would agree that regardless of the design and implementation details, building a testing tool is not a simple task. I'm seeing the direct use of this structure in a test engine as just a shuffling of the deck chairs (as Grahame likes to put it).</p>",
        "id": 153830234,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364878
    },
    {
        "content": "<p>Getting back to the proposed structure, as I stated above I agree having this is good. Building the summary tables should be generated via a computable format. However, if we were to continue down the path of using this structure as input to a test engine, I feel that it will out of necessity need to grow and expand to support the explicit testing definitions that a test engine requires. As we add the missing features outlined above to this structure, it will increasingly look more like what we already have in the TestScript resource. The Testing Group put a lot of thought into the design of TestScript for DSTU2 and the current specification. Rather than add another format for a test engine to ingest, we could use this new computable structure format in a slightly different way. This structure could be used by a TestScript generator to produce the TestScript resources that define the approved \"FHIR API &lt;version&gt; Test Definitions\".</p>",
        "id": 153830235,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364888
    },
    {
        "content": "<p>As an example of what this might look like, I have taken the read operation/interaction from the existing summary tables and built a corresponding FHIR API STU3 Test Definition (TestScript) for a Patient read on our AEGIS FHIR STU3 server (GET <a href=\"http://wildfhir.aegis.net/fhir/TestScript/fhir-api-stu3-patient-read-xml\" target=\"_blank\" title=\"http://wildfhir.aegis.net/fhir/TestScript/fhir-api-stu3-patient-read-xml\">http://wildfhir.aegis.net/fhir/TestScript/fhir-api-stu3-patient-read-xml</a>).</p>",
        "id": 153830236,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464364900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> the proposed JSON was not to replace TestScript at all, so things like \"the ability to validate against profiles\" doesn't apply here -- that will remain a function of the TestScript. The proposed JSON was just to make the basic assertions that validate the structure of the requests and responses, and eliminates the need to reassert every header and response code for each operation in every TestScript. The TestScript will have to continue to assert things like all of your bullet points above. In your example, using this \"request/response schema\" (using the word schema as an analogy) you can eliminate lines 32-79, 86-92, 99-120 from your example TestScript with the exact same functionality.</p>",
        "id": 153830252,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1464374543
    },
    {
        "content": "<p>I would have thought that at least some of the things Richard listed would be candidates for addition to the json</p>",
        "id": 153830320,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464390175
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span> I believe what <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> was offering adding something new which parallels what Test Script already does may in fact become more confusing.  While our objective is to make it simply, if we are not careful we could make it more confusing for the community at large.  <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> identified alternative paths to automating and simplifying the generation of Test Scripts.  I think if we can support a broader range of inputs - such as IG, Profile, Resource, Model such as MDHT, and others - each providing a way to input into some mechanism which generates or outputs Test Script Resource (and does so quickly and efficiently) - we can keep the Test Script Resource as the Authoritative Approach to test FHIR Implementations.   I agree with <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> (if I am reading him/it correctly) we can add to JSON Tests.  I am keen to see what happens with the FluentPath test implementations.   </p>",
        "id": 153830399,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1464459469
    },
    {
        "content": "<p>well, there's already a set of unit tests for fluent path. I guess I could extract them to a more structured form</p>",
        "id": 153830414,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464515879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span> Yes, I know the proposed JSON is not a replacement for TestScript but is meant to be a way to simplify a TestScript. The intent as I understand it (please correct me if I mis-state) is that the proposed JSON represents pre-defined asserts that will always be used by a FHIR test engine. As you stated, this would drastically reduce the number of explict asserts following any given test operation. This sounds like a great idea at first and I agree that all of the rich features of TestScript do not need to be available for these base API asserts. Though, as I continue to think about this, I still have concerns and questions.</p>",
        "id": 153830542,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464623969
    },
    {
        "content": "<p>Even though the proposed JSON implicitly defines the base API asserts, the test engine will still need to explicitly implement those asserts. So, there still needs to be explicit definitions of the base API asserts for a FHIR test engine to correctly execute.</p>",
        "id": 153830543,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464623982
    },
    {
        "content": "<p>If a FHIR test engine were required to implement and always execute these base API asserts; i.e. make the test engine smarter, the test engine is now constrained. For instance, how does the test engine deal with testing situations where negative testing (error and exception conditions) must be verified? In other words, a test can be designed to force a system under test to respond to bad requests and data where the test will succeed when the system under test responds with an appropriate and expected error? The test engine would then need to 'know' not to apply the base API success asserts.</p>",
        "id": 153830544,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464623992
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> <span class=\"user-mention\" data-user-id=\"191381\">@Jason Walonoski</span> I believe we need to perform a full examination of all the implementation pages - http.html, search.html, operations.html, messaging.html and services.html - to produce a complete and accurate structure that represents what we are calling the \"Base FHIR API\". This structure would then be initially used to generate the summary tables. We can then take a better look at its potential use by and within a test engine.</p>",
        "id": 153830545,
        "sender_full_name": "Richard Ettema",
        "timestamp": 1464624032
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> <span class=\"user-mention\" data-user-id=\"191370\">@Richard Ettema</span> I agree that clarifying the N/A makes sense (Bullet 1), and adding support to the JSON for Date Header, _format parameter, Accept, Accept-Charset (Bullet 2 and sub-bullets) makes sense. If we add the features of Bullet 3 (and sub-bullets), I suspect we'd just end up with another set of TestScripts. That is fine and where we are today, but the idea was to explore a way to make some basic things in every TestScript implicit --- unless the TestScript wanted to explicitly execute things like check response code, or check a header -- for negative testing or otherwise. I think the more complicated actions in Bullet 3 should remain in TestScript. At any rate, I think (?) that we all agree that we want a computable \"Base FHIR API\" structure as Richard stated, and I submit that JSON example as a beginning.</p>",
        "id": 153830711,
        "sender_full_name": "Jason Walonoski",
        "timestamp": 1464698176
    }
]