[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span>  &amp;  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  could you share test cases for FHIR path in a format like JSON schema for example <a href=\"https://github.com/json-schema/json-schema\" target=\"_blank\" title=\"https://github.com/json-schema/json-schema\">https://github.com/json-schema/json-schema</a>, o different implementer can test their implementations against it.</p>",
        "id": 153857669,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1479462021
    },
    {
        "content": "<p>we use xml for test cases because it does comments. See <a href=\"http://hl7.org/fluentpath/tests.html\" target=\"_blank\" title=\"http://hl7.org/fluentpath/tests.html\">http://hl7.org/fluentpath/tests.html</a></p>",
        "id": 153857674,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1479463582
    },
    {
        "content": "<p>(and don't really want to maintain multiple formats for it, though you can write a converter for yourself if you like)</p>",
        "id": 153857702,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1479467307
    },
    {
        "content": "<p>that should be autoconvertable using standard xml --&gt; json tools</p>",
        "id": 153857704,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1479467672
    },
    {
        "content": "<p>I'm going to implement fhirpath in C for postgresql, clojure &amp; js - could you give me links to existing grammars and we definitely need tests not only in xml, but also in json</p>",
        "id": 153864966,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482775636
    },
    {
        "content": "<p>grammar: <a href=\"http://hl7.org/fhirpath/grammar.html\" target=\"_blank\" title=\"http://hl7.org/fhirpath/grammar.html\">http://hl7.org/fhirpath/grammar.html</a>. We don't have tests in json, but you're welcome to translate them. </p>",
        "id": 153864968,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1482776560
    },
    {
        "content": "<p><a href=\"http://hl7.org/fluentpath/tests.html\" target=\"_blank\" title=\"http://hl7.org/fluentpath/tests.html\">http://hl7.org/fluentpath/tests.html</a> - 404 :(</p>",
        "id": 153864969,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482778634
    },
    {
        "content": "<p>Provided grammar is too abstract - so no difference for .name and .count() , where() or .unexistingFn()  :(</p>",
        "id": 153864970,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482779419
    },
    {
        "content": "<p>Yeah, that's on purpose, we didn't want to put function names in the grammar. The only things in the grammar are operations with syntax.</p>",
        "id": 153864971,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1482781251
    },
    {
        "content": "<p>The tests are here, but yes, they're only in XML: </p>",
        "id": 153864972,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1482781326
    },
    {
        "content": "<p><a href=\"https://github.com/FHIR/fluentpath/tree/master/tests\" target=\"_blank\" title=\"https://github.com/FHIR/fluentpath/tree/master/tests\">https://github.com/FHIR/fluentpath/tree/master/tests</a></p>",
        "id": 153864973,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1482781327
    },
    {
        "content": "<p>I must have a wrong path on the serer...</p>",
        "id": 153864975,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1482783259
    },
    {
        "content": "<p>no. <a href=\"http://hl7.org/fhirpath/tests.html\" target=\"_blank\" title=\"http://hl7.org/fhirpath/tests.html\">http://hl7.org/fhirpath/tests.html</a></p>",
        "id": 153864976,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1482783278
    },
    {
        "content": "<p>Here i've started more semantic grammar - <a href=\"https://gist.github.com/niquola/72f24aeaa3066c9941605adcfd2e0008\" target=\"_blank\" title=\"https://gist.github.com/niquola/72f24aeaa3066c9941605adcfd2e0008\">https://gist.github.com/niquola/72f24aeaa3066c9941605adcfd2e0008</a></p>",
        "id": 153864977,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482785355
    },
    {
        "content": "<p>Looks ambiguous:    <code>Patient.name.given = 'Ewout'</code>    could be like  <code>Patient.name.given.concat().some($this = 'Ewout')</code><br>\nAnd again some philosophical note: a lot of features doesn't mean it's great; minimum and sufficient - does!<br>\nMay be split Fhirpath into <code>minimal-required</code> and <code>fancy-optional</code> parts?</p>",
        "id": 153864978,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482789656
    },
    {
        "content": "<p>all good languages have redundancy. ambiguity is not the same thing</p>",
        "id": 153864983,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1482817796
    },
    {
        "content": "<p>Question: we have [index] syntax in fhirpath, could \"index\" be fhirpath expression or just integer? Because implicit context it looks like not?!</p>",
        "id": 153864997,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482930836
    },
    {
        "content": "<p>Symmetry: why | is operator, but combine (which does almost the same) is function?</p>",
        "id": 153864998,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482943329
    },
    {
        "content": "<p>Could we say that functions like <code>empty</code> or <code>count</code> always should be the last in chain?</p>",
        "id": 153865000,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482944579
    },
    {
        "content": "<p>I think index could be an expression. I treat it as one</p>",
        "id": 153865013,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1482958416
    },
    {
        "content": "<p>probably combine is a function rather than an operator because we came to it's need later, and adding a function is easier than adding an operator</p>",
        "id": 153865014,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1482958464
    },
    {
        "content": "<p>I think empty and count are liekly to be last, but not guaranteed to be</p>",
        "id": 153865015,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1482958539
    },
    {
        "content": "<p>In case those folks on this thread missed it earlier - Richard posted on the testing thread the following:  Everyone,<br>\nJust wanted to let you know that a key new feature of Touchstone v3.3.x is the inclusion of support for fhirpath expression evaluation within TestScripts. The following TestScript fhirpath related elements, added for STU3, can now be defined and executed by Touchstone:<br>\nvariable.expression<br>\nassert.expression<br>\nassert.compareToSourceExpression</p>",
        "id": 153865025,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1482968002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> oh, operator vs function looks like random choice?  Implicit conversions to collection and back to value also bad idea, which brings indeterminism ;(. It would be nice to have clear deterministic model as foundation for fhirpath. There is well formulated functors, applicative and monads approach to work with collection in a composable way - for example math, string and date operations could be functors <a href=\"http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html#just-what-is-a-functor,-really\" target=\"_blank\" title=\"http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html#just-what-is-a-functor,-really\">http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html#just-what-is-a-functor,-really</a>. Also take a look at reduce as more generic approach - <a href=\"http://clojure.com/blog/2012/05/08/reducers-a-library-and-model-for-collection-processing.html\" target=\"_blank\" title=\"http://clojure.com/blog/2012/05/08/reducers-a-library-and-model-for-collection-processing.html\">http://clojure.com/blog/2012/05/08/reducers-a-library-and-model-for-collection-processing.html</a> - getting paths in collections, filters, ops like count, empty etc could be expressed as reduce functions. Also we need clearly specify how implicit data context is propagated in functions - here the idea of piping and/or carrying could be used</p>",
        "id": 153865029,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482985358
    },
    {
        "content": "<p>Operators vs functions - in haskell and ocaml all functions of two arguments could be written in infix (operators) notation</p>",
        "id": 153865030,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482985505
    },
    {
        "content": "<p>So grammar quite easily could be written to enable this automatically. </p>",
        "id": 153865031,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482985666
    },
    {
        "content": "<p>We could treat dot (.) as pipe operation (if we have carrying) or macro (if not)</p>",
        "id": 153865032,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1482985897
    },
    {
        "content": "<p>I'm not sure what you mean by implicit conversion to collection and back brings indeterminism?</p>",
        "id": 153865050,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483041126
    },
    {
        "content": "<p>By deterministic, I mean that the expression will give the same result every time it is evaluated.</p>",
        "id": 153865051,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483041144
    },
    {
        "content": "<p>How does implicit conversion to/from a list change that?</p>",
        "id": 153865052,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483041162
    },
    {
        "content": "<p>As far as operator vs function being a random choice, it's not random, it's based on expected usage and traditional expressions. Plus is an infix operator because that's how most people expect to be able to invoke it.</p>",
        "id": 153865056,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483043155
    },
    {
        "content": "<p>the discussion started with a single case where we might have defined an operator instead of a function, but didn't</p>",
        "id": 153865058,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483043762
    },
    {
        "content": "<p>So I think in that case, (| vs combine), we defined an infix operator because we expected to be doing lots more unioninig than combining.</p>",
        "id": 153865059,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483044111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> i mean indeterministic by different implementations ( i think <em>unspecified behaviour</em> is better word): for example you have <code>some.expression &gt; 2</code> where some expression evaluated into [1,2,3] and we got  =&gt; <code>[1,2,3] &gt; 2 </code> - what result should we expect?</p>",
        "id": 153865060,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483044546
    },
    {
        "content": "<p>If we always distinct list vs value operations, we could be accurate and  precise:   <code>expression.some( $this &gt; 2)  or expression.all($this &gt; 2)</code></p>",
        "id": 153865061,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483044644
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> in that case we expect a run-time error because the \"&gt;\" operator expects singleton inputs. The specification indicates that when an operator that expects a singleton input is given a collection with more than one element at runtime, that an error is thrown.</p>",
        "id": 153865062,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483045196
    },
    {
        "content": "<p>If you want to return only elements that are greater than 2, you use a where: <code>expression.some.where($this &gt; 2)</code></p>",
        "id": 153865063,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483045271
    },
    {
        "content": "<p>No, i mean logical operation</p>",
        "id": 153865064,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483045979
    },
    {
        "content": "<p>What about    <code>name.given = 'Smith'</code>, should it fail if <code>given.count &gt; 1</code>?</p>",
        "id": 153865065,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483046126
    },
    {
        "content": "<p>Yes.</p>",
        "id": 153865066,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483046203
    },
    {
        "content": "<p>I mean, if we introduce explicit conversion to/from collection and forbid such type of implicit operations on collection with one item - it will be much less frustrating :)</p>",
        "id": 153865067,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483046317
    },
    {
        "content": "<p><code>name.given.where($this = 'Smith').exists()</code> and <code>name.given[0] = 'Smith'</code></p>",
        "id": 153865068,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483046370
    },
    {
        "content": "<p>So, in the CQL usage, we have defined an option to indicate whether or not those types of implicit conversions to and from lists are allowed.</p>",
        "id": 153865069,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483046374
    },
    {
        "content": "<p>But FHIRPath itself allows you to make that decision as part of the implementation.</p>",
        "id": 153865070,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483046409
    },
    {
        "content": "<p>The point being that if you as the author know that .given will only have one element, then the compiler shouldn't prevent you from expressing something that you know will work.</p>",
        "id": 153865071,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483046451
    },
    {
        "content": "<p>Bad parts of javascript is good  evidence, that such decisions are evil. Let say you use such ubiquitous expression as invariant in some national profile?</p>",
        "id": 153865072,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483046619
    },
    {
        "content": "<p>I agree there are cases where you don't want to allow that kind of flexibility, but there are cases where you do want it too, so the specification allows the more general, and implementations can impose the more strict interpretation as necessary.</p>",
        "id": 153865073,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483046727
    },
    {
        "content": "<p>Hey, we are talking about interop :)</p>",
        "id": 153865074,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483046778
    },
    {
        "content": "<p>So fhirpath is not interoperable?</p>",
        "id": 153865075,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483046812
    },
    {
        "content": "<p>That's a pretty broad generalization.</p>",
        "id": 153865076,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483046836
    },
    {
        "content": "<p>I'm not even sure what it means. :)</p>",
        "id": 153865077,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483046848
    },
    {
        "content": "<p>Why - if some expressions could be interpreted by different implementations differently - is this interoperability? And this expressions will be in the heart of search, validation etc.</p>",
        "id": 153865078,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483046905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> what do you think?</p>",
        "id": 153865079,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483046936
    },
    {
        "content": "<p>Part of using an invariant within a given environment would require that you specify the behavior so that different implementations would get the same interpretation.</p>",
        "id": 153865080,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483046970
    },
    {
        "content": "<p>Within the FHIR specification specifically, invariants are allowed to use the implicit conversions to/from lists, but the implementations are expected to throw when singleton expectations are violated. I don't see how that results in a spec that is not interoperable?</p>",
        "id": 153865081,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483047058
    },
    {
        "content": "<p>It's like runtime and compile time errors. What if this expression is used in indexing function in database :/  </p>",
        "id": 153865082,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483047297
    },
    {
        "content": "<p>And it's just a matter of one additional operation to be precise!</p>",
        "id": 153865083,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483047364
    },
    {
        "content": "<p>No, you'd need to support ordering as well, but that's a different issue.</p>",
        "id": 153865084,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483047416
    },
    {
        "content": "<p>Note: it would be good to capture some of these implementations details (in test cases), and leverage testing to both see what works well, but to ensure folks are (where important) implementing this in a way which supports being interoperable :) - our approach is to avoid exclusive \"happy path\" testing, we would like to throw some of these examples which would be negative test case.  If anyone is able to articulate on this thread a negative (exception) test case, we will evaluate how to test for it - during an FHIR message exchange.</p>",
        "id": 153865085,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1483047489
    },
    {
        "content": "<p>And I agree, it's like runtime vs compile-time errors, and some implementations can choose to use compile-time errors, and some can use runtime. FHIRPath allows both. Within FHIR, FHIRPath invariants use runtime because there are lots of cases where the authors know (based on profile information that may or may not be available to the compiler) that a given expression will work, where a strict compiler would force them to use an extra operator.</p>",
        "id": 153865086,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483047566
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191460\">@Mario Hyland</span> There are several negative test cases in the FHIRPath test suite: <a href=\"https://github.com/FHIR/fluentpath/tree/master/tests\" target=\"_blank\" title=\"https://github.com/FHIR/fluentpath/tree/master/tests\">https://github.com/FHIR/fluentpath/tree/master/tests</a></p>",
        "id": 153865087,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483047638
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> fhirpath also missed <code>min</code> and <code>max</code> functions!</p>",
        "id": 153865088,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483047671
    },
    {
        "content": "<p>Haven't needed them so far.</p>",
        "id": 153865089,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483047789
    },
    {
        "content": "<p>The intent of FHIRPath is to be sufficient.</p>",
        "id": 153865090,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483047805
    },
    {
        "content": "<p>The simple place you need it is specify expressions for sorting in search.</p>",
        "id": 153865091,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483047845
    },
    {
        "content": "<p>I think all this mess with collection/value is result of <code>xml</code>ish  thinking :)</p>",
        "id": 153865092,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483047943
    },
    {
        "content": "<p>Comparison operators can define expressions for sorting in search.</p>",
        "id": 153865093,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483047978
    },
    {
        "content": "<p>I mean, you need expression to extract value by which you will sort - to build index</p>",
        "id": 153865094,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483048024
    },
    {
        "content": "<p>Coming late to this discussion... It seems to me that implicit conversions to/from lists (to satisfy operators that take single input, or to throw an error at runtime if  they're unsatisfied) is a \"sharp edge\" of the language without a huge benefit. But maybe I'm just missing the benefit...  </p>",
        "id": 153865097,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1483050066
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span>, <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>   why this expressions - <code>&lt;expression invalid=\"true\"&gt;name.given1&lt;/expression&gt;  or &lt;expression invalid=\"true\"&gt;Encounter.name.given&lt;/expression&gt;</code> are marked as invalid, do you mean we have to verify against fhir structure? This expressions are syntactically valid fhirpath expression, but not valid from fhir resources structure point of view. Should we mix this two things?</p>",
        "id": 153865103,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483106356
    },
    {
        "content": "<p>or by <code>invalid</code> you just mean empty result?</p>",
        "id": 153865104,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483106425
    },
    {
        "content": "<p>I could not stop :) In fhirpath we have expressions  like <code>value.is(Quality)</code> - but  in json we have key - <code>valueQuaility</code> in xml - tag <code>valueQuallity</code> -  this require backtracking in implementation or usage of FHIR metadata to evaluate such type of expressions - which is not good. And this is consequences of our polymorphics and serialization design. I think, we should serialize into <code>value: {type: 'Quality,...}  or &lt;value type=\"Quality\" value=\"\"&gt;</code> or do not use such type of expressions in fhirpath, or at least say it like <code>value[x].is(Quality)</code>.</p>",
        "id": 153865105,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483108494
    },
    {
        "content": "<p>Do we really need <code>as</code>as operator and <code>as</code> as function?</p>",
        "id": 153865106,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483111459
    },
    {
        "content": "<p><a href=\"https://medium.com/@niquola/query-languages-for-recursive-data-structures-da348036f679#.cc3s55rgt\" target=\"_blank\" title=\"https://medium.com/@niquola/query-languages-for-recursive-data-structures-da348036f679#.cc3s55rgt\">https://medium.com/@niquola/query-languages-for-recursive-data-structures-da348036f679#.cc3s55rgt</a> - i've put some thoughts about fhirpath into small post :) </p>",
        "id": 153865107,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483120603
    },
    {
        "content": "<p>Those tests are invalid for is and as, the .is() and .as() functions were removed in favor of the is and as operators.</p>",
        "id": 153865108,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483120705
    },
    {
        "content": "<p>And those were designed as operators so that we can tell in the grammar when we are parsing a type name.</p>",
        "id": 153865109,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483120720
    },
    {
        "content": "<p>And yes, the tests are marked invalid because they are expected to throw an error (either compile-time or run-time). I don't see a problem with having tests that expect a particular data model, though it would be nice if the tests indicated what model they were expected to be evaluated against.</p>",
        "id": 153865110,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483120823
    },
    {
        "content": "<p>The tests are full evaluation tests, not just syntax tests.</p>",
        "id": 153865111,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483120853
    },
    {
        "content": "<p>Here's some background posts that I think address the questions you raise in your blog entry:</p>",
        "id": 153865112,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483124312
    },
    {
        "content": "<p><a href=\"http://www.healthintersections.com.au/?p=2400\" target=\"_blank\" title=\"http://www.healthintersections.com.au/?p=2400\">http://www.healthintersections.com.au/?p=2400</a></p>",
        "id": 153865113,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483124313
    },
    {
        "content": "<p><a href=\"https://github.com/cqframework/clinical_quality_language/wiki/FHIRPath:CQL::XPath:XQuery\" target=\"_blank\" title=\"https://github.com/cqframework/clinical_quality_language/wiki/FHIRPath:CQL::XPath:XQuery\">https://github.com/cqframework/clinical_quality_language/wiki/FHIRPath:CQL::XPath:XQuery</a></p>",
        "id": 153865114,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483124324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span> tightly coupling data model and query language is diminish this language  applicability/reuse. <code>name.given1</code> is a worst case  of all - compiletime/runtime - because it should take meta data about types in runtime (there is no tips for compile time - it should be at least Patient.name.given1) . You could live with compile time checks, which require a lot of metadata - but it is very difficult to optimize such checks in runtime. </p>",
        "id": 153865122,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483132620
    },
    {
        "content": "<p>If you want something like type checking, then annotate it with types, if you are dynamic - then this expression is valid and just return nothing.</p>",
        "id": 153865123,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483132708
    },
    {
        "content": "<p>Validation for schema, could be just optional feature on top of schema-agnostic fhirpath (not required).</p>",
        "id": 153865124,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483132816
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> FHIRPath doesn't tightly couple data model and query language. FHIRPath is a generic language that works against any model.</p>",
        "id": 153865129,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483134674
    },
    {
        "content": "<p>The tests were created to test the implementations that we were creating against the fhir specific extensions to the language also, not just the core language.<br>\nThe format of the test file as XML isn't important, as its just a source for the test engine, and we needed something to be able to share.</p>",
        "id": 153865224,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1483402378
    },
    {
        "content": "<p>We have <code>contains</code> function on strings and <code>contains</code> operator on sets and also in example we have <code>ValueSet.expansion.repeat(contains)</code>?  Fhirpath is like quest game for implementers, it harms my brain :(</p>",
        "id": 153865247,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483433550
    },
    {
        "content": "<p>The <code>contains</code> in <code>ValueSet.expansion.repeat(contains)</code> is resolved as a property name because it doesn't have parentheses. So the repeat recursively invokes the contains property until there are no more results.</p>",
        "id": 153865280,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483462574
    },
    {
        "content": "<p>As far as similar functions on different types, some of that is inevitable, there are only so many words available, so we tried to go with the most common usages of function names for each domain. Sometimes that results in overlap, not sure how to avoid that.</p>",
        "id": 153865281,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483462753
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> can you add a task to add min() and max() functions? Agree thtey are useful for indexing</p>",
        "id": 153865339,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483476534
    },
    {
        "content": "<p>you should not confuse the details of the test suite with the language details. We  could add test suites for different applications, but a test suite that was application independent would not be very useful, so we didn't define on </p>",
        "id": 153865340,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483476587
    },
    {
        "content": "<p>I do intend to do a v2 test suite at some stage</p>",
        "id": 153865341,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483476604
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span>  for name clashes we could use <code>namespaces</code>: <code>str/contains</code> <code>coll/contains</code>. Bryn, are you sure we need all this temporal algebra in fhirpath,  as i understand it was ported from CQL?</p>",
        "id": 153865416,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483526848
    },
    {
        "content": "<p>FHIRPath users asked for more than we did</p>",
        "id": 153865417,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483527041
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> i've added issue about min/max to gforge. Yes, that's what i'm talking in my blog post -  general purpose language at the end!</p>",
        "id": 153865419,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483527184
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> have you seen XPath 3 - <a href=\"https://www.w3.org/TR/xpath-30/\" target=\"_blank\" title=\"https://www.w3.org/TR/xpath-30/\">https://www.w3.org/TR/xpath-30/</a>?</p>",
        "id": 153865420,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483527538
    },
    {
        "content": "<p>a little. I prefer not to look :-)</p>",
        "id": 153865423,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483529900
    },
    {
        "content": "<p>xml... <a href=\"http://thedailywtf.com/articles/sche-ma\" target=\"_blank\" title=\"http://thedailywtf.com/articles/sche-ma\">http://thedailywtf.com/articles/sche-ma</a> ... only look if I really have too... !</p>",
        "id": 153865424,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483530028
    },
    {
        "content": "<p>Let do not make fhirpath like this :)</p>",
        "id": 153865425,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483532927
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> FHIRPath doesn't have a temporal algebra, so I'm not sure what you're referring to?</p>",
        "id": 153865444,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483544372
    },
    {
        "content": "<p>If we use <code>+</code> to concatenate strings (like in js), should we define <code>-</code>for strings? :) Most of languages do not use <code>+</code> for strings, this is too javascriptish and source of many bugs.</p>",
        "id": 153865533,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483567074
    },
    {
        "content": "<blockquote>\n<p>This differs from + on two strings, which will result in an empty collection when one of the operands is empty.</p>\n</blockquote>",
        "id": 153865534,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483567242
    },
    {
        "content": "<p>This is a joke of the day :)  - if we use arithmetic operator on strings and some of strings are empty we return empty collection. Even LISP does not go so far. </p>",
        "id": 153865535,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483567383
    },
    {
        "content": "<p>But every SQL dialect does.</p>",
        "id": 153865536,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483567486
    },
    {
        "content": "<p>If I ask you to concatenate two strings, but you don't know what one of the strings is, what's the right answer?</p>",
        "id": 153865538,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483567515
    },
    {
        "content": "<p>You can choose to ignore the thing that you don't know, but that's making an explicit choice about how to handle missing information, and it's not always the right choice.</p>",
        "id": 153865539,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483567543
    },
    {
        "content": "<p>The more conservative response is to say \"I don't know what the resulting string would be because I don't know what one of the inputs is\". Which is what all SQL dialects do.</p>",
        "id": 153865540,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483567580
    },
    {
        "content": "<p>Please take a look at tons of javascript WTFs produced by such types of  implicit conversions , it's a well known <code>bad parts</code> of js</p>",
        "id": 153865541,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483567634
    },
    {
        "content": "<p>it sounds like you are talking about different things....</p>",
        "id": 153865542,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483567674
    },
    {
        "content": "<p>We don't define implicit conversions between integers and strings, which is really the source of the gotchas.</p>",
        "id": 153865543,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483567697
    },
    {
        "content": "<p>why do not use special operation for strings concatenation?  Choice of <code>&amp;</code> for strings also looks strange - it's bitwise operator  in c-like languages. </p>",
        "id": 153865545,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483568083
    },
    {
        "content": "<p>well, at some point, every special operator is used for something somewhere</p>",
        "id": 153865546,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483568295
    },
    {
        "content": "<p>Yes, that's true :) I've just looked into different languages string concat - there are zoo of all possible combinations: Haskell <code>++</code>, Postgresql <code>||</code>, Ocaml <code>^</code>. I forgot in Java it's really <code>+</code>.</p>",
        "id": 153865548,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483568524
    },
    {
        "content": "<p>Yeah, + is I think the most common in traditional languages (C, Java, C#, JavaScript, T-SQL). I also really like &amp; for concatenation, it means \"and\", so it works conceptually, and hopefully we never have bitwise operators in CQL or FHIRPath :)</p>",
        "id": 153865555,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483568877
    },
    {
        "content": "<p>oh yes, don't we all love bitwise operators...</p>",
        "id": 153865557,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483568909
    },
    {
        "content": "<p>May be redefine <code>-</code> for strings - for symmetry? It's a joke or may be not.  So we'll get algebraic data types.</p>",
        "id": 153865558,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483569040
    },
    {
        "content": "<p>Not opposed to it, but you'd have to define clear semantics. It's interpretable in any number of ways, so it's typically not expressible as a binary operation, needs more input.</p>",
        "id": 153865560,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483569186
    },
    {
        "content": "<p>a-b - remove all character sequences b from a - what else could it mean? </p>",
        "id": 153865567,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483569812
    },
    {
        "content": "<p>I could see myself using that.... but not often]</p>",
        "id": 153865568,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483569830
    },
    {
        "content": "<p>Remove the first appearance of b, remove the last appearance of b, etc...</p>",
        "id": 153865569,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483569865
    },
    {
        "content": "<p>hat's why it could only mean all of them</p>",
        "id": 153865574,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483569922
    },
    {
        "content": "<p>What if removing b resulted in a new appearance of b. Should it keep going?</p>",
        "id": 153865580,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483570193
    },
    {
        "content": "<p>LISPER NOTE:  empty list as NULL = NIL. We wrap all values in collection - yes <code>functor</code> composability is nice feature, simulating <code>maybe</code> monad by collections - also ok, but i still have doubts about  generalising this approach to whole language.</p>",
        "id": 153865582,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483570392
    },
    {
        "content": "<p>sure ;-). But I'm not really arguing for this. </p>",
        "id": 153865586,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483570544
    },
    {
        "content": "<p>For example - should this fail  or return collection of first letters <code>Patient.name.given.substring(0,1)</code> if given.count() &gt; 1? I'm still puzzled with <code>Patient.name.given = 'Nicola'</code> in samples</p>",
        "id": 153865595,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483571067
    },
    {
        "content": "<p>the first is clearly documented. the answer is null if it's a collection. So is the second: Returns true if the left collection is equal to the right collection</p>",
        "id": 153865596,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483571186
    },
    {
        "content": "<p>To return a collection of first letters, you'd use select to invoke the substring on each element of the collection.</p>",
        "id": 153865598,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483571284
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  But right is not a collection, or we assume it's <code>['Nicola']</code>. So <code>select</code> is a  functional <code>map</code>?!</p>",
        "id": 153865601,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483572099
    },
    {
        "content": "<p>everything is a collection. in this case, a collection with a single value</p>",
        "id": 153865602,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483572131
    },
    {
        "content": "<p>['Nicola'] = 'Nicola'</p>",
        "id": 153865603,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483572150
    },
    {
        "content": "<p>.. you're unique ;-0</p>",
        "id": 153865604,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483572160
    },
    {
        "content": "<p>:)</p>",
        "id": 153865605,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483572168
    },
    {
        "content": "<p>could we somehow get collection of collections, or they are always flatten?</p>",
        "id": 153865607,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483572356
    },
    {
        "content": "<p>don't know. </p>",
        "id": 153865608,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483572370
    },
    {
        "content": "<p>They are flattened in path traversal, but with a select you could get a list of lists.</p>",
        "id": 153865609,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483572406
    },
    {
        "content": "<p>I think. That might need clarification :)</p>",
        "id": 153865611,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483572451
    },
    {
        "content": "<p>And my collection constructor is (a | b | c) = [a, b, c]?</p>",
        "id": 153865612,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483572454
    },
    {
        "content": "<p>Yes.</p>",
        "id": 153865613,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483572483
    },
    {
        "content": "<p>Nope, clearly documented, select flattens the results.</p>",
        "id": 153865614,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483572522
    },
    {
        "content": "<p>And fhirpath always returns collection as result of expression?</p>",
        "id": 153865615,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483572645
    },
    {
        "content": "<p>yes</p>",
        "id": 153865616,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483572692
    },
    {
        "content": "<p>Yes, though for clarity in the documentation, operations and functions that expect singletons are described using the type, rather than the collection type.</p>",
        "id": 153865617,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483572697
    },
    {
        "content": "<p>singleton = collection of one element?</p>",
        "id": 153865618,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483572727
    },
    {
        "content": "<p>Yes.</p>",
        "id": 153865619,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483572737
    },
    {
        "content": "<p>If everything is a collection, what logical expressions should return  - [true], [false]?</p>",
        "id": 153865668,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483610071
    },
    {
        "content": "<p>I still argue against expressions like Observation.value.value - which requires fhirpath engine to know about  FHIR polymorphics and metadata to evaluate. Please , do not mix this. At least add some hint like <code>Observation.value[x].value</code>. Or as i've already asked, let's encode polymorpics like: <code>{value: {type: SomeType , value: .... or valueSomeType}}</code> - as i see most of ref. libraries use Observation.value getter - that's why you think it's natural to write such expressions, but it's not natural for implementations based purely on data formats (json, xml). It's also simplify json schema :)</p>",
        "id": 153865669,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483610832
    },
    {
        "content": "<p>Why in tests  comparison of date and time is not type error ? <code>birthDate != @12:00</code> expected false, not error</p>",
        "id": 153865670,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483611452
    },
    {
        "content": "<p>Oh, i see </p>\n<blockquote>\n<p>For dateTime and time comparisons with partial values (e.g. dateTimes specified only to the day, or times specified only to the hour), the comparison returns empty ({ }), not false.</p>\n</blockquote>\n<p>What is motivation not to raise exception?</p>",
        "id": 153865671,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483611574
    },
    {
        "content": "<p>And what is difference between {} and false (or [false] :)?  - true, false, unknown?</p>",
        "id": 153865673,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483611714
    },
    {
        "content": "<p>you can create a task for a future version of FHIRPath to use Observation.value[x] not Observation.value, but I don't like your chances. But you pretty much have to know the same information to resolve value[x] as value, so it doesn't make that much difference. </p>",
        "id": 153865683,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483614555
    },
    {
        "content": "<p>the tools ensure, btw, that there'll never be yyyyXXX and yyyy[x] - that would create potential confusion already, so isn't allowed. </p>",
        "id": 153865684,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483614592
    },
    {
        "content": "<p>you're also welcome to create a task proposing changing the way polymorphics are serialised, but i can't see it getting up; you're the only one who's bugged by it </p>",
        "id": 153865685,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1483614621
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> we added a choice type to CQL 1.2, partly to support FHIR, but partly to support QDM-style unions. FHIR isn't the only data model with choice types, so having a language that can deal with them is a good thing. If you feel strongly about not including them, I'd welcome your comments on the CQL 1.2 ballot.</p>",
        "id": 153865707,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1483631886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  i will create tickets.  Most of current users just use ref.libraries (which is written by 4 people in the same paradigm of code generation) and do not fill this pain, but think about future users, libraries, databases. Complexity of all implementations are doubled by requirement to keep metadata available for such situations and it's just accidental complexity.  Data is self-valuable - why do you want Observation.value in Spec, Java or C#, but do not want it in the same shape in serialised form? This decision forces to write reference libraries (hardcode versions etc), for all engines which deal with FHIR (even partially like fhirpath), without real need. Data format by itself could keep this aspects of  model semantic without need for additional tools (like ref libraries). I argue, that this data will outlast all libraries - why it should be freaked?</p>",
        "id": 153865719,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1483638295
    }
]