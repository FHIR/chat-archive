[
    {
        "content": "<p>The <a href=\"http://hl7.org/fhir/datatypes.html#Attachment\" target=\"_blank\" title=\"http://hl7.org/fhir/datatypes.html#Attachment\">Attachment</a> data type specifies a hash attribute and that the hash of the data must be computed using SHA1. With the announcement this year of SHA1 collisions, has there been any considerations for allowing the hash to be computed via other algorithms (e.g. SHA256)? </p>\n<p>The idea being that Attachment.hash would have a companion attribute, say Attachment.hashAlgorithm, that would allow one to specify which algorithm was used to compute the hash.</p>",
        "id": 153912060,
        "sender_full_name": "Jeffrey Willis",
        "timestamp": 1507033768
    },
    {
        "content": "<p>That sounds like a reasonable thing to submit as a change request. Would you be willing to do that?  (In fact, any place that we \"fix\" a specific algorithm, we probably want to allow for the possibility of future variation.)</p>",
        "id": 153912093,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1507058162
    },
    {
        "content": "<p>we've rejected this change before - we don't need crypto safe hashing here, and therefore why do we need to ask systems to support more than one simple hashing algorithm</p>",
        "id": 153912132,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1507061522
    },
    {
        "content": "<p>In addition to what Grahame said... just picking a different hash does not make the hash value any more useful for non-repudiation. Any case that requires non-repudiation needs to use a Digital Signature structure like what is provided in Provenance.signature.</p>",
        "id": 153912157,
        "sender_full_name": "John Moehrke",
        "timestamp": 1507063113
    },
    {
        "content": "<p>The hash element is there to detect technical failures (e.g., storage rot, transport glitch, incorrect version). All of these are detectable with SHA1, and don't require any more complex hashing algorithm.</p>",
        "id": 153912161,
        "sender_full_name": "John Moehrke",
        "timestamp": 1507063339
    },
    {
        "content": "<p>I would be far more comfortable recommending that hash become an extension, than for us to attempt to create a structure that supports many hashing algorithms. As a pluggable hashing algorithm seems useful, until you recognize the burden on any consuming system. It must implement all possible algorithms, as it never knows what algorithm might have been used.  Removing the hash, recognizes that current technology doesn't really need a hash except in specific situations (e.g. when metadata and data are managed on different systems under different SLA terms).</p>",
        "id": 153912164,
        "sender_full_name": "John Moehrke",
        "timestamp": 1507063442
    },
    {
        "content": "<p>the point of the hash is that you if you have a reference, rather than data inline, you can check that the data is the same as what was initially referred to by checking the hash of the data you get when you actually access the data.</p>",
        "id": 153912171,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1507064217
    },
    {
        "content": "<p>Should the stated requirements change from </p>\n<blockquote>\n<p>Included so that applications can verify that the contents of a location have not changed and so that a signature of the content can implicitly sign the content of an image without having to include the data in the instance or reference the url in the signature.</p>\n</blockquote>\n<p>to leave out or qualify the text about signatures.</p>",
        "id": 153912208,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1507084847
    },
    {
        "content": "<p>yes that would be a good idea</p>",
        "id": 153912209,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1507087409
    },
    {
        "content": "<p>Issue created <a href=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=13995\" target=\"_blank\" title=\"https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=13995\">#13995</a></p>",
        "id": 153912214,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1507088085
    },
    {
        "content": "<p>Good catch. The hash should never have included anything about signature. It is simply an integrity check. A signature requires more than just a good hash algorithm, and is well handled by the Provenance.signature mechanism.</p>",
        "id": 153912248,
        "sender_full_name": "John Moehrke",
        "timestamp": 1507119676
    },
    {
        "content": "<p>Thank you, everyone. You've answered my concerns and I believe continuing to use SHA1 for integrity checks on Attachment will work just fine.</p>",
        "id": 153912666,
        "sender_full_name": "Jeffrey Willis",
        "timestamp": 1507226868
    },
    {
        "content": "<p>Rather belatedly bringing this old thread back.  Our issue is that we already have a hash (SHA256) associated with the data and we'd just like to re-use it/pass it through rather than computing an additional hash.<br>\nIs there a common extension for supporting alternate algorithms?</p>",
        "id": 165586364,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1557799794
    }
]