[
    {
        "content": "<p>Hi,</p>\n<p>I want to write a fhirpath constraint that the meta element should have exactly one profile element. <br>\nThis should work for every resource that is contained as entry in a Bundle.</p>\n<p>This seems to work:</p>\n<p>&lt;element id=\"Bundle\"&gt;<br>\n&lt;path value=\"Bundle\"/&gt;<br>\n      &lt;constraint&gt;<br>\n        &lt;key value=\"exactlyOneMetaProfile\" /&gt;<br>\n        &lt;severity value=\"error\" /&gt;<br>\n        &lt;human value=\"Exactly one meta.profile\" /&gt;<br>\n        &lt;expression value=\"entry.all(resource.meta.profile.count()=1)\" /&gt;<br>\n      &lt;/constraint&gt;<br>\n&lt;/element&gt;</p>\n<p>Or is there a better solution?</p>",
        "id": 245015077,
        "sender_full_name": "Katarina",
        "timestamp": 1625563980
    },
    {
        "content": "<p>First, forcing there to be exactly one profile is generally a bad thing to do.  Systems should be able to declare as many profiles as they want - and as a recipient you should just ignore any you don't care about/recognize.  It's fine for you to drop any declarations you don't care about/support if you don't have a means to store them.  In fact, it's a bad idea to impose upper cardinality limits on most elements because it interferes with interoperability.  Source systems should be able to send whatever data they have and receivers should extract the data they care about from whatever's sent, ignoring the rest.  Imposing cardinality limits driven by what you can store (as opposed to what's a genuine error to exist at all) means that the system must create and maintain a specific export for your system - which increases costs and complexity.</p>\n<p>That said, to constrain cardinality, simply set differential.element.min and max=1 for the path Bundle.meta.profile.  No need for an invariant.</p>",
        "id": 245053701,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1625584683
    }
]