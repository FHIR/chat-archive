[
    {
        "content": "<p>Can we enforce a specific order of slices? Something like: medications in a list shall be ordered by date of start ascending.</p>",
        "id": 272180065,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1645046446
    },
    {
        "content": "<p>or medication ingredients shall be sorted by role</p>",
        "id": 272180120,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1645046471
    },
    {
        "content": "<p>is that actually slicing? Or just an invariant?</p>",
        "id": 272180172,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645046500
    },
    {
        "content": "<p>If a final resource instance is represented in JSON then ordering is not guaranteed at all.</p>",
        "id": 272180198,
        "sender_full_name": "Shamil Nizamov",
        "timestamp": 1645046518
    },
    {
        "content": "<p>If ordering by date is important to the client, why don't they sort the medications by date? If role is important, then shouldn't there be a type or category of ingredient you can group by?</p>",
        "id": 272180326,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1645046581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"192195\">Shamil Nizamov</span> <a href=\"#narrow/stream/179166-implementers/topic/slice.20ordering/near/272180198\">said</a>:</p>\n<blockquote>\n<p>If a final resource instance is represented in JSON then ordering is not guaranteed at all.</p>\n</blockquote>\n<p>Ordering of keys is not guaranteed, but I think <span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> is talking about ordering of items in arrays, which is definitely supported in JSON.</p>",
        "id": 272183199,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1645047758
    },
    {
        "content": "<p>right, ordering of items in an array.</p>",
        "id": 272183380,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1645047878
    },
    {
        "content": "<p>Challenge at hand: I have data coming in and I need to ensure a given order of the repeatable elements.  While the functional analysts are seeing what order is that, once they do, I want to see if there is any mechanism in FHIR.</p>",
        "id": 272183639,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1645048025
    },
    {
        "content": "<p>These are repeatable elements and I don't have so far the need for slicing, unless slicing is the way to enforce a given sequence (which I don't see how it would be)</p>",
        "id": 272183702,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1645048069
    },
    {
        "content": "<p>taking medication.ingredient. I want to sort by role</p>",
        "id": 272183819,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1645048110
    },
    {
        "content": "<p>this is pretty difficult on two parts. The first is expressing an order predicate in FHIRPath. I suspect it's possible by playing around with the aggregate() function, but it's not immediately obvious. if it turns out that it's not possible, we could propose a more direct way (on <a class=\"stream\" data-stream-id=\"179266\" href=\"/#narrow/stream/179266-fhirpath\">#fhirpath</a>)</p>\n<p>The second and probably less tractable issue is the actual correct order for 'role' - typically the alphabetical order of codes is irrelevant and there's some deeper meaning.</p>",
        "id": 272188255,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645050442
    },
    {
        "content": "<p>Note that enforcing order on elements where order doesn't have meaning is a very bad idea and will generally interfere with interoperability.  (And if order does have a defined meaning, then the sort is already defined, and you don't have to do it.)</p>",
        "id": 272190383,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645051624
    },
    {
        "content": "<p>Only the core resource definition can define meaning to order - it can't be introduced by IGs or profiles.</p>",
        "id": 272190439,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645051661
    },
    {
        "content": "<p>I know that ordering of arrays is supposed to be maintained but if you don't trust that is going to happen. you could add an ordering extension.  (as we did in our Questionnaire IG).</p>",
        "id": 272193707,
        "sender_full_name": "Eric Haas",
        "timestamp": 1645053667
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span> I don't know why what would make any difference</p>",
        "id": 272196469,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645055782
    },
    {
        "content": "<p>if the resource get decomposed and the recomposed between system that are FHIR facades it adds a redundant layer of cross checking.   At the time it seemed important to the folks on the call.</p>",
        "id": 272197744,
        "sender_full_name": "Eric Haas",
        "timestamp": 1645056610
    },
    {
        "content": "<p>well, ok. redundant is redundant...</p>",
        "id": 272197799,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645056658
    },
    {
        "content": "<p>If you don't trust the system to maintain the order, why do you trust it to keep the extension?</p>",
        "id": 272204731,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645062689
    },
    {
        "content": "<p>In general, you can never ever trust that the order of anything will be maintained forever exactly as you saw it/stored it unless somebody applies that ordering. If you aren't absolutely sure that the provider of the data ordered the list for you, then you'll have to do so. There are so many layers happening where somebody might not have cared about maintaining sequence it's just better for the processor to do a quick sort based on whatever attribute the processor wants to process them in. There are some lists in FHIR that have a sequence number because in those cases sequence is important and nobody can trust that physical sequence will be maintained forever and ever by everybody that touches it.</p>",
        "id": 272268732,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1645109004
    },
    {
        "content": "<p>If a FHIR system is conformant, it's required to retain the order of array elements - end stop.  If it doesn't, it will - at minimum - break any embedded signatures.  At worst, it's going to mis-order elements where order is significant.</p>\n<p>Obviously systems can do non-conformant things, but that doesn't mean that adding extra layers is going to make things better.</p>",
        "id": 272275801,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645111736
    },
    {
        "content": "<p>That's a fine requirement on a FHIR server. Does every JSON/XML serializer/deserializer have the same requirement? Does every other tool that might be used in the eco-system?</p>",
        "id": 272277893,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1645112529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179166-implementers/topic/slice.20ordering/near/272275801\">said</a>:</p>\n<blockquote>\n<p>If a FHIR system is conformant, it's required to retain the order of array elements - end stop.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> -- I don't think that's true for every array element (or even most).  The spec actually says ordering does not need to be retained if the meaning of the order has not been defined (<a href=\"http://hl7.org/fhir/R4/conformance-rules.html#cardinality\">here</a>):</p>\n<blockquote>\n<p>For elements that have cardinality &gt; 1, the order in which they appear may have meaning. Unless the element definition (either in this specification or the extension) defines a meaning to the order explicitly (using ElementDefinition.orderMeaning), the meaning of the order is not defined, and implementations are allowed to reorder the elements. Note that it is not possible to define a meaning for the order of the elements in a profile using a StructureDefinition.</p>\n</blockquote>",
        "id": 272279280,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1645113063
    },
    {
        "content": "<p>Expecting an implementation to maintain the order of every array makes a lot of assumptions about how that implementation stores data.  For example, the <code>Encounter.reasonReference</code> array could be represented on a source system via a join table, a relationship to problems/procedures/etc on encounter, or a relationship to encounters on problems/procedures/etc.  Not every system is going to maintain an order on those relationships -- especially if there is no business (or clinical) reason to do so.</p>",
        "id": 272280099,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1645113399
    },
    {
        "content": "<p>If we allow implementations to re-order elements, then we can kiss any hope for digital signatures good-bye...  Wow, that wording has been there since STU2.  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> - how do we rationalize this statement and the need for signatures?</p>",
        "id": 272282081,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645114166
    },
    {
        "content": "<p>Would a digital signature be considered part of the resource (and stored) or would a digital signature be added JIT as the resource is being serialized for transmission, validated at the consumer and then dropped.</p>",
        "id": 272283671,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1645114853
    },
    {
        "content": "<p>Where a signature is part of the resource (like Bundle) it should be stored within the resource.</p>",
        "id": 272287742,
        "sender_full_name": "David Pyke",
        "timestamp": 1645116651
    },
    {
        "content": "<p>If you are storing the serialized copy of the resource, then you can store the signature as well. But if you are decomposing the resources and attempting to \"recreate\" the bundle then it's unlikely that you'll ever be able to get the bytes lined up exactly correct in order to match a signature.</p>",
        "id": 272289005,
        "sender_full_name": "Daniel Venton",
        "timestamp": 1645117199
    },
    {
        "content": "<p>very dependent on the kind of digital signature. Fundamentally there are digital signatures that are (a) encapsulating, (b) encapsulated, and (c) external.</p>",
        "id": 272294028,
        "sender_full_name": "John Moehrke",
        "timestamp": 1645118990
    },
    {
        "content": "<p>well, obviously, a system that doesn't preserve order can't make a digital signature survive whatever it does that loses the digital signature. That's not new or surprising, but a system that's taking a resource apart and putting it in a database, and then it's not going to be concerned with that.</p>",
        "id": 272316237,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645128613
    },
    {
        "content": "<p>Which essentially means that digital signatures can generally only survive passing through systems designed to handle them.  A digital signature that passes through an arbitrary set if intermediaries is likely to get trashed.</p>",
        "id": 272316538,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645128769
    },
    {
        "content": "<p>I didn't realize we'd agreed to this as reality.  (It certainly makes FHIR conformance easier for systems that don't care about signatures, but it makes the use of signatures really tenuous.  And it sort of argues for a canonicalization algorithm that automatically sorts data where sort order is meaningless.</p>",
        "id": 272316690,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645128852
    },
    {
        "content": "<p>Should we have a change request to a) call attention to this issue; and/or b) define such a canonicalization mechanism?</p>",
        "id": 272316727,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645128880
    },
    {
        "content": "<blockquote>\n<p>A digital signature that passes through an arbitrary set if intermediaries is likely to get trashed</p>\n</blockquote>\n<p>yup. That's a statement of truth. Which is why we pretty much don't see digital signatures used with RESTful APIs anywhere.</p>",
        "id": 272325113,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645133340
    },
    {
        "content": "<p>not just with FHIR</p>",
        "id": 272325153,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645133353
    },
    {
        "content": "<p>I thought it was pretty clear, actually</p>",
        "id": 272325185,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645133366
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179166-implementers/topic/slice.20ordering/near/272190383\">said</a>:</p>\n<blockquote>\n<p>Note that enforcing order on elements where order doesn't have meaning is a very bad idea and will generally interfere with interoperability.  (And if order does have a defined meaning, then the sort is already defined, and you don't have to do it.)</p>\n</blockquote>\n<p>I will need to pass my entries through an algorithm and I want to do it in a specific sequence. Is there a way to see in FHIR whether that sequence is in place?</p>",
        "id": 272330194,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1645135164
    },
    {
        "content": "<p>For example, if order is alphabetical, i'd like to see that entry[1] is alphabetically after entry[0] and so on</p>",
        "id": 272330299,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1645135207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> - where do you think it's clearly stated now?</p>",
        "id": 272339992,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645141042
    },
    {
        "content": "<p><a href=\"http://build.fhir.org/updates.html\">http://build.fhir.org/updates.html</a> and and both format pages have an implementation note in the canonical section about the use of signatures outside document bundles, but that could be clearer. And the page about updates could talk about signatures</p>",
        "id": 272341552,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645142199
    },
    {
        "content": "<p>I would think the signature page itself should indicate that there's no guarantee the signatures will be valid across persistence.  And also define canonicalization algorithms that force a sort order (to allow signatures).</p>",
        "id": 272342877,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645143091
    },
    {
        "content": "<p>we have a signature page?</p>",
        "id": 272348108,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645147331
    },
    {
        "content": "<p>We have a signature data type with a whole bunch of information about signatures.</p>",
        "id": 272351381,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645150224
    },
    {
        "content": "<p>it has the same comment</p>",
        "id": 272353076,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1645151837
    },
    {
        "content": "<p>I don't see any comment that talks about the fact that persisting order isn't reliable and that therefore, regardless of reidentification, signatures can't be counted on.</p>",
        "id": 272410563,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1645195883
    },
    {
        "content": "<p>there are canonical for signatures.. but for multi value elements I don't think we have  a rule.</p>",
        "id": 272455727,
        "sender_full_name": "John Moehrke",
        "timestamp": 1645217524
    },
    {
        "content": "<p>There is a bunch of signature pages</p>\n<ul>\n<li>General discussion of Digital Signatures -- <a href=\"https://hl7.org/fhir/signatures.html\">https://hl7.org/fhir/signatures.html</a></li>\n<li>Signature Datatype -- <a href=\"https://hl7.org/fhir/datatypes.html#signature\">https://hl7.org/fhir/datatypes.html#signature</a><ul>\n<li>XML vs JSON signatures</li>\n</ul>\n</li>\n<li>FAQ on signatures -- <a href=\"https://hl7.org/fhir/secpriv-module.html#signature\">https://hl7.org/fhir/secpriv-module.html#signature</a></li>\n</ul>",
        "id": 272455898,
        "sender_full_name": "John Moehrke",
        "timestamp": 1645217641
    },
    {
        "content": "<p>The Signature datatype does address the fact that the signature will be specific to a FHIR mime-type; thus the signer and the validator do need to agree to one of the FHIR mime-types... (Or both).</p>",
        "id": 272456020,
        "sender_full_name": "John Moehrke",
        "timestamp": 1645217707
    },
    {
        "content": "<p>but restating ... I don't think we have a solution for multi value elements... hmm</p>",
        "id": 272456190,
        "sender_full_name": "John Moehrke",
        "timestamp": 1645217803
    },
    {
        "content": "<p>All of these are reasons why I have cautioned EVERYONE against thinking signatures are easy. Signatures are only practical across a Binary. That Binary may have a Provenance linkage to a FHIR Document Bundle, or to the accessible Resources within; where that Provenance declares that it is proof that the Binary was received and that the signature on the Binary was checked. This can be done for anything, but my first point is that signatures of Binary are really the only practical use-case.</p>",
        "id": 272457106,
        "sender_full_name": "John Moehrke",
        "timestamp": 1645218211
    }
]