[
    {
        "content": "<p>does anyone know how slicing works when you have multiple \"section\" elements with varying discriminators? Ex: \"code\" for one slice and \"mode\" for another slice? are you supposed to output</p>\n<ul>\n<li>element (slicing, disciminator \"code\")</li>\n<li>element (section with \"code\")</li>\n<li>element (slicing, discriminator \"mode\")</li>\n<li>element (section with \"mode\")</li>\n</ul>",
        "id": 153891653,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496163297
    },
    {
        "content": "<p>between the sections, or inside the sections?</p>",
        "id": 153891670,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496169753
    },
    {
        "content": "<p>this is multiple sections, each section has a different discriminator... one having \"code\" as the discriminator, the other having \"mode\" as the disciminator. In my example bullets, that is four different &lt;element&gt; entries. The first being the one that describes the discriminator (slice) for \"code\", the second being the definition of \"code\", the third being the element that describes the discriminator (slice) for the section with \"mode\", and the fourth being the element that describes the \"mode\"</p>",
        "id": 153891706,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496174568
    },
    {
        "content": "<p>I don't think you can re-slice within the same profile.  Can you define it as a single set of slicing with multiple discriminators?</p>",
        "id": 153891794,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496242589
    },
    {
        "content": "<p>I'm not sure. This is something that is supported in Trifolia, and something that is done reasonably often with CDA templates. Trying to figure out how to implement the equivalent for Trifolia exports. </p>",
        "id": 153891805,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496245234
    },
    {
        "content": "<p>Is re-slicing within the same profile not supported by the spec in general, or is it the tooling that doesn't support it?</p>",
        "id": 153891806,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496245269
    },
    {
        "content": "<p>(the ig publisher, for example)</p>",
        "id": 153891807,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496245282
    },
    {
        "content": "<p>When we slice, we slice all repetitions of an element.  So re-slicing would essentially accomplish the same as multiple discriminators anyhow.  I'm not sure if the spec explicitly prohibits it, but given that it doesn't allow any difference in behavior, it probably should if it doesn't</p>",
        "id": 153891808,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496245655
    },
    {
        "content": "<p>no you can't re-slice. How would discriminators work then? either list all the discriminators, or give up and not list any</p>",
        "id": 153891859,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496273549
    },
    {
        "content": "<p>This is what I was thinking of:</p>",
        "id": 153891953,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496331966
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>    &lt;differential&gt;\n        &lt;element&gt;\n            &lt;path value=&quot;Composition&quot;/&gt;\n            &lt;min value=&quot;1&quot;/&gt;\n        &lt;/element&gt;\n        &lt;element&gt;\n            &lt;path value=&quot;Composition.section&quot; /&gt;\n            &lt;sliceName value=&quot;code_slice&quot; /&gt;\n            &lt;slicing&gt;\n                &lt;discriminator&gt;\n                    &lt;type value=&quot;value&quot;&gt;&lt;/type&gt;\n                    &lt;path value=&quot;code&quot;&gt;&lt;/path&gt;\n                &lt;/discriminator&gt;\n                &lt;rules value=&quot;open&quot; /&gt;\n            &lt;/slicing&gt;\n        &lt;/element&gt;\n        &lt;element&gt;\n            &lt;path value=&quot;Composition.section.code.coding.code&quot; /&gt;\n            &lt;sliceName value=&quot;code_slice&quot; /&gt;\n            &lt;fixedCode value=&quot;test1&quot; /&gt;\n        &lt;/element&gt;\n        &lt;element&gt;\n            &lt;path value=&quot;Composition.section&quot; /&gt;\n            &lt;sliceName value=&quot;title_slice&quot; /&gt;\n            &lt;slicing&gt;\n                &lt;discriminator&gt;\n                    &lt;type value=&quot;value&quot; /&gt;\n                    &lt;path value=&quot;title&quot; /&gt;\n                &lt;/discriminator&gt;\n                &lt;rules value=&quot;open&quot;&gt;&lt;/rules&gt;\n            &lt;/slicing&gt;\n        &lt;/element&gt;\n        &lt;element&gt;\n            &lt;path value=&quot;Composition.section.title&quot; /&gt;\n            &lt;sliceName value=&quot;title_slice&quot; /&gt;\n            &lt;fixedString value=&quot;my section title&quot; /&gt;\n        &lt;/element&gt;\n    &lt;/differential&gt;\n</pre></div>",
        "id": 153891954,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496331973
    },
    {
        "content": "<p>In this case, two separate slices, with two separate discriminators...</p>",
        "id": 153891955,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496332050
    },
    {
        "content": "<p>I don't understand why this is useful; you can't use the discriminator to discriminate, in this case. Might as well just not have any discriminators </p>",
        "id": 153891978,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496351086
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Agree with your conclusions to Sean.  However, concerned about \"can't re-slice\" within the same profile.  Absolutely should not be true, and it's critical for slicing extensions:<br>\nExample: Patient.extension is already sliced by url.  I create sliceName <code>Patient.extension:researchAuth</code> and then slice that extension by something: <code>Patient.extension:researchAuth/mnResearchAuth</code>.  In other words, the only way to slice an extension is by re-slice (since the extension definition itself is the base slice).</p>",
        "id": 153892127,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1496416898
    },
    {
        "content": "<p>Reslicing in a derived profile is fine.  But I don't understand the purposes of declaring slicing twice on the same element in the same profile.</p>",
        "id": 153892128,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496417061
    },
    {
        "content": "<p>Agree, that's not allowed.  Maybe I just misunderstood the comment \"I don't think you can re-slice within the same profile.\"</p>",
        "id": 153892129,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1496417130
    },
    {
        "content": "<p>Each element may have only one slicing declaration (and therefore one set of discriminators), and that slicing definition is immutable in \"child\" profiles.</p>",
        "id": 153892130,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1496417215
    },
    {
        "content": "<p>I agree with that.  I was referring to multiple slicing definitions for the same element declared in the same profile.</p>",
        "id": 153892132,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496418890
    },
    {
        "content": "<p>So, you don't think you should be able to say (in one profile), I expect to have a \"section\" like X, and another \"section\" like Y?</p>",
        "id": 153892161,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496427956
    },
    {
        "content": "<p>you're already saying that in the definition of the slices. The purpose of discriminator is to say 'which fields do you look at to tell all these slices apart easily'</p>",
        "id": 153892184,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496440634
    },
    {
        "content": "<p>What I understand here is that Sean is trying to have list of discriminators say:</p>\n<ul>\n<li>slice the these element based on code here  AND THEN</li>\n<li>slice the element based on system there ( not the code) AND THEN</li>\n<li>slice based on some other element over there ( not the code or the system)</li>\n</ul>\n<p>The <code>..*</code> on the discriminator element means AND as in</p>\n<p>based on code AND system AND some other element</p>\n<p>Shouldn't that still work? since they will all be uniquely defined by the combination?</p>",
        "id": 153892191,
        "sender_full_name": "Eric Haas",
        "timestamp": 1496449713
    },
    {
        "content": "<p>It's perfectly fine to slice by code, then system, then something else.  But you can't slice some things by code and other things by system.  If code is the first discriminator, then <em>everything</em> gets sliced by code and only those items with the same code would be sliced by the second discriminator.</p>",
        "id": 153892198,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496454997
    },
    {
        "content": "<p>it probably will. </p>",
        "id": 153892199,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1496457595
    },
    {
        "content": "<p>?</p>",
        "id": 153892201,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496458895
    },
    {
        "content": "<p>In this case, I'm not just looking for each element in the instance to be unique, I'm looking for each element to meet specific criteria, and not all elements will have the same set of criteria...</p>",
        "id": 153892553,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496777988
    },
    {
        "content": "<p>With slicing, your first task is defining the discriminators that determine what rules will apply.  Then you add the extra constraints to each combination of discriminators that is of interest</p>",
        "id": 153892582,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496798070
    },
    {
        "content": "<p>Ok. So, I guess you're saying that the list of discriminators doesn't matter as much in my scenario; they are just used to say \"look at these things for uniqueness\"... Then each separate set of elements following the list of discriminators can have different criteria.</p>",
        "id": 153892687,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1496855416
    },
    {
        "content": "<p>I'm not fully clear on your scenario, but I think so.  Discriminators allow you to identify the set of repetitions to which a particular set of constraints should apply.</p>",
        "id": 153892693,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1496857181
    },
    {
        "content": "<p>Lloyd,<br>\nIn this case the profile is specifying that the  identifier have cardinality [1..*] but one of them shall have a value element which is used in conditional creates. So it seemed like if the element id for this particular  instance of the identifier was called conditionalCreateIdentifier, that would be a decent discriminator. Of course an application reading this data is likely not interested in the identifier since its purpose was to help uploads. But in general it would seem that giving an element id a unique name in a profile would be a good way to find those element instances which are part of the profile. Does that make sense?</p>",
        "id": 153893124,
        "sender_full_name": "Brian Reinhold",
        "timestamp": 1497019563
    },
    {
        "content": "<p>The discriminator has to be data that will appear in the instance - and you generally won't get ids on elements in the instance - and if you do, they'll be meaningless except as linking tools.  Your discriminator should be Identifier.system, Identifier.type or Identifier.use or Identifier.period or some combination of those.</p>",
        "id": 153893125,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1497019852
    },
    {
        "content": "<p>Oops; that was a mistake; migrated to another site and lost all my typing. <br>\nThe problem with that is that those parameters are all defined and have to be something specified unless I can create a identifier.system that means nothing except that it identifies (no pun intended) this particular identifier. For example, identifier.system=\"conditionalCreateIndentifier\". Not your average URI</p>",
        "id": 153893127,
        "sender_full_name": "Brian Reinhold",
        "timestamp": 1497020320
    },
    {
        "content": "<p>Then define and use an extension</p>",
        "id": 153893128,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1497020566
    },
    {
        "content": "<p>Bummer. There has got to be a better way ... </p>",
        "id": 153893133,
        "sender_full_name": "Brian Reinhold",
        "timestamp": 1497024495
    },
    {
        "content": "<p>You must include a \"semanticly meaningful\" element in your instance that says \"hey, this is what this thing is\".  If possible, try to use one from the core spec.  If not, you'll need an extension.  The \"id\" element is not semanticly meaningful.  You can't expect anyone to populate it consistently (in the unlikely event they populate it at all), nor interpret it in any way.  Its purpose is to let you point to other elements from inside a resource, to link narrative to discrete data, to allow Provenance to refer to specific elements within a resource, etc.  It's a pointer/identifier, not a meaningful label.</p>",
        "id": 153893188,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1497070864
    }
]