[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> Last time I asked about OAS support for FHIR in general, the consensus was that there were pretty large chunks of stuff that wouldn't convert well from profiles to OAS / JSON schemas. Has that improved?</p>\n<p>I'm specifically curious about response elements: does the output OAS spec include field descriptions, etc. for the response bodies?</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"321544\">@John French</span> <span class=\"user-mention\" data-user-id=\"307478\">@Dave Shekhar</span> <span class=\"user-mention\" data-user-id=\"307475\">@John Zulim</span> <span class=\"user-mention\" data-user-id=\"295356\">@Sarah Tully</span></p>",
        "id": 208709202,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1598976166
    },
    {
        "content": "<p>(I'm following up on this thread: <a href=\"#narrow/stream/179166-implementers/topic/hapi-fhir\">https://chat.fhir.org/#narrow/stream/179166-implementers/topic/hapi-fhir</a>)</p>",
        "id": 208709255,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1598976181
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"192789\">@Karl M. Davis</span> .  I haven't delved into profile support for OAS specifically yet.  It's on my list for the project, but will almost certainly be after the connectathon.</p>\n<p>That said, there are a significant number of challenges, which is why I'm building tooling to do this instead of focusing on static generation.  By loading the specs (currently supporting DSTU2 through R5 preview) I have access to all the base definitions, types, and descriptions.  By connecting to the server, I have a list of actual resources, search parameters, etc. that are supported.  With a fair number of settings I can define the general characteristics of the OAS file (e.g., OAS version, which operations you want in the file, case of id's, etc.).</p>\n<p>Even with all that, most tooling forbids things like circular references (which happens on extensions, for example), so I am playing with expanding various definitions to be inline instead of references.  It still needs to cut at certain levels (e.g., go 'x' levels deep, then to object), but the approach feels promising.  I'll note that it's still experimental right now, and I'm trying to get a feel for what people actually need.</p>\n<p>If you look at the example <a href=\"https://app.swaggerhub.com/apis-docs/GinoCanessa/fhir-r_4_4_0_1/1.0.0#/\">here</a> you can get a feel for the current state - it has model information (with descriptions) for all the schema, and even has descriptions for the search parameters.  That particular example was generated as a read-only spec (read/search) with <code>fhir+json</code> MIME type, etc..</p>",
        "id": 208711778,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598977213
    },
    {
        "content": "<p>Overall, it's still WIP but I feel good about getting to a useful point.</p>",
        "id": 208712103,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598977362
    },
    {
        "content": "<p>Mind if I restate that back to verify I understood?</p>\n<p>Basically: it <strong>does</strong> support response field descriptions, etc. but <strong>does not</strong> do anything with cardinality or with profiles that are more constrained than the general FHIR spec. For our use cases (the CMS Blue Button 2 APIs and friends which mostly revolve around ExplanationOfBenefit resources, then, it'd list all of the standard EOB fields, but not our extensions, and wouldn't help users identify which of the (hundreds of) EOB fields they might actually see back. That about right?</p>\n<p>(Not at all a complaint, to be clear: just want to ensure that I'm tracking. I think that what you already have is very impressive!)</p>",
        "id": 208718915,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1598980517
    },
    {
        "content": "<p>It does not yet include <em>anything</em> from profiles, but that is coming up shortly on my list.  Beyond that, if you have a particular use in mind, I'm happy to add it to the list, or at least go through it to see what's possible.</p>",
        "id": 208719782,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598980952
    },
    {
        "content": "<p>what's OAS?</p>",
        "id": 208750546,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598995311
    },
    {
        "content": "<p><a href=\"https://swagger.io/specification/\">Open API Specification</a> - used to be called Swagger files.</p>",
        "id": 208751751,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598995941
    },
    {
        "content": "<p>oh right. thanks.</p>",
        "id": 208752465,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598996405
    },
    {
        "content": "<p>so we need to talk about this. Currently, the publication tooling generates OAS documents for any capability statements it sees. They are relatively fully populated, except for the deep issues in json schema. For some reason I don't understand, everyone is ignoring these and complaining that nothing is producing them. </p>\n<p>Which is causing alternative work like this, which is... well, I'm all in favour of people taking work on, but I don't see how it will integrate with the existing tool chains.</p>",
        "id": 208752685,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598996526
    },
    {
        "content": "<p>nor do I see how it will help with the actual problem, which is in the json schema side of things</p>",
        "id": 208752713,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598996545
    },
    {
        "content": "<p>I think one of the challenges with baking generation into the publication process is that there's a bunch of decisions that need to be made when creating an OpenAPI specification file -- different trade-offs for different target environments. So having something configurable is pretty important.</p>",
        "id": 208753636,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1598997084
    },
    {
        "content": "<p>what are those?</p>",
        "id": 208753682,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598997121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> can provide much better detail than I can -- but we have seen specific implementations with limits on total size of generated files, number of attributes allowed, subset of json schema supported, whether references to content types (vs directly embedded types) are supported, etc.</p>",
        "id": 208754303,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1598997532
    },
    {
        "content": "<p>this is for openapi tooling problems?</p>",
        "id": 208754441,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598997630
    },
    {
        "content": "<p>Let's call it tooling diversity ;-) But yes.</p>",
        "id": 208754538,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1598997707
    },
    {
        "content": "<p>And frankly we in the fhir community are pretty familiar with this type of diversity; there are lots of ways to build a valid fhir server, for example. Not everyone supports all the fancy stuff.</p>",
        "id": 208754643,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1598997760
    },
    {
        "content": "<p>well, I expected that your answer would be that we need to support diversity in the security/deployment parts of the openapi document. I hadn't been thinking about tooling diversity.</p>",
        "id": 208754800,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598997844
    },
    {
        "content": "<p>either way, the conclusion is that there's no single openapi document for a capability statement?</p>",
        "id": 208754834,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598997871
    },
    {
        "content": "<p>I mean, we can endeavor to write one that is maximally complete and correct. I'm not saying that isn't worthwhile. I'm just saying that there's more to do beyond that.</p>",
        "id": 208755259,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1598998164
    },
    {
        "content": "<p>Sorry, was recording my track orientation.  Most of my work has been to support different tooling that cannot consume the schema files directly.  For example:</p>\n<ul>\n<li>one toolchain I've been working with requires ID's to start with a lower-case, another with upper-case</li>\n<li>security toolchains often don't need schema, but do need paths, search parameters, and MIME types</li>\n<li>some toolchains work better with restricted sets (e.g., only access to these 5 resources)</li>\n<li>etc.</li>\n</ul>",
        "id": 208755278,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598998186
    },
    {
        "content": "<p>Between that and all the different \"random\" requirements (e.g., one app requires every element have a description that starts with an upper-case letter and ends with a period), I couldn't see how to make one that would suit all needs.</p>",
        "id": 208755587,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598998359
    },
    {
        "content": "<p>well, that's all rather discouraging. But... if Josh is right, and there can be a canonical one that is worth us publishing, have you looked at what we do publish?</p>",
        "id": 208755714,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598998440
    },
    {
        "content": "<p>I've looked at it, but not in depth (looks good from cursory though).  I've only seen <code>fhir.schema.json</code> though, nothing specific to a server (e.g., including paths, search parameters, etc.)</p>",
        "id": 208756343,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598998803
    },
    {
        "content": "<p>well, here's an example - always generated, but apparently the editors are extremely resistant to actually linking to it:<br>\n<a href=\"https://www.hl7.org/fhir/us/core/us-core-server.openapi.json\">https://www.hl7.org/fhir/us/core/us-core-server.openapi.json</a></p>\n<p>(at least US core does link to it)</p>",
        "id": 208756492,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598998903
    },
    {
        "content": "<p>Ah, I do remember that one now (Eric has linked to it before).  One of the first cases I was solving required OAS 2.0 without any schema elements, so I looked at it but moved on</p>",
        "id": 208756720,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598999041
    },
    {
        "content": "<p>(it also required the file be &lt; 1 MB, if you want a laugh)</p>",
        "id": 208756793,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598999077
    },
    {
        "content": "<p>the bit that makes me nervous is setting up a parallel infrastructure that creates openapi documents without any reconciliation, so that we get incompatible interpretations of openapi documents</p>",
        "id": 208756925,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598999169
    },
    {
        "content": "<p>Fair - but I can't see how to reconcile direct conflicts to make it useful for tooling</p>",
        "id": 208757160,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598999341
    },
    {
        "content": "<p>I see this as an on-demand type service (eventually I'll get to building the UI) - give it a URL, check some boxes, and get a file that works for your needs.</p>",
        "id": 208757300,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598999430
    },
    {
        "content": "<p>I am happy to put in additional steps/validations if that's the concern, but I'm somewhat at a loss as to how.. even converting between OAS 2.0 and 3.0 is rough in practice.</p>",
        "id": 208757406,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598999515
    },
    {
        "content": "<p>I think I decided to only support 3.0.</p>",
        "id": 208757458,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598999532
    },
    {
        "content": "<p>other than that... I'm not sure either. I don't suppose you can generate by starting with the one I generate and changing it? (probably not, but I don't understand how some of the issues you talked about can even describe the same API)</p>",
        "id": 208757525,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1598999601
    },
    {
        "content": "<p>I probably could - but the codegen project works off the JSON specs directly today.  The project builds the generated content for the fhir-net-api now, so something that major would need to be a different project altogether</p>",
        "id": 208757756,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598999718
    },
    {
        "content": "<p>How about for a next step I figure out settings that match to generate a document the same as the <code>fhir.schema.json</code> file, then add a comparison to the official one to my tests.  That way, we know it <em>can</em> look the same.</p>",
        "id": 208758004,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1598999906
    },
    {
        "content": "<p>that sounds like a good idea</p>",
        "id": 208758468,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1599000261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> <a href=\"#narrow/stream/179166-implementers/topic/fhir-codegen.20for.20OAS/near/208752685\">said</a>:</p>\n<blockquote>\n<p>Currently, the publication tooling generates OAS documents for any capability statements it sees. They are relatively fully populated, except for the deep issues in json schema. For some reason I don't understand, everyone is ignoring these and complaining that nothing is producing them. </p>\n</blockquote>\n<p>Same question for you, then, Graham: Last time I asked about OAS support for FHIR in general, the consensus was that there were pretty large chunks of stuff that wouldn't convert well from profiles to OAS / JSON schemas. Has that improved?</p>\n<p>I'm specifically curious about response elements: does the output OAS spec include field descriptions, etc. for the response bodies?</p>",
        "id": 208772786,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1599013129
    },
    {
        "content": "<p>(Apologies: I'm actually not all that familiar with OAS myself (just hopeful that we'll get to leverage it!), and can't <em>quite</em> tell from the USCore example you posted above.)</p>",
        "id": 208773136,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1599013480
    },
    {
        "content": "<p>I generate an openapi document hooked up to the json schema - for the base FHIR resources. I think it's correct. But the tools are all over the place, and don't agree much</p>",
        "id": 208778452,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1599020858
    }
]