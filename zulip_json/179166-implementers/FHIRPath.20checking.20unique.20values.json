[
    {
        "content": "<p>Hi, I'm trying to specify constraint to make sure patient address does not contain duplicate use and type values. Can this be done in FHIRPath, something like address.select(use, type).isDistinct()? The combination of address use and type needs to be unique. Thanks.</p>",
        "id": 174798227,
        "sender_full_name": "frank cao",
        "timestamp": 1567523754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191359\">@Bryn Rhodes</span></p>",
        "id": 174800574,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1567525246
    },
    {
        "content": "<p>Before enforcing the constraint, consider that patients may have multiple home or business addresses and may have 'historic' addresses that are no longer active.  It may be better to require that one address of each use+type combination be designated as primary/preferred using an extension.  That way you're not preventing the client from sending the addresses they know about.</p>",
        "id": 174800769,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1567525374
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> <br>\nThanks Lloyd. I'll give it some thoughts. Can this be done in FHIRPath, though? I need some guidance on the syntax of the expression, especially the select(expression) part.</p>",
        "id": 174802769,
        "sender_full_name": "frank cao",
        "timestamp": 1567526697
    },
    {
        "content": "<p>That's why I drew Bryn's attention to the thread.  I'm not super familiar with the 'select' operation.  Best to get advice from an expert :)</p>",
        "id": 174803394,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1567527124
    },
    {
        "content": "<p><code>address.select(use | type).isDistinct()</code></p>\n<p>the select returns a collections of collections where the inner collection contains the use and the type. The isDistinct() checks that the outer collection has no duplicates.</p>",
        "id": 174819746,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567537675
    },
    {
        "content": "<p>Thanks Grahame. I'm not sure if isDistinct() can be used here as it will only return true if all the items are distinct. If I have two addresses, one with use = \"home\", type = \"physical\", the other one with use = \"home\", type = \"postal\", your query will return false, but I want to compare the combination so this should pass. What I need is something like address[0].select(use|type) != address[1].select(use|type), but how do I expand it to work beyond 2 addresses?</p>",
        "id": 174891532,
        "sender_full_name": "frank cao",
        "timestamp": 1567610036
    },
    {
        "content": "<p>I thought that was how that FHIRPath works. Did you test it?</p>",
        "id": 174920907,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567629630
    },
    {
        "content": "<p>The problem is that the select won't preserve the combinations, it will jut put them all in a single list. So you won't have a list of pairs of use/type elements, which is what you're really trying to say is unique here, if I'm understanding the question correctly.</p>",
        "id": 174952548,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1567670055
    },
    {
        "content": "<p>I think without a constructor, you'd have to do something hackish like <code>select(use &amp; type).isDistinct</code></p>",
        "id": 174952612,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1567670135
    },
    {
        "content": "<p>ok yes I missed this: </p>\n<blockquote>\n<p>(collections resulting from evaluation of <em>projection</em> are flattened)</p>\n</blockquote>\n<p>So yes, have to hack with &amp;</p>",
        "id": 174952812,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567670311
    }
]