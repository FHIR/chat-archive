[
    {
        "content": "<p>Literal references can be specified as a logical id without the resource type e.g. 'abc1234'. Also, logical-ids are only required to be unique for a given resource type, so I could have a Patient resource 'abc1234' and a RelatedPerson resource 'abc1234'. This could cause problems with compartment membership because the same reference field is used to model relationships to more than one type of resource. For example, CareTeam.participant indicates that the CareTeam resource belongs to a given Patient compartment as well as a RelatedPerson compartment. If the same logical-id were used for both a Patient and a (perhaps completely unrelated!) RelatedPerson 'abc1234'.  this would map a CareTeam resource into a compartment it might not actually belong to.</p>\n<p>Forcing relative references to include the resource-type is one solution, but deviates from the specification. Has anyone else hit this and is there a recommended approach?</p>",
        "id": 216890571,
        "sender_full_name": "Robin Arnold",
        "timestamp": 1605542288
    },
    {
        "content": "<p>Logical ids should be a combination of system + value - and together those SHOULD be globally unique across all resource types.</p>",
        "id": 216890847,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1605542402
    },
    {
        "content": "<p>A literal reference without the type isn't legal. There are some contexts where you can use id alone, for example reference search, but each of those contexts has some language like \"Servers SHOULD reject a search where the logical id refers to more than one matching resource across different types\" to clarify what happens.</p>",
        "id": 216891156,
        "sender_full_name": "Paul Church",
        "timestamp": 1605542503
    },
    {
        "content": "<p>That said, it's certainly possible for the logical identifier to exist on multiple.  E.g. pointing by social security number and it resolving on Patient, RelatedPerson and Practitioner.  The reality is that logical references aren't as precise as true references.  Even if you add resource type, there's a possibility of multiple matches.</p>",
        "id": 216891161,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1605542505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> yes, I agree that the search specification indicates that the search should be rejected if the logical id matches more than one resource across different types, but it provides a way to disambiguate such cases by specifying the desired type in the search string. But this still leaves the issue with compartment membership.</p>",
        "id": 216893213,
        "sender_full_name": "Robin Arnold",
        "timestamp": 1605543251
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> perhaps I'm misreading the spec, but it does seem as though literal references don't require the type. \"For this reason, the reference may indicate directly the target resource type\".</p>",
        "id": 216893829,
        "sender_full_name": "Robin Arnold",
        "timestamp": 1605543513
    },
    {
        "content": "<p>I read the spec as requiring the type in any case where it can't be inferred, because of \"a Reference always point[s] to another resource, which has a fixed and known type\".</p>\n<p>I don't think this is entirely clear from the wording though. The \"may indicate directly\" wording points in the opposite direction. The Google implementation does not allow the type to be omitted in any case.</p>",
        "id": 216896065,
        "sender_full_name": "Paul Church",
        "timestamp": 1605544435
    },
    {
        "content": "<p>To me, the spec is clear that relative references should be of the form <code>ResourceType/123</code>.<br>\nHowever, I don't see anything in the datatype definitions (i.e. no constraints other than the one about starting with <code>#</code>) that enforces that.</p>",
        "id": 216896158,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1605544465
    },
    {
        "content": "<p>We know absolute references are allowed as well, and that these need not match the FHIR REST API pattern.  But would it still be possible to add some kind of URI pattern constraint?</p>",
        "id": 216896559,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1605544639
    },
    {
        "content": "<p>and, without this type of enforcement, is an opaque string value truly \"invalid\"?</p>",
        "id": 216896805,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1605544737
    },
    {
        "content": "<p>The section on <a href=\"https://build.fhir.org/references.html\">references</a> makes clear what the URL is allowed to be.  It's either an absolute URL, it's a type/id or it's a local reference (starts with '#').  A bare id is never legal.</p>",
        "id": 216899472,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1605545801
    },
    {
        "content": "<p>There is no part of that section that clearly states the type/id part of what you just said.</p>",
        "id": 216899699,
        "sender_full_name": "Paul Church",
        "timestamp": 1605545890
    },
    {
        "content": "<p>also, what constitutes a valid absolute URL.  does it need to match <code>scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]</code> ?</p>",
        "id": 216900189,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1605546134
    },
    {
        "content": "<p>I'm not sure where I got the impression (I tried to look for anything to back this up) but I was under the impression that a reference that is bound to only one resourceType by the base fhir spec is allowed to not give the resource type in the reference (i.e. Patient.managingOrganization=123 implies Organization/123 but Patient.generalPractitioner=123 is invalid because of this very reason) is this not the case?</p>",
        "id": 216900328,
        "sender_full_name": "ryan moehrke",
        "timestamp": 1605546198
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"237342\">@ryan moehrke</span> there are two different parts to this.</p>\n<ol>\n<li>what appears in the Resource</li>\n<li>what you can use to search it</li>\n</ol>",
        "id": 216900425,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1605546244
    },
    {
        "content": "<p>for 1, it must be <code>ReferenceType/id</code> (for relative references)</p>",
        "id": 216900503,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1605546271
    },
    {
        "content": "<p>for 2, you can omit the <code>ReferenceType/</code> prefix if its unambiguous</p>",
        "id": 216900533,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1605546288
    },
    {
        "content": "<blockquote>\n<p>for 2, you can omit the ReferenceType/ prefix if its unambiguous</p>\n</blockquote>\n<p>(And as a side note, one way to make it unambiguous in a search is with a modifier -- e.g., <code>Observation?subject:Patient=123</code>. Though this particular example would be pretty unusual, since there's a dedicated <code>patient=</code> search parameter that accomplishes exactly this restriction out of the box.)</p>",
        "id": 216902558,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1605547184
    },
    {
        "content": "<p>(it annoys the heck out of me that you can do subject:Patient=123 or subject=Patient/123 or patient=123 to solve the same problem)</p>",
        "id": 216902744,
        "sender_full_name": "Paul Church",
        "timestamp": 1605547267
    },
    {
        "content": "<p>We should probably just come up with a <a href=\"https://xkcd.com/927/\">new unified syntax that can do it all!</a></p>",
        "id": 216912656,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1605551655
    },
    {
        "content": "<p>It's technically possible to put just a base string in the reference:</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"s2\">\"patient\"</span> <span class=\"err\">:</span> <span class=\"p\">{</span> <span class=\"nt\">\"reference\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"8cdf70c5-a3d0-4910-935d-d59594079647\"</span><span class=\"p\">}</span> <span class=\"err\">}</span>\n</code></pre></div>\n<p>What this means is that the literal reference <code>[base]/8cdf70c5-a3d0-4910-935d-d59594079647</code> resolves to something that is a valid resource type of the resources allowed in this context.</p>\n<p>Obviously this means that the target resource is not being served up by a server that conforms to the RESTful API. And therefore it is indeterminate what it means for RESTful API search, since the RESTful search is search on the RESTful API.</p>",
        "id": 216934136,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1605561759
    },
    {
        "content": "<p>I'm very sorry if the answer to this is obvious to everyone but me... but is this problem made worse by situations where there are <strong>multiple</strong> FHIR servers, each playing unique roles in an HIE architecture? For example... if there is a FHIR server acting as an EMPI and a separate one acting as a shared health record (SHR... or CDR), are we forced into needing to employ fully specified URLs? And if not, are relative references able to operate outside the scope of a single FHIR server?</p>",
        "id": 216937918,
        "sender_full_name": "Derek Ritz",
        "timestamp": 1605563682
    },
    {
        "content": "<p>Relative references are limited to the scope of a single server (unless their served up by a facade that masks the existence of multiple back-end servers)</p>",
        "id": 216938106,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1605563791
    },
    {
        "content": "<p>That's the only way to ensure unique resolution</p>",
        "id": 216938147,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1605563816
    },
    {
        "content": "<blockquote>\n<p>are relative references able to operate outside the scope of a single FHIR server</p>\n</blockquote>\n<p>The specification does not say that this is not possible. Note the double negative there, with care. There are immediately obvious challenges with doing this, but if the eco-system can ensure that each type has a master server, and this is fixed in advance, then it's possible. But that's super fragile; much much better to use absolute references</p>",
        "id": 216938599,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1605564035
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  and <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>. So... realistically... one would be well-served to always use absolute references as a matter of good practice. This way -- if separate servers needed to be lit up at a later date (to handle high traffic loads, for example) -- it'd all just keep working... right? And if relative references were used... perhaps not so much.</p>",
        "id": 216938862,
        "sender_full_name": "Derek Ritz",
        "timestamp": 1605564183
    },
    {
        "content": "<p>maybe. depends on how it plays out. Typically, multiple servers = multiple IP address for the same name in DNS, and the scaling solution is opaque to clients. But if it's not... then maybe absolute references would have helped (retrospectively)</p>",
        "id": 216939116,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1605564300
    },
    {
        "content": "<p>my understanding is that relative references would be in the context of an obvious base.. the example given here is that they are used within  a Bundle, so the base on the bundle gives context. <br>\nI don't think that one MUST use relative references inside a Bundle... right?</p>",
        "id": 216939153,
        "sender_full_name": "John Moehrke",
        "timestamp": 1605564318
    },
    {
        "content": "<p>thus a trusted intermediary (I) might assemble a Bundle made up of federated queries out to many (A, B, C, D) . Each of the federated queries would have had relative references to each Bundle response.. that trusted intermediary (I) might then create a Response Bundle of its-own (I:Bundle) expand  all the relative references from the (A, B, C, D) bundles into full URL and assemble them all into the one Bundle owned by the trusted intermediary (I-Bundle). Given that this trusted intermediary didn't add any resources of its-own (not disallowed, just for example), then all the resources in the Bundle would not have relative References but have fully specified URL back to the federation of resource servers. The result would be clear and compliant. --- right?</p>",
        "id": 216939895,
        "sender_full_name": "John Moehrke",
        "timestamp": 1605564689
    },
    {
        "content": "<p>yes it could be done that way</p>",
        "id": 216940407,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1605564916
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  -- is that what a <strong>Document Registry</strong> actor might do (as defined in the IHE MHDS spec)? This seems to be very much the kind of trusted role the <strong>Interoperability Layer</strong> plays in an <strong>OpenHIE</strong> architecture and the kind of tasks it could be expected to perform.</p>",
        "id": 216942974,
        "sender_full_name": "Derek Ritz",
        "timestamp": 1605566396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193307\">@Derek Ritz</span>  MHDS does not need to do this as the Document Registry is the owner of the DocumentReference, DocumentManifest, and List resources.  Same is true of the other central FHIR services (PMIR, SVCM, ATNA, etc). This is just normal MHDS... But it might be a solution for a federation of MHDS(s)</p>",
        "id": 217005823,
        "sender_full_name": "John Moehrke",
        "timestamp": 1605621953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> this is OK iff the id is unique across all resource types in a given context. But the spec states that: \"The logical id is unique within the space of all resources of the same type on the same server.\" By inference, it does not need to be unique across resource types, which I think exposes the issue described in my original post. Because this relates to compartment membership, I believe this could lead to information leakage.</p>",
        "id": 217144180,
        "sender_full_name": "Robin Arnold",
        "timestamp": 1605711136
    },
    {
        "content": "<p>I'm not sure what you mean. If you use a literal reference then that can only resolve to one address, and that can't be more than one thing</p>",
        "id": 217161886,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1605717773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"304455\">@Robin Arnold</span> According to <a href=\"https://build.fhir.org/references.html#literal\">https://build.fhir.org/references.html#literal</a> \"a relative URL, which is relative to the Service Base URL, or, if processing a resource from a bundle, which is relative to the base URL implied by the Bundle.entry.fullUrl (see Resolving References in Bundles)\". I don't see, in your example, how you can use relative reference without resource type.</p>",
        "id": 217163384,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1605718341
    },
    {
        "content": "<p>Consider this scenario. I create a resource \"Patient/abc\" and then \"CareTeam/ct1\" which includes a participant reference = \"abc\". This places \"CareTeam/ct1\" in the compartment of \"Patient/abc\".</p>\n<p>Now let's add a new resource \"RelatedPerson/abc\" which has nothing to do with the above resources, other than it happens to share the same literal id. This is valid, because ids are only unique within a resource type. However, this causes our resource \"CareTeam/ct1\" to be included in the compartment of this new resource (based on participant reference = \"abc\" and according to the compartment definition for CareTeam).</p>",
        "id": 217164370,
        "sender_full_name": "Robin Arnold",
        "timestamp": 1605718749
    },
    {
        "content": "<p>Here is problem. According to the spec, the relative url is based on \"<strong>Service Base URL</strong>\" (see the link in my previous post). So unless your patient can be accessed by [base]/abc, reference = abc is not correct.</p>",
        "id": 217169098,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1605720709
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191506\">@Yunwei Wang</span> this is ideally what I'd like to have confirmed. I suspect I'm missing something implied by  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> in his earlier post: \"It's technically possible to put just a base string in the reference: \"patient\" : { \"reference\" : \"8cdf70c5-a3d0-4910-935d-d59594079647\"} }\".</p>",
        "id": 217171468,
        "sender_full_name": "Robin Arnold",
        "timestamp": 1605721739
    },
    {
        "content": "<p>My take on what Grahame said is that the spec allows that case, but unless <strong>your implementation</strong> serves up a resource at [base]/123, you are free to reject \"reference\":\"123\" because it can't refer to anything on your server.</p>",
        "id": 217172969,
        "sender_full_name": "Paul Church",
        "timestamp": 1605722377
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> very reasonable.</p>",
        "id": 217173598,
        "sender_full_name": "Robin Arnold",
        "timestamp": 1605722668
    },
    {
        "content": "<p>Yes. That is my understanding too. If your server does serve Patient/123 at [base]/123, there is no problem for refernece = 123. But then you cannot claim that [base]/123 also serve as endpoint for RelatedPersion/123. The url serves one resource only.</p>",
        "id": 217173811,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1605722763
    }
]