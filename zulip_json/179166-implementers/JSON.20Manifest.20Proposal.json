[
    {
        "content": "<p>All: I've made a proposal around the JSON format here: <a href=\"http://www.healthintersections.com.au/?p=2626\" target=\"_blank\" title=\"http://www.healthintersections.com.au/?p=2626\">http://www.healthintersections.com.au/?p=2626</a></p>",
        "id": 153885254,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492691018
    },
    {
        "content": "<p>comments wlelcome</p>",
        "id": 153885255,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492691025
    },
    {
        "content": "<p>Nice explanation. I worry about the 'fragile' nature that you do describe. It presents rich opportunity for unintended collisions. That is two very different extensions choose the same short name. not easy to detect, unless you are exhaustive; and the target audience of this new approach are these that don't want to be exhaustive. I understand and sympathize with them. They are important. But we know the problems of 'Z' segments. This is better, but not much. Possible to require servers be strict, thus detect collisions; but servers can't detect your other 'fragile</p>",
        "id": 153885257,
        "sender_full_name": "John Moehrke",
        "timestamp": 1492692284
    },
    {
        "content": "<p>How would this proposal handle new attributes added to resources in new FHIR versions? what happens if \"trial\" is added as a core element? One advantage of the current approach is that extensions and standard elements essentially live separate namespaces.</p>",
        "id": 153885289,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1492709121
    },
    {
        "content": "<p>Similarly, if you use external manifests, what happens if both define the \"trial\" extension? There isn't the same namespace qualification that the current approach has.</p>",
        "id": 153885291,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1492709341
    },
    {
        "content": "<p>Elliot, my same concern. collisions are hard to detect.</p>",
        "id": 153885292,
        "sender_full_name": "John Moehrke",
        "timestamp": 1492709458
    },
    {
        "content": "<p>Yeah, just reread your post. Exactly the issues you mention.</p>",
        "id": 153885293,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1492709551
    },
    {
        "content": "<p>Also brings up issues of signing content. Is there a canonical form? What happens if we both use the same extension, but I name the attribute foo, and you name it bar? What happens if I do an inband manifest, and you do out of band?</p>",
        "id": 153885294,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1492709694
    },
    {
        "content": "<p>I think of this as being a \"proprietary syntax\" that only works in a limited context, but where there's a straight-forward transform to a \"standard\" syntax.  When you're working with the proprietary syntax, you're going to want your object model to align with that syntax, which means the reference implementations aren't going to work well/at all.  Furthermore, if you're going to do that, people are going to want slices to manifest too - here's my MRN, here's my SSN, etc.  Would it not be cleaner to come up with a transform between a profile-driven syntax and the \"standard\" syntax?  So long as the syntax-driving profile were identified in the instance and resolvable, it would be possible for the client to interact with a standard server.  And it would mean that systems that wanted to deal with \"pure\" (non-fragile) FHIR could do so, while those who wanted to look at the data model their particular way could do so.  (Heck, they could even have a profile that expressed elements in their language of choice and still be able to interoperate cleanly.)</p>",
        "id": 153885320,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492717465
    },
    {
        "content": "<p>as I said in my post, it's fragile. Not at all good for interoperability. You need control over your context to make this safe. But the problem is, lots of implementers have that control over their environment....</p>",
        "id": 153885333,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492718573
    },
    {
        "content": "<p>we could extend this to cover slicing but that's a big step in complexity and fragility</p>",
        "id": 153885334,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492718601
    },
    {
        "content": "<p>If it's not good for interoperability, and only applies for when implementers have control over their environment, why bother? Implementers who aren't interested in interoperability can implement their own FHIR-like thing on their own. They don't even need to bother with declaring extensions -- just add the extra elements without noting they are extensions. Who cares? It's a pre-arranged private exchange anyhow.</p>",
        "id": 153885339,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1492718801
    },
    {
        "content": "<p>But it would essentially then be implementer-specific.  \"I want this data - oh and by the way, use this serialization that matches my internal data model\".  It wouldn't be quite that tight, but with a profile-driven serialization, it could be quite close.</p>",
        "id": 153885341,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492718840
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191380\">@Elliot Silver</span> In the end, interoperability means \"implementers who are capable of exchange\" - so making things super-easy for implementers enhances interoperability <em>if</em> there's a way to ensure that what's exchanged is consumable by others.</p>",
        "id": 153885342,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492718901
    },
    {
        "content": "<p>I think if we had the ability to post data to a server that pointed to a rendering profile or request data from a server specifying a rendering profile, that would meet the needs of these simple/limited/(lazy?) systems.  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>, we'd have to decide what level of complexity in rendering was reasonbly for servers to undertake.  I just think if we're going to essentially come up with what's essentially a profile-driven syntax, we may as well look at the whole thing.  Slicing and \"what extensions do I use and how do I know them\" are pieces, but so is treating non-supported elements as extensions, treating elements that have been constrainted to x..1 as non-arrays, using local/friendly names, etc.  Some of those things will be easy, some hard.  But they may as well all be on the table for discussion.</p>",
        "id": 153885343,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492719156
    },
    {
        "content": "<p>so there's a big line to cross here - the JSON manifest proposal I made is limited to things that can be resolved automatically with only the instance, and that are simple to compute. And could be supported by the reference implementations no problems. It's *not* a profile driven syntax. That's a real step up in terms of complexity</p>",
        "id": 153885350,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492719837
    },
    {
        "content": "<p>As regarding why bother if it's not good for interoperability.... because few of us live in a binary place where FHIR is purely for interoperability, or purely for internal use. Almost always, there's a cross-over between one and the other. Which is why people are using FHIR internally. And the noise about parameters and extensions is ongoing. </p>",
        "id": 153885352,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492719925
    },
    {
        "content": "<p>note that I originally came to this proposal from the Parameters resource, seeking to resolve the outcome that cds-hooks community refused to make cds-hooks a FHIR operation because of the JSON syntax</p>",
        "id": 153885353,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492719976
    },
    {
        "content": "<p>Still - I find it a bit special to basically include 'part of the definition/schema' as part of the data being transferred. I recognize that it can pave the road for a more dynamic approach if 'spec first' is not what one is looking for. I myself cannot see how this provides value as I'm a 'spec first' kinda guy. While the proposal might make sense to others, I find it redundant and deeming it unnecessary, IMHO.</p>",
        "id": 153885504,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1492796277
    },
    {
        "content": "<p>Looks good to me.  I doubt there will be any concerns raised from the Meteor community.  We're fine with the existing approach; so glad to see that this proposal is specifically listed as additional, since it's value proposition is a bit net-neutral for us right now.  It might help with inbound resources that are using unknown extensions.   Would this go onto the base <code>Resource</code> so it gets added to all Resources in one go?</p>",
        "id": 153885513,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1492801803
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> - Rather than thinking of them as simple/limited/lazy, it might help to think of them as direct-wire-to-database or wire-to-cache systems (and vice versa).  They're simple in the same way that a Cisco router with fibre optics is simple; in that they're optimized for performance rather than trying to normalize into a relational database.  </p>",
        "id": 153885515,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1492802036
    },
    {
        "content": "<p>I wasn't trying to be pejorative (except perhaps with that last one - there will be some of those too).  I think it's a group we need to support.  The question is whether we try to come up with a single solution that will work for everyone or come up with a \"translatable\" solution for those folks that can be converted to something that works for everyone else - i.e. separate the persistance/manipulation representation from the exchange representation but rather than having everyone figure out how to do that mapping themselves, provide a standardized mechanism that does most of the work.</p>",
        "id": 153885519,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492803659
    },
    {
        "content": "<p>there's no more information in the instance than is already there. This is not including part of the definition/schema in the instance</p>",
        "id": 153885531,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492807074
    },
    {
        "content": "<p>No worries.  No offense taken here.  :)<br>\nAny particular reason why <code>@manifest</code> instead of <code>@extensions</code>?  Also, if we're thinking about translatable solutions for persistance/manipulation representation, the two other items that would really help to address are <code>meta.fhirVersion</code> and how the DateTime datatype is handled.  </p>",
        "id": 153885535,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1492807295
    },
    {
        "content": "<p>We're still targetting FHIR being \"versionless\" once normative, so are resisting adding fhirVersion.  What are the issues w/ date/time?  (Feel free to just link if it's already been discussed)</p>",
        "id": 153885536,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492807373
    },
    {
        "content": "<p>@manifest because it's for the Parameters resource too.</p>",
        "id": 153885537,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492807413
    },
    {
        "content": "<p>My fundamental challenge here is that this syntax is only useful to a client if <em>all</em> inbound content aligns with the particular names that client wants - otherwise they have to go through the work of parsing the manifest, mapping extensions from the regular extension format, mapping unrecognized \"manifested\" constraints back to the old format, and generally doing a bunch of extra work that's uglier than what they have to do now.  And, generally speaking, I expect they won't.  Which means they'll only accept inbound data that aligns with their particular manifest - giving us a ton of silos that can't talk to each other.  In short, this promises to seriously break interoperable data exchange.  And the use-case for it <em>isn't</em> interoperable data exchange - it's back-end processing and persistence.  So rather than break the exchange format, why not provide a mechanism to convert between the exchange syntax and a persistenace/processing syntax that's easy to work with and share the libraries that do that work.  That prevents silos, but makes it easy for those who want to use FHIR internally in a less painful way.</p>",
        "id": 153885543,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492807744
    },
    {
        "content": "<p>The use case is <em>not</em> back-end processing and persistence. It's client/server in a tightly managed environment. Your alternative will be worse, in that it's much more work to bridge the silos. And you're ignoring the fact that already have silos a la cds-hooks. My real intent was to make a better representation for the Parameters resource, since the json form is seriously not good</p>",
        "id": 153885547,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492807974
    },
    {
        "content": "<p>Most JSON datastores use a Javascript Date() object to natively store date/time.  But FHIR's DateTime is basically a string, so as to handle fuzzy/incomplete dates.  Pragmatically speaking, boxing/unboxing DateTime is one of only two instances where we modify resources along the data layer.  The other is converting between versions.  Otherwise, the FHIR resources are fluid between client, server, and database (all using the V8 javascript VM).  It would be simple enough to convert to String for the underlying DateTime, except we don't want to lose fast indexing/search along our time vector.  So we box/unbox any Date/Time fields.</p>",
        "id": 153885550,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1492808442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> How is it more work to bridge the silos if everyone uses the \"traditional\" syntax for exchange  - and it's easy to conver to and from the \"internal\" syntax?</p>",
        "id": 153885569,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492809015
    },
    {
        "content": "<p>because the internal syntax will get used for exchange.</p>",
        "id": 153885570,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492809138
    },
    {
        "content": "<p>Not conformantly if we say that's not allowed - and proprietary syntaxes are used for exchange all the time.  At least this would be a semi-priorietary with an automated conversion</p>",
        "id": 153885571,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492809868
    },
    {
        "content": "<p>Do you rally want to introduce a breaking change in a maturity 5 part of the specs?</p>",
        "id": 153885596,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1492875170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> the proposal isn't <em>breaking</em> in the sense that it's an additional option rather than a change to the presently-defined format. That said, I'm not sure it's a net win for the community to have a second way of doing things (let alone a second way that's easy to trip on by writing non-robust parsers that ignore the <code>manifest</code> property and assume that all property names are fixed, \"like in my own environment\").</p>",
        "id": 153885597,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1492886239
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> I assume you'll weigh in here when you've had a chance to review :-)</p>",
        "id": 153885598,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1492886326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  Cool! (i proposed similar solution couple of times :), in next version of aidbox  we go even father - we extract Element from StructureDefinition into separate resource  and allow add new elements to existing resources, using the same syntax like FHIR specs, but we treat user elements as extensions when converting back into FHIR. In our internal model there is no conceptual difference between FHIR Elements and UserDefined Extensions. I hope next FHIR improvement will be about polymorphic/union elements: <code>{value: {Quantity: {....}}}</code>!  We also modified Reference type for internal references: <code>{reference: '/Patient/pt-1'} =&gt; {id: 'pt-1', resourceType: 'Patient'}</code> - more structured  and convenient representation. If you give me some time in Madrid - i could present this.</p>",
        "id": 153885600,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1492896101
    },
    {
        "content": "<p>Extensions are unavoidable, new FHIR elements could be considered (developed and introduced) like extensions (if we would unify extensions and FHIR elements). Key feature of interoperability for me  - server  provides meta-information about information!  Wishful thinking: we need solid core - how to define resource and it's elements (it should be minimalistic, well-designed and stable), then using this core  - FHIR defines standard resources  and elements and vendors/users define their own's  - there is clear way from extension to standard  - just remove prefix :) like in css: <code>-webkit-radius-border =&gt; radius-border</code></p>",
        "id": 153885601,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1492897227
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> : if a server returns extensions using this new format a client expecting the old one would no longer see the extensions. A SMART-compliant FHIR server that switched to this new format will break all the existing SMART client - that will no longer see the authentication URLs extensions. Seems pretty breaking to me.</p>",
        "id": 153885611,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1492904481
    },
    {
        "content": "<p>My understanding is that this behavior would only happen if a client asked for some new content type... </p>",
        "id": 153885612,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1492913167
    },
    {
        "content": "<p>Best thought, as usually, in the morning: similar to hypermedia driven clients, <strong>FHIR clients should be metadata driven</strong> (with not hardcoded access to data elements)</p>",
        "id": 153885614,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1492925013
    },
    {
        "content": "<p>[sound of a coin dropping] - having read the proposal again I can see that I misunderstood it. As I understand it now (from my newly gained epiphany), I can see how it is more 'easy' to read from a Json-client perspective / easier accessible. What I also see is that the representation is changed without losing information. If this is true, a suggestion (in order not to break any existing implementations) could be to add an extra content-type - i.e. : application/fhir+json+manifest. One can then rely on regular http content negotiation to see if this new json representation is supported or not, thereby making the new representation purely optional.</p>",
        "id": 153885626,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1492946978
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> \"-webkit-\" works as a prefix because you can count the number of relevant browsers in existence using your fingers.  The number of FHIR servers will number in the 10s if not 100s of thousands - managing prefixes is going to be a pain - which pushes us to URLs which then starts to look like XML namespaces which I haven't generally seen a lot of enthusiasm for in the JSON space.</p>",
        "id": 153885634,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492961501
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> yes I understand, but to be honest - it would be -cerner-border-radius or -epic-race ;) That's ok to work with manifest, uris and aliases  - but moving broadly accepted extensions into core, should be - just remove prefix.</p>",
        "id": 153885636,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1492963724
    },
    {
        "content": "<p>That's why I think extensions should be defined using same syntax as ordinary FHIR elements.</p>",
        "id": 153885637,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1492963864
    },
    {
        "content": "<p>Except it wouldn't be \"-cerner\".  It would have to be something like \"-com-cerner-border-radius\" because we're not going to manage namespaces for hundreds of thousands of organizations and vendors.</p>",
        "id": 153885646,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1492978959
    },
    {
        "content": "<p>very early on we considered manually assigning namespaces by appliation for FHIR implementers to use as extensions. The community had a pretty strong message about that</p>",
        "id": 153885648,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1492982107
    },
    {
        "content": "<p>(dupe)</p>",
        "id": 153885769,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1493055805
    },
    {
        "content": "<p>Ha, so it wasn't a dupe and I deleted my comment. :P</p>\n<p>2nd try: the whole JSON debate usually comes down to interoperability (current format) vs. JSON-purism (i.e. being able to use keypaths to get at a value). My thought was that I'd still expect extensions, like \"trials\" to live in <code>extensions.trials</code>. So, in Grahame's proposal, would it make sense to have <code>\"trials\": \"renal\"</code> live under <code>extension</code>? This would obviously break our current format.</p>\n<div class=\"codehilite\"><pre><span></span>{\n  &quot;resourceType&quot;: &quot;Patient&quot;,\n  &quot;id&quot;: &quot;ex1&quot;,\n  &quot;extension&quot;: {\n    &quot;trials&quot;: &quot;renal&quot;\n  },\n  &quot;@extension&quot;: {\n    &quot;trials&quot;: {\n      &quot;url&quot;: &quot;http://example.org/StructureDefinition/trials&quot;,\n      &quot;type&quot;: &quot;code&quot;\n    }\n  },\n  &quot;active&quot;: true\n}\n</pre></div>\n\n\n<p>Personally I might prefer something that stays contained in <code>extension</code>, e.g. the following, but this one doesn't follow any established pattern that I'm aware of:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  &quot;resourceType&quot;: &quot;Patient&quot;,\n  &quot;id&quot;: &quot;ex1&quot;,\n  &quot;extension&quot;: {\n    &quot;trials&quot;: &quot;renal&quot;,\n    &quot;@trials&quot;: {\n      &quot;url&quot;: &quot;http://example.org/StructureDefinition/trials&quot;,\n      &quot;type&quot;: &quot;code&quot;\n    }\n  },\n  &quot;active&quot;: true\n}\n</pre></div>",
        "id": 153885869,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1493087902
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191339\">@Pascal Pfiffner</span>  you could use specific prefix <strong>extension</strong> for your extension's keys or use extensions in extensions to separate elements, you want to visually distinguish.  For me, it's very important, to not create ghetto for <em>Extensions</em> - they are first class citizen :)</p>",
        "id": 153885875,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1493090202
    },
    {
        "content": "<p>the discussion on this has been interesting but has largely born out my original description: both Lloyd and Nicola want to make extensions first class citizens - but they are worried about very different things, because of a very different perspective</p>",
        "id": 153885923,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493126115
    },
    {
        "content": "<p>Hi @<strong>nicola (RIO)</strong> ,<br>\nI am very interested in your reflexion arround reference ( {reference: '/Patient/pt-1'} =&gt; {id: 'pt-1', resourceType: 'Patient'} ). I ask a related question here <a href=\"#narrow/near/75849/stream/analytics.20on.20FHIR/topic/Apache.20Drill\" title=\"#narrow/near/75849/stream/analytics.20on.20FHIR/topic/Apache.20Drill\">https://chat.fhir.org/#narrow/near/75849/stream/analytics.20on.20FHIR/topic/Apache.20Drill</a> <br>\nFor some reason, implementing FHIR as a relational model needs allowing joins between resources, and the way FHIR specifies references is not friendly for that. <br>\nCan you elaborate on that ? </p>\n<p>Thanks</p>",
        "id": 153886485,
        "sender_full_name": "natus",
        "timestamp": 1493537405
    },
    {
        "content": "<p>have you looked at the way this is resolved in the RDF format? </p>",
        "id": 153886513,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1493609829
    },
    {
        "content": "<p>@natus Yes, definitely!  In aidbox we convert FHIR JSON  into internal representation where <code>reference</code> becomes  resourceType &amp; id or absolute uri. We also fix polymorphic[x]  into   <code> valueString =&gt; value: {string: ...}</code> and inline extensions (similar to Grahame  last proposal). Transformation is little bit tricky, because requires metadata - i could share algorithm or clojure code - if you would like. Better would be make alternative FHIR JSON format part of standard. <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  may be create technical work group to design it :)?</p>",
        "id": 153887162,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1493923288
    },
    {
        "content": "<p>Thanks for your answer.</p>\n<blockquote>\n<p>reference becomes resourceType &amp; id or absolute uri</p>\n</blockquote>\n<p>This solution sounds good. However, I won't use it until FHIR aproves that as an official alternative to deal with. To me implementing FHIR is wether 100% FHIR or 0% FHIR;  never between.</p>",
        "id": 153887164,
        "sender_full_name": "natus",
        "timestamp": 1493924092
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-email=\"niparisco@gmail.com\" data-user-id=\"2424\">@natus</span> we also convert back from internal representation into valid FHIR  - so for external users almost 100% FHIR, internally 80% :)</p>",
        "id": 153887169,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1493927410
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> - What kind of datastore are you using?  MongoDB?  CouchDB?  Something that stores in native JSON?</p>",
        "id": 153887170,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1493927472
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191678\">@Abigail Watson</span> PostgreSQL with jsonb :)</p>",
        "id": 153887185,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1493929621
    },
    {
        "content": "<p><img alt=\":+1:\" class=\"emoji\" src=\"/static/generated/emoji/images/emoji/+1.png\" title=\":+1:\"> for postgres</p>\n<blockquote>\n<p>I assume the uri you are using is an integer ? Then <a href=\"http://Encounter.Patient.id\" target=\"_blank\" title=\"http://Encounter.Patient.id\">Encounter.Patient.id</a> is a FK ?</p>\n</blockquote>",
        "id": 153887196,
        "sender_full_name": "natus",
        "timestamp": 1493930449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191430\">@Paul Knapp</span> would like to bring this proposal back to life and discuss it further (after discussion in committee)</p>",
        "id": 153888895,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1494406536
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> could you share the algorithm or clojure code ? I am also interested in thanks</p>",
        "id": 153891401,
        "sender_full_name": "natus",
        "timestamp": 1495825784
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193729\">@natus</span> ,   I'm working on gist about this transformation - hope publish it next week</p>",
        "id": 153891432,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1495962418
    },
    {
        "content": "<p>This proposal directly addresses a number of usability issues I have with the current FHIR specification.</p>\n<p>Using an unordered collection of extension maps precludes the ability to lookup the extensions efficiently. Using a map keyed on the extension id would address this issue. As it stands, the data needs to be converted into a map before it can be used effectively.</p>\n<p>The value* notation is problematic because it prevents you from knowing what keys are present in the map without inspecting it. A standard type key would provide a clean way to select the value key.</p>\n<p>The reference proposal makes it easier to tell the type of the reference for the user. It's immediately obvious whether the resource being referenced is local or external, and no parsing is required to query the resource. Again, using a map structure for local references where they're keyed on their id makes the data immediately usable as they can be looked up in the map.</p>\n<p>All of these changes would result in a better out of the box experience for the users.</p>",
        "id": 153893825,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1497465293
    }
]