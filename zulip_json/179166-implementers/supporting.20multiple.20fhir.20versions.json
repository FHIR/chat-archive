[
    {
        "content": "<p>In some use cases of FHIR servers there may be compelling reasons (graceful version upgrades, disparate versions in connected systems, etc)  to build the server so that it can accept/emit more than one version of FHIR, but there does not seem to be any mechanism for negotiating which version to use.  Does anyone have any thoughts about how best to handle these scenarios?</p>",
        "id": 153875514,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1488980552
    },
    {
        "content": "<p>While we're still in the STU phase, this is difficult because there's no backward/forward compatibility between versions.  The typical approach is to create multiple server endpoints - one for each supported version.  The endpoints then handle translation to and from the internal interface layer (whether that's a single FHIR version or something proprietary).  As we move to normative, it should be possible for different versions to all be posted to the same endpoint.  The server is tuned to the most recent version it supports and ignores data that's based on future versions (as the rare data element added to core in the future is guaranteed to be ignorable)</p>",
        "id": 153875545,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1488990623
    },
    {
        "content": "<p>I suspect that approach is going to make deployment, maintenance, and upgrading of FHIR applications and servers quite painful.  I'm already encountering this pain during the development of new applications.  Here are a couple of articles describing a couple of ways of handling this... <a href=\"https://www.narwhl.com/2015/03/the-ultimate-solution-to-versioning-rest-apis-content-negotiation/\" target=\"_blank\" title=\"https://www.narwhl.com/2015/03/the-ultimate-solution-to-versioning-rest-apis-content-negotiation/\">https://www.narwhl.com/2015/03/the-ultimate-solution-to-versioning-rest-apis-content-negotiation/</a>, <a href=\"https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/\" target=\"_blank\" title=\"https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/\">https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/</a>.</p>",
        "id": 153875553,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1488992350
    },
    {
        "content": "<p>Which part of the approach are you referring to?  The part prior to normative or the part after normative?  There's no question that the phase prior to normative is painful, but it's a pain implementers knowingly take on in choosing to implement a spec that's not yet locked down.  And we're not willing to incur the cost of complexity/baggage/brokenness that comes from locking down the spec or maintaining backwards compatibility with specifications that haven't yet been well beaten on by the community.  If you're seeing pain in the approach for post-normative, please describe your concerns further</p>",
        "id": 153875561,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1488996268
    },
    {
        "content": "<p>I've railed about this before. The current practice of having FHIR version numbers for the spec while it's changing that are indistinguishable from version numbers that represent frozen forms is really frustrating.</p>",
        "id": 153876308,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489440320
    },
    {
        "content": "<p>why is it frustrating?</p>",
        "id": 153876347,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1489445069
    },
    {
        "content": "<p>Because you can never know, just by looking at the version string, whether the thing it references is fixed or (potentially) moving</p>",
        "id": 153876348,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489445132
    },
    {
        "content": "<p>there's only one vrsion that's moving. The current version</p>",
        "id": 153876350,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1489445156
    },
    {
        "content": "<p>But how do you know what that is (just by looking at the version string)?<br>\nAnd then one day, that very same string is no longer \"current\", so it's status changes.</p>",
        "id": 153876351,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489445217
    },
    {
        "content": "<p>you can't, just by looking at the version string, but why would it matter? </p>",
        "id": 153876352,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1489445255
    },
    {
        "content": "<p>If I (my client software) looks at a capability statement and sees 1.9.0, then today it's fair to accept that it is current and there may be variation in behaviour (eg the public HAPI server uses content rather than content-mode for CodeSystem search), but at some point 1.9.0 will no longer be 'current' so should be fixed, but I can't rely on a server that reports 1.9.0 actually implementing the \"latest 1.9.0\", just \"one of\" the 1.9.0s</p>",
        "id": 153876354,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489445563
    },
    {
        "content": "<p>If there was a policy of odd vs even minor versions (even being fixed, odd moving), or x.y.z-SNAPSHOT or x.y.z.commit then a client could be confident when a reported version actually referred to the frozen instance of the spec.</p>",
        "id": 153876355,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489445658
    },
    {
        "content": "<p>Let me put it again - <a href=\"https://www.youtube.com/watch?v=oyLBGkS5ICk\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=oyLBGkS5ICk\">https://www.youtube.com/watch?v=oyLBGkS5ICk</a>, semantic vesioning is antipattern :(</p>\n<div class=\"message_inline_image\"><a href=\"https://www.youtube.com/watch?v=oyLBGkS5ICk\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=oyLBGkS5ICk\"><img src=\"https://i.ytimg.com/vi/oyLBGkS5ICk/default.jpg\"></a></div>",
        "id": 153876356,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489445712
    },
    {
        "content": "<p>1hr 15m is a long time to invest -- I can't find the slides; is there a (longer) TLDR :)</p>",
        "id": 153876359,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489446038
    },
    {
        "content": "<p>here is some abstract - <a href=\"http://blog.ezyang.com/2016/12/thoughts-about-spec-ulation-rich-hickey/\" target=\"_blank\" title=\"http://blog.ezyang.com/2016/12/thoughts-about-spec-ulation-rich-hickey/\">http://blog.ezyang.com/2016/12/thoughts-about-spec-ulation-rich-hickey/</a></p>",
        "id": 153876360,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446071
    },
    {
        "content": "<p>That's an an-pattern of it's own</p>",
        "id": 153876361,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1489446079
    },
    {
        "content": "<p>I've reported how we updated 3 major versions of clojure and all libraries on some project  and all tests was passed - it's true! Java backward compatability! HTML</p>",
        "id": 153876362,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446181
    },
    {
        "content": "<p>May be it looks little bit messy, but life will be much more simple! Every expirienced engeneer knows how to refactor/change in a safe way.</p>",
        "id": 153876363,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446253
    },
    {
        "content": "<p>None of this really helps my problem though.  When I see a server reporting fhir version \"X\", I can't be confident that it actually implements \"the latest X\"</p>",
        "id": 153876364,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489446321
    },
    {
        "content": "<p>We do not need version at all :)</p>",
        "id": 153876365,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446338
    },
    {
        "content": "<p>feature detection - like in CSS :)</p>",
        "id": 153876366,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446353
    },
    {
        "content": "<p>If you need name from Patient - you just check - there is <a href=\"http://Patient.name\" target=\"_blank\" title=\"http://Patient.name\">Patient.name</a> - that's all</p>",
        "id": 153876367,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446470
    },
    {
        "content": "<p>This will open ability for standard to evlolve continuously (every week or even day)  - this is like agile in process, continuous delivery in operations</p>",
        "id": 153876368,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446530
    },
    {
        "content": "<p>If everybody agree on some element - it could be published and used next week</p>",
        "id": 153876369,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446621
    },
    {
        "content": "<p>That what's happening with software last 20 years  - spinning up release cycles to exremes.</p>",
        "id": 153876370,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446678
    },
    {
        "content": "<p>If you need to search for CodeSystems based on content=complete, then you need to first retrieve /metadata (sometimes &gt;500k in my experience, even though much smaller than in DSTU2 with CodeSystem info)</p>",
        "id": 153876371,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489446686
    },
    {
        "content": "<p>versions could be like git commit  - SHA from metadata </p>",
        "id": 153876373,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446800
    },
    {
        "content": "<p>but...if you have a client-side mechanism that makes v ersion numbers immaterial for you, that's fine.  It shouldn't be an argument against fixing something that's inherently brittle</p>",
        "id": 153876374,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489446862
    },
    {
        "content": "<p>Backward compatabilyt will work with static typed clients too :)</p>",
        "id": 153876375,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446947
    },
    {
        "content": "<p>You just have to detect <code>version &gt;=  i need</code></p>",
        "id": 153876376,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489446999
    },
    {
        "content": "<p>intensive vs extensive dichotomy</p>",
        "id": 153876380,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489447845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> would something like an 'unstable' boolean flag on the capabilitystatement be sufficient for your purposes or are you in need or something more fine grained?</p>",
        "id": 153876572,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489496998
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> I like the idea of feature detection as a way of making versioning a moot point.</p>",
        "id": 153876573,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489497167
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193229\">@Kevin Olbrich</span> Adding an extra property to the Capability statement seems like overkill when just using 1.9.0.unstable (or an existing convention with well-known ordering rules like 1.9.0-SNAPSHOT) would do just as well.</p>",
        "id": 153876579,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489497929
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193229\">@Kevin Olbrich</span>  I think, for global FHIR application - feature detection &amp; backward compatability is a right trade-off - i'm pretty sure, if FHIR will get global adoption - many versions will coexist - why not make it legal and reduce pain of migrations and interactions. This just requires following simple rules in FHIR design and evolution - <code>don't change or remove, only add</code>.</p>",
        "id": 153876580,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489498134
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> I take your point, and that's pretty much how we operate with our Snapper client, but I see these version strings also as convenient labelling of a collection of features (also, not everything that's important is discoverable through the Capability statement).<br>\nEven Git has tags, etc and not just SHAs</p>",
        "id": 153876581,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489498158
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> I agree</p>",
        "id": 153876582,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489498265
    },
    {
        "content": "<p>@<strong>nicola (RIO)</strong> Isn't that principle of <code>don't change or remove, only add</code> more or less in line with what one would expect with a normative release?</p>",
        "id": 153876583,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489498285
    },
    {
        "content": "<p>I would also love to see better use of tagging for versions.  It would be great if I could go to the github project and get a list of releases and tarballs of the artifacts related to that release at a nice, predictable url.</p>",
        "id": 153876584,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489498356
    },
    {
        "content": "<p>One more thing, how does a DSTU2 (for example) client tell a not-yet STU3 server that it expects to get a DSTU2 ConceptMap without the group property?  The content negotiation thing has to work in both directions</p>",
        "id": 153876585,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489498371
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193229\">@Kevin Olbrich</span>  I hope. But it's better to develop culture of 'non-breaking' changes from the early time!</p>",
        "id": 153876587,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489498452
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> i think, it shoud not tell - <code>don't give me something</code>, but - <code>give me something, if you are able</code> - open world principle</p>",
        "id": 153876588,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489498528
    },
    {
        "content": "<p>In general I agree with that, but it strikes me that there has been a lot of thrash in the early days of FHIR and trying to keeps all of that around indefinitely is not practical.</p>",
        "id": 153876589,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489498533
    },
    {
        "content": "<p>If a client could inspect the schema of the resources that a server provided, it could determine if a particular attribute existed and was the right format.  Seems like that might add a lot of overhead on the communications.</p>",
        "id": 153876590,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489498638
    },
    {
        "content": "<p>That's trade-off, a lot of obsolete code in java - they do compaction, but after several years after deprication.</p>",
        "id": 153876591,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489498644
    },
    {
        "content": "<p>indeed - by \"tell\" I meant \"express\" / \"request\".  With stable, predictable version strings the Accept header could be used for this (give me a application/fhir+json;fhirVersion=1.4.0 rendering of the resource)</p>",
        "id": 153876592,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489499068
    },
    {
        "content": "<p>Or <code>application/fhir+json;fhirVersion=&gt;1.4.0</code> :)</p>",
        "id": 153876593,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489499149
    },
    {
        "content": "<p>yeah, I've been considering using the content type stuff so that a single server could handle multiple versions of fhir.</p>",
        "id": 153876594,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489499190
    },
    {
        "content": "<p>Good idea, we are working now on multi-version server  (but for different tenants) - i will try to serve old versions api  from newer endpoints!</p>",
        "id": 153876596,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489499315
    },
    {
        "content": "<p>what language are you using to implement that?</p>",
        "id": 153876597,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489499365
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193229\">@Kevin Olbrich</span> the best one - clojure</p>",
        "id": 153876598,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489499568
    },
    {
        "content": "<p>Sadly, the <code>&gt;</code> is an invalid character in a <code>token</code> as per the Accept Header syntax.  But, I dont think that's needed. A client will (should) ignore any extraneous stuff, sp the version string here is about identifying (too broadly, I know) what the client desires.  So if stuff is only ever added in later versions, then <code>=&gt;1.4.0</code> is semantically equivalent to <code>=1.4.0</code>  When it isn't, then you have breakage, and <code>=&gt;1.4.0</code>wouldn't suit the client anyway</p>",
        "id": 153876600,
        "sender_full_name": "Michael Lawley",
        "timestamp": 1489499655
    },
    {
        "content": "<p>I converted  all versions metadata (structure def, search params etc) into internal unified format - so, i think, to implement multi-version server will not be big challenge (may be only some corner cases).</p>",
        "id": 153876601,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489499711
    },
    {
        "content": "<p>Looks like this is possible - convert versions on fly - i will report results.</p>",
        "id": 153876602,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489499798
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191343\">@Michael Lawley</span> good point</p>",
        "id": 153876604,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1489499865
    },
    {
        "content": "<p>I am also thinking that the CapabilityStatement should allow for (1..*) fhirVersion elements...</p>",
        "id": 153876605,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489499865
    },
    {
        "content": "<p>but that might cause some problems with older clients in particular.</p>",
        "id": 153876606,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489499938
    },
    {
        "content": "<p>I suppose we could add a new attribute 'standardVersion' that would be allow multiple versions to be reported.</p>",
        "id": 153876607,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489500022
    },
    {
        "content": "<p>For those FHIR Developers/Implementers testing with Touchstone - they are able to see and test either client or server against various FHIR published versions.  This will afford the community an opportunity to see how backwards / future proofing a solution is.  As we test FHIR 1.8.0 vs 1.9.0 we can see how much the spec has changed.  I agree with the multiple end points supporting a capability statement based query by a client to server - prior to any information exchange occuring.  I think the client should performance some due dilengence on the server.  Not sure how the server will do the same of the client :(  Interesting to see some IG and FHIR approaches on one hand reference DSTU 2 and call for resources from STU3 (not sure how that is going to work out).</p>",
        "id": 153876615,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1489503543
    },
    {
        "content": "<p>several comments:<br>\n - so it would be good to have a task for documenting a version parameter on the accept header<br>\n- versioning will work exactly as Nicola would like once we go normative, and that's planned for the next release for the core (not sure what that is yet)<br>\n- already, a client can do everything by introspection, rather than by versioning. It's just hard work<br>\n- our intent has always been that there will be no need to do version negotiation</p>",
        "id": 153876680,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1489519288
    },
    {
        "content": "<p>Ok, I get some of this:<br>\n- \"our intent\" ... no need to do version negotiation - based on what we have seen, even with updated Provider Directory capabilities and published end-points which include version specific details.  Both FHIR Client and Server (including FHIR Services) may want to take an additional step as a percaution.  Whether introspecting a header, or interrogating a capability statement. Or am I to read your comment as you are stating we should warn folks off from this approach?</p>",
        "id": 153876791,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1489544049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191460\">@Mario Hyland</span> There's a difference between the behavior we have right now in STU where there's no backward compatibility requirement and we can (and do) make breaking changes between versions and what we'll eventually have when things are locked down.  But once we're at normative, systems shouldn't care about version - they just check whether the elements they care about are present and ignore what they don't expect.  (And are safe when doing so.)</p>",
        "id": 153876795,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1489545484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> How do you envision the 'introspection' approach working?  Say if I want to know if a server can handle a minimum set of resources and attributes in order to know if it is capable of handling a particular integration, how would I figure that out?  The resources I can get from the CapabilityStatement, but if there was an attribute that is present on a 1.8.0 server that is not on 1.4.0, how would I figure that out?</p>",
        "id": 153876941,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489584954
    },
    {
        "content": "<p>Supporting a given version doesn't mean you'll support all of the core elements from that version.  If your question is \"will the server support the following 5 attributes?\", the only way to know is to retrieve the CapabilityStatement and trace through to the StructureDefinition profiles for each resource and see what elements the server supports.</p>",
        "id": 153876948,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1489589220
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> Yeah, I see that now.  Thanks.</p>",
        "id": 153876952,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1489589589
    },
    {
        "content": "<p>FHIR Web Site Version page - <a href=\"http://hl7.org/fhir/directory.html\" target=\"_blank\" title=\"http://hl7.org/fhir/directory.html\">http://hl7.org/fhir/directory.html</a> - FHIR Version 3 Official should also be <strong>BOLD</strong> - similar to DSTU 2 and DSTU 1</p>",
        "id": 153879246,
        "sender_full_name": "Mario Hyland",
        "timestamp": 1490217224
    },
    {
        "content": "<p>ok. will be updated soon (back of a queue of 500k files being uploaded)</p>",
        "id": 153879251,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1490218025
    },
    {
        "content": "<p>After the discussion in Madrid, I wrote an article on this topic: <a href=\"https://www.linkedin.com/pulse/fhir-nuts-bolts-versioning-chris-grenz\" target=\"_blank\" title=\"https://www.linkedin.com/pulse/fhir-nuts-bolts-versioning-chris-grenz\">https://www.linkedin.com/pulse/fhir-nuts-bolts-versioning-chris-grenz</a></p>",
        "id": 153890330,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1495060972
    },
    {
        "content": "<p>Or at least a closely related topic! </p>",
        "id": 153890331,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1495061003
    }
]