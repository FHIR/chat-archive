[
    {
        "content": "<p>Do we really need to use <code>:iterate</code> modifier for chained includes? It just introduces confusion between chaining and the recursive case. From the implementer's point of view, this is two completely different algorithms - chained and recursive one.</p>",
        "id": 181916077,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574771319
    },
    {
        "content": "<p>What to do if iterate missed ? For example: <code>MedicationDispense?_include=MedicationDispense:prescription&amp;_include=MedicationRequest:performer</code> should we ignore include or show error message?</p>",
        "id": 181916213,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574771428
    },
    {
        "content": "<p>How to distinguish between a recursive case and just self-reference without hierarchy?</p>",
        "id": 181916299,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574771497
    },
    {
        "content": "<p>I would suggest using something like <code>:recursive</code> instead of ':iterate' or use ':iterate' only for recursive case (not chained).</p>",
        "id": 181916389,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574771565
    },
    {
        "content": "<p>Isn’t this too late to change?</p>",
        "id": 181928674,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574780230
    },
    {
        "content": "<p>Did anybody implement this without any problems? <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span>  <span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> ?</p>",
        "id": 181928979,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574780378
    },
    {
        "content": "<p>We missed this correction and just added in aidbox alias for  iterate=recursive :(</p>",
        "id": 181929180,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574780456
    },
    {
        "content": "<p>I do tend to agree the way this works is a bit confusing..</p>\n<p>I know HAPI's current behaviour for <span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> 's example query above wouldn't actually return any performer, since there is no <code>:iterate</code> on the second include so it doesn't apply to subsequent rounds of include loading. You can work around this by specifying <code>_include:iterate=MedicationRequest:performer</code>, which is easy to do but I find it counter-intuitive since you're not really iterating on that include at all. You're just asking for it to be applied to the results of the first include. Re-reading the spec, I think it's safe to say that this is the way it's supposed to work at least.</p>\n<p>TBH I'm not sure how this could be improved though. Adding other modifiers seems like it's just layering more confusing stuff on (not to mention the fact that the http page is normative). We could add text perhaps that specifies that <code>_include</code> on a resource type other than the one being searched for will apply to any resources returned by the first round of include loading? I feel like that would be a nightmare to describe, but it would certainly make the example above a bit more intuitive.</p>",
        "id": 181930982,
        "sender_full_name": "James Agnew",
        "timestamp": 1574781502
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> did you implement recursive version of iterate?</p>",
        "id": 181936615,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574784482
    },
    {
        "content": "<p>how do you distinguish is it recursive or not?</p>",
        "id": 181938101,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574785366
    },
    {
        "content": "<p>or user has to write :iterate for each iteration?</p>",
        "id": 181938151,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574785423
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span>  i'm not sure i understand your question. We did implement it, and i am, well, reeeeeasonably sure it's implemented to spec.</p>\n<p>You have to add <code>:iterate</code> (or <code>:recurse</code> - we also just treat them as synonyms) to each include parameter. I.e. any include without iterate is only applied to the actual search results, and any include with iterate is applied to search results but also to new results pulled in by previous includes. Is that what you mean?</p>",
        "id": 181939121,
        "sender_full_name": "James Agnew",
        "timestamp": 1574786074
    },
    {
        "content": "<p>i mean Initial idea of recursive was for request like Organization?_include:recursive=Organization:part-of make as much iterations as needed to get all chlidren and children of children,.... Did you implement this logic? Or hapi makes only one iteration for part-of?</p>",
        "id": 181950689,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574793678
    },
    {
        "content": "<p>This recursive iterations logic is expensive and makes great diff with just chained includes. So for performance reason it is important to distinguish this two.</p>",
        "id": 181951023,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574793887
    },
    {
        "content": "<p>right, important to differentiate, which is why we added iterate. The server doesn't have to keep iterating for ever</p>",
        "id": 181952721,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1574794892
    },
    {
        "content": "<p>do you mean query should be like this: ?_inc:iterate=partof&amp;_inc:iterate=partof to get grandparents?</p>",
        "id": 181965877,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574803660
    },
    {
        "content": "<p>i always assumed that <code>Organization?_include:iterate=Organization:part-of</code> iterates into all children and children of children.<br>\ni understood the iterate here <code>MedicationDispense?_include=MedicationDispense:prescription&amp;_include:iterate=MedicationRequest:performer</code> as a for-each</p>",
        "id": 182009553,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1574853559
    },
    {
        "content": "<blockquote>\n<p>Did anybody implement this without any problems? <span class=\"user-mention silent\" data-user-id=\"191319\">James Agnew</span>  <span class=\"user-mention silent\" data-user-id=\"191757\">Christiaan Knaap</span> ?</p>\n</blockquote>\n<p>We haven't implemented :iterate yet. And apparently nobody has missed it either.</p>",
        "id": 182012462,
        "sender_full_name": "Christiaan Knaap",
        "timestamp": 1574856462
    },
    {
        "content": "<p>We have some clients, who use it :(</p>\n<p>Just to demonstrate a real cases :</p>\n<div class=\"codehilite\"><pre><span></span>GET /RequestGroup\n    ?_id=reqgroup1\n    &amp;_include=patient,author\n    &amp;_include:iterate=RequestGroup:target:MedicationRequest\n    &amp;_include:iterate=MedicationRequest:medication\n    &amp;_include:iterate=MedicationRequest:requester:PractitionerRole\n    &amp;_include:iterate=MedicationRequest:intended-performer:Organization\n    &amp;_include:iterate=PractitionerRole:practitioner\n    &amp;_include:iterate=Patient:organization\n    &amp;_include:iterate=PractitionerRole:location\n    &amp;_revinclude:iterate=AllergyIntolerance:patient\n</pre></div>\n\n\n<p>:)</p>",
        "id": 182013407,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574857427
    },
    {
        "content": "<p>I drafted a tiny proposal for _(rev)include alternative - <code>_with</code> parameter - <a href=\"https://gist.github.com/niquola/48d106a88dbf93eb17783c0d5c5beb36\" target=\"_blank\" title=\"https://gist.github.com/niquola/48d106a88dbf93eb17783c0d5c5beb36\">https://gist.github.com/niquola/48d106a88dbf93eb17783c0d5c5beb36</a> :)</p>",
        "id": 182020330,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574862735
    },
    {
        "content": "<blockquote>\n<p>i mean Initial idea of recursive was for request like Organization?_include:recursive=Organization:part-of make as much iterations as needed to get all chlidren and children of children,.... Did you implement this logic? Or hapi makes only one iteration for part-of?</p>\n</blockquote>\n<p>hapi doesn't stop after one Iteration (which i think is the right approach):<br>\n<a href=\"https://fhir.molit.eu/r4/Observation?_id=559&amp;_include:iterate=Observation:has-member\" target=\"_blank\" title=\"https://fhir.molit.eu/r4/Observation?_id=559&amp;_include:iterate=Observation:has-member\">https://fhir.molit.eu/r4/Observation?_id=559&amp;_include:iterate=Observation:has-member</a></p>",
        "id": 182023356,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1574864823
    },
    {
        "content": "<p>Try nested case: Patient?_id=???&amp;_revinclude=Observation:subject&amp;_include:iterate=Observation:has-member</p>",
        "id": 182024294,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574865367
    },
    {
        "content": "<p>works and gets parent, child, grandchild:<br>\n<a href=\"https://fhir.molit.eu/r4/Patient?_id=564&amp;_revinclude=Observation:subject&amp;_include:iterate=Observation:has-member\" target=\"_blank\" title=\"https://fhir.molit.eu/r4/Patient?_id=564&amp;_revinclude=Observation:subject&amp;_include:iterate=Observation:has-member\">https://fhir.molit.eu/r4/Patient?_id=564&amp;_revinclude=Observation:subject&amp;_include:iterate=Observation:has-member</a></p>",
        "id": 182027178,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1574867129
    },
    {
        "content": "<p>Cool! Now how to interpret the following request:</p>\n<p><a href=\"https://fhir.molit.eu/r4/Patient?_id=564&amp;_revinclude=Observation:subject&amp;_include:iterate=Observation:derived-from\" target=\"_blank\" title=\"https://fhir.molit.eu/r4/Patient?_id=564&amp;_revinclude=Observation:subject&amp;_include:iterate=Observation:derived-from\">https://fhir.molit.eu/r4/Patient?_id=564&amp;_revinclude=Observation:subject&amp;_include:iterate=Observation:derived-from</a></p>\n<p>is it recursive or not?</p>",
        "id": 182032980,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1574871116
    },
    {
        "content": "<p>i changed the second include to the correct revinclude, works.....:</p>\n<p><a href=\"https://fhir.molit.eu/r4/Patient?_id=603&amp;_revinclude=Observation:subject&amp;_revinclude:iterate=Observation:derived-from\" target=\"_blank\" title=\"https://fhir.molit.eu/r4/Patient?_id=603&amp;_revinclude=Observation:subject&amp;_revinclude:iterate=Observation:derived-from\">https://fhir.molit.eu/r4/Patient?_id=603&amp;_revinclude=Observation:subject&amp;_revinclude:iterate=Observation:derived-from</a></p>",
        "id": 182099995,
        "sender_full_name": "Patrick Werner",
        "timestamp": 1574939381
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  Are we ok with this ambiguity of iterate? I would suggest to get back :recursvie for recursive cases.</p>",
        "id": 182158313,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575015223
    },
    {
        "content": "<blockquote>\n<p>i changed the second include to the correct revinclude, works.....:</p>\n<p><a href=\"https://fhir.molit.eu/r4/Patient?_id=603&amp;_revinclude=Observation:subject&amp;_revinclude:iterate=Observation:derived-from\" target=\"_blank\" title=\"https://fhir.molit.eu/r4/Patient?_id=603&amp;_revinclude=Observation:subject&amp;_revinclude:iterate=Observation:derived-from\">https://fhir.molit.eu/r4/Patient?_id=603&amp;_revinclude=Observation:subject&amp;_revinclude:iterate=Observation:derived-from</a></p>\n</blockquote>\n<p>the problem is that it can be both recursive and not! And now it is impossible to say this implicitly :(</p>",
        "id": 182158413,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575015322
    },
    {
        "content": "<p>I haven't followed where this is ambiguous?</p>",
        "id": 182172139,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575029068
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>    here is the simplest explanation!</p>\n<p>How can I include only the first layer of parents <code>Observation:derived-from</code> (i.e. with no recursion) for this example - <code>Patient?_id=603&amp;_revinclude=Observation:subject&amp;_revinclude:iterate=Observation:derived-from</code> ?</p>\n<p>Problem with mixed things - is to unmix them :)</p>",
        "id": 182186510,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575041936
    },
    {
        "content": "<p>you can't. It's all or nothing. In the spec</p>",
        "id": 182194123,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575049359
    },
    {
        "content": "<p>isn't it unaesthetic   - with  :recursive user will be able to do this and implementation will be simpler ;)</p>",
        "id": 182235376,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575113004
    },
    {
        "content": "<p>umm? :recurse and :iterate are synonyms?</p>",
        "id": 182249161,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575137164
    },
    {
        "content": "<p>Or do not use :iterate for chained includes (it's redundantly)</p>",
        "id": 182325089,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575276459
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  should I stop? or create an issue?</p>",
        "id": 182364466,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575305386
    },
    {
        "content": "<p>I'm still not sure that I follow the issue. If you want to be able to specify a 'only -once' or a count of iterations to do, I follow that. Otherwise, I'm not sure what the issue is - the committee renamed :recurse to :iterate, and that seems to have caused confusion?</p>",
        "id": 182368640,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575307794
    },
    {
        "content": "<p>Committee has extended meaning of :iterate to chained incudes - i.e. mixed up two different things ;(</p>",
        "id": 182496777,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575407825
    },
    {
        "content": "<p>I'm still not seeing the different things</p>",
        "id": 182511875,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1575417951
    },
    {
        "content": "<p>With chained include you just do one \"iteration\", for recursive you do as many as possible  - isn't it serious difference?</p>",
        "id": 182525556,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575435272
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> what do you think? Is it a problem or not?</p>",
        "id": 182525817,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575435718
    },
    {
        "content": "<p>I see the distinction but it only makes a difference in cases of type X referring to type X - for most references there is no recursion possible. It looks like we are only discussing the case where the client wants to follow exactly one level of Observation:derived-from or Patient:link or similar, and is not happy if the server continues into more than one level. But the server already has the discretion to decide how deep to follow the recursion, so does the client really have that level of control? If you could limit to no more than 1 level, why not also limit to no more than 2 levels?</p>",
        "id": 182561334,
        "sender_full_name": "Paul Church",
        "timestamp": 1575470662
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> there are many references, which can refer to the same resource type and/or other - for example, <a href=\"https://www.hl7.org/fhir/observation-definitions.html#Observation.hasMember\" target=\"_blank\" title=\"https://www.hl7.org/fhir/observation-definitions.html#Observation.hasMember\">https://www.hl7.org/fhir/observation-definitions.html#Observation.hasMember</a> - should for example Observation?_include=has-member be recursive for self-references or not?</p>",
        "id": 182574552,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575478367
    },
    {
        "content": "<p>Ability to explicitly specify a limit for recursion is a good idea (we are thinking to introduce it as an extension)</p>",
        "id": 182574755,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575478498
    },
    {
        "content": "<p>The use case seems exotic - so an extension would probably be a good idea should someone need it. A lot of things in the query syntax don't meet the \"80%\" criterium anyway (ok, that doesn't officially apply to query parameters, but it might as well), so I'd rather see stuff removed (as if that's likely to happen..) than added.</p>",
        "id": 182634960,
        "sender_full_name": "René Spronk",
        "timestamp": 1575531602
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191372\">@René Spronk</span>  just to show you \"real-world\" query:</p>\n<div class=\"codehilite\"><pre><span></span>/RequestGroup?\n  _include=target&amp;\n  _include=patient:Patient\n    _include=Patient:organization,\n    _revinclude:iterate=AllergyIntolerance:patient:Patient&amp;\n    _revinclude=Condition:subject:Patient&amp;\n  _include=author:PractitionerRole&amp;\n    _include=PractitionerRole:practitioner:Pracitioner&amp;\n    _include=PractitionerRole:location&amp;\n    _revinclude=Contract:subject:PractitionerRole&amp;\n  _include=RequestGroup:target:MedicationRequest&amp;\n      _include=MedicationRequest:medication&amp;\n      _include=MedicationRequest:requester:PractitionerRole&amp;\n      _include=MedicationRequest:intended-performer:Organization&amp;\n      _include=MedicationRequest:intended-performer:Organization\n</pre></div>",
        "id": 182639603,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575536195
    },
    {
        "content": "<p>That's fine - but having to distinguish between 1 or 2 or unlimited depth in an iterative _include ? That sounds exotic to me.</p>",
        "id": 182640129,
        "sender_full_name": "René Spronk",
        "timestamp": 1575536627
    },
    {
        "content": "<p>That's mostly for performance reason - handling such huge includes efficiently is a challenge.</p>",
        "id": 182640201,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575536675
    },
    {
        "content": "<p>Looks like nobody interested in this inconsistency right now - ok let's wait for more implementers and users will report this problem :)</p>",
        "id": 182944293,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575888764
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194833\">@Patrik Sundberg</span> have you implemented <code>(rev)include:iterate</code> in google health API?</p>",
        "id": 182953874,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1575897440
    },
    {
        "content": "<p>The Google API supports :iterate but limited to a max depth of 2 at the moment. Our interpretation is that all iterates are recursive for self-references. We have performance and pagination concerns about increasing the max depth. I think for your complex include example we would prefer to implement GraphDefinition operations or GraphQL rather than try to make that query performant in the form of a search.</p>",
        "id": 183169133,
        "sender_full_name": "Paul Church",
        "timestamp": 1576078857
    },
    {
        "content": "<p>Related question about _include - if a Patient?_include=Patient:organization search result contains two Patients that both refer to the same Organization, does that Organization resource appear once or twice in the searchset bundle? If once, how does this interact with pagination?</p>",
        "id": 183170136,
        "sender_full_name": "Paul Church",
        "timestamp": 1576079444
    },
    {
        "content": "<p>Bumping this question - how do other implementers handle resources from _include that could appear more than once in the results? Do they appear multiple times? Once per page? Only once overall?</p>",
        "id": 183281462,
        "sender_full_name": "Paul Church",
        "timestamp": 1576171675
    },
    {
        "content": "<p>Once in each page where it is referenced or referencing - the process is compute the page of results, look for all include related to the resources in the page and add them to the page,</p>",
        "id": 183284024,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1576173521
    },
    {
        "content": "<p>We decided to iterprer :iterate as recursive only if source and target specified and equal. As well we support old :recurse for explicit recursion.  To be honest,  you don't need :iterate modifier for chained includes - in aidbox they are optional. <a href=\"https://docs.aidbox.app/basic-concepts/search-1/_include-and-_revinclude\" target=\"_blank\" title=\"https://docs.aidbox.app/basic-concepts/search-1/_include-and-_revinclude\">https://docs.aidbox.app/basic-concepts/search-1/_include-and-_revinclude</a></p>",
        "id": 183334631,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1576222057
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> if we make recursion explicit,  i do not see performance complications to limit depth of includes: each include is just one query.</p>",
        "id": 183334739,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1576222193
    },
    {
        "content": "<p>@grahame i worry how this breaking change was introduced  without real feedback from major implementers. Can we organize kinda subscriptions/notifications for fhir server implementers about such changes?</p>",
        "id": 183335057,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1576222548
    },
    {
        "content": "<p>just little bit (technically open) open and formal process  right after such changes  is appear and before bulk balloting? Something like email with google form and short description  for those who don't participate in wg meetings, but still interested and affected in/by such changes</p>",
        "id": 183335336,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1576222921
    },
    {
        "content": "<p>well, we had several rounds of balloting and calls for comments. The process couldn't be more open than it is</p>",
        "id": 183341617,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1576229510
    },
    {
        "content": "<p>it's true, though, that I don't find anything in Zulip about this</p>",
        "id": 183341671,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1576229527
    },
    {
        "content": "<p>no, I did: <a href=\"#narrow/stream/179166-implementers/topic/_include\" title=\"#narrow/stream/179166-implementers/topic/_include\">https://chat.fhir.org/#narrow/stream/179166-implementers/topic/_include</a></p>",
        "id": 183341810,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1576229653
    }
]