[
    {
        "content": "<p>Is there a standard way to version FHIR REST interfaces?  (e.g. <a href=\"https://host/{FHIR-VERSION}/{API-VERSION}/Patient/1\" target=\"_blank\" title=\"https://host/{FHIR-VERSION}/{API-VERSION}/Patient/1\">https://host/{FHIR-VERSION}/{API-VERSION}/Patient/1</a> )</p>",
        "id": 153910550,
        "sender_full_name": "Jonny Rylands",
        "timestamp": 1506372986
    },
    {
        "content": "<p>Not at present.  And our intention, once things are normative, is for version not to matter anymore.</p>",
        "id": 153910583,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1506395482
    },
    {
        "content": "<p>will still have business versions...</p>",
        "id": 153910602,
        "sender_full_name": "David Hay",
        "timestamp": 1506406259
    },
    {
        "content": "<blockquote>\n<p>Not at present.  And our intention, once things are normative, is for version not to matter anymore.</p>\n</blockquote>\n<p>That being said, DSTU2, and increasingly STU3 and R4 will be around for a <em>long</em> time - and it's kind of a FAQ.  Out of interest: As a client - what would you do if there was a \"standard\" way of finding the endpoint for a specific version - would you envision being able to use multiple versions.....I can see that would get likelier with each version of the spec, and resources becoming more mature...</p>",
        "id": 153910616,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1506419188
    },
    {
        "content": "<p>No in the most part I wouldn't envisage a client using multiple API versions (or negotiating versions).</p>\n<p>The purpose of the API versioning is two fold - to prevent against breaking backwards compatibility, and to be able to technically and clinically assure a clients implementation of a particular version of an API.  The assurance breaks if the interface evolves over time, hence our need for versioned interfaces. (- or never to change our interface! :-))</p>\n<p>Note by API version I'm referring to the version of the interface, rather than the FHIR version, though the two are obviously interconnected.</p>\n<p>Also to mention that the clients are not in our direct control, and therefore we cannot simultaneously update client &amp; interface/implementation at the same time.</p>",
        "id": 153910654,
        "sender_full_name": "Jonny Rylands",
        "timestamp": 1506431054
    },
    {
        "content": "<p>I really want to hold to the no versioning, as Lloyd has expressed. BUT when we get to R4, we are going to be faced with no alternative. This because in R4 we will not be taking ALL resources to Normative, some will be STU. Those STU resources might take a few additional revisions before they become normative. Thus in R4 we must support a normative Bundle holding normative resources, and non-normative resources. Those non-normative resources might be generation 4 or 5 or 6 or their final normative... Thus I hate to say it, but we need some solution eventually.</p>",
        "id": 153910655,
        "sender_full_name": "John Moehrke",
        "timestamp": 1506431485
    },
    {
        "content": "<p>One aspect that I am getting out of this is the endpoint url remaining the same, yet the API version going up.  Some clients (at least the .NET and Java ones) let you verify this by getting the CapabilityStatement and checking the version - but that's kind of chicken and egg, using a specific version of the CapabilityStatement (which was renamed as well in STU3!) to check the version.  Following something like you sketched out as a best practice is a good thing - and I see it being done that way.</p>\n<p>At the San Diego WGM we found examples of both out in the wild:</p>\n<ul>\n<li>\n<p>Facebook does put the version in the url: <code>https://www.facebook.com/v2.10/dialog/oauth?\n  client_id={app-id}\n  &amp;redirect_uri={redirect-uri}</code> (see <a href=\"https://developers.facebook.com/docs/apps/versions/\" target=\"_blank\" title=\"https://developers.facebook.com/docs/apps/versions/\">https://developers.facebook.com/docs/apps/versions/</a> for their policies)</p>\n</li>\n<li>\n<p>GitHub uses a media type: application/vnd.github.VERSION.raw+json (<a href=\"https://developer.github.com/v3/media/\" target=\"_blank\" title=\"https://developer.github.com/v3/media/\">https://developer.github.com/v3/media/</a>)</p>\n</li>\n</ul>\n<p>The latter situation allows for content negotiation involving versions. An interesting concept that we might want to try out at the next connectathon in New Orleans in january.</p>",
        "id": 153910676,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1506433603
    },
    {
        "content": "<p>We are operating under the assumption that we will need to support multiple FHIR version simultaneously for quite some time.  The approach we are taking towards that is to pass the version in the Accept header by setting the mime type to something like 'application/fhir+json; fhirVersion=3.0.1' and then switching versions on the server.</p>",
        "id": 153911036,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1506527128
    },
    {
        "content": "<p>We are offering multiple endpoints by version rather than doing anything like headers.</p>",
        "id": 153911047,
        "sender_full_name": "Matthew Spielman",
        "timestamp": 1506538602
    },
    {
        "content": "<p>The AcceptHeader approach isn't standard and isn't likely to be recognized by most servers</p>",
        "id": 153911113,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1506552983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193229\">@Kevin Olbrich</span> <span class=\"user-mention\" data-user-id=\"191921\">@Matthew Spielman</span>  - that's interesting you each represent one of the options I mentioned - I'd be interested in why you have chosen one over the other...</p>",
        "id": 153911181,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1506584136
    },
    {
        "content": "<p>The mime-type one is automatic since we have changed mime-type between DSTU2 and STU3...</p>",
        "id": 153911225,
        "sender_full_name": "John Moehrke",
        "timestamp": 1506603369
    },
    {
        "content": "<p>Neither of these address my concern about mixtures. specifically that at R4 we will have mixtures from that point forward.</p>",
        "id": 153911227,
        "sender_full_name": "John Moehrke",
        "timestamp": 1506603412
    },
    {
        "content": "<p>Not sure what you mean by \"mixtures\" John.  In a given instance, all resources must be from a single version.  If you're sending an R5 instance, all content will be from R5.  It's just that the normative content will also be compatible with R4.</p>",
        "id": 153911246,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1506609670
    },
    {
        "content": "<p>Okay, so your perspective is that once a Resource goes normative it is not \"R4\", it is \"Normative\". Thus all Normative are infinitely compatible. Somehow I knew that, and agree with it.. but it did get lost in the versioning discussion. Especially since we are projecting \"R4\" as something that 'contains normative' content... thus there is marketing that seems to indicate normative resources do have a \"Revision\" number...</p>",
        "id": 153911253,
        "sender_full_name": "John Moehrke",
        "timestamp": 1506610698
    },
    {
        "content": "<p>A normative resource in R5 could even have an extra data element or two than it had in R4.  It's just that the backward compatibility rules would allow you to ignore those elements if you're processing them as R4 instances.</p>",
        "id": 153911254,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1506610801
    },
    {
        "content": "<p>Wouldn't having only some resources normative mean the FHIR API endpoint as a whole is not normative?  (in that it's important for the client to know the server's FHIR API version)</p>",
        "id": 153911255,
        "sender_full_name": "Joel Schneider",
        "timestamp": 1506610981
    },
    {
        "content": "<p>Would CapabilityStatement.resource be a reasonable place to indicate something about the normative vs. non-normative status of a resource implementation?</p>",
        "id": 153911256,
        "sender_full_name": "Joel Schneider",
        "timestamp": 1506611687
    },
    {
        "content": "<p>Some notes here: <a href=\"https://www.hl7.org/fhir/versions.html\" target=\"_blank\" title=\"https://www.hl7.org/fhir/versions.html\">https://www.hl7.org/fhir/versions.html</a></p>",
        "id": 153911283,
        "sender_full_name": "David Hay",
        "timestamp": 1506621726
    },
    {
        "content": "<p>CapabilityStatement lets you indicate the version of FHIR you support - which in turn tells you which resources are Normative and should have the normative compatibility rules applied.</p>",
        "id": 153911373,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1506625601
    },
    {
        "content": "<p>I think that it would make sense to indicate this in the CapabilityStatement.resource - curious if there are any who would disagree.</p>",
        "id": 153911382,
        "sender_full_name": "Aaron Seib",
        "timestamp": 1506625891
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> We took the accept header approach because we need to be able to integrate with multiple partners with dissimilar FHIR versions and maintaining a separate url endpoint (and possibly servers) struck us as a maintenance nightmare.  We also liked the accept header approach because it makes more semantic sense to us for the URL of the resource to define where to find the information and the details of the serialization format and fhir version are about how to transmit that data.  Internallly we handle all our objects as domain models and serialize/deserialize them to/from the requested FHIR version as necessary, and we have built some code generation tools that can abstract away a lot of the implementation details.   This article is an interesting read on the subject... <a href=\"https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/\" target=\"_blank\" title=\"https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/\">https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/</a>.  Another benefit of this approach is that a client can upgrade their version at any time and so long as they request a FHIR version our server supports they can just use the existing url they may have stored and they can expect to get the resource back without having to munge their data.</p>",
        "id": 153911397,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1506629066
    },
    {
        "content": "<p>For those interested:  <a href=\"https://www.linkedin.com/pulse/fhir-nuts-bolts-versioning-chris-grenz/\" target=\"_blank\" title=\"https://www.linkedin.com/pulse/fhir-nuts-bolts-versioning-chris-grenz/\">https://www.linkedin.com/pulse/fhir-nuts-bolts-versioning-chris-grenz/</a></p>",
        "id": 153911398,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1506629307
    },
    {
        "content": "<p>I'm also very interested in the topic of versioning the API for backwards compatibility within a single FHIR version.    </p>\n<p>Maybe the terminology is:</p>\n<ul>\n<li>fhir-spec-version (e.g. 1.0.2)</li>\n<li>fhir-patch-version (i.e. what set of patches you have for Epic's implementation of 1.0.2)</li>\n<li>fhir-resource-version (the vread/vid in the RESTful API.  I just list list this for completeness - this is well understood I think)</li>\n</ul>\n<p>My specific concern how to not break all of the connected clients we have when we roll out a bug fix (for example, when we fix a bug in our implementation of FHIR 1.0.2).  I had also thought about using an HTTP header so the client could tell us what fhir-patch-version they want (i.e. what set of bug fixes they want us to apply when we render the resource we send back to them).</p>\n<p>I'm sure Epic is the only FHIR server implementation that will have any bugs though, so maybe it's not applicable to the general community :).</p>\n<p>Our problem is that operationally, if our server has a bug, often the clients that connect to us will implement a workaround.  If that client is connecting to our FHIR server at two different sites, they would have that workaround applied to both sites.  When we roll out a bug fix, one site may get it before the other side, so the client would need to remove the workaround for just the one site, but not the other.  This seems ok for 2 sites, but once we are at 300+ sites it won't be realistic for clients to migrate away from the workaround one site at a time.</p>\n<p>Add to this that a client may be connecting to Cerner and Epic servers, having a common way to specify the patch-level they want would be cool.</p>",
        "id": 153911399,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1506630387
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191764\">@Cooper Thompson</span> couldn't the CapabilityStatement.software.version be used to determine if a workaround should be used with a specific server?</p>",
        "id": 153911405,
        "sender_full_name": "Kevin Olbrich",
        "timestamp": 1506630770
    },
    {
        "content": "<p>We're using the FHIR version within the server root path, e.g. <a href=\"https://fhir.example.org/fhir/0.5/Patient\" target=\"_blank\" title=\"https://fhir.example.org/fhir/0.5/Patient\">https://fhir.example.org/fhir/0.5/Patient</a> or <a href=\"https://fhir.example.org/fhir/1.0/Patient\" target=\"_blank\" title=\"https://fhir.example.org/fhir/1.0/Patient\">https://fhir.example.org/fhir/1.0/Patient</a>. Not all our resources support both versions so our clients are either using the 0.5 or 1.0 collection of resources (eventually 2.0). Conveniently this means it's straightforward (well sort of) to get the Conformance statement for the supported resources for each version.</p>\n<p>Discretely versioning each resource is surely tricky because there are references returned to other resource locations in many parts of the data model, which are supposed to be relative to the server root of the FHIR server.</p>\n<p>We haven't had too many problems with breaking backwards compatibility since so much of FHIR is optional anyway and extensions use \"name/value\" semantics. So, clients need to know how to deal with content that isn't there. Most of the issues we've had so far with changes is making sure that clients understand the quirks of standard FHIR responses, e.g. OperationOutcome resources can be mixed in with the expected resource type requested (so you have to check the resource type before trying to parse it), or that the Bundle won't have an empty array it will just not be there if the total is 0.</p>\n<p>Having said all this, we use Accept header versioning for all our other non-FHIR APIs.</p>",
        "id": 153911414,
        "sender_full_name": "David Teirney",
        "timestamp": 1506632686
    },
    {
        "content": "<blockquote>\n<p>CapabilityStatement lets you indicate the version of FHIR you support - which in turn tells you which resources are Normative and should have the normative compatibility rules applied.</p>\n</blockquote>\n<p>It's encouraging to understand that CapabilityStatement.fhirVersion will enable safe client/server interactions using normative resources.</p>\n<p>Presumably the FHIR implementation offered by any stable/production FHIR endpoint (base url) should never change in a way that breaks backward compatibility, because doing that could be dangerous, and would be very unfriendly to existing clients.</p>",
        "id": 153911420,
        "sender_full_name": "Joel Schneider",
        "timestamp": 1506636104
    },
    {
        "content": "<p>Yeah, versioning definitely needs to be handled at the API level, not the resource level.  <span class=\"user-mention\" data-user-id=\"194138\">@Aaron Seib</span> Are you arguing for including the normative status in the CapabilityStatement?  That wouldn't make a whole lot of sense because the CapabilityStatements don't get to decide whether something is normative or not - that's HL7's call.  All the CapabilityStatement can do is declare what version of FHIR overall is supported by that endpoint.</p>",
        "id": 153911433,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1506652086
    },
    {
        "content": "<p>I disagree that versioning \"definitely needs to be handled at the API level, not the resource level.\"  The API must be versioned at the API level, but a stream of resources could be a mix of versions.  In many systems, the stream <em>will</em> be a mix.  Any <em>one</em> resource must be a single version (although I could envision a Bundle with a mix in some limited use cases).</p>",
        "id": 153911475,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1506691227
    },
    {
        "content": "<p>Systems (e.g. integration engines) that include mappings between versions could be perfectly happy with a mix of post-normative versions.</p>",
        "id": 153911476,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1506691320
    },
    {
        "content": "<p>Each instance must be a single version - and the references in those instances need to resolve to the same version if they're resolvable.  If you do funky things with headers, you can send different types of instances to the same URL, but you're essentially establishing distinct \"virtual\" endpoints via your headers.</p>",
        "id": 153911484,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1506697936
    },
    {
        "content": "<p>Agree with the caveat that I think it would be OK for an R5 Observation (normative) to reference an R4 Patient (normative).  If we distinguish between normative versions in these situations, interop is very much hindered.</p>",
        "id": 153911493,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1506700740
    },
    {
        "content": "<p>In an instance, an R5 Observation would need to reference an R5-compliant patient.  It's just easy to do that if patient is normative.</p>",
        "id": 153911516,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1506711678
    },
    {
        "content": "<p>We have a server that has been in a pilot for over a year, and need to carry forward AuditEvent and other data across FHIR versions. We cannot (must not) migrate the old records. We can easily write code that can deal with multiple FHIR versions, but to do that we need an efficient way to determine what version a resource is. We're currently using a meta.tag for that, that gets parsed out and stored in the AuditEvent table for easy access to choose what FHIR version parser to use.</p>",
        "id": 153911524,
        "sender_full_name": "Jonathan Shultlis",
        "timestamp": 1506728617
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> We took the accept header approach  (...)   This article is an interesting read on the subject... <a href=\"https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/\" target=\"_blank\" title=\"https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/\">https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/</a>. </p>\n</blockquote>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"193229\">@Kevin Olbrich</span>, interesting read....</p>",
        "id": 153911808,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1506957894
    },
    {
        "content": "<p>\"Support all three wrong ways\" ;-)    Makes me think of our current Accept/_format couple...</p>",
        "id": 153911809,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1506958274
    },
    {
        "content": "<p>so we talked about this in San Deigo, and agreed that in new Orleans we'll do a connctathon stream around using application/fhir.[version] to evaluate how that goes. In the meantime, anyone can version their APIs by putting the version in the URL itself - that will work whatever. But it does confuse identity and reference. </p>\n<p>As for merging version in a stream (or a bundle!) ... it's sort of logical, but there's some unresolvable pitfalls around moving content between resources between versions, etc. So I think that for the next version, and in regard to previous versions, we'll just put our hands over our ears and pretend we don't have to think about that. But that won't fly in the R4/R5 land</p>",
        "id": 153911959,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1506997713
    },
    {
        "content": "<blockquote>\n<p>Is there a standard way to version FHIR REST interfaces?  (e.g. <a href=\"https://host/{FHIR-VERSION}/{API-VERSION}/Patient/1\" target=\"_blank\" title=\"https://host/{FHIR-VERSION}/{API-VERSION}/Patient/1\">https://host/{FHIR-VERSION}/{API-VERSION}/Patient/1</a> )</p>\n</blockquote>\n<p>The Touchstone project recommendation is to use the <code>fhirVersion</code> in the URL path base. <br>\n We've been doing the following in our Node apps:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nx\">JsonRoutes</span><span class=\"p\">.</span><span class=\"nx\">add</span><span class=\"p\">(</span><span class=\"s2\">&quot;put&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;/&quot;</span> <span class=\"o\">+</span> <span class=\"nx\">fhirVersion</span> <span class=\"o\">+</span> <span class=\"s2\">&quot;/Patient/:id&quot;</span><span class=\"p\">,</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">req</span><span class=\"p\">,</span> <span class=\"nx\">res</span><span class=\"p\">,</span> <span class=\"nx\">next</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"p\">...</span> <span class=\"p\">}</span>\n</pre></div>\n\n\n<p>Where <code>fhirVersion</code> is one of the following versions:<br>\n<a href=\"https://www.hl7.org/fhir/directory.html\" target=\"_blank\" title=\"https://www.hl7.org/fhir/directory.html\">https://www.hl7.org/fhir/directory.html</a></p>\n<p>We've been getting quite successful interoperability with the Touchstone conformance tests doing so.</p>\n<p>ps.  The 'versionless' ideal that people have seems to suggest a slight misunderstanding of the DICOM standard (which is not versionless, contrary to popular talking points).</p>",
        "id": 153913397,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1507674301
    },
    {
        "content": "<p>if the version isn't specified in the URL, how do I figure out what version of an external Reference I am meant to request from the external server? I understand that this confuses identify and reference but how would I go about separating those concepts in the scenario?</p>",
        "id": 153914810,
        "sender_full_name": "Adrian Lanzafame",
        "timestamp": 1508397613
    },
    {
        "content": "<p>The CapabilityStatement for the server endpoint will declare what version it supports</p>",
        "id": 153914848,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1508419833
    },
    {
        "content": "<p>I am getting around to specifying the X-version API track for the new Orleans connectathon.</p>",
        "id": 153915255,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508712665
    },
    {
        "content": "<p>It seems to me that given where we are, there needs to be a single simple call that a client can make of a server: \"what versions do you support\"</p>",
        "id": 153915256,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508712691
    },
    {
        "content": "<p>retrieving a full conformance statement has proven slow in practice, and then we renamed it - both of those were annoying but manageable. But if the first question you have for a server is now 'what versions can you be?' then we need some new API.</p>",
        "id": 153915257,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508712773
    },
    {
        "content": "<p>Connectation Proposal: <a href=\"http://wiki.hl7.org/index.php?title=201801_Versioned_API\" target=\"_blank\" title=\"http://wiki.hl7.org/index.php?title=201801_Versioned_API\">http://wiki.hl7.org/index.php?title=201801_Versioned_API</a></p>\n<p>comments welcome - I'm not sure how far to push scenario #4. In a few days my server will start supporting scenario#1</p>",
        "id": 153915266,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508724866
    },
    {
        "content": "<p>with regard to the connectathon details:</p>",
        "id": 153915267,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508724877
    },
    {
        "content": "<p>in San Diego we (ITS and FHIR-I) agreed that we would use application/fhir.r3+xml|json to differentiate between FHIR versions on a version-independent interface</p>",
        "id": 153915268,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508724931
    },
    {
        "content": "<p>but when I presented this to the Australian connectathon last week, there was a strong preference for a parameter: application/fhir+xml|json; fhir-version=r3</p>",
        "id": 153915269,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508724965
    },
    {
        "content": "<p>then, when I implemented, I discovered that there was a variety of mime types across my implementation that needed the same treatment (e.g., at a minimum, for turtle and nd-json). And the only way to do it consistently was with a mime type parameter</p>",
        "id": 153915270,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508725053
    },
    {
        "content": "<p>hence I have proposed that instead</p>",
        "id": 153915271,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508725060
    },
    {
        "content": "<p>I see at mix of #2 and #3 from <a href=\"https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/\" target=\"_blank\" title=\"https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/\">https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/</a> #2 in the proposal.</p>",
        "id": 153915292,
        "sender_full_name": "Jens Villadsen",
        "timestamp": 1508741347
    },
    {
        "content": "<p>yes. that's right. a mix</p>",
        "id": 153915293,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1508741373
    },
    {
        "content": "<p>I'm just wondering whether even calling $version makes too much assumptions, by using FHIR to ask something about FHIR.  Would OPTIONS work as well (without breaking CORS this time)</p>",
        "id": 153916787,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1509380966
    },
    {
        "content": "<p>how would that work?</p>",
        "id": 153916807,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1509391465
    },
    {
        "content": "<p>Thought about returning an OPTIONS with an Accept header including the accepted formats  + versions</p>",
        "id": 153916832,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1509395110
    },
    {
        "content": "<p>I can't find anyone else using it like this?</p>",
        "id": 153916833,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1509395246
    },
    {
        "content": "<p>Indeed. To quote a random Google search I did about this: \"As RESTful Web Services puts it, “OPTIONS is a promising idea that nobody uses.”\"</p>",
        "id": 153916834,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1509395373
    },
    {
        "content": "<p>except CORS.... which makes it difficult for anyone other use, in my view</p>",
        "id": 153916835,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1509395394
    },
    {
        "content": "<p>the simplified json representation was intended to jump us around the versioning issues</p>",
        "id": 153916866,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1509412178
    }
]