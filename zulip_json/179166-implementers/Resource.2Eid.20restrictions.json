[
    {
        "content": "<p>Hello everyone!</p>\n<p>During discussions in the FHIR work group of HL7 Austria a problem was made aware concerning the handling of resource IDs, which affects multiple vendors:<br>\nSome vendors are currently trying to implement a FHIR interface connected to a backend systems e.g. an IHE XDS affinity domain. In the FHIR standard an ID of a Resource is restricted to 64 characters, including alpha numerics,-,. . While this works great for database IDs it is not really suitable for scenarios in which a data storage for FHIR resources does not exist and the only thing available as IDs are the identifiers (e.g. patient ID, document ID) consisting of an assigning authority and a value as it is quite often used in IHE profiles (PIX, XDS,...). Please note that although this problem did occur first during the implementation of IHE Profiles with FHIR it is not limited to it.  <br>\nThis requires the implementation of such a FHIR interface to build a mapping table by reassigning new IDs and storing them in a separate data pool. This makes the whole implementation hard to maintain, complicated and not scalable. Is it possible to remove or extend the length restriction?</p>\n<p>Thanks<br>\n<span class=\"user-mention\" data-user-id=\"192145\">@Patrick Mangesius</span> , <span class=\"user-mention\" data-user-id=\"192159\">@jb</span> - fyi</p>",
        "id": 153977558,
        "sender_full_name": "Reinhard Egelkraut",
        "timestamp": 1532436308
    },
    {
        "content": "<p>we're pretty keen not to extend the id beyond 64 characters. I would've though 64 characters was plenty long enough for hashing schemes etc</p>",
        "id": 153977561,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532436582
    },
    {
        "content": "<p>thanks, grahame! what exactly do you mean when you mention hashing schemes? e.g. in our case, a patient id may consist of an oid (theoretically unlimited in length) as assigner, some sort of separator and an uuid value (limited to 36characters). this could very easily extend beyond 64 characters.</p>",
        "id": 153977573,
        "sender_full_name": "jb",
        "timestamp": 1532437671
    },
    {
        "content": "<p>so you can hash all that to a long hash with exceedingly low clash rates.( on par with UUIDs). Or you can hash the OID part to a standard 10 character hash... or you can have a maintenance table that assigns OIDs a key....</p>",
        "id": 153977574,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532437986
    },
    {
        "content": "<p>no need to impose &gt;64 chars on everyone....</p>",
        "id": 153977575,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532437999
    },
    {
        "content": "<p>They need to be able to take an ID, and figure out what that means in their backend. This is not something that a hash can help with. A hash is a oneway translation, they need the other direction.</p>",
        "id": 153977579,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532438289
    },
    {
        "content": "<p>well, you can add a key to the table that is a hash. Or one of the other solutions....</p>",
        "id": 153977580,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532438427
    },
    {
        "content": "<p>Thanks, John. That's exactly the problem. Other than that, I'm not quite sure why a longer id would \"impose\" something. Can't imagine how this would lead to a larger implementation effort for anyone.</p>",
        "id": 153977581,
        "sender_full_name": "jb",
        "timestamp": 1532438448
    },
    {
        "content": "<p>Well, maintaining a tables sounds easy, but imposes scalability problems which have to be solved (e.g. think about clustering)</p>",
        "id": 153977582,
        "sender_full_name": "jb",
        "timestamp": 1532438475
    },
    {
        "content": "<p>if we say that ids can be longer than 64 characters, many servers will have to make bigger fields and indexes. I don't see why that's necessary</p>",
        "id": 153977583,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532438526
    },
    {
        "content": "<p>if you have a table, you can have a key</p>",
        "id": 153977584,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532438536
    },
    {
        "content": "<p>as indicated, this is not unique to the IHE MHD profiles.. but we can use them as an example of the problem. The _id would thus need to contain: homeCommunityID + RepositoryID + DocumentUUID. I am sure Imaging has other examples. Likely other use-cases too.  A table is the solution they are forced to maintain, and it becomes fragile and full of useless information. Yes one could have expiration of table entries, and I did warn IHE readers (consumer actors) that they should not expect any DocumentReference to be persistent beyond a reasonable amount of time.   --- So, is there some increase in size that seems justifiable but still reasonable?</p>",
        "id": 153977586,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532438665
    },
    {
        "content": "<p>not really, because people will keep coming across ever longer composite keys that are monstrous UUID things</p>",
        "id": 153977588,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532438823
    },
    {
        "content": "<p>if the document has a UUID, than a UUID is enough, no?</p>",
        "id": 153977589,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532438834
    },
    {
        "content": "<p>well, in xds you will need at least to know the repository id...</p>",
        "id": 153977590,
        "sender_full_name": "jb",
        "timestamp": 1532438861
    },
    {
        "content": "<p>I try to be sympathatic where I can, but 64 chars is a lot, backed by a ISO std, and changing it is a long piece of string for everyone to deal with - ids are indexed values</p>",
        "id": 153977591,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532438906
    },
    {
        "content": "<p>It is enough to do a lookup in a local table. It is actually enough to do an XDS GetDocuments... just looking for a solution that does not involve an intermediate lookup.</p>",
        "id": 153977592,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532438950
    },
    {
        "content": "<p>and why do you need to know the repository id?</p>",
        "id": 153977593,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532438951
    },
    {
        "content": "<p>realistically, they are trying to stuff more than minimally necessary into it...</p>",
        "id": 153977594,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532439049
    },
    {
        "content": "<p>limits like this will cause them to think harder... I don't mind that....  Just supporting the question needing to be asked.</p>",
        "id": 153977595,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532439111
    },
    {
        "content": "<p>because in MHD we're trying to map to xds operations</p>",
        "id": 153977596,
        "sender_full_name": "jb",
        "timestamp": 1532439183
    },
    {
        "content": "<p>We approached iti-68 as a iti 43</p>",
        "id": 153977597,
        "sender_full_name": "jb",
        "timestamp": 1532439208
    },
    {
        "content": "<p><a href=\"https://www.ihe.net/uploadedFiles/Documents/ITI/IHE_ITI_TF_Vol2b.pdf\" target=\"_blank\" title=\"https://www.ihe.net/uploadedFiles/Documents/ITI/IHE_ITI_TF_Vol2b.pdf\">https://www.ihe.net/uploadedFiles/Documents/ITI/IHE_ITI_TF_Vol2b.pdf</a> - &gt;3.43.4.1.2</p>",
        "id": 153977598,
        "sender_full_name": "jb",
        "timestamp": 1532439223
    },
    {
        "content": "<p>\"A required repositoryUniqueId that identifies the repository from which the document is<br>\n4560 to be retrieved. This value corresponds to XDSDocumentEntry.repositoryUniqueId.\"</p>",
        "id": 153977599,
        "sender_full_name": "jb",
        "timestamp": 1532439236
    },
    {
        "content": "<p>there where also discussions on the connectathon about that. The only viable solution was to retrieve the document via an additional registry roundtrip.</p>",
        "id": 153977601,
        "sender_full_name": "jb",
        "timestamp": 1532439294
    },
    {
        "content": "<p>it works, but I don't think it's great.</p>",
        "id": 153977602,
        "sender_full_name": "jb",
        "timestamp": 1532439317
    },
    {
        "content": "<p>but the XDS Api doesn't front for any repository at all, right? only known repositories, and you don't add repositories on the fly?</p>",
        "id": 153977603,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532439351
    },
    {
        "content": "<p>you only need to know the RepositoryID for the retrieve of the document. That is done with the DocumentReference.content.attachment.url. A datatype url does not have this limit, a URL is much bigger.</p>",
        "id": 153977604,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532439366
    },
    {
        "content": "<p>the problem is the <a href=\"http://DocumentReference.id\" target=\"_blank\" title=\"http://DocumentReference.id\">DocumentReference.id</a> would need to include just the entryUUID in XDS; and the homeCommunityID+entryUUID in a XCA...</p>",
        "id": 153977605,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532439432
    },
    {
        "content": "<p>I wonder if they are thinking <a href=\"http://Binary.id\" target=\"_blank\" title=\"http://Binary.id\">Binary.id</a>...</p>",
        "id": 153977606,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532439556
    },
    {
        "content": "<p>it was exactly the problem that on the connectathon, they required to be the attachment be a reference to a binary</p>",
        "id": 153977607,
        "sender_full_name": "jb",
        "timestamp": 1532439587
    },
    {
        "content": "<p>currently searching a wiki page....</p>",
        "id": 153977608,
        "sender_full_name": "jb",
        "timestamp": 1532439651
    },
    {
        "content": "<p>i think the problem was addressed here:</p>",
        "id": 153977609,
        "sender_full_name": "jb",
        "timestamp": 1532439670
    },
    {
        "content": "<p><a href=\"https://github.com/usnistgov/iheos-toolkit2/wiki/MHD-Testing-at-2018-North-American-Connectathon#light-weight-multiple-repository-support\" target=\"_blank\" title=\"https://github.com/usnistgov/iheos-toolkit2/wiki/MHD-Testing-at-2018-North-American-Connectathon#light-weight-multiple-repository-support\">https://github.com/usnistgov/iheos-toolkit2/wiki/MHD-Testing-at-2018-North-American-Connectathon#light-weight-multiple-repository-support</a></p>",
        "id": 153977610,
        "sender_full_name": "jb",
        "timestamp": 1532439671
    },
    {
        "content": "<p>yes, in MHD on Create (Provide transaction) the DocumentReference.content.attachment.url is a Binary...</p>",
        "id": 153977611,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532439684
    },
    {
        "content": "<p>For documentreference  id can be sha-1 from canonical content, like in git  :)</p>",
        "id": 153977612,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1532439742
    },
    {
        "content": "<p>that github text does not help me understand the problem. A DocumentReference itself is not Repository specific, it is Registry specific. So there is no logic that the <a href=\"http://DocumentReference.id\" target=\"_blank\" title=\"http://DocumentReference.id\">DocumentReference.id</a> needs to hold the repository identifier.  The only place the repository identifier is needed is in the DocumentReference.content.attachment.url... and that is not constrained to 64 characters.</p>",
        "id": 153977613,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532440094
    },
    {
        "content": "<p>The text is from bill majurski. It's talking about the fact that they required the DocumentReference.content.attachment.url to point to some form of <a href=\"http://Binary.id\" target=\"_blank\" title=\"http://Binary.id\">Binary.id</a>. Wich was a mistake obviously, if I'm interpreting the resolution correctly: <a href=\"https://github.com/usnistgov/iheos-toolkit2/wiki/MHD-Testing-at-2018-North-American-Connectathon#iti-resolution-2\" target=\"_blank\" title=\"https://github.com/usnistgov/iheos-toolkit2/wiki/MHD-Testing-at-2018-North-American-Connectathon#iti-resolution-2\">https://github.com/usnistgov/iheos-toolkit2/wiki/MHD-Testing-at-2018-North-American-Connectathon#iti-resolution-2</a></p>",
        "id": 153977614,
        "sender_full_name": "jb",
        "timestamp": 1532440406
    },
    {
        "content": "<p>in the mhd specification, it is very clear: 3.67.4.2.2.2.1 Document location: \" IHE does not specify the format of the URL\"</p>",
        "id": 153977615,
        "sender_full_name": "jb",
        "timestamp": 1532440817
    },
    {
        "content": "<p>so, Bill is an authoritative person in IHE, regarding XDS, but not FHIR. He has statements on that github that there was some kind of ITI decision. These are NOT true, there have been no discussion in ITI. This article is pointed to in a Change Proposal he submitted (CP-ITI-1113), this CP is limited to questions around the response returned to a Document Source on the Provide Document Bundle transaction.  Specifically, this ties back to my statements above regarding the DocumentReference.content.attachment.url need only conform to a URL datatype.  Where he recommends only: <br>\n MHD profile documentation needs review and possibly make this lack of format restriction more obvious to the reader<br>\nwhich I clearly would agree with... but this is NOT an issue with FHIR id limits</p>",
        "id": 153977616,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532440857
    },
    {
        "content": "<p>so, back to the FHIR discussion.... generally it still seems that there might be times when it might be useful to be able to stuff more than one backend id into a FHIR API Resource id... Like we discussed above with homeCommunityID+entryUUID. <br>\nI am however hearing Grahame push back on that, with references to basis from ISO for the 64 character limit.</p>",
        "id": 153977617,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532441012
    },
    {
        "content": "<p>ok. i understand that. so as far as I see it, the only options are:  1) hash the values and accept possible collisions (albeit the chance of this happening is very small, for patient id's, you absolutely don't want that to happen) or 2) deal with some sort of persistence.</p>",
        "id": 153977618,
        "sender_full_name": "jb",
        "timestamp": 1532441075
    },
    {
        "content": "<p>?</p>",
        "id": 153977619,
        "sender_full_name": "jb",
        "timestamp": 1532441090
    },
    {
        "content": "<p>yes some sort of persistence</p>",
        "id": 153977620,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1532441103
    },
    {
        "content": "<p>Introducing a persistence is often not a very practical way - especially for small Services that are just mapping between the different datapools that could be build in a lightweight way. They are simply acting as proxies. Requiring them to introduce a persistence brings avoidable complexity and the chance of errors. You have to think about synchronization, how to handle clustered environments etc.</p>",
        "id": 153977624,
        "sender_full_name": "Patrick Mangesius",
        "timestamp": 1532441671
    },
    {
        "content": "<p>Can't you query the DocumentReference by identifier instead of using the id?</p>",
        "id": 153977668,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1532448836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span>  Currently we actually have a bigger problem with patients. It would maybe be a workaround to do a query by identifier. However at least connectathon testing requires to do at least one read operation for every pdqm search. </p>\n<p>Also it's actually pretty convenient for clients. Image doing a \"Search\" with the _summary or _elements parameter set and getting a very small response, and then only \"Read\" the resource fully you really need in a second step. Without having to parse a bundle again, exactly knowing which type of resource you will get and being absolutely sure you will get a single result (e.g. for typical master-&gt;detail flows).</p>",
        "id": 153977693,
        "sender_full_name": "jb",
        "timestamp": 1532461421
    },
    {
        "content": "<p>@jb I don't follow your use-case flow there. The search bundle with _summary will be a bag of Patient resources, that are just missing elements that might have values. So you know by this bundle the URL you can do  GET on, and you know that they are Patient resources... so I don't understand what is missing.</p>",
        "id": 153977732,
        "sender_full_name": "John Moehrke",
        "timestamp": 1532466242
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> \"that are just missing elements....\" Which is perfect if youwant to save bandwidth.... Using _elements even works better in this regard because the client can choose. E.g. showing a list of patient with only name and gender -&gt; on click show patient details along with address etc. It was just an example. It's convenient to retrieve the full resource by id then, that's all. But that's probably not what this topic should be about, it was simply a response to <span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span>  why we don't just use the identifier param for another  query. To make it simple for the client.</p>",
        "id": 153977841,
        "sender_full_name": "jb",
        "timestamp": 1532502595
    },
    {
        "content": "<p>So, to make a little summary of this discussion:</p>\n<p>For architectures in which FHIR is used just as API, not with a full FHIR server and which have a light weight design with no DB connection (communication servers or proxies in a DMZ; integration components with just a in-memory DB which are clustered or have multiple instances behind a load balancer), there are scenarios for which the vendors have to find a way to create resource.ids  out of existing data, which is most of the time not even in their hands (old data structures of the legacy system, a connected IHE Affinity Domain, ...).</p>\n<p>Some of the use cases, where the logical Id of a resource could therefore be potentially larger than 64 characters, are for example:</p>\n<ul>\n<li>IHE - MHD with multiple repositories, referencing patients in DocumentReference/Manifest via patient Ids (and the use of OIDs to make them unique)</li>\n<li>FHIR API for legacy systems for which a combination of identifiers/attributes will be used to create a unique logical Id</li>\n</ul>\n<p>The discussed potential solutions for this problem in this chat are:<br>\n1. remove or extend the restriction on <a href=\"http://resource.id\" target=\"_blank\" title=\"http://resource.id\">resource.id</a> for 64 characters</p>\n<ul>\n<li>would still be possible till R4 is released (after that it will get very hard I assume)</li>\n<li>requires some existing systems to adapt adequately their DB structures where the logical id is stored (not all of them actually have this restriction in place on their storage) as well as the according indexes</li>\n<li>some validations on existing FHIR servers might also need an adaption </li>\n</ul>\n<p>2. basically force every system, which is providing FHIR APIs for these use cases, to create some kind of extra persistence or some other kind of workaround to map logical IDs of the resources to identifying attributes of the data, which could get interesting (though not impossible) for architectures</p>\n<ul>\n<li>where the components are located in a DMZ, so customers don't want to have an additional DB because of the licence costs and access to the DB behind the DMZ is prohibited </li>\n<li>where the components are located in a clustered environment or behind a load balancer, so there has to be a way to synchronise the <a href=\"http://resource.id\" target=\"_blank\" title=\"http://resource.id\">resource.id</a> mappings between the different instances </li>\n</ul>\n<p>Both solutions would solve the above mentioned problematic use cases, but at least in my opinion the latter creates much more extra effort for implementers than the first one.</p>\n<p>However, currently it seems during this discussion that the second option is the recommended one, correct?</p>",
        "id": 153981801,
        "sender_full_name": "Reinhard Egelkraut",
        "timestamp": 1533303503
    },
    {
        "content": "<p>so, we have a limit today.. you are saying there are good use-cases where that limit presents problems... There is also good reason to have some kind of a limit. Moving to infinite length would not work in other ways. Doubling would just move the problem as eventually you will have this problem with two 64 character ids needing to be combined into a 128+... so I don't see an obvious step beyond the limit we have today...   What is your solution?</p>",
        "id": 153981803,
        "sender_full_name": "John Moehrke",
        "timestamp": 1533304701
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> ,</p>\n<p>sorry for the late response but we had holiday season in Austria and it therefore took a while to gather the input after people came back.</p>\n<p>I understand that there is no easy solution for these scenarios that will solve 100% of the problems, hence we looked for guidance in this chat. <br>\nAlso, I've heard that there is another discussion ongoing, about adding other information to the URL for versioning purposes which could potentially lead to even shorten the allowed length of 64 characters for a logical id, is that correct?<br>\nSo there are opposing requirements, which doesn't make things easier.</p>\n<p>But nevertheless here are two suggestions which could solve our problems with the length restriction and we would be interested to get your opinions on it:</p>\n<ul>\n<li>use string as data type for the logical id instead of id<ul>\n<li>id is according to the FHIR data type model a sub set of string, so for FHIR servers with existing storage there wouldn't be much to change</li>\n<li>string itself has also a length limit (1024 characters in R4) so infinity is not an issue here</li>\n<li>FHIR servers could keep their own length restriction of 64 characters, since they are responsible of creating and maintaining the logical ids</li>\n<li>if just a FHIR API is in place, longer logical ids are possible now if it would be necessary </li>\n</ul>\n</li>\n<li>would it be possible to use/allow for the logical id a similar mechanism as for token?<ul>\n<li>the logical id itself would be similar to [code] (which is also a sub set of string), it could even keep the length restriction of 64 characters</li>\n<li>but it would be possible to add information in a defined way like [code]|[system] where e.g. system could be an OID to an id</li>\n<li>exact searches are possible</li>\n</ul>\n</li>\n</ul>\n<p>Are these valid suggestions or are there other technical aspects which would speak against them, that we missed?</p>",
        "id": 153997352,
        "sender_full_name": "Reinhard Egelkraut",
        "timestamp": 1537189939
    },
    {
        "content": "<p>The format of the id must meet the following rules: it must be unique for a particular resource type on a particular servers; and it must be a valid 'key' for all of the database technologies we know of.  The current constraints on length and allowed characters are driven by the second.  I'm not sure what sort of solution we can come up with that doesn't involve hashing to get within the 64 characters and maintaining some sort of conversion table between the HL7 id and the logical id</p>",
        "id": 153997374,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1537196038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191890\">@Reinhard Egelkraut</span> there is a discussion about limiting the effective length of the id in one very specific context, but it is not relevant to your use case. String has a length limit of 1MB, not 1K. There's no reason to have id if we don't use it for <a href=\"http://Resource.id\" target=\"_blank\" title=\"http://Resource.id\">Resource.id</a>. </p>\n<p>It's true that servers can control their ids - in some cases. But it's also true that truncating Ids is not possible. Fixing the length limit of FHIR ids guarantees that truncation won't be an issue in the eco-system. I do not think that the community would find it of value to change this. (and, in fact, process wise, it would be possible to change if it the current infrastructure ballot fails)</p>\n<p>as for your last suggestion: you're actually describing how the identifier element works. I can't imagine how that would work on <a href=\"http://Resource.id\" target=\"_blank\" title=\"http://Resource.id\">Resource.id</a>.</p>",
        "id": 153997881,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1537319175
    },
    {
        "content": "<p>If I was implementing this, I'd use a lookup table, but the only thing that would have in it would be the persistent short identifiers for assigning authorities. e.g. </p>\n<p>id 1.{uuid}</p>\n<p>where '1' is a key in the table of assigning authorities. maintaning this short list should not be a challenge - at least, I don't see why it is. And I don't see, from anything in this discussion (I just read it all again) why that wouldn't work. I can see that's less convenient than to simply have astonishingly long ids, but not why it's something that's impossible to maintain (even in a cluster / facade farm)</p>",
        "id": 153997882,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1537319621
    },
    {
        "content": "<p>I have to import some patient resources in a test environment and the patientid is not numeric. It is being inserted into database and I can retrieve it by doing a search like this \"hapi-fhir-jpaserver4/search?serverId=home&amp;pretty=true&amp;resource=Patient&amp;param.0.qualifier=&amp;param.0.0=&amp;param.0.1=<strong>PATIENTID</strong>&amp;param.0.name=_id&amp;param.0.type=token&amp;sort_by=&amp;sort_direction=&amp;resource-search-limit=</p>\n<p>When I create another resource and do a reference with this patient then searching this resource doesn't return anything when searching by Patient/<strong>PATIENTID</strong> in subject of the new resource.</p>\n<p>Any idea?</p>",
        "id": 153998585,
        "sender_full_name": "Kostas Karkaletsis",
        "timestamp": 1537450273
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> ?</p>",
        "id": 153998636,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1537455314
    },
    {
        "content": "<p>I'm sorry, I don't really understand the flow you're describing. Do you mean you create a resource, but it's not showing up in a search for it shortly afterwards?</p>\n<p>If that's it, you'd probably being affected by HAPI FHIR's query cache. You can disable the query cache for an individual request by using the <code>Cache-Control</code> header as shown here: <a href=\"https://smilecdr.com/docs/current/fhir_repository/performance_and_caching.html\" target=\"_blank\" title=\"https://smilecdr.com/docs/current/fhir_repository/performance_and_caching.html\">https://smilecdr.com/docs/current/fhir_repository/performance_and_caching.html</a></p>\n<p>You can even disable it entirely (or shorten its duration) using settings on the DaoConfig</p>",
        "id": 153998648,
        "sender_full_name": "James Agnew",
        "timestamp": 1537455944
    }
]