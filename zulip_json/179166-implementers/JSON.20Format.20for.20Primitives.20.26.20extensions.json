[
    {
        "content": "<p>Are we sure we want to see this in real systems - <a href=\"https://gist.github.com/niquola/6c826639a7f0061a9e3274c3f7272cae#file-ups-yaml-L74\" target=\"_blank\" title=\"https://gist.github.com/niquola/6c826639a7f0061a9e3274c3f7272cae#file-ups-yaml-L74\">https://gist.github.com/niquola/6c826639a7f0061a9e3274c3f7272cae#file-ups-yaml-L74</a> ?</p>",
        "id": 153965303,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527626817
    },
    {
        "content": "<p>If this is really required and FHIR primitives is not primitives - let's encode it in terrible xmlish style  <code>code: \"string\"</code> =&gt; <code>code: {value: \"string\"}</code></p>",
        "id": 153965307,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527627204
    },
    {
        "content": "<p>I'm pretty sure, that non-fhir developers community will be really confused by such corner cases.</p>",
        "id": 153965313,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527627686
    },
    {
        "content": "<p>yes. we had a big long argument about this in the past. What you propose is exactly what we still had and what I wish we still had. But we decided that it was a better balance to make the simple cases very simple and the corner cases very hard</p>",
        "id": 153965320,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527627932
    },
    {
        "content": "<p>but it's too late to change this now</p>",
        "id": 153965321,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527627944
    },
    {
        "content": "<p>Let's create second json serialization format - this is not breaking change!</p>",
        "id": 153965324,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527627998
    },
    {
        "content": "<p>It could be optional - pretty sure most of users will switch on it eventually</p>",
        "id": 153965326,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527628079
    },
    {
        "content": "<p>I can work on it :) .</p>",
        "id": 153965327,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527628113
    },
    {
        "content": "<p>I'm pretty sure that's a bad idea. I don't think people will be interested. But we could have a straw poll - indicate by choosing <span class=\"emoji emoji-1f44d\" title=\"thumbs up\">:thumbs_up:</span> or <span class=\"emoji emoji-1f44e\" title=\"thumbs down\">:thumbs_down:</span> as a response to the message above</p>",
        "id": 153965338,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527628496
    },
    {
        "content": "<p>Competing versions of the same syntax - especially at this point in the standard life cycle - would not be doing implementers any favors.  Most implementers will be using one of the reference implementations, meaning they don't care.  The only thing new to the argument here is JSON schema and that was in its infancy at the time the decision was made.  I don't think there's anything about the syntax that says it can't work.  It just makes certain edge-case usecases harder.</p>",
        "id": 153965357,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527629302
    },
    {
        "content": "<p>Hiding complexity in reference implementation  lib does not eliminate it :(</p>",
        "id": 153965369,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527629537
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> I'm not sure what you're basing the idea that most implementors will be using a reference implementation on. My team certainly isn't, and we will be affected by these edge cases. Furthermore, it seems to me that the protocol itself should be usable without having to rely on third party libraries. If the design is such that the wire format itself is not directly usable that's a fundamental failure of the FHIR specification.</p>",
        "id": 153965372,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1527629626
    },
    {
        "content": "<p>no it's not necessary. We argued about this a lot back when we made this decision. Json schema wasn't a factor then, but I generate json schema ok for this now - I don't think it's that complex.</p>",
        "id": 153965388,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527630608
    },
    {
        "content": "<p>I don't like the decision we made, but it seems way to late to change it. and it does make the simple cases much simpler. we rarely encounter extensions on primitives. <em>except for translation</em> but we've never got into gear about a good json representation of translations</p>",
        "id": 153965389,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527630729
    },
    {
        "content": "<p>The fact that JSON is a second class citizen in FHIR is incredibly problematic in my opinion. This is the most commonly used data format today, and many platforms support it natively. Currently, FHIR wire format is pretty much unusable without complex and fragile libraries. I think that focusing on XML as the primary representation is really misguided.</p>",
        "id": 153965405,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1527631388
    },
    {
        "content": "<p>the <em>only</em> respect in which JSON is a second class citizen is that we prefer XML for the base examples since JSON doesn't have comments. In every other respect, JSON is an equal ctiizen</p>",
        "id": 153965406,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527631493
    },
    {
        "content": "<p>The way the data is structured in FHIR is not how idiomatic JSON is structured. For example, many instances where you have collections of maps appear to be a artifact of directly translating XML nodes into JSON. Meanwhile, idiomatic JSON would favor use of maps as the top level element keyed on the id of each node. Another example is that collections are named with singular names, where idiomatic JSON would use plural to indicate that they are collections.</p>\n<p>From what I see, JSON representation is basically just XML format dumped into JSON. Having JSON as a first class citizen would mean structuring data in JSON idiomatic fashion, and FHIR does not do that.</p>\n<p>In practical terms it means that you have to go through a complex, error prone, and expensive parsing step before you're able to work with the data effectively.</p>",
        "id": 153965413,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1527631885
    },
    {
        "content": "<p>we talked about pluralising the names - that's something we decided not to do. I don't know how significant that is</p>",
        "id": 153965416,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527632758
    },
    {
        "content": "<p>the issue of maps - that's come up before. That's got nothing to do with xml vs json, and everything to do with complexities in the data. We try for as simple as possible, but sometimes it's just not possible</p>",
        "id": 153965418,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527632799
    },
    {
        "content": "<p>I suspect this will remain a hot topic for years to come. :)  Maybe a compromise here is what Grahame referred to in the past as a \"database representation\". In the proto representation we already unroll some of these extensions into named tuples, based on the profiles of various resources in use, which makes the db setup and queries easier. I don't think such a representation has to be tied to json at all, and i'm not sure if it has any place being sent over the wire directly, but i do think there is value in talking through what it would look like.</p>",
        "id": 153965420,
        "sender_full_name": "Patrik Sundberg",
        "timestamp": 1527633068
    },
    {
        "content": "<p>I end up taking the data that comes over the wire and then transforming it into a usable form. The question is not of data complexity, but of the use cases the format is optimized for. I also get the impression that nobody on the core team works with JSON data directly, and therefore the problems are not apparent because nobody is dog fooding the protocol.</p>\n<p>The decisions appear to often be based on assumptions, such as the case with <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> suggesting that people are predominantly using 3rd party libraries. I see very little evidence that there's any effort to validate such assumptions based on the broader community usage. This results in many key decisions being made by a small closed group, and then when people find them problematic they're told that it's too late to change anything.</p>",
        "id": 153965422,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1527633489
    },
    {
        "content": "<p>\"Too late to change\" comes from where we are in the standards process.  If we change the syntax now, it has a huge impact on implementers - of which there are now thousands.  It also means we can't go normative this cycle, which impacts even more.  The decisions weren't made by a small closed group - the nature of the JSON protocol were made with a great deal of open discussion.  The final shape of the syntax was landed on in a room with 40+ people in it and lots of active discussion - and that was after lots of beating on it in connectathon.  It's certainly possible (likely) that for certain uses, the syntax is not ideal.  The same would be true of the XML and RDF syntaxes.  The focus of the syntax is not persistance or internal data operations, it's just exchange.   If those other uses had been primary considerations, it's entirely possible that any of the syntaxes would look different than they do now.</p>",
        "id": 153965437,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527650951
    },
    {
        "content": "<p>The assertion of \"it's too late\" also isn't a veto.  You can vote.  If there are enough people who agree, then the change will be made.  I think that the number of people invested in the current syntax make that an unlikely outcome, but you're absolutely welcome to make the effort.  Grahame's statement should not be taken as a \"you can't\", but rather \"based on where the community is at, it's probably not a good use of your time\".</p>",
        "id": 153965438,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527651085
    },
    {
        "content": "<p>Correct. There are things in the XML syntax that I don't like either - and I am pretty sure the designers of HTTP or actually any piece of spec or software would love to roll back some of their decisions. At some point however, the cost of change is larger than the benefit - as software engineers I am sure we all recognize this.  Personally I think we've past that point quite some time ago.</p>",
        "id": 153965460,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1527665425
    },
    {
        "content": "<p>\"I also get the impression that nobody on the core team works with JSON data directly\" - very much not the case.</p>",
        "id": 153965462,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527667559
    },
    {
        "content": "<p>btw, restructuring the data for easy consumption for a particular use case is pretty common. I've run into quite a few people using graphql for that... I'm trying to encourage them to standardise on the work documented at <a href=\"http://build.fhir.org/graphql.html\" target=\"_blank\" title=\"http://build.fhir.org/graphql.html\">build.fhir.org/graphql.html</a></p>",
        "id": 153965463,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527667616
    },
    {
        "content": "<p>We can start experiment with new json format - if it will fail  - that's ok, but if we will get real interest ... As a second format, this will be non-breaking addition, which can be abandoned at any time :)</p>",
        "id": 153965482,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527671460
    },
    {
        "content": "<p>well, ok. how's it going to be different? going to the direct representation of primitives, and extensions, ok. what else?</p>",
        "id": 153965484,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527671634
    },
    {
        "content": "<ul>\n<li>polymorphic elements</li>\n</ul>",
        "id": 153965485,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527671666
    },
    {
        "content": "<p>oh? so how are you proposing to do that?</p>",
        "id": 153965486,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527671744
    },
    {
        "content": "<p>Something as discussed here <a href=\"https://github.com/fhir-fuel/fhir-fuel.github.io/issues/2\" target=\"_blank\" title=\"https://github.com/fhir-fuel/fhir-fuel.github.io/issues/2\">https://github.com/fhir-fuel/fhir-fuel.github.io/issues/2</a></p>",
        "id": 153965487,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527671797
    },
    {
        "content": "<p>It should be similar to what you have in ref.lib. - i.e. Observation.value.string</p>",
        "id": 153965488,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527671831
    },
    {
        "content": "<p>As well as local references as {id: \"...\", resourceType: \"Resource\"}</p>",
        "id": 153965489,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527671869
    },
    {
        "content": "<p>i don't know what you mean about the reflib.</p>",
        "id": 153965490,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527671917
    },
    {
        "content": "<p>Java/ C#</p>",
        "id": 153965491,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527671932
    },
    {
        "content": "<p>I assumed that was what you mean but I don't know how that's relevant. And that page has 2 solutions.</p>",
        "id": 153965493,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527671981
    },
    {
        "content": "<p>local references?</p>",
        "id": 153965494,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527671988
    },
    {
        "content": "<p>Local means on the same server/db - <a href=\"https://github.com/fhir-fuel/fhir-fuel.github.io/issues/4\" target=\"_blank\" title=\"https://github.com/fhir-fuel/fhir-fuel.github.io/issues/4\">https://github.com/fhir-fuel/fhir-fuel.github.io/issues/4</a></p>",
        "id": 153965495,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527672030
    },
    {
        "content": "<p>Hi Nicolai, the json example for solution 2 is exactly the same as the first - I cannot quite grasp what solution 2 is!</p>",
        "id": 153965500,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1527677516
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> do you mean union/polymorphic representation? this is open for discussion on GitHub</p>",
        "id": 153965501,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527677787
    },
    {
        "content": "<p>I mean the example under the heading \"Solution 2\" here: <a href=\"https://github.com/fhir-fuel/fhir-fuel.github.io/issues/2\" target=\"_blank\" title=\"https://github.com/fhir-fuel/fhir-fuel.github.io/issues/2\">https://github.com/fhir-fuel/fhir-fuel.github.io/issues/2</a>.  That snippet of json is exactly the same as the example under Solution 1!</p>",
        "id": 153965502,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1527677884
    },
    {
        "content": "<p>The difference is in 1. we have value key in 2: key is named after type: <code>{\"value\": \".....\", \"type\": \"string\"}</code> or <code>{\"string\": \"..........\"}</code></p>",
        "id": 153965503,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527677957
    },
    {
        "content": "<p>This can be unified with primitives representation: we can choose or {\"value\": ....} or {\"&lt;type&gt;\": .......}</p>",
        "id": 153965505,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527678031
    },
    {
        "content": "<p>Oh ah, thanks, I failed to notice that ;-)</p>",
        "id": 153965507,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1527678128
    },
    {
        "content": "<p>What are use cases for primitive extensions? nullFactors?</p>",
        "id": 153965508,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527678408
    },
    {
        "content": "<p>Why we can't  just create extension one level up to represent the same logic?</p>",
        "id": 153965509,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527678578
    },
    {
        "content": "<p>How do you handle extended primitives in ref. impl. ? I still think, this will be source of pain in many technologies, without real profit.</p>",
        "id": 153965511,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527679001
    },
    {
        "content": "<p>I think graphql would address the problem, and the existing work looks very promising.</p>",
        "id": 153965512,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1527683626
    },
    {
        "content": "<p>extension 1 level up fails for elements that repeat</p>",
        "id": 153965522,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527687037
    },
    {
        "content": "<p>and is messy because now you can't interpret primitives without their context. Not that the json is any different now... my real unhappiness with it....</p>",
        "id": 153965523,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527687069
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  What are real use cases for primitive extensions? May we find another solution for it?</p>",
        "id": 153965526,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527687184
    },
    {
        "content": "<p>I think NullFactor should be handled in a different way, not by extensions</p>",
        "id": 153965527,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527687212
    },
    {
        "content": "<p>we didn't define it for null flavor. There's a number of primitive data type extensions in the spec. you should have a look at those</p>",
        "id": 153965528,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527687372
    },
    {
        "content": "<p>Do you mean code extensions in basic structure-definitions? Why do you spec the core features by extensions?</p>",
        "id": 153965535,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527687966
    },
    {
        "content": "<p>no I mean the extensions defined here:</p>",
        "id": 153965537,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527688119
    },
    {
        "content": "<p><a href=\"http://build.fhir.org/extensibility-registry.html\" target=\"_blank\" title=\"http://build.fhir.org/extensibility-registry.html\">http://build.fhir.org/extensibility-registry.html</a></p>",
        "id": 153965538,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527688136
    },
    {
        "content": "<p>the code extensions in the structure definitions are a special case - they are effectively the fhir equivalent of compiler magic</p>",
        "id": 153965539,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527688161
    },
    {
        "content": "<p>A few of the use-cases we've hit so far for primitive extensions:<br>\n- express a date in an alternate calendaring system<br>\n- provide \"original text\" for any data subsequently encoded as a date, number or boolean (i.e. what did the user actually see/type)<br>\n- provide translations of a string<br>\n- provide a calculation instead of a value (e.g. express an offset from some specified time-point instead of a date, provide a formula rather than a numeric element</p>",
        "id": 153965592,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527689231
    },
    {
        "content": "<p>The interesting thing about FHIR's JSON syntax is that 5 years ago I was making almost the same argument (\"nobody on the core team uses JSON\", \"this is just thinly transformed XML\", and \"it's not idiomatic\") to promote the opposite change (from \"all primitives are behind <code>.value</code> properties\" --&gt; \"just make FHIR primitives be JSON primitives\").</p>\n<p>In hindsight, I'm sorry I was persuasive -- because what I was trying to do was save JSON-centric developers from what I considered the line noise of extra properties everywhere... but the real pain was the fact that primitives in FHIR just aren't primitives. Trying to optimize for what I considered the extremely common case of \"unadorned primitives\" leaves a whole lot of pain in the less common cases, and makes the underlying model was less elegant.</p>",
        "id": 153965640,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1527692099
    },
    {
        "content": "<p>I'm still confused by solid point  - <code>primitives, which are not primitives</code> and suspect, that we are trying to solve orthogonal problems like i18n and alternative calendars with wrong tool -  extended primitives.</p>",
        "id": 153965650,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527692379
    },
    {
        "content": "<p>If primitive is not enough - use complex type!</p>",
        "id": 153965652,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527692440
    },
    {
        "content": "<p>Every single place primitives appear, there's the potential for them to not be enough</p>",
        "id": 153965665,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527692843
    },
    {
        "content": "<ul>\n<li>Date is a complex type by definition - let's just model it like {calendar: '', date: '', time: ''}</li>\n<li>to preserve original info we can have extensions - this is not common case to document it, in some resources, where this is common case we can create dedicated elements to record this</li>\n<li>for translation we can have complex i18n text {lang: '...', text: ''}, like Narrative</li>\n</ul>",
        "id": 153965666,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527692855
    },
    {
        "content": "<p>We don't want to add the complexity of those use-cases for everyone</p>",
        "id": 153965667,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527692874
    },
    {
        "content": "<p>The whole point of extensions is to keep the data simple unless use-cases drive a need for complexity</p>",
        "id": 153965668,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527692895
    },
    {
        "content": "<p>You can't possibly model all the potential use-cases ahead of time.  Extension is for \"all the weird use-cases implementers will come up with\"</p>",
        "id": 153965671,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527692943
    },
    {
        "content": "<p>They will always come up with more than you can imagine.</p>",
        "id": 153965672,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527692955
    },
    {
        "content": "<p>That's true :/</p>",
        "id": 153965674,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527693011
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> while I understand that there is impact on implementors due to changes, the impact on millions of people who will ultimately be using the protocol once it's normative outweighs that by orders of magnitude. Any decisions that are made now will affect many people for decades to come, and favoring convenience for current implementors over that seems rather short sighted to me. Having ~40 people make decisions that will impact the community at large is not really a convincing argument. The decision should be based on collecting feedback from the experience of the wider community using the protocol in the wild.</p>\n<p>While the protocol focuses on the exchange, the fact that the data has to be extracted from the exchange protocol is still an important consideration. Ultimately, if the protocol is difficult to work with that will lead to errors when people attempt to extract the data from it, and that directly impacts patient safety.</p>\n<p>I'd also like to note that UHN has been one of the early adopters of FHIR, and we have tried to make suggestions for the protocol from the start. The message has always been the same. So, while technically we are able to make suggestions, very little feedback ends up being integrated back into the standard in practice. I've been hearing the line that people have already implemented the current version and therefore it's not worth changing from the start.</p>",
        "id": 153965676,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1527693057
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> so we can tell, that FHIR does not have primitive types - but containers for primitives with extension points?</p>",
        "id": 153965684,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527693326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> Correct.  FHIR has no true primitives.  Every 'primitive' has extension points.</p>",
        "id": 153965692,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527693746
    },
    {
        "content": "<p>I still have doubts about  abusing and wrong interpretation of primitive extensions in real use. <br>\nThings like </p>\n<div class=\"codehilite\"><pre><span></span> &quot;_active&quot;: {&quot;extension&quot;: [{\n        &quot;url&quot;: &quot;http://example.org/fhir/StructureDefinition/recordStatus&quot;,\n        &quot;valueCode&quot;: &quot;archived&quot;\n    }]},\n</pre></div>\n\n\n<p>looks like changing semantic. Such type of power looks dangerous.</p>",
        "id": 153965693,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527693753
    },
    {
        "content": "<p>And with extending primitives people will always have this temptation</p>",
        "id": 153965700,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527693900
    },
    {
        "content": "<p>There are some programming languages, which allow extension of primitives (js,ruby) and this is considered like bad practice and source of bugs &amp; confusion. Because primitives is one of semantic foundation :)</p>",
        "id": 153965704,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527694044
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194001\">@Dmitri Sotnikov</span> The process you describe is what we've been doing for the past 6 years.  Change requests and ballot submissions have been coming in.  The specification reflects the evolution that's resulted from that feedback and the consensus of the community.  In the end, the decisions about proposed changes are made by people who show up on the calls and who vote in the ballot.  There comes a point where the community who's engaged (and who makes the decisions) decide that the cost of further change isn't worth it.  We try to make that community as broad as we can, but we can't second guess them when they make a decision.</p>",
        "id": 153965705,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527694141
    },
    {
        "content": "<p>I've worked with many open source projects, and FHIR specification process is very opaque  in comparison. The fact that people have to show up to the calls to vote is a perfect example of that.</p>",
        "id": 153965708,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1527697518
    },
    {
        "content": "<p>One of the main issues is that a lot of the discussions are ephemeral in nature. There needs to be a list of proposed features/changes that is public and easily accessible making it possible for the community to meaningfully engage in the process.</p>",
        "id": 153965709,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1527697893
    },
    {
        "content": "<p>gForge is intended as the public, easily accessible description of proposed features/changes.  Sometimes they start out as ephemeral, but discussion within the tracker usually tries to make them concrete.  In terms of decision-making, there are two types, both inherited from the HL7 organization - work group decisions and ballots.  We have no ability to change how the balloting process works.  That's driven by ANSI.  In terms of work groups, major decisions are generally put out for discussion on Zulip prior to voting on a call.  I don't think there's ever been a situation where there was extensive support for something on Zulip only to have the decision reversed by a small group on the call.  (Though it's super common for the Zulip conversation to be totally silent or only have 1-2 people chime in.)  There's certainly lots of ability for those who can't attend the calls to share their perspective and to sway opinion.</p>",
        "id": 153965719,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527704525
    },
    {
        "content": "<blockquote>\n<p>Though it's super common for the Zulip conversation to be totally silent or only have 1-2 people chime in.</p>\n</blockquote>\n<p>This is precisely the problem, because nobody just sits and watches Zulip all day just on an off chance that an issue that affects them comes up for discussion. Being able to participate and affect meaningful change requires a large commitment. This ends up excluding a lot of users who simply don't have the time to do this. A typical approach is to have a public forum for discussions that's persistent, and have separate discussion threads for each issue. This allows people to see what the proposals are easily, see the state of the current discussion, and contribute their experience.</p>",
        "id": 153965730,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1527707077
    },
    {
        "content": "<p>I think our upcoming move to developing the spec on GitHub, with pull requests driving review, will help in this regard. But <span class=\"user-mention\" data-user-id=\"194001\">@Dmitri Sotnikov</span> your observations here are very much on the mark.</p>\n<p>My assessment is that FHIR runs in a very meritocratic, pragmatic way compared with others healthcare standards efforts... but falls short of the mark compared with well-managed open-source projects.</p>",
        "id": 153965748,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1527710157
    },
    {
        "content": "<p>\"A typical approach is to have a public forum for discussions that's persistent, and have separate discussion threads for each issue\" - in fact, I thought we did have that</p>",
        "id": 153965751,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527710348
    },
    {
        "content": "<p>I am not so confident that pull requests will make things better. There's a language gulf between 'the process of changing the standard' and 'the meaning of the standard' - that's the one I live every day. So I'm worried that they'll make things worse, not better.</p>",
        "id": 153965753,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527710495
    },
    {
        "content": "<p>and this is the reason why FHIR is more difficult to engage with than a standard open source project - this language gap, and because changes have to deal with 'what's possible' not 'what happens'</p>",
        "id": 153965754,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527710549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194001\">@Dmitri Sotnikov</span> the competing priorities in the json format have probably attracted the most broad comment of all the parts of the spec over the last few years. We had extensive discussions about this for over a year. My perspective is that the change was a case to aiming for 'too simple' but I wasn't able to be persuasive on this</p>",
        "id": 153965759,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527710700
    },
    {
        "content": "<p>\"I'd also like to note that UHN has been one of the early adopters of FHIR, and we have tried to make suggestions for the protocol from the start. The message has always been the same. So, while technically we are able to make suggestions, very little feedback ends up being integrated back into the standard in practice. I've been hearing the line that people have already implemented the current version and therefore it's not worth changing from the start.\" - I'm sorry you feel that. There's a tension between open discussion and revisiting a subject again and again because different people have different priorities, and actually making some decision, and growing more and more weight around it. </p>\n<p>In this case, Nicola has consistently been unhappy with the json format, primarily because of storage concerns, and he's had one or 2 voices supporting him. These numbers are much less compared to the number of people who weighed in originally, or who would comment if we tried to change this (or, in this case, document a second format). That's driven the outcome in this case.</p>",
        "id": 153965768,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527711366
    },
    {
        "content": "<p>you'll say that straw poll above says different - that's why I'm still in this thread (the only reason)</p>",
        "id": 153965769,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527711477
    },
    {
        "content": "<p>back to json... if I was going to change the way we handle polymorphics, I'd do this:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  &quot;resourceType&quot; : &quot;Observation&quot;,\n  &quot;value&quot;:  {\n    &quot;_type&quot; : &quot;string&quot;,\n   &quot;value&quot; : &quot;the-value&quot;\n  }\n}\n</pre></div>",
        "id": 153965770,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527711576
    },
    {
        "content": "<p>or, for a complex data type:</p>\n<div class=\"codehilite\"><pre><span></span>{\n  &quot;resourceType&quot; : &quot;Observation&quot;,\n  &quot;value&quot;:  {\n    &quot;_type&quot; : &quot;Coding&quot;,\n   &quot;system&quot; : &quot;the-uri&quot;,\n  &quot;code&quot; : &quot;the code&quot;\n  }\n}\n</pre></div>",
        "id": 153965771,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527711683
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> this looks prettier. May be use @type instead of _type (like json-ld). As well for unification we can change resourceType for @type too</p>",
        "id": 153965775,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527712147
    },
    {
        "content": "<p>I deliberately didn't propose @type because it's overloaded by json-ld and we would not be using it consistently with json-ld</p>",
        "id": 153965776,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527712269
    },
    {
        "content": "<p>I don't feel strongly about that. json-ld is problematic,  I think... I don't think we'll ever go there</p>",
        "id": 153965778,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527712369
    },
    {
        "content": "<p>Another alternative is use type name as key - this will simplify exact access (at least in database) without filtering by type:  <code>resource.value.string or resource.value.Coding</code></p>",
        "id": 153965779,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527712379
    },
    {
        "content": "<p>resource.value.string.value ? yay!</p>",
        "id": 153965780,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527712407
    },
    {
        "content": "<p>with primitive extensions - yes :(</p>",
        "id": 153965782,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527712426
    },
    {
        "content": "<p>but I don't see how resource.value.string is better than resource.valueString</p>",
        "id": 153965783,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527712435
    },
    {
        "content": "<p>it's an additional access point without any semantic improvement</p>",
        "id": 153965784,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527712461
    },
    {
        "content": "<p>It's more consistent, simple logical check - you will be able to have collection of polymorphics</p>",
        "id": 153965785,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527712483
    },
    {
        "content": "<p>As well check that value exists will be <code>resource.value is not null</code> instead of resource.valueString || resource.valueCoding</p>",
        "id": 153965786,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527712518
    },
    {
        "content": "<p>Another check - required constraints on it in json-schema using <em>required</em> key</p>",
        "id": 153965788,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1527712611
    },
    {
        "content": "<p>I'm a bit disconcerted by Josh (who was one of the stronges proponents of the current JSON syntax) indicating that he feels it was a mistake and Grahame (lead architect for FHIR) also saying it's a mistake.  And the sole arguments against change being \"it impacts too many people\".  </p>\n<p>We are not yet normative.  If we're going to make this change, it would likely mean that the JSON couldn't go normative this cycle (though XML still could).  I suspect a lot of people will vote against this change because they use JSON for exchange, but don't use JSON internally and don't really care what the JSON looks like so long as it carries the data.  For them, change of any sort is bad.  However, I'm curious whether any of those who actually <em>use</em> JSON for storage or internal manipulation would vote against this change.  I'd hate for us to lock down on something where the community consensus is already \"we did it wrong\", but we feel we're too far along to change.</p>",
        "id": 153965809,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1527715257
    },
    {
        "content": "<p>well... specifically: the way we do primitives is a mistake. On balance, I don't agree with the other changes being discussed here.</p>",
        "id": 153965813,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527715601
    },
    {
        "content": "<p>but I do think it's too late to change, personally</p>",
        "id": 153965814,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527715611
    },
    {
        "content": "<p>and those people who think that we don't value json as much as xml... there's <em>nothing</em> that could say that as strongly as not making json normative</p>",
        "id": 153965815,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527715643
    },
    {
        "content": "<p>Again, I'd like to point out that once the spec becomes normative everybody using it will be affected by it for a very long time to come. If there is a consensus that the current design is a mistake, it really should be changed. The inconvenience for the few early adopters is insignificant when considered against the burden this would put on literally every healthcare IT organization that will be using this standard. I can't stress this point enough.</p>",
        "id": 153965868,
        "sender_full_name": "Dmitri Sotnikov",
        "timestamp": 1527718820
    },
    {
        "content": "<p>it's not a question of how much you stress the point, but how people will vote.</p>",
        "id": 153965919,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527719019
    },
    {
        "content": "<p>and I don't think that this is <em>that</em> big a deal. In fact, I think that many json implementers will vote for the current format, given a choice, simply because 100% of the primitives they deal with are simpler in the current format</p>",
        "id": 153965951,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527719137
    },
    {
        "content": "<p>In our current system we are very much JSON-oriented and use it internally as our data structure (which was the simplest way to start). However, we are again and again hitting all the same issues mentioned above, with extensions and with type variants. In every place we work with data in a generic way we have to remember to handle extensions and type variants properly.</p>\n<p>At this point it looks like restructuring the data would have been much better approach (and we already do that in one part of the system). It was deceptively \"easy\" to use JSON representation directly (I didn't think about extensions and type choices until I got familiar enough with FHIR).</p>\n<p>On the other hand, as much as I would love to have an alternative JSON representation, supporting both XML and JSON means some conversion is still needed (at very least, arrays are represented differently, etc) -- and if you do it, you might as well do it for JSON, too.</p>",
        "id": 153965997,
        "sender_full_name": "Ivan Dubrov",
        "timestamp": 1527727703
    },
    {
        "content": "<p>Oh, forgot about the GraphQL. The current JSON representation is also leaking into GraphQL API, which is also non ideal (polymorphic types are better represented using GraphQL unions, for example).</p>",
        "id": 153966010,
        "sender_full_name": "Ivan Dubrov",
        "timestamp": 1527737266
    },
    {
        "content": "<p>i certainly considered that. But there was some reason I didn't.... I think because I wanted standard graphql logic over existing json to work as expected....</p>",
        "id": 153966029,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527753064
    },
    {
        "content": "<blockquote>\n<p>but I don't see how resource.value.string is better than resource.valueString</p>\n</blockquote>\n<p>When I mentioned the thing I wanted to change about our Xml representation, it was actually very similar to this: the fact that we have not separated clearly the type from the name has proven a disadvantage in a few spots.   For one, I'd like to offer my users a consistent path to a property, so my API's offer access using the name, not name+type - this requires access to metadata, even at the faster lower-levels of my parser.  Second, instead of a hashed lookup of the name, I need to compare prefixes in the list of elements, which is measurably slower again.  </p>\n<p>Which is not to say I am in favor of changing the serialization format, that would cause me way more pain than this.  Having an \"optional\" alternative (as Nicolai suggested) would of course turn out into just  another obligation on the server writers, cause now you need to support both.  I would do it, but I can see not everyone would jump for joy...</p>",
        "id": 153966069,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1527772854
    },
    {
        "content": "<p>the HAPI POJOs create both paths... fine for the RI I know. but changing to that would have other strong disadvantages...</p>",
        "id": 153966120,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1527799694
    },
    {
        "content": "<p>Blog about this: <a href=\"http://www.healthintersections.com.au/?p=2824\" target=\"_blank\" title=\"http://www.healthintersections.com.au/?p=2824\">http://www.healthintersections.com.au/?p=2824</a></p>",
        "id": 153967249,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528258571
    },
    {
        "content": "<p>If one JSON format is better for exchange and another for persistence, then the answer may be <em>just</em> for implementations to convert from one format to another where necessary and I'm guessing that the relevant class/utility already exists, somewhere. Agree that changing the exchange (FHIR) format at this stage looks bad from a product perspective and two exchange formats for JSON will hinder interoperability.</p>",
        "id": 153967267,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1528262668
    },
    {
        "content": "<p>so we would not offer any advice about a single internal-suitable format?</p>",
        "id": 153967301,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528284145
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> I don't think you can make the assertion that \"most implementers will use one of the reference implementations\" given that A) many implement a façade and therefore don't require one of the reference implementations and B) most mature development shops will have to take financial and legal responsibility for their systems and that the reference systems are unlikely to accept that risk on their behalf.</p>",
        "id": 153967306,
        "sender_full_name": "Paul Knapp",
        "timestamp": 1528284708
    },
    {
        "content": "<p>no. Lloyd was wrong about that. Many applications do, but many don't</p>",
        "id": 153967307,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528284755
    },
    {
        "content": "<p>As a sort of side-topic, I'd like to add that the <strong>JSON Schema</strong> backing all resources / data types is important to my organization. We develop a <a href=\"https://www.mirthcorp.com/community/wiki/display/mirth/Mirth+Connect+3.6.0+-+What's+New#MirthConnect3.6.0-What'sNew-FHIRConnectorExtension\" target=\"_blank\" title=\"https://www.mirthcorp.com/community/wiki/display/mirth/Mirth+Connect+3.6.0+-+What's+New#MirthConnect3.6.0-What'sNew-FHIRConnectorExtension\">FHIR Connector Extension</a> for our open-source product called Mirth Connect that is used by thousands of healthcare implementers globally. The FHIR Connector uses the JSON Schema to create a dynamic <a href=\"https://www.mirthcorp.com/community/wiki/display/mirth/FHIR+Resource+Builder\" target=\"_blank\" title=\"https://www.mirthcorp.com/community/wiki/display/mirth/FHIR+Resource+Builder\">GUI resource builder</a>.</p>\n<p>It's important that if the JSON format changes, that the JSON Schema is also kept up to date. If the format \"branches\" into two possibilities, I think that can be expressed with a \"oneOf\" property. Or it may make sense to branch the entire thing into two separate schemas?</p>",
        "id": 153967325,
        "sender_full_name": "Nick Rupley",
        "timestamp": 1528290377
    },
    {
        "content": "<p>EDIT: Sorry this Zulip interface is very confusing, can't tell if I'm replying to a thread or creating a new thread in this topic haha...</p>",
        "id": 153967327,
        "sender_full_name": "Nick Rupley",
        "timestamp": 1528290448
    },
    {
        "content": "<p>I agree with <span class=\"user-mention\" data-user-id=\"196058\">@Nick Rupley</span>... it is important to keep the json schema updated.<br>\nI also, however, believe that the current JSON format is very good for automatically generated GUIs</p>",
        "id": 153967477,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1528301899
    },
    {
        "content": "<p>Framework's like angular have problems binding to simple data types, and require binding to a primitive <em>within</em> an object</p>",
        "id": 153967481,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1528301940
    },
    {
        "content": "<p>Which is exactly what we do, now. So, I think we will equally-so run into issues with binding UI's (with frameworks like Angular) if we change the JSON format for primitives</p>",
        "id": 153967483,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1528302003
    },
    {
        "content": "<p>Just to also put this on the table: another (well documented) problem with the current JSON format is the disconnect between FHIR's <code>decimal</code> data type and how it's represented in JSON. Many JSON libraries have precision issues since they use float or double representations for numbers, and almost all lose trailing zeroes. The only solution to this particular problem I believe would be to represent decimals as string, which like all the other proposals here would make the JSON format \"less native\" to use IMHuO – tradeoffs vs. tradeoffs.</p>",
        "id": 153967494,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1528303231
    },
    {
        "content": "<p>Current json format can not be accurately described by json schema, because primitive extensions and polymorphics. <span class=\"user-mention\" data-user-id=\"191339\">@Pascal Pfiffner</span>  if we make primitive to be json object i think decimal notation will be more clear {decimal: “...”}</p>",
        "id": 153967525,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528310734
    },
    {
        "content": "<p>we already comment about precision here: <a href=\"http://build.fhir.org/json.html#primitive\" target=\"_blank\" title=\"http://build.fhir.org/json.html#primitive\">http://build.fhir.org/json.html#primitive</a></p>",
        "id": 153967527,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528314785
    },
    {
        "content": "<p>this was also discussed at length... it wasn't simple</p>",
        "id": 153967528,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528314818
    },
    {
        "content": "<p>the current json format can be described completely with JSON schema but the schema doesn't tell you about the relationships e.g. between id and _id</p>",
        "id": 153967529,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528314862
    },
    {
        "content": "<p>you can not express required constraints on primitives and only one for valueX or valueY on polymorphics</p>",
        "id": 153967533,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528315055
    },
    {
        "content": "<p>there is no constraints on primitives. And I think I do express the only one thing. but it gets real complex if you mix primitives in the choice...</p>",
        "id": 153967537,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528315266
    },
    {
        "content": "<p>Yes, this is documented and was discussed, just trying to ensure that it's mentioned in this thread in case JSON format redesign is indeed being considered.</p>",
        "id": 153967545,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1528316091
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> ‘required’ means min=1 in profile</p>",
        "id": 153967556,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528317878
    },
    {
        "content": "<p>json schema does not have require ‘property a or b’ keyword</p>",
        "id": 153967557,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528317934
    },
    {
        "content": "<p>and ‘one of property’</p>",
        "id": 153967558,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528318014
    },
    {
        "content": "<p>ah yes, that is correct</p>",
        "id": 153967559,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528318033
    },
    {
        "content": "<p>json schema probably should have that...</p>",
        "id": 153967565,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528318629
    },
    {
        "content": "<p>I voted <span class=\"emoji emoji-1f44d\" title=\"thumbs up\">:thumbs_up:</span> on revisiting the issue, only because I think it's going to be a recurring theme and a little more documentation around XML-&gt;JSON would help. I'll wager that people coming to FHIR/healthcare in 2018 are overwhelmingly coming from JSON backgrounds. They will ask the same question as <span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> , and I think they deserve an answer. Reading through this thread has been difficult, so pointing people back to it would not be helpful.</p>",
        "id": 153967585,
        "sender_full_name": "Nick Hatt",
        "timestamp": 1528321089
    },
    {
        "content": "<p>For example, this in the XML format documentation has always bugged me: </p>\n<blockquote>\n<p>Given the way extensions work, applications reading XML resources will never encounter unknown elements.</p>\n</blockquote>\n<p>If a core design principle is that <code>applications reading XML resources will never encounter unknown elements</code>, I'm fine with that, but it's helpful to know that that's a principle to quell my frustration with iterating through extensions in JSON.</p>",
        "id": 153967587,
        "sender_full_name": "Nick Hatt",
        "timestamp": 1528321306
    },
    {
        "content": "<p>so you think we should repeat that on the JSON page?</p>",
        "id": 153967594,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528321826
    },
    {
        "content": "<p>We wouldn't necessarily need to repeat it on the JSON page, but having a separate page that provides background and context for why things are the way they are (perhaps with a link from the main JSON and XML pages) wouldn't be a bad thing.  Implementers could ignore, but those who have questions could read it or be directed there.</p>",
        "id": 153967605,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1528322450
    },
    {
        "content": "<p>might be wiki content...</p>",
        "id": 153967606,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528322485
    },
    {
        "content": "<p>i still do not think current design is good and predict a lot of negative feedback in the future from json land :(</p>",
        "id": 153967607,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528323108
    },
    {
        "content": "<p>can we represent primitives as primitives in simple case and switch to object notation in case of extensions: ‘’’attr: “...” or ‘attr: { ext: ..., value: ...}’’’?</p>",
        "id": 153967608,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528323308
    },
    {
        "content": "<p>I kind of like that but I think that it would cause a lot of run time errors</p>",
        "id": 153967609,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528323378
    },
    {
        "content": "<p>this is more regular and this errors looks reasonable</p>",
        "id": 153967610,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528323431
    },
    {
        "content": "<p>I cannot recall that specific proposal ever being discussed before</p>",
        "id": 153967611,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528323446
    },
    {
        "content": "<p>at least in databases we will use “res.attr.value or res.attr” expression and this can be unified with polymorphics res.attr.string and res.attr.Quantity</p>",
        "id": 153967612,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528323637
    },
    {
        "content": "<p>also polymorphics representation as res.attr.Quantity simplify fhirpath impl res.attr.as(Quantity)</p>",
        "id": 153967615,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528323992
    },
    {
        "content": "<blockquote>\n<p>also polymorphics representation as res.attr.Quantity simplify fhirpath impl res.attr.as(Quantity)</p>\n</blockquote>\n<p>Yes, that's one of the lovely aspects of separating the path from the type. If we'd consider that, we should do the same for XML though. I would not necessarily do it with a \".\" though, as it becomes ambiguous whether you are talking about a path or a type, so I would prefer another separator.</p>",
        "id": 153967733,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1528353706
    },
    {
        "content": "<p>We've discussed alternatives like the one Nicolay describes (having both attr: and attr: { ext: value: }, but we shied away from it, because the path to the value would change depending on whether the value has extensions (or an id).   So, you'd have to try both \"attr\" and \"attr.value\" if the first is null.</p>",
        "id": 153967734,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1528353900
    },
    {
        "content": "<p>actually the first would be an object, not null. json-ld does this with the @context</p>",
        "id": 153967737,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528354542
    },
    {
        "content": "<p>though it's either an object or string that's areference to the object. I don't remember discussing it</p>",
        "id": 153967738,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528354577
    },
    {
        "content": "<blockquote>\n<p>actually the first would be an object, not null. json-ld does this with the @context</p>\n</blockquote>\n<p>Indeed, object.   So, is that a concern, <span class=\"user-mention\" data-user-id=\"191318\">@nicola (RIO/SS)</span> ?</p>",
        "id": 153967783,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1528359133
    },
    {
        "content": "<p>In the US DSTU2 is already widely used, and so here to stay for years - so changes to a new JSON format would mean that everyone in the US would have to support _both_ the new and the old formats</p>",
        "id": 153967853,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1528393195
    },
    {
        "content": "<p>yes that's true</p>",
        "id": 153967871,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528400883
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> it will be used after normative release  by much more users for a decades</p>",
        "id": 153968065,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528475350
    },
    {
        "content": "<p>Maybe - but everyone would still have to support both formats for a good part of those decades</p>",
        "id": 153968076,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1528477688
    },
    {
        "content": "<p>Some servers does not support xml or json, so this is not a big problem :). I think, in later phase FHIR will be driven by implementations like HTTP, HTML and CSS is driven by browsers.</p>",
        "id": 153968093,
        "sender_full_name": "nicola (RIO/SS)",
        "timestamp": 1528484456
    },
    {
        "content": "<p>I have to say, having reviewed some of my code.... I would strongly prefer </p>\n<blockquote>\n<p>represent primitives as primitives in simple case and switch to object notation in case of extensions: ‘’’attr: “...” or ‘attr: { ext: ..., value: ...}’’’?</p>\n</blockquote>\n<p>There's existing unreported bugs in my code in the corner cases around the existing approach</p>",
        "id": 153968176,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528501024
    },
    {
        "content": "<p>but it seems, based on feedback to this point, there's just not enough interest to support a change this size. (lots of interest in a very small community...)</p>",
        "id": 153968177,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1528501301
    },
    {
        "content": "<blockquote>\n<p>However, I'm curious whether any of those who actually <em>use</em> JSON for storage or internal manipulation would vote against this change.  I'd hate for us to lock down on something where the community consensus is already \"we did it wrong\", but we feel we're too far along to change.</p>\n</blockquote>\n<p>So many thoughts.</p>\n<p>+1 for Nicola’s concept of ‘inlining’, which I’ve referred to in the past as ‘flattening’ or ‘resolving’.  It would be great to see official rules and guidance on this.  Internally, FHIR resources will get globbed together into phylogenetic trees, cladograms, graphs, and other complex data structures.  The idea that resources are always exchanged in a Bundle is probably the largest discrepancy between the official spec and our use of FHIR in internal storage and data models.</p>\n<p>The FHIR wire format being unusable without complex and fragile 3rd party libraries is just a matter of time.  Once the standard goes normative, we can begin adding more tooling and moving those libraries into database drivers, network drivers, preprocessors, build tools, IDEs, etc.  That becomes possible when the standard goes normative and we can point other organizations to a spec that has the backing of HL7 and ANSI.</p>\n<p>Also, if the wire format doesn’t support FHIR natively, change the wire protocol!  Which is essentially what we’ve begun to do by defining the <code>application/json+fhir</code> mime type.  HL7 and ANSI have enough political clout and long-term process management, that they can think in these terms.  Lets keep in mind that we’re defining a new standard through formal standards development processes, rather than simply writing software that conforms to existing standards.</p>\n<p>That we have to go through a complex, error prone, and expensive parsing step before we’re able to work with the data effectively isn’t a convincing argument to me.  That’s  basically the experience of anybody who has used or written their own network driver.  This issue has been present since the dawn of telecommunications.  Let’s just be glad that our complex, error prone, and expensive encoding/decoding is human readable in JSON and English and is well documented in a robust API.  And that it’s not pipe delimited, or requires us parsing ZMODEM or Kermit parameters.</p>\n<p>But once we receive the data, we have to write it to the database.  Besides decimal representation, date and geolocation lat/long are the things we have to regularly accommodate for. We’re slowly refining and refactoring our database mapping functions, and will eventually get them into a differential package that we can submit to Mongo.  </p>\n<p>Date usage, and the need to handle partial knowledge about birthdates, is probably the $64K healthcare use case that drives the need to actually depart from existing JSON primitives.  We currently cast to a Date() object for internal storage, but that’s clinically problematic for a bunch of reasons.  We make heavy use of the Moment.js library, which comes close to being able to parse the HL7 rules on date management; and will probably wind up attaching a Provenance resource to the object if there’s not enough information to resolve to an ISO Date.  Like...  if we get a birthdate that is simply “1950”, we’re currently storing as “Jan 1st, 1950, 00:00:00’, and will probably add a meta tag or extension that points to a provenance value set or Provenance resource type that says ‘this date is fuzzy and unknown’.  </p>\n<p>Trivia fact... the first video monitor was actually a cathode ray tube, which was used as a storage device at the time.  So Sean’s comments about Angular’s problems with binding to simple data types is actually quite relevant and has a long history.  We deal with something similar, in that we’re using isomorphic code, and have a library called minimongo that implements our server side storage API in the web browser.  So, those storage issues with decimal, date, and lat/long are on both server and client.  But, by the same token, we have an isomorphic library that can box/unbox the values as needed.</p>\n<p>Regarding disk storage, we’d like to see the application/json+fhir` mime type extended to a file extension.  Do we simply save a FHIR file as a .json file?  I quite like having .fhir, .ccd, and .bundle extensions.  </p>\n<p>tl;dr - Personally, we’re fine with the approach to primitives that’s been developed to date, and wouldn’t want to hold up R4 normative with a last minute change.  Would encourage people to think about the life cycle of a standard, and how once things go normative, it will lead to tooling, drivers, etc that support the standard - even if they dont currently exist.</p>\n<p>Apologies for the wall of text.</p>",
        "id": 153971014,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1529608911
    },
    {
        "content": "<p>Why both .fhir and  .bundle extensions?</p>",
        "id": 153971018,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1529612154
    },
    {
        "content": "<p>We have different import rules based on the file extension.  We’re stIll a bIt undecided if clinical workflow is better supported by defining the extension as data content type or top level resource.  There’s an argument for either (or even both, as in the case of <code>TestPatient.bundle.fhir</code> vs <code>TestPatient.Medication.fhir</code>).  The biggest use case by far is import/export functionality.  Which is a type of file transfer and interoperability if you think about it... data transfer via persistent data storage.</p>",
        "id": 153971023,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1529616938
    },
    {
        "content": "<p>And if you really want to run with the idea, consider how DICOM works as a container mechanism for JPG files (analagous to the manilla patient record folders).  Maybe a .fhir extension shouldn’t be a modified .json file at all.  Maybe it should be a password protected .zip file, which would enforce encrypted data at rest and HIPAA compliance.  Just a thought.</p>",
        "id": 153971028,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1529618717
    },
    {
        "content": "<p>Different types of Bundles would be handled differently though.  And we may eventually have other FHIR resource types (or environments where other existing FHIR resource types) are handled differently.  I think that if the system knows it's FHIR, that's enough information to look inside and decide how it wants to process it.</p>",
        "id": 153971032,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1529625797
    },
    {
        "content": "<p>Totally agreed the resourceType field has all the logic we need, and using .bundle or other .resourceType extensions probably isn’t the way to go.  If it’s a .fhir extension, expect to be able to open up the file and find a resourceType field.  That alone would be hugely useful to draft into the specification.</p>",
        "id": 153971034,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1529627323
    },
    {
        "content": "<p>The one thing tha does, though, is locks .fhir into being a .json analog (totally reasonable), so using it as a .zip file is out.  Which makes me then think about .sfhir</p>",
        "id": 153971036,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1529627404
    },
    {
        "content": "<p>SFHIR = Secure Fast Healthcare Interoperability Resource = password encrypted zip file containing a .fhir file</p>",
        "id": 153971037,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1529627465
    },
    {
        "content": "<p>That does raise the question of whether we need a different extension for the JSON, XML, RDF and eventually other syntaxes used with fhir.</p>",
        "id": 153971104,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1529674388
    },
    {
        "content": "<p>I apologize for necroposting, but I need to vent a bit since I'm facing this issue once again.</p>\n<p>After almost three years working with FHIR (which included implementing both a FHIR-native server and frontend libraries), I can say that current JSON representation is one of the biggest obstacles (mostly, for frontend / JavaScript-based platforms).</p>\n<p>On backend, where we use non-JavaScript based language (Rust), we designed our static types in a way that they reflect FHIR semantics (where primitive types are actual composite objects and type choices are choice types, enums). It did require us to write our custom serializers / deserializers for JSON since standard one wouldn't map data the way we wanted, but there were other reasons to do that anyway, and in the end, it's not that complicated. It worked out pretty well in the end, I think. However, it was possible primarily because we were able to restrict wire format issue to deserialization / serialization logic, which happens early.</p>\n<p>However, frontend part, where everything is \"JSON-native\", and there is really no need for \"deserialization\" to happen, current JSON representation is a huge problem:</p>\n<ul>\n<li>It's hard to express types (say, TypeScript) over existing JSON representation that are accurate.</li>\n<li>Being not able to pass primitive value as a single value makes all kinds of auto-generated or metadata-driven forms really hard.</li>\n<li>Same for type choices</li>\n<li>Writing data back to resource (updating its fields) requires knowledge of parent of item being edited: you cannot just \"return\" updated value. Somewhat manageable for primitives which could be special-cased (because you have two places to write at most, the value itself, and its \"element\" counterpart), but worse for type choices (where you would need to know all the other possible fields to look at). Typechoices with primitive values? Oh, well. Actually, primitives are also quite difficult for the case when arrays of primitives are involved.</li>\n<li>As an extension of previous problem, (React) state management for any kind of forms based on FHIR type (say, editor for OperationDefinition) is _really_ hard because state management works well when you can structure your components such that children \"selects\" subset of state from their parent, and it is not easy / possible with current scheme.</li>\n<li>Since extensions are relatively rare on primitives, it encourages yolo approach (\"you only live once\") to development where extensions are simply ignored.</li>\n</ul>\n<p>These issues are not impossible to solve, but they really throw a wrench into any kind of metadata-driven approach to FHIR resources.</p>\n<p>I understand concerns about the need to support yet another wire format. I would expect that upgrading backend systems should be less of an issue (although, will incur some cost), but will impact existing frontend / JavaScript-based libraries.</p>\n<p>I'm optimistic, though, that in the end it would be a net positive change.</p>",
        "id": 204120749,
        "sender_full_name": "Ivan Dubrov",
        "timestamp": 1594922872
    },
    {
        "content": "<p>These are all the same arguments I made back when we settled on the current format. But it really is too late to change</p>",
        "id": 204157806,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1594943903
    }
]