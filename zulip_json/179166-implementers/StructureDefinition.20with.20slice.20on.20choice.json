[
    {
        "content": "<p>StructureDefinition/ElementDefinition has this rule about slicing:<br>\n\"An element with a cardinality of 0..1 and a choice of multiple types can be sliced by type. This is in order to specify different constraints for different types. In this case, the discriminator SHALL be \"@type\"\"<br>\nDoes anyone know any examples of how this is represented?<br>\nEx: Trying to figure out if the element with \"slicing\" should have a path of \"Observation.effective[x]\" and a discriminator of \"@type\". Then does that mean that children of the slice should have a path of \"Observation.effective[x].effectiveDateTime\"?</p>",
        "id": 153858990,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480443274
    },
    {
        "content": "<p>that doesn't seem right to me... but not sure what is</p>",
        "id": 153858991,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480443296
    },
    {
        "content": "<p>there is an example in US Lab Diagnostic Order</p>",
        "id": 153859000,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480444783
    },
    {
        "content": "<p>where is that at? not seeing it under \"Examples\" of StructureDefinition</p>",
        "id": 153859002,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480444915
    },
    {
        "content": "<p>Ok. Maybe I found it... I see this:</p>",
        "id": 153859005,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480445130
    },
    {
        "content": "<div class=\"codehilite\"><pre>&lt;element&gt;\n  &lt;path value=&quot;DiagnosticOrder.extension.valueReference&quot;/&gt;\n  &lt;short value=&quot;Value of extension&quot;/&gt;\n  &lt;definition value=&quot;Value of extension - may be a resource or one of a constrained set of the data types (see\n   Extensibility in the spec for list).&quot;/&gt;\n  &lt;min value=&quot;1&quot;/&gt;\n  &lt;max value=&quot;1&quot;/&gt;\n  &lt;base&gt;\n    &lt;path value=&quot;Extension.value[x]&quot;/&gt;\n    &lt;min value=&quot;0&quot;/&gt;\n    &lt;max value=&quot;1&quot;/&gt;\n  &lt;/base&gt;\n  &lt;type&gt;\n    &lt;code value=&quot;Reference&quot;/&gt;\n    &lt;profile value=&quot;http://hl7.org/fhir/StructureDefinition/uslab-pract&quot;/&gt;\n  &lt;/type&gt;\n  &lt;mustSupport value=&quot;true&quot;/&gt;\n  &lt;mapping&gt;\n    &lt;identity value=&quot;rim&quot;/&gt;\n    &lt;map value=&quot;N/A&quot;/&gt;\n  &lt;/mapping&gt;\n&lt;/element&gt;\n</pre></div>",
        "id": 153859006,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480445133
    },
    {
        "content": "<p>But I see nothing about slicing in this example...</p>",
        "id": 153859007,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480445150
    },
    {
        "content": "<p>is it just the use of &lt;base&gt; that makes this work?</p>",
        "id": 153859008,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480445158
    },
    {
        "content": "<p>in the R2 version, you can find @type used as a descriminator</p>",
        "id": 153859010,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480445248
    },
    {
        "content": "<p>what about STU3?</p>",
        "id": 153859011,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480445281
    },
    {
        "content": "<p>STU3 is hard to search because the IGs have been moved out of the spec. I see if on DAF2 condition on onset[x] though</p>",
        "id": 153859014,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480445620
    },
    {
        "content": "<p>ok</p>",
        "id": 153859019,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480446424
    },
    {
        "content": "<p>I think I see what you're talking about</p>",
        "id": 153859021,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480446431
    },
    {
        "content": "<p>having multiple &lt;type&gt; for each type supported</p>",
        "id": 153859022,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480446437
    },
    {
        "content": "<p>but that rule about slicing in my first post confuses me then</p>",
        "id": 153859023,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480446469
    },
    {
        "content": "<p>it seems to indicate that I should use slicing</p>",
        "id": 153859024,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480446474
    },
    {
        "content": "<p>not type</p>",
        "id": 153859025,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480446476
    },
    {
        "content": "<p>further-more, how do I say valueCodeableConcept should be bound to a value set</p>",
        "id": 153859026,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480446489
    },
    {
        "content": "<p>&lt;type&gt; doesn't seem to include any binding information</p>",
        "id": 153859027,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480446497
    },
    {
        "content": "<p>that's when you have to slice by @type - so you can make different constraints for different types</p>",
        "id": 153859028,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480446675
    },
    {
        "content": "<p>tell me if you think this pseudo structuredefn is correct:</p>",
        "id": 153859029,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480446760
    },
    {
        "content": "<p>&lt;element&gt;<br>\n  &lt;path value=\"Observation.extension.value[x]\" /&gt;<br>\n  &lt;min value=\"1\" /&gt;<br>\n  &lt;max value=\"2\" /&gt;<br>\n  &lt;slicing&gt;<br>\n    &lt;discriminator value=\"@type\" /&gt;<br>\n  &lt;/slicing&gt;<br>\n&lt;/element&gt;<br>\n&lt;element&gt;<br>\n  &lt;path value=\"Observation.extension.valueCodeableConcept\" /&gt;<br>\n  ... bindings ...<br>\n&lt;/element&gt;</p>",
        "id": 153859030,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480446869
    },
    {
        "content": "<p>yes I think so</p>",
        "id": 153859031,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1480447104
    },
    {
        "content": "<p>ok. good enough for me, for now, then</p>",
        "id": 153859032,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480447197
    },
    {
        "content": "<p>:)</p>",
        "id": 153859033,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480447198
    },
    {
        "content": "<p>wish I knew why zulip code-blocked by first xml, but not the second</p>",
        "id": 153859034,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480447233
    },
    {
        "content": "<p>oh... maybe because of the \"...bindings...\"</p>",
        "id": 153859039,
        "sender_full_name": "Sean McIlvenna",
        "timestamp": 1480447317
    },
    {
        "content": "<p>For a slicing example check out <a href=\"http://healthedatainc.com/go-ftp/US-Core/structuredefinition-us-core-observationresults.html\" target=\"_blank\" title=\"http://healthedatainc.com/go-ftp/US-Core/structuredefinition-us-core-observationresults.html\">http://healthedatainc.com/go-ftp/US-Core/structuredefinition-us-core-observationresults.html</a>.  Did it to specify the bindings.  Although having tried to use this core profile, I wound up having to reslice which I'd rather avoid.  Would creating an invariant to avoid reslicing work here?  e.g if type a then bind to A if type b then bind to B.</p>",
        "id": 153860185,
        "sender_full_name": "Eric Haas",
        "timestamp": 1480841819
    }
]