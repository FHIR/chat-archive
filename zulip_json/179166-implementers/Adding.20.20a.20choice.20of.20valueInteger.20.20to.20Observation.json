[
    {
        "content": "<p>The Orders and Observation workgroup is considering the tracker - <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=13375&amp;start=0\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=13375&amp;start=0\">#13375</a> to add  a choice of valueInteger to Observation resource.  We are seeking feedback on this before voting on whether to approve this tracker.  Specifically looking feedback on any negative consequences.</p>",
        "id": 153895702,
        "sender_full_name": "Eric Haas",
        "timestamp": 1498767830
    },
    {
        "content": "<p>The main negative consequence is that increases the likelihood that different implementers will uses a different data type to capture the same Observation value.  There's already a (slight) likelihood of that now with CodeableConcept vs. boolean.  But the risk is much higher with Quantity vs. integer.  As an aside, Quantity allows you to display Quantity.unit which is often helpful for human interpretation.  With integer, you're totally reliant on the Observation.code.coding.display or Observation.code.text which, in some cases, may not be totally clear.  As far as I can tell, the only benefit of adding valueInteger is that you eliminate one layer of nesting - Observation.valueInteger as opposed to Observation.valueQuantity.value.  I'm not sure the saving 7 characters is worth the complexity of supporting an additional type, deciding which observations should use Quantity vs. integer, loss of the expressive capability that Quantity provides around unit, and need for extra logic to handle both types when graphing or doing other numerical analysis.</p>",
        "id": 153895718,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1498768525
    },
    {
        "content": "<p>I don't understand how this is any different from having an Integer datatype and a count specialization on Quantity.  Those same arguments would apply there but we have two choices....</p>",
        "id": 153895755,
        "sender_full_name": "Eric Haas",
        "timestamp": 1498771483
    },
    {
        "content": "<p>Also my expectation is that at my end of the spectrum  - publshing the standard specification you would want to provide a broader level of support and optionality and as you move to the other end of the spectrum - the implemenation you would profile ( at least informally ) what you will use. </p>",
        "id": 153895756,
        "sender_full_name": "Eric Haas",
        "timestamp": 1498771819
    },
    {
        "content": "<p>The main difference is that we use the integer data type on elements that <em>can't</em> possibly be anything than an integer.  To my knowledge, we've never supported a choice of integer|Quantity.  With Observation, frequently values <em>can</em> be something other than an integer, so there's a need to have Quantity.</p>",
        "id": 153895759,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1498773619
    },
    {
        "content": "<p>With FHIR, we're not doing design-by-constraint.  We provide necessary flexibility, but we try not to be more flexible than necessary.  Variability is the enemy of interoperability, so we try to only support flexibility where it's necessary to support implementer capabilities.  It's not clear how that could be the case here.</p>",
        "id": 153895760,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1498773696
    },
    {
        "content": "<p>I don't think we are jumping on 'the design by constraint' train  -  if you expect integer values you would expect to find valueInteger without having to read the spec.</p>",
        "id": 153895762,
        "sender_full_name": "Eric Haas",
        "timestamp": 1498775900
    },
    {
        "content": "<p>It adds complexity, it adds likelihood of non-interoperable variation, and it doesn't increase expressive functionality.  If there's confusion, it can be addressed with a paragraph in the notes section.  I don't see the benefit being worth the cost.</p>",
        "id": 153895769,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1498794833
    },
    {
        "content": "<p>A agree with Lloyd here, but we do need clear and obvious documentation about how to use valueQuantity for what valueInteger could do.</p>",
        "id": 153895773,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1498800463
    },
    {
        "content": "<p>Based on UCUM specifications any string between a {} is actually a value of 1. Thus a value of {beats}/min is actually equivalent to {b}/min. <br>\nHowever as far as I can tell in FHIR,  these are codes not equivalent as they are not an exact match.<br>\nIs it possible to aim for interoperability without also requiring the enforcement of UCUM rules as well? <br>\nAnd if the argument is to use a unit of 1 for all counts (rather than the {}), then does this not take away from the human readability?</p>",
        "id": 153895857,
        "sender_full_name": "Sadiq Saleh",
        "timestamp": 1498842784
    },
    {
        "content": "<p>The codes are definitely not equivalent.  So a value set expecting \"{beats}/min\" would not match on \"1/min\" even though both codes correspond to the same UCUM concept.  (In much the same way as a value sets that includes a pre-coordinated SNOMED concept wouldn't accept the post-coordinated variant.)</p>",
        "id": 153895871,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1498852958
    },
    {
        "content": "<p>Lloyd: define equivalent in that sentence. Because I think they are equivalent, thought they are not the smae</p>",
        "id": 153895875,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1498853937
    },
    {
        "content": "<p>Equivalent means \"not equal from a string perspective\", which is what matters if you're dealing with an enumerated value set.  (You're fine if you're using a subsumption based value set - something like \"all UCUM codes that express distance\".)</p>",
        "id": 153895876,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1498854784
    },
    {
        "content": "<p>But with an enumerated value set, if the enumeration contains \"1/min\" and doesn't contain \"{beats}/min\", only the former would be a legal value in the instance - regardless of the fact that the meaning of the two is the same.</p>",
        "id": 153895877,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1498854843
    },
    {
        "content": "<p>The are 2 timely issues on this stream:</p>\n<ul>\n<li>Mine - the original one which is the tracker we, OO are considering.  of which my concern about having to read the damn specification in order to express valueInteger has not been addressed to my satisfaction - is that a barrier to adoption or at least an unnecessary hurdle for implementers. ( It was the same with valueBoolean - after the 3 separate tracker requesting it - OO gave in and added it ....either nobody bothered read the notes on how to handle it or did not agree with it  )</li>\n<li>Sadiq's - UCUM issue which is timely because we need to say more about Quantity vis a vis UCUM.  I think in <a href=\"https://chat.fhir.org/#narrow/stream/implementers/topic/UCUM.20bpm.20-.20heart.20rate.20at.20wrist\" target=\"_blank\" title=\"https://chat.fhir.org/#narrow/stream/implementers/topic/UCUM.20bpm.20-.20heart.20rate.20at.20wrist\">this stream</a>  Lloyd summarizes this issue very well and namely the fact that UCUM provides a human readable {[whatever-you-are-counting]} and the Quantity.unit do very similar things.  i.e., provide a way to display the units to the end user.  putting the <code>{}</code> stuff in Quantity.code may be problematic for systems.  OO has a tracker on that and will probably punt to MNM or Vocab to say more on this particular topic in a more general way.</li>\n</ul>",
        "id": 153895891,
        "sender_full_name": "Eric Haas",
        "timestamp": 1498862604
    },
    {
        "content": "<p>Why is it a problem to have to read the specification to figure out how to express valueInteger?  I think setting that as an expectation to avoid interoperability issues is a reasonable tradeoff...</p>",
        "id": 153895893,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1498866500
    },
    {
        "content": "<p>I support adding valueInteger to Observation. There are lots of observations whose values are fundamentally and always integers. How many people in your household? On a scale of 1-5 how would you rate your satisfaction? What is the Mitotic Count Score (1, 2 or 3)?  I don't believe the issue is referencing the value, it is roundoff error in representing an integer value as a decimal. Is 1.0000000000000001 (the nearest decimal to 1 in one system) equal to 0.9999999999999 (the nearest decimal to 1 in a different system) equal?  This is basic to every computer language. It's nutty that FHIR Observations do not support integers.</p>",
        "id": 153896836,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1499954124
    },
    {
        "content": "<p>\"How many people in your household?\" should get an answer of \"x people\". Just as \"How tall are you (in centimetres)?\" should get an answer of \"x cm.\"</p>",
        "id": 153896912,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1500009964
    },
    {
        "content": "<p>Whether scores and ratings are numeric or rather codes (thus CodeableConcepts in FHIR)  is one of the discussions that will probably never settle. Despite the fact that scores are often calculated by adding up subscores, many systems are treating them as codes. But even if you treat them as numeric, it should be \"x score points\" or \"x rating points\" rather than \"x\".<br>\nI also think that the mentioned precision issues should be handled on the implementation side (something that is also within the capability of every computer language). If you store/send \"1.0000000000000001\" within a decimal element, that should mean exactly \"1.0000000000000001\" and not \"1 +/-0000000000000001\". If you want to have \"1\" and you know that your calculation result has only 3 significant figures, ensure to round properly.<br>\nThe FHIR spec is quite clear on how to handle the precision of decimals, up to the required ability to keep trailing zeros.</p>",
        "id": 153896914,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1500018297
    },
    {
        "content": "<p>So, tl;dr: I don't see increased functionality by adding integer, but I would see increased confusion and decreased interoperability, as Lloyd pointed out.</p>",
        "id": 153896915,
        "sender_full_name": "Stefan Lang",
        "timestamp": 1500018437
    },
    {
        "content": "<p>I'm not seeing us circling towards resolution on this issue. It seems to me that the issues are relatively clear, and people differ on values. Mu summary is that adding valueInteger is clearer for newbies encountering the spec who have what looks like an integer, and aren't used to the ucum code tricks that insiders know all about, and also allows newbies to defer the precision issue (though I agree with Stefan). But adding it means that there'll always be the question for ever with regard to having to look for either valueInteger, or a valueQuantity with a UCUM code - and many people will get caught out by that</p>",
        "id": 153897668,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1500640372
    },
    {
        "content": "<p>e.g. it's a classic reader vs writer thing</p>",
        "id": 153897669,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1500640384
    },
    {
        "content": "<p>In my opinion, the newbie issue can be minimized with some clear documentation and a couple of examples</p>",
        "id": 153897692,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1500646478
    },
    {
        "content": "<p>+1 to using valueQuantity so that you get the units.</p>",
        "id": 153898230,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1501047931
    },
    {
        "content": "<p>The issue is now closed OO voted in favor.</p>",
        "id": 153898510,
        "sender_full_name": "Eric Haas",
        "timestamp": 1501111694
    }
]