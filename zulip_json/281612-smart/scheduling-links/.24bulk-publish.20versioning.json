[
    {
        "content": "<p>As we're looking at doing updates based on connectathon feedback, I'm curious if folks have opinions on how to version $bulk-publish.  We have several folks building integrations with our existing $bulk-publish endpoints.  We are looking at splitting out availability by vaccine product, and that will change the resolution of capacity reporting.  The simple option is just splitting by the URL path.  E.g. v1/$bulk-publish vs. v2/$bulk-publish.  However I figured I'd ask if folks have other preferences like using an HTTP request header.</p>",
        "id": 236192752,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619450089
    },
    {
        "content": "<p>A few things here. Ideally steps like \"splitting availability by vaccine product\" don't require different versions: the current spec allows you to publish with or without. And provides hints to clients about how often to poll (via response headers).</p>",
        "id": 236194154,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619450517
    },
    {
        "content": "<p>So in practice I don't think there's an issue yet.</p>",
        "id": 236194235,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619450533
    },
    {
        "content": "<p>When we start assigning version numbers to the Scheduling Links IG, <span class=\"user-mention\" data-user-id=\"192576\">@Robert Scanlon</span> had asked about hosting a <code>/metadata</code> endpoint (i.e.,. a CapabilityStatement) as a sibling path to $bulk-publish, which would keep some of those versioning semantics 1) in their usual fhir home, and 2) out of the way for clients that don't yet care. Does that make sense to you <span class=\"user-mention\" data-user-id=\"191764\">@Cooper Thompson</span> ?</p>",
        "id": 236194476,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619450624
    },
    {
        "content": "<p>Hmm... /metadata seems a little heavy.  Also, I've brought this up in the past on #implementers, but there is a difference between the spec version and implementation/patch version.  In this case, there was a spec version change, but the changes (at least the ones we are looking at) were fully compatible.  It is really an implementation/patch-specific version that I'm looking at.    This is currently an unsolved problem in the base FHIR REST API (<a href=\"#narrow/stream/179166-implementers/topic/FHIR.20API.20versioning/near/153911399\">New API Version</a>, <a href=\"#narrow/stream/179166-implementers/topic/How.20do.20you.20let.20users.20know.20a.20newer.20API.20version.20is.20available.3F\">FHIR API Versioning</a>), so maybe I'm being too optimistic that we'll have a simple solution for $bulk-publish.</p>",
        "id": 236196636,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619451419
    },
    {
        "content": "<p>Specifically, the change we are looking at is to split our capacity reporting to make it more granular (based on vaccine product).  So we'll end up with more Schedules.  Existing integrations that use the less-granular capacity with a single Schedule still need to work though.</p>",
        "id": 236196863,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619451506
    },
    {
        "content": "<p>Yeah I was going to point out the same thing <span class=\"user-mention\" data-user-id=\"191764\">@Cooper Thompson</span> -- FHIR versioning support is more about being able to support multiple versions of FHIR at a single endpoint, which is different than this.</p>",
        "id": 236197476,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1619451759
    },
    {
        "content": "<p>It would be nice if FHIR gave an answer to this, because I imagine it is a very common practical issue and would further justify using the spec.</p>",
        "id": 236197620,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1619451834
    },
    {
        "content": "<p>Yeah, we've been looking at an option for a client-specified Epic-Fhir-Version header or something like that (for the normal REST API, not SMART Scheduling Links).  I agree that it would be better if there were a standard way, but there hasn't really been much appetite in the FHIR community.</p>",
        "id": 236198455,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452157
    },
    {
        "content": "<p>My point regarding /metadata is that FHIR has very few base requirements, and it is a bit concerning whenever there is a base requirement that doesn't provide positive value for all use cases.  The fact that we don't mention it here, and our tests don't check for it, makes me wonder if it has value.  It would be nice if it solved this problem, because that would help justify the overhead of making everyone implement it.</p>",
        "id": 236198503,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1619452181
    },
    {
        "content": "<p>You have an excellent point.  I have a LOT of experience working with FHIR integrations, and as far as I know, the <em>only</em> reason anyone ever looks at /metadata is to get the OAuth2 URLs, which are now in .well-known.</p>",
        "id": 236198715,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452264
    },
    {
        "content": "<p>Which isn't even required now with well-known ;-)</p>",
        "id": 236198763,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1619452289
    },
    {
        "content": "<p>I guess not the <em>only</em> reason.  Inferno also checks it for search params.  But AFAIK Inferno is the only one doing that <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> .</p>",
        "id": 236198926,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452359
    },
    {
        "content": "<p>For /metadata, I was expecting it'd use <code>CapabilityStatement.instantiates</code> to name a specific IG version like \"<a href=\"http://fhir-registry.smarthealthit.org/CapabilityStatement/smart-scheduling-links|1.3.2\">http://fhir-registry.smarthealthit.org/CapabilityStatement/smart-scheduling-links|1.3.2</a>\" (or whatever).</p>",
        "id": 236198943,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452364
    },
    {
        "content": "<p>But the instantiates goes back to the FHIR version (or IG version), no the implementation patch level.</p>",
        "id": 236199014,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452390
    },
    {
        "content": "<p>What does 'implementation patch level' refer to?</p>",
        "id": 236199051,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452401
    },
    {
        "content": "<p>using <code>.instantiates</code> is the pattern we've used for bulk data an other IGs, but I agree with your distaste for this. Separate questions 1) does it solve the problem, if distastefully, and 2) what solution would you prefer?</p>",
        "id": 236199130,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452440
    },
    {
        "content": "<p>I sort of described it <a href=\"#narrow/stream/179166-implementers/topic/FHIR.20API.20versioning/near/153911399\">here</a>.  But a good example is just doing a bug fix.</p>",
        "id": 236199209,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452459
    },
    {
        "content": "<blockquote>\n<p>Specifically, the change we are looking at is to split our capacity reporting to make it more granular (based on vaccine product). So we'll end up with more Schedules. Existing integrations that use the less-granular capacity with a single Schedule still need to work though.</p>\n</blockquote>\n<p>I'm unclear on this -- correctly written clients shouldn't assume any specific number of Schedules.</p>",
        "id": 236199235,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452470
    },
    {
        "content": "<p>For example, we have FHIR IDs that have invalid characters (slashes).  If we fix that and deploy it as a patch, we've increased the patch version, even if we are still implementing the same spec version.</p>",
        "id": 236199302,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452508
    },
    {
        "content": "<p>\"Correctly written clients\" is 1) a very optimistic assumption and 2) varies a lot based on what you consider \"correct\".</p>",
        "id": 236199370,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452538
    },
    {
        "content": "<p>I think when you talk about \"patch version\" you're talking not about a FHIR version but a version of Epic's software. This is a bit like FHIR libraries managing library versions -- e.g., <a href=\"https://www.nuget.org/packages/Hl7.Fhir.R4\">https://www.nuget.org/packages/Hl7.Fhir.R4</a> shows the following library versions for the Firely R4 .NET libraries, totally separate from any standardized FHIR versions:</p>\n<p><a href=\"/user_uploads/10155/svgP6UDnNO917Fv31fwzneUp/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/svgP6UDnNO917Fv31fwzneUp/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/svgP6UDnNO917Fv31fwzneUp/image.png\"></a></div>",
        "id": 236199474,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452568
    },
    {
        "content": "<blockquote>\n<p>Cooper Thompson: \"Correctly written clients\" is 1) a very optimistic assumption and 2) varies a lot based on what you consider \"correct\". </p>\n</blockquote>\n<p>Sure, but I don't think this is a problem that can be fixed with version numbers; unless you're saying you'd host multiple versions at once and let clients stick to their existing behavior or opt into new behavior by changing their endpoint when they're ready? In any case, some changes are considered \"breaking\", and adding more schedules (in line with what the spec already allows) wouldn't be what I'd consider breaking -- but ultimately that'd be an Epic-internal decision, just as Firely decides what to call 2.0.3 vs 3.0.1 in their FHIR R4 .NET library.</p>",
        "id": 236199714,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191315\">Josh Mandel</span> <a href=\"#narrow/stream/281612-smart.2Fscheduling-links/topic/.24bulk-publish.20versioning/near/236199714\">said</a>:</p>\n<blockquote>\n<p>unless you're saying you'd host multiple versions at once and let clients stick to their existing behavior or opt into new behavior by changing their endpoint when they're ready?</p>\n</blockquote>\n<p>Exactly this.</p>",
        "id": 236199903,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452752
    },
    {
        "content": "<p>What you consider breaking and what breaks apps in PRD varies.  We've broken apps in PRD with some <em>very</em> subtle spec-compatible changes before.</p>",
        "id": 236200072,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452808
    },
    {
        "content": "<p>So from this perspective, I think the important <em>interop</em> need is if you're listing 10 different endpoints in a directory, we want to make sure an aggregator tool knows they're all related so it can just subscribe to the most recent one, and not get 9x copies of the various schedules.</p>",
        "id": 236200074,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452809
    },
    {
        "content": "<p>For now, we might just do multiple endpoints.  But in general, we'd be talking about hundreds or thousands of patch changes, so we're looking at a client-specified header to indicate what patch behavior they want.</p>",
        "id": 236200297,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452885
    },
    {
        "content": "<blockquote>\n<p>Cooper Thompson: What you consider breaking and what breaks apps in PRD varies. We've broken apps in PRD with some very subtle spec-compatible changes before.</p>\n</blockquote>\n<p>I understand, and this is ultimately your call (my naive perspective is: try to ensure clients are handling data according the actual spec and not overly indexed on Epic's implementation -- that said, I know it's hard and you don't want to break stuff \"on principle\" when you can instead just make stuff work.)</p>",
        "id": 236200308,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452891
    },
    {
        "content": "<blockquote>\n<p>we're looking at a client-specified header to indicate what patch behavior they want</p>\n</blockquote>\n<p>And presumably the default is \"latest/best release\" if a client doesn't specify such a header?</p>",
        "id": 236200443,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452936
    },
    {
        "content": "<p>Or is it \"server maintains a list of defaults for each client\"?</p>",
        "id": 236200474,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452950
    },
    {
        "content": "<p>(That breaks down for public data of course.)</p>",
        "id": 236200511,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452963
    },
    {
        "content": "<p>Many of the changes are not specific to Epic's implementation, but rather to the behavior of the API.  For example, if we have a <a href=\"http://Procedure.search\">Procedure.search</a> API, and initially we don't support EKGs, but then we add EKG support, that is a behavior change that might impact apps.</p>",
        "id": 236200542,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619452977
    },
    {
        "content": "<p>*not specific, I think you mean?</p>",
        "id": 236200593,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619452991
    },
    {
        "content": "<p>Fixed</p>",
        "id": 236200645,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619453004
    },
    {
        "content": "<blockquote>\n<p>For example, if we have a <a href=\"http://Procedure.search\">Procedure.search</a> API, and initially we don't support EKGs, but then we add EKG support, that is a behavior change that might impact apps.</p>\n</blockquote>\n<p>Again, this feels really hard to me to me; well written clients should understand that servers will return more stuff over time. But to be clear, I'm just musing; I'm not trying to tell you how to design your system -- if you want to give clients this degree of opt-in, that seems fair.</p>",
        "id": 236200886,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619453109
    },
    {
        "content": "<p>Practically: I don't see anything bulk-publish-specific about this discussion, per your note above. If you want to add an extra optional header like <code>please-opt-me-into-epic-patch-version: 3.1.2</code> or even <code>please-opt-me-into-epic-semver: ^3.0.0.</code> (with semver like syntax), that sounds fine, as long as the defaults work.</p>",
        "id": 236201093,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1619453191
    },
    {
        "content": "<p>We have had applications that our customers use in PRD break when we've made \"compatible\" changes.  So we're very gun-shy (which might be another word for \"experienced\"?).</p>",
        "id": 236201201,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619453247
    },
    {
        "content": "<blockquote>\n<p>But in general, we'd be talking about hundreds or thousands of patch changes</p>\n</blockquote>\n<p>Geez, how many of these would you want to simultaneously support?</p>",
        "id": 236202158,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1619453671
    },
    {
        "content": "<p>Well, for HL7v2, it is basically \"all of them\".  Though we retire v2 compatibility options at specific Epic major version upgrades.  However FHIR is harder than HL7v2, since v2 tends to be used inside the organization, during an upgrade the customer can review all their systems and plan for the retirement.  Since FHIR is often used outside the organization, and an app can be used by multiple organizations, we can't really tie retirement to a version upgrade, since different organizations upgrade at different times.</p>",
        "id": 236203205,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1619454126
    }
]