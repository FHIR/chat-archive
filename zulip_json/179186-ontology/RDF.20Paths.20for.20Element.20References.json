[
    {
        "content": "<p><span class=\"user-mention\" data-user-email=\"grahame@healthintersections.com.au\" data-user-id=\"10\">@Grahame Grieve</span> - I'm building a FHIR to RDF conversion for Python use and encountered a a disparity in interpretations.  Taking the valueset resource as an example, the \"exclude\" element references (has the same definition as) the \"include\" element.   The question is whether we use \"include\" or \"exclude\" in the inner path names.  My interpretation shows an exclude as:</p>\n<div class=\"codehilite\"><pre><span></span> fhir:ValueSet.compose [\n        fhir:ValueSet.compose.exclude [\n            fhir:index &quot;0&quot;^^xsd:integer ;\n            fhir:ValueSet.compose.exclude.concept [\n                fhir:index &quot;0&quot;^^xsd:integer ;\n                fhir:ValueSet.compose.exclude.concept.code [\n                    fhir:value &quot;5932-9&quot;\n                ] ;\n</pre></div>\n\n\n<p>while the FHIR rendering has \"exclude\" in the outermost tag, but then reverts to \"include\" in the inner tags:</p>\n<div class=\"codehilite\"><pre><span></span> fhir:ValueSet.compose [\n  fhir:ValueSet.compose.exclude [\n       fhir:index 0;\n       fhir:ValueSet.compose.include.system [ fhir:value &quot;http://loinc.org&quot; ];\n       fhir:ValueSet.compose.include.concept [\n         fhir:index 0;\n         fhir:ValueSet.compose.include.concept.code [ fhir:value &quot;5932-9&quot; ];\n</pre></div>\n\n\n<p>Before I try to fix my utility, I wanted to double check that you are certain that the FHIR rendering is what was intended.</p>",
        "id": 153906327,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505157842
    },
    {
        "content": "<p>the fhir rendering is what is intended - the element is only defined once, and then erused</p>",
        "id": 153906332,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505157991
    },
    {
        "content": "<p>reused</p>",
        "id": 153906333,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505157996
    },
    {
        "content": "<p>But that rule applies in both situations, as it is just a question whether the outermost label \"include\" or \"exclude\" persists through the definition or reverts.  Another example would be in testscript -- where a \"setup.action\" is contained in a test.action.operation by the FHIR interpretation:</p>\n<div class=\"codehilite\"><pre><span></span>fhir:TestScript.test.action.operation [\n         fhir:TestScript.setup.action.operation.type [\n           fhir:Coding.system [ fhir:value &quot;http://hl7.org/fhir/testscript-operation-codes&quot; ];\n           fhir:Coding.code [ fhir:value &quot;update&quot; ]\n         ];\n         fhir:TestScript.setup.action.operation.resource [ fhir:value &quot;Patient&quot; ];\n</pre></div>\n\n\n<p>It seems a bit confusing to me, but if this is what you think it should be...</p>",
        "id": 153906337,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505158430
    },
    {
        "content": "<p>I would think it would still be a test.action.operation, even if it reuses the setup model</p>",
        "id": 153906338,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505158468
    },
    {
        "content": "<p>both which situations?</p>",
        "id": 153906378,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505164419
    },
    {
        "content": "<p>\"The element is only defined once and then reused...\" -- it can be reused whether it is compose.exclude throughout or exclude in the outermost and include within -- this is going to  confuse the dickens out of folks</p>",
        "id": 153906512,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505168499
    },
    {
        "content": "<p>if you say that it has to be .exclude, then you have to track the alternative names into the tree below it</p>",
        "id": 153906534,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505171301
    },
    {
        "content": "<p>that's the sort of thing that sounds less confusing but it more confusing structurally. And I thought that would matter more for RDF</p>",
        "id": 153906535,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505171371
    },
    {
        "content": "<p>We'll bring it up in the next HCLS RDF meeting to make sure that everyone understands the issues, but I suspect we'd like to change it.</p>",
        "id": 153906941,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505226873
    },
    {
        "content": "<p>At the meeting here? I'm very opposed to changing it. It would mean that all my serialisers would have to remember state. I can't see how this is practical for anyone else either</p>",
        "id": 153906952,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505229823
    },
    {
        "content": "<p>No - the meeting isn't occurring there.  It would be later.  This should only impact the RDF serializer but, if you feel strongly about it, we've got some extra work to do on our side and will need to be able to explain why we've got an \"include\" in the interior of the \"exclude\" node and why it isn't parallel with xpath or json path expressions</p>",
        "id": 153906959,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505229994
    },
    {
        "content": "<p>Well, that's inherent in the content model. The serialiser should not try to backpatch it</p>",
        "id": 153906968,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505230365
    },
    {
        "content": "<p>Not sure I understand. The xpath for an excluded concept is something like \"ValueSet.compose.exclude.concept\".  Why should it be ValueSet.compose.exclude Valueset.compose.include.concept in RDF?  And why should the identity depend on which was defined first.  You could have just as easily defined \"exclude\" and then said \"include\" --&gt; see \"exclude\".</p>",
        "id": 153906972,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505230894
    },
    {
        "content": "<p>That said, again, if you feel strongly about it, we can figure out how to deal with and explain it. Not worth a major battle.</p>",
        "id": 153906973,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505230949
    },
    {
        "content": "<p>identity depends on what the definition says. It's true that definitions must be backwards only but that's for convenience.</p>",
        "id": 153906983,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505231862
    },
    {
        "content": "<p>but the key thing here is that the RDF identifer is the element identifier, not the path identifier</p>",
        "id": 153906985,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505231891
    },
    {
        "content": "<p>this also applies to recursive elements like ValueSet.expansion.contains.contains</p>",
        "id": 153906987,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505231907
    },
    {
        "content": "<p>The only place where this is an issue is the relatively few items where the reference is (arguably) structural rather than semantic.   Recursive definitions are fine, as the semantics should be the same.  It is just the couple of places where, in one context \"Valueset.compose.include.concept\" identifies a concept to be included and, in another, the exact same tag identifies a concept to be excluded.  At the moment, these all appear to be in structural elements so they won't impact how we represent clinical data.  Again, if you feel strongly about it, I'll change the code on our end and add an explanation that sometimes \"include.concept\" is  included and sometimes it is excluded.</p>",
        "id": 153906996,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505233106
    },
    {
        "content": "<p>yeah well, the naming is not an optimum outcome, that's for sure.</p>",
        "id": 153906999,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505233775
    },
    {
        "content": "<p>but the problem is in the definitions, not the streaming</p>",
        "id": 153907000,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505233795
    },
    {
        "content": "<p>talking about it in ITS now</p>",
        "id": 153907001,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505233880
    },
    {
        "content": "<p>possible resolution... I will describe later</p>",
        "id": 153907008,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505234892
    },
    {
        "content": "<p>Excellent.  Will hold off until I hear back.</p>",
        "id": 153907016,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505235282
    },
    {
        "content": "<p>so with regard to this... if you look at the UML for value set, you'll see that the elements in question live in a named class</p>",
        "id": 153907390,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505312397
    },
    {
        "content": "<p>\"ConceptSet\"</p>",
        "id": 153907391,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505312400
    },
    {
        "content": "<p>Yes -- with two associations, one named \"include\" and one named \"exclude\"</p>",
        "id": 153907455,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505321263
    },
    {
        "content": "<p>right. so the thing is, the name on the properties should not be either '.include' or 'exclude', it should be '.conceptSet'</p>",
        "id": 153907477,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505321804
    },
    {
        "content": "<p>That is exactly how it would have worked had we built a complex type for ConceptSet rather than embedding its definition inline, no?</p>",
        "id": 153907691,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505336443
    },
    {
        "content": "<p>yes. but we don't have to build a complex type for that- we just have to use the supplied name properly</p>",
        "id": 153907812,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505339064
    },
    {
        "content": "<p>Makes sense. Looks like it comes from the structuredefinition-explicit-type-name extension.  A possible issue -- if it were a complex type, its name would necessarily be unique.  Here, no guarantee.  Do we ( a ) prefix ValueSet onto it or ( b ) just assume that it will be unique or ( c ) your're just confused, Solbrig, stop overthinking it??</p>",
        "id": 153908275,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505411981
    },
    {
        "content": "<p>prefix ValueSet on it, i think. But we don't always do that. Next week I'll look into the conditions under which we can assume it's unique</p>",
        "id": 153908279,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1505412537
    },
    {
        "content": "<p>No big hurry.  I'm testing a python based JSON to RDF conversion utility and this is one of the issues I've encountered.</p>",
        "id": 153908305,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505414003
    },
    {
        "content": "<p>The other is just a 24 caret bug, most likely on my part.  I filed a report on it, but I think I'll just go ahead and fix it...</p>",
        "id": 153908307,
        "sender_full_name": "Harold Solbrig",
        "timestamp": 1505414036
    }
]