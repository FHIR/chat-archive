[
    {
        "content": "<p>I'm starting to think about <a href=\"https://docs.google.com/document/d/1hNFaEDY9SL4MUWzv9wBU-D8ag-sSmXSanBHbcEuMkAo/edit?usp=sharing\" target=\"_blank\" title=\"https://docs.google.com/document/d/1hNFaEDY9SL4MUWzv9wBU-D8ag-sSmXSanBHbcEuMkAo/edit?usp=sharing\">reusable software componenents</a> (see also the other thread in implementers stream) and it seems that most of the interesting common operations will require injection of some kind of ontology service. This has me wondering if any thought has gone into defining a standard API for such a service?</p>",
        "id": 153831243,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464867202
    },
    {
        "content": "<p>what do you think it would do, and why would FHIR define such a thing? surely that's a core ontology w3C thing?</p>",
        "id": 153831244,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464867272
    },
    {
        "content": "<p>(I'm thinking to identify simple, common operations with no external dependencies to explore initially - but it should also be possible work with an injected service)</p>",
        "id": 153831245,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464867292
    },
    {
        "content": "<p>well a common operation would be a apply a mapping eg given a problem list with mainly SNOMED codes, generate a list in ICD 10 code</p>",
        "id": 153831246,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464867381
    },
    {
        "content": "<p>SparQL like?</p>",
        "id": 153831247,
        "sender_full_name": "Michael van der Zel",
        "timestamp": 1464867384
    },
    {
        "content": "<p>also classify the problems by body system...</p>",
        "id": 153831248,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464867405
    },
    {
        "content": "<p>Erich, you should start by reading the terminology service </p>",
        "id": 153831249,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464867424
    },
    {
        "content": "<p>maybe <span class=\"user-mention\" data-user-id=\"191421\">@Michael van der Zel</span> ...</p>",
        "id": 153831250,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464867437
    },
    {
        "content": "<p>is that a FHIR thing <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> ?</p>",
        "id": 153831251,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464867499
    },
    {
        "content": "<p>(sorry appreciate this is bit of a noob question)</p>",
        "id": 153831252,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464867521
    },
    {
        "content": "<p>yes <a href=\"http://hl7-fhir.github.io/terminology-service.html\" target=\"_blank\" title=\"http://hl7-fhir.github.io/terminology-service.html\">http://hl7-fhir.github.io/terminology-service.html</a></p>",
        "id": 153831253,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464867532
    },
    {
        "content": "<p>bingo! thanks <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> </p>",
        "id": 153831254,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464867584
    },
    {
        "content": "<p>i'd looked quickly at the <a href=\"https://www.hl7.org/fhir/valueset.html\" target=\"_blank\" title=\"https://www.hl7.org/fhir/valueset.html\">https://www.hl7.org/fhir/valueset.html</a> and related resource but had missed this page</p>",
        "id": 153831255,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464867670
    },
    {
        "content": "<p>is there a list of implementations ?</p>",
        "id": 153831256,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464867831
    },
    {
        "content": "<p>my server. Ontoserver, Apelon. IMO. NLM. We're starting to prepare for certification of the services </p>",
        "id": 153831257,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464867908
    },
    {
        "content": "<p>wow</p>",
        "id": 153831259,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464868170
    },
    {
        "content": "<p>ok so then (thinking in javascript sorry) it should be possible to define an API as a lightweight wrapper around this (is it REST?) service and then this service could be an injectable dependency into a library that performs \"common simple operations\" on FHIR data... ?</p>",
        "id": 153831261,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464868393
    },
    {
        "content": "<p>yep</p>",
        "id": 153831262,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464868406
    },
    {
        "content": "<p>sweeet!</p>",
        "id": 153831263,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464868414
    },
    {
        "content": "<p>I look forward to seeing the certification criteria for FHIR-based Terminology Services. Will the Connectathon Tests form the basis of these requirements?</p>",
        "id": 153831337,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464902588
    },
    {
        "content": "<p>well, that's the process that will lead towards the certification tests</p>",
        "id": 153831338,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464902659
    },
    {
        "content": "<p>I had a read of <a href=\"http://hl7-fhir.github.io/terminology-service.html\" target=\"_blank\" title=\"http://hl7-fhir.github.io/terminology-service.html\">http://hl7-fhir.github.io/terminology-service.html</a> now</p>",
        "id": 153831421,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464950011
    },
    {
        "content": "<p>it gets a bit wooly around the \"closure\" table</p>",
        "id": 153831422,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464950065
    },
    {
        "content": "<p>(we used to call them \"ancestor tables\")</p>",
        "id": 153831423,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464950092
    },
    {
        "content": "<p>I guess I should have a hard poke at the onto server - then I maybe up for a few patches</p>",
        "id": 153831424,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464950177
    },
    {
        "content": "<p>closure we haven't tested yet. Getting there</p>",
        "id": 153831425,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464950219
    },
    {
        "content": "<p>idea is for client to incrementally build its own table holding all possible is-a links between a set of \"codes of interests\"?</p>",
        "id": 153831426,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464950293
    },
    {
        "content": "<p>yes, client knows the table, but not the grounds on which it is built - that's what the terminology server knows. My server supports closure, but it's the only one at this time</p>",
        "id": 153831429,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464950656
    },
    {
        "content": "<p>ah</p>",
        "id": 153831431,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464950724
    },
    {
        "content": "<p>so this depends on the server keeping a track of which links it has let the client know about?</p>",
        "id": 153831432,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464950756
    },
    {
        "content": "<p>y</p>",
        "id": 153831433,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464950764
    },
    {
        "content": "<p>that could get expensive with a lot of clients...</p>",
        "id": 153831434,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464950781
    },
    {
        "content": "<p>well, up to the server to decide how to manage that. I'll let users fill up my database, and then I'll just wipe it ;-)</p>",
        "id": 153831435,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464950833
    },
    {
        "content": "<p>heh</p>",
        "id": 153831436,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464950841
    },
    {
        "content": "<p>of course if a user runs my server locally, they can have whatever policy they want</p>",
        "id": 153831437,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464950927
    },
    {
        "content": "<p>btw are we sure \"closure\" is the correct term?</p>",
        "id": 153831440,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951051
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Closure_(computer_programming)\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Closure_(computer_programming)\">https://en.wikipedia.org/wiki/Closure_(computer_programming)</a></p>",
        "id": 153831441,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951094
    },
    {
        "content": "<p>yes. see <a href=\"http://dirtsimple.org/2010/11/simplest-way-to-do-tree-based-queries.html\" target=\"_blank\" title=\"http://dirtsimple.org/2010/11/simplest-way-to-do-tree-based-queries.html\">http://dirtsimple.org/2010/11/simplest-way-to-do-tree-based-queries.html</a></p>",
        "id": 153831442,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464951118
    },
    {
        "content": "<p>yeah i read that link</p>",
        "id": 153831443,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951273
    },
    {
        "content": "<p>actually this seems the derivation</p>",
        "id": 153831444,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951286
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Transitive_closure\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Transitive_closure\">https://en.wikipedia.org/wiki/Transitive_closure</a></p>",
        "id": 153831445,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951287
    },
    {
        "content": "<p>y</p>",
        "id": 153831446,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464951297
    },
    {
        "content": "<p>At the Montreal Connectathon, Caroline Macumber from Apelon suggested that they may have implemented the full closure operation, but was going to check with the relevant developer. I started a while back, but wasn't comfortable that I understood the complete use case - notably around notifying and updating clients when the server rebuilds a transitive closure table after a new version of the code system is implemented. A UML Sequence Diagram might be useful; I re-read the spec and Grahame's blog entry several times - but something seemed to be missing.</p>",
        "id": 153831447,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464951485
    },
    {
        "content": "<p>so it seems that \"closure\" actually just means the property of generating a finite set (in mathematics) </p>",
        "id": 153831448,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951566
    },
    {
        "content": "<p>the key element is that this based on the transitive <code>is-a</code> links...</p>",
        "id": 153831449,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951616
    },
    {
        "content": "<p>too be honest I'm thinking that supporting incremental creation of these \"is-a closure tables\" (?? IsACT ??) via client-server operation is \"in the 80%\"</p>",
        "id": 153831450,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951754
    },
    {
        "content": "<p>but I can certainly see the utility in the base operation of \"give me the subset of is-a links that involve members both in a given set\"</p>",
        "id": 153831451,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951809
    },
    {
        "content": "<p>? anyone who wants to use a terminology server to handle all their terminology logic will be lead kicking and screaming to maintaining a closure table</p>",
        "id": 153831452,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464951820
    },
    {
        "content": "<p>take hiearchy table =&gt; explode</p>",
        "id": 153831453,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951856
    },
    {
        "content": "<p>sorry, anyone who maintains a relational database who....</p>",
        "id": 153831454,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464951859
    },
    {
        "content": "<p>its a simple enough operation...</p>",
        "id": 153831455,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464951973
    },
    {
        "content": "<p>I persist SNOMED CT in SQL Server and have a transitive closure table; but, to date, profiling and execution plans show no discernible performance difference between the table-valued function that I used for subsumption queries using the core tables, and the one that uses the closure table. However, I suspect that might change when the server is under a heavy load.</p>",
        "id": 153831456,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464952175
    },
    {
        "content": "<p>the key difference is that the closure table built this way is capable of dealing with post-coordination etc</p>",
        "id": 153831457,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464952339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191364\">@Peter Jordan</span> can you describe your \"table-valued function that I used for subsumption queries using the core tables\" vs. the \"closure table\"?<br>\nI'm not quite sure what the former one is - it sort of sounds like a \"closure table\" under the hood (or bonnet):)</p>",
        "id": 153831458,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1464952369
    },
    {
        "content": "<p>That makes sense, but I don't support post-co-ordination...yet.</p>",
        "id": 153831459,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464952398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> - ok that isn't as simple :-)</p>",
        "id": 153831460,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464952407
    },
    {
        "content": "<p>it is for the client, that's the key - it's just a code. It's not interested in the internal details. code, closure table, whatever...</p>",
        "id": 153831461,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464952454
    },
    {
        "content": "<p>how common is post-cordination  out there in the real world?</p>",
        "id": 153831462,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464952484
    },
    {
        "content": "<p>uncommon. mostly because of the closure table problem. </p>",
        "id": 153831463,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464952502
    },
    {
        "content": "<p>because everyone pre-generates their closure tables, if they have them, and then they can't deal with post-coordination </p>",
        "id": 153831464,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464952529
    },
    {
        "content": "<p>we especialy haven't explored the post-coordination aspects yet, as far as I know<br>\nand I was going to say, I think that presumes that the post-coordinated expression will be assigned an identifier (on the fly)? - which is the SNOMED CT idea of the \"expression library\" </p>",
        "id": 153831465,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1464952570
    },
    {
        "content": "<p>not necessary for the client. Or the API. Server might decide to do that for itself, but that's it's business </p>",
        "id": 153831466,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464952604
    },
    {
        "content": "<p>does the ontoserver to a basic closure (still think a better name is needed) operation?</p>",
        "id": 153831467,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464952672
    },
    {
        "content": "<p>don't know whether Michael and the team have done that</p>",
        "id": 153831468,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464952691
    },
    {
        "content": "<p>i'm getting curious about how long it would take my PC (2years old with 16G ram) too generate an ancestor table on snomed...</p>",
        "id": 153831469,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464952763
    },
    {
        "content": "<p>and then to get postgress to load it...</p>",
        "id": 153831470,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464952793
    },
    {
        "content": "<p>depends. generating the closure table for sct-us purely in ram takes me 45 seconds</p>",
        "id": 153831471,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464952802
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span>, I'm not sure if you're familiar with table-valued functions in SQL Server - they're a special type of stored procedure that return a table. The relevant logic uses self-joins on the relationship table, I'd be quite happy to send it to you. Because it uses a larger table than the 2-column transitive closure one, I suspect that it (and/or the relevant indexes) might take up more memory so might be more likely to slow down when SQL Server is nearing its memory peak.</p>",
        "id": 153831472,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464952847
    },
    {
        "content": "<p>gad I'm not getting any work done...</p>",
        "id": 153831473,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464952995
    },
    {
        "content": "<p>yes, I am somewhat familiar with them in general, Peter - but I've tended to do most of my db work in Oracle<br>\nI would like to have a look at it</p>",
        "id": 153831474,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1464953036
    },
    {
        "content": "<p>this is too interesting</p>",
        "id": 153831475,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464953045
    },
    {
        "content": "<p>we used to use oracle in the 90's because it had <code>connect by</code></p>",
        "id": 153831476,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464953063
    },
    {
        "content": "<p>which was way too slow compared with a \"transitive closure\" table</p>",
        "id": 153831477,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464953100
    },
    {
        "content": "<p>Using the Pearl Script supplied by IHTSDO, it takes less than a minute to generate the closure table for the international edition of SCT - on my 64 bit server with lots of RAM. It takes at least 5 mins on my 32 bit test machine.</p>",
        "id": 153831478,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464953175
    },
    {
        "content": "<p>yes, I think \"connect by\" is a great feature - I've made extensive use of it for this sort of thing<br>\nlike building a \"closure table\" (althought I didn't call it that at first) on the fly (\"just in time\")</p>",
        "id": 153831479,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1464953179
    },
    {
        "content": "<p>but looking at this... <a href=\"http://hl7-fhir.github.io/terminology-service.html\" target=\"_blank\" title=\"http://hl7-fhir.github.io/terminology-service.html\">http://hl7-fhir.github.io/terminology-service.html</a> <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> I am thinking the \"incremental build\" component of the \"closure\" operation just seems erm non-core ?</p>",
        "id": 153831480,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464953246
    },
    {
        "content": "<p>a certainly see the generation of the initial table as a core feauture tho...</p>",
        "id": 153831481,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464953337
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192001\">@Erich Schulz</span> yes, the pre-computed full closure table is significantly faster than doing a hierarchical query each time - that's why we adopted the caching approach which builds the closure table as needed, rather than pre-computing all of it, most of which will never be used<br>\njust a different approach</p>",
        "id": 153831482,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1464953414
    },
    {
        "content": "<p>yes I can see the rationale for serving a subset</p>",
        "id": 153831483,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464953455
    },
    {
        "content": "<p>it was the incremental building of a subsets I was questioning...</p>",
        "id": 153831486,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464953623
    },
    {
        "content": "<p>(at least as part of core API )</p>",
        "id": 153831489,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464953718
    },
    {
        "content": "<p>mainly because it imposes a burden on the server to track its previous messages to clients in a pattern that may not scale awfully well and introduces a bunch of complexities around \"time to live\"</p>",
        "id": 153831491,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464953804
    },
    {
        "content": "<p>I'm having a look at ontoserver <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> - it looks way more cut-down than <a href=\"http://hl7-fhir.github.io/terminology-service.html\" target=\"_blank\" title=\"http://hl7-fhir.github.io/terminology-service.html\">http://hl7-fhir.github.io/terminology-service.html</a></p>",
        "id": 153831492,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464954799
    },
    {
        "content": "<p>The transitive closure table generated from the 20160131 snapshot version of the SCT International Edition has 5,470,090 rows!</p>",
        "id": 153831493,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464954811
    },
    {
        "content": "<p>so if was stored as pair of 64bit bytes...</p>",
        "id": 153831494,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464954857
    },
    {
        "content": "<p>that is ~25M</p>",
        "id": 153831495,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464954891
    },
    {
        "content": "<p>I dont't think ontoserver is much cut down. It does everything that we've worked through so far</p>",
        "id": 153831496,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464955234
    },
    {
        "content": "<p>Storage is cheap, it's all about memory.  The table has 2 columns of SCTIDs - IHTSDO recommend that these are persisted as 64 bit integers, but as they aren't true numbers I store them as chars and I know others who do likewise.</p>",
        "id": 153831497,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464955262
    },
    {
        "content": "<p>I think that the incremental closure table is wroth having. it is more work for the server, but we've always said that's a good deal for the client</p>",
        "id": 153831498,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464955273
    },
    {
        "content": "<p>I store the closure table as an array of pairs of 4 byte unisgned int, which each 4 bytes is a look up to an array of string values that represent the codes</p>",
        "id": 153831499,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464955344
    },
    {
        "content": "<p>are many systems doing this currently?</p>",
        "id": 153831500,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464955347
    },
    {
        "content": "<p>but I don't use a database for this. </p>",
        "id": 153831501,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464955363
    },
    {
        "content": "<p>not many, but all the terminology servics have had to do something about this problem in order to support integrated search across terminologies and other things</p>",
        "id": 153831502,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464955416
    },
    {
        "content": "<p>...but what's the trigger for clients to request updates when the server refreshes the closure table?</p>",
        "id": 153831503,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464955419
    },
    {
        "content": "<p>given it is a 45 second operation to rebuild the entire thing and releases come out once a month? (max) I'm struggling to see a high ROI...</p>",
        "id": 153831504,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464955472
    },
    {
        "content": "<p>because you can't build it in advance</p>",
        "id": 153831505,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464955505
    },
    {
        "content": "<p>(just to emphasis am talking about incremental builds... not subseting... subsetting is gold)</p>",
        "id": 153831506,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464955530
    },
    {
        "content": "<p>unless you prohibit post-coordination. which everyone does, but it cripples the tx</p>",
        "id": 153831507,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464955534
    },
    {
        "content": "<p>do you have link for ontoserver subsumption test?</p>",
        "id": 153831508,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464955604
    },
    {
        "content": "<p>the $validate option... what link do you want?</p>",
        "id": 153831509,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464955652
    },
    {
        "content": "<p>Things will be trickier if/when IHTSDO move to more frequent SCT releases.</p>",
        "id": 153831510,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464955684
    },
    {
        "content": "<p>mmm </p>",
        "id": 153831511,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464955720
    },
    {
        "content": "<p>it's a solvable problem. I've got to write a client to help the ontoserver guys test their closure table</p>",
        "id": 153831512,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464955745
    },
    {
        "content": "<p>i guess I'm just flagging 80:20 situation...</p>",
        "id": 153831513,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464955756
    },
    {
        "content": "<p>perhaps opportunity to have inititial simple API definition then a second wave?</p>",
        "id": 153831514,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464955794
    },
    {
        "content": "<p>then you don't follow what the 80:20 is about. </p>",
        "id": 153831515,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464955809
    },
    {
        "content": "<p>?</p>",
        "id": 153831516,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464955992
    },
    {
        "content": "<p><a href=\"http://www.clipular.com/c/4745096286699520.png?k=oAARjjxSNY7fDU3cgP6HeFBTC2E\" target=\"_blank\" title=\"http://www.clipular.com/c/4745096286699520.png?k=oAARjjxSNY7fDU3cgP6HeFBTC2E\">http://www.clipular.com/c/4745096286699520.png?k=oAARjjxSNY7fDU3cgP6HeFBTC2E</a></p>\n<div class=\"message_inline_image\"><a href=\"http://www.clipular.com/c/4745096286699520.png?k=oAARjjxSNY7fDU3cgP6HeFBTC2E\" target=\"_blank\" title=\"http://www.clipular.com/c/4745096286699520.png?k=oAARjjxSNY7fDU3cgP6HeFBTC2E\"><img src=\"http://www.clipular.com/c/4745096286699520.png?k=oAARjjxSNY7fDU3cgP6HeFBTC2E\"></a></div>",
        "id": 153831517,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464955994
    },
    {
        "content": "<p>all the terminology servers implement some kind of feature for managing a closure table</p>",
        "id": 153831518,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464956061
    },
    {
        "content": "<p>sure</p>",
        "id": 153831520,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956087
    },
    {
        "content": "<p>I can only repeat...</p>",
        "id": 153831521,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956095
    },
    {
        "content": "<p>transitive closure table = gold</p>",
        "id": 153831522,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956110
    },
    {
        "content": "<p><strong>incremental building</strong> of client-server building of TCT is in a different plane</p>",
        "id": 153831523,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956170
    },
    {
        "content": "<p>not saying its bad...</p>",
        "id": 153831524,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956210
    },
    {
        "content": "<p>then you don't need to consume it. nor worry about it. </p>",
        "id": 153831525,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464956218
    },
    {
        "content": "<p>just saying that today its only implemented by a single server...</p>",
        "id": 153831526,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956245
    },
    {
        "content": "<p>sorry not trying to be difficult </p>",
        "id": 153831527,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956318
    },
    {
        "content": "<p>the concern is I go looking for the resource on the ontoserver and it isn't there</p>",
        "id": 153831528,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956354
    },
    {
        "content": "<p>even the base resource as far as I can see</p>",
        "id": 153831529,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956366
    },
    {
        "content": "<p>which base resource? </p>",
        "id": 153831530,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464956376
    },
    {
        "content": "<p>for a transitive closure table</p>",
        "id": 153831531,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956391
    },
    {
        "content": "<p>you mean ConceptMap?</p>",
        "id": 153831532,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464956427
    },
    {
        "content": "<p>they have the transitive closure table expressed with conceptmap??</p>",
        "id": 153831533,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956463
    },
    {
        "content": "<p>concept map is part of it, but I wasn't sure what you meant. But they haven't implemented closure API yet</p>",
        "id": 153831534,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464956496
    },
    {
        "content": "<p>k</p>",
        "id": 153831535,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956504
    },
    {
        "content": "<p>so what I'm thinking is if the base spec is simple then that implementation can occur more rapidly</p>",
        "id": 153831536,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956531
    },
    {
        "content": "<p>because I can write a script to make my own</p>",
        "id": 153831537,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956570
    },
    {
        "content": "<p>well, simple problems are simple. yes. And a client can just do subsumption testing directly, no problems</p>",
        "id": 153831538,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464956573
    },
    {
        "content": "<p>...and store the results each time it requests a new test...and (possibly) be aware (somehow) when the server loads a new version of the code system that might make its cached results redundant. Which begs the question, why does the server need to maintain a record of client closures?</p>",
        "id": 153831540,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464956792
    },
    {
        "content": "<p>i'm thinking it could be useful to have a table of the current servers and the services they provide...</p>",
        "id": 153831542,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464956977
    },
    {
        "content": "<p>if the server doesn't know what subset the client is dealing with, it must return the close for everything, but everything is not finite </p>",
        "id": 153831543,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464956984
    },
    {
        "content": "<p>yes that is true</p>",
        "id": 153831544,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464957011
    },
    {
        "content": "<p>so somehow the client needs to identify the subset it is interested in</p>",
        "id": 153831545,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464957035
    },
    {
        "content": "<p>i agree that is core functionality</p>",
        "id": 153831546,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464957058
    },
    {
        "content": "<p>well, it can build it gradually, or it can accelerate the process </p>",
        "id": 153831548,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464957077
    },
    {
        "content": "<p>what I'm suggesting may not be core is incremental expansion of the TCT...</p>",
        "id": 153831550,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464957092
    },
    {
        "content": "<p>the key words being \"incremental expansion\"</p>",
        "id": 153831551,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464957114
    },
    {
        "content": "<p>I'm still missing something here. Although I fully understand why a client needs to persist the results of individual subsumption queries, I can't see the need for a server to (effectively) maintain a record of those results - what value does that add, e.g. does it make it any easier for the client to be made aware when those results may be superseded by a code system update? What's the value proposition for this additional complexity?</p>",
        "id": 153831552,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464957612
    },
    {
        "content": "<p>it would save some bandwidth...</p>",
        "id": 153831553,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464957709
    },
    {
        "content": "<p>the key point is how the client becomes aware that it needs to rebuild its stored transitive closure subset, because the code system has been updated</p>",
        "id": 153831556,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1464958143
    },
    {
        "content": "<p>an expiry date? or a \"last-updated\" service?</p>",
        "id": 153831557,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464958192
    },
    {
        "content": "<p>there are also tools like rsync and git that eat incremental updating for breakfast</p>",
        "id": 153831559,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464958771
    },
    {
        "content": "<p>building this functionality into the core services seems to violate the \"do one thing well\" principle</p>",
        "id": 153831560,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464958842
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> that key point applies to all use cases where a client persists the results of SNOMED CT queries.  <span class=\"user-mention\" data-user-id=\"192001\">@Erich Schulz</span> - SNOMED CT updates can either add or inactivate concepts and relationships - versioning is based on the active/inactive status at the specified release date (effective time). Concepts can be activated, deactivated and reactivated - but never deleted.</p>\n<p>From a client perspective, I'd persist the relevant CodeSystem version and periodically check it with the one returned by the Terminology Server. When there's a new version, I'd refresh all the persisted query results - subsumptions or otherwise. Therefore, from an EHR/EMR service perspective, I still don't see a use case for a separate, and distinct, process for closure subsets. However, it would be informative to understand the requirements of other categories of terminology service client.</p>",
        "id": 153831615,
        "sender_full_name": "Peter Jordan",
        "timestamp": 1464988850
    },
    {
        "content": "<p>I agree, Peter.  I think your suggestion is reasonable, and similar to what I've implemented before (although with an \"internal\" terminology server, rather than an external API).  I think you may be right about the need, and the means of achieving it.  Yes, we need to consider all (known) client perspectives.  I've been intending to spend some time looking at $closure in greater depth, and this discussion is good impetus for doing that. </p>",
        "id": 153831618,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1464991417
    }
]