[
    {
        "content": "<p>In this report (<a href=\"https://onfhir.hl7.org/2016/05/20/fhir-meeting-report-montreal-may-2016/\" target=\"_blank\" title=\"https://onfhir.hl7.org/2016/05/20/fhir-meeting-report-montreal-may-2016/\">https://onfhir.hl7.org/2016/05/20/fhir-meeting-report-montreal-may-2016/</a>) it states that STU3 will plan to address \"Introduction of RDF, tied to an ontological base\".<br>\nI'm assuming the latter \"ontological base\" is the RIM ? (as expressed in the RIM.ttl document)</p>",
        "id": 153829137,
        "sender_full_name": "Renato Iannella",
        "timestamp": 1463963469
    },
    {
        "content": "<p>more generally, i meant, there's an RDF  format, and it will be supported by fhir.ttl which provides a set of definitions that allow you to reason with the turtle format and rim.ttl which provides some ontology, and that this will be base to build further ontology bindings on</p>",
        "id": 153829141,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463964758
    },
    {
        "content": "<p>note, though, that actually building ontology bindings is hard work - the ontologies are very unrelated to what FHIR is trying to do. Surprisingly so, to me</p>",
        "id": 153829142,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463964789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> - all that you wrote doens't address the question. </p>",
        "id": 153829143,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463964820
    },
    {
        "content": "<p>take this example:</p>",
        "id": 153829144,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463964824
    },
    {
        "content": "<div class=\"codehilite\"><pre> fhir:Observation.code [\n     fhir:CodeableConcept.coding [\n       fhir:index 0;\n       fhir:concept loinc:29463-7;\n       fhir:Coding.system [ fhir:value &quot;http://loinc.org&quot; ];\n       fhir:Coding.code [ fhir:value &quot;29463-7&quot; ];\n       fhir:Coding.display [ fhir:value &quot;Body Weight&quot; ]\n     ], [\n       fhir:index 1;\n       fhir:concept loinc:3141-9;\n       fhir:Coding.system [ fhir:value &quot;http://loinc.org&quot; ];\n       fhir:Coding.code [ fhir:value &quot;3141-9&quot; ];\n       fhir:Coding.display [ fhir:value &quot;Body weight Measured&quot; ]\n     ], [\n       fhir:index 2;\n       fhir:concept sct:27113001;\n       fhir:Coding.system [ fhir:value &quot;http://snomed.info/sct&quot; ];\n       fhir:Coding.code [ fhir:value &quot;27113001&quot; ];\n       fhir:Coding.display [ fhir:value &quot;Body weight&quot; ]\n     ], [\n       fhir:index 3;\n       fhir:Coding.system [ fhir:value &quot;http://acme.org/devices/clinical-codes&quot; ];\n       fhir:Coding.code [ fhir:value &quot;body-weight&quot; ];\n       fhir:Coding.display [ fhir:value &quot;Body Weight&quot; ]\n     ]\n  ];\n</pre></div>",
        "id": 153829145,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463964862
    },
    {
        "content": "<p>you say: \"The concept absolutely *must* exist at the CodeableConcept level - because that's the semantic.\" - but no, the semantic is that the codings have the links to the terminologies. that they aggregate meaning on the CodeableConcept is something we derive. And so can a reasoner</p>",
        "id": 153829146,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463964977
    },
    {
        "content": "<p>Yes, the codings have links to the terminologies.  But, for a CodeableConcept, the *meaning* of the code accrues at the level of the CodeableConcept.  The Observation.code is the body weight.  That's where the reasoning needs to happen.  And more specifically, the concept expressed by the code is the intersection of all of the concepts represented by the codings</p>",
        "id": 153829148,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463965258
    },
    {
        "content": "<p>all that is true, but not addressing the point</p>",
        "id": 153829152,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463966400
    },
    {
        "content": "<p>What's the point then?  The concept shouldn't be declared on the instances because the conversion tool can't possibly know all the terminologies, and for most servers, loading all of SNOMED just to convert data from XML to RDF is too heavy anyhow.  When the concept is introduced, it's going to need to be introduced as a characteristic of Observation.code - where the reasoning needs to happen.</p>",
        "id": 153829156,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463966994
    },
    {
        "content": "<p>at least, we're getting to the core! yay</p>",
        "id": 153829157,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463967040
    },
    {
        "content": "<p>what does it matter where it's declared if the conversion tool doesn't know the terminologies? </p>",
        "id": 153829158,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463967060
    },
    {
        "content": "<p>and what does the size of snomed have to do whith where it's introduced?</p>",
        "id": 153829159,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463967084
    },
    {
        "content": "<p>We want to make it easy to convert between XML, JSON and RDF.  RDF should be \"just another serialization\" handled by the reference implementations.  And we'd like to make generating it as low overhead as possible so that most servers will support it.</p>",
        "id": 153829160,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463967391
    },
    {
        "content": "<p>yep. we do indeed. so what's your point? </p>",
        "id": 153829161,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463967439
    },
    {
        "content": "<p>Expecting servers to include the \"concept\" element - which requires having copies of the (sometimes large) terminologies and intricate knowledge of how they work is not conducive to that end.</p>",
        "id": 153829162,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463967442
    },
    {
        "content": "<p>... so? </p>",
        "id": 153829163,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463967455
    },
    {
        "content": "<p>So, we shouldn't be doing it by default, nor showing it as expected practice in the examples or documentation.  We can note it as an optional alternative.</p>",
        "id": 153829164,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463967489
    },
    {
        "content": "<p>doing what? </p>",
        "id": 153829165,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463967553
    },
    {
        "content": "<p>your argument here is curiously unfocused. The specific question is that the committee decided that fhir:concept only goes on Coding, not on CodeableConcept. You're passionately opposed to ... something.... but I'm not sure what it is you're opposed to </p>",
        "id": 153829166,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463968221
    },
    {
        "content": "<p>I'm making several arguments:<br>\n1. fhir:concept should not appear in the examples in the spec except as a special case because it's not something any implementer can count on being in the RDF<br>\n2. fhir:concept needs to appear on the structure in the instance that corresponds to the concept.  In the case of a CodeableConcept, that's at the CodeableConcept level.  It's the Observation.code that's being declared to be \"body weight\" - that's where the reasoning needs to happen.  The reasoning happens at the attribute level.  The whole purpose of the root level of CodeableConcept is to represent the concept.</p>",
        "id": 153829167,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463968443
    },
    {
        "content": "<p>#1 I don't see why we shouldn't add it in the examples so implementers can see where it goes. </p>\n<p>#2. You haven't begun to make a coherent case for this. As you said, the codings have the link to the terminology, and the meaning accrues to the CodeableConcept. So that's what the RDF should say - fhir:concept on the Coding, the reasoner infers it on the CodeableConcept </p>",
        "id": 153829168,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463968564
    },
    {
        "content": "<p>#1 - add it in one example that deals with it explicitly.  But adding it everywhere is going to lead people to think they can/should expect it, but they can't.</p>",
        "id": 153829169,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463968841
    },
    {
        "content": "<p>The reasoner needs to infer it in the first place.  So why infer it somewhere other than where it needs to be?</p>",
        "id": 153829170,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463968886
    },
    {
        "content": "<p>If we're going to go through the work of including it in the instance so it doesn't have to be inferred, why not put it where it needs to be?</p>",
        "id": 153829171,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463968921
    },
    {
        "content": "<p>but see, that's what I think - put it where it makes sense. There's some ontological confusion here, perhaps. As for the example, it's really trivial, if you know the syntax transform, to put it everywhere. really, trivial. I don't see why it wouldn't be expected for the common public terminologies</p>",
        "id": 153829172,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463969308
    },
    {
        "content": "<p>It makes sense to be where you have to reason.  And when you reason, you're reasoning on Observation.code, not one of the codings.  All of the concepts are in play simultaneously.  </p>",
        "id": 153829173,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463969604
    },
    {
        "content": "<p>It shouldn't be expected for the common public terminologies because that presumes that the converters are aware of the rules for all of the terminologies.  Why would we require injection of extra knowledge (knowledge that will continuously be evolving) into what should be a simple wire format transformation?  If we put it in the converters, that's just going to produce an ongoing maintenance issue.</p>",
        "id": 153829174,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463969693
    },
    {
        "content": "<p>you keep saying that. But there's an underlying assumption: you can't reason at that level if the fhir:concept is on the Coding, not the CodeableConcept. I believe that's what the committee disagreed with. so merely hammering away on that point is not going to move the discussion along</p>",
        "id": 153829175,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463969696
    },
    {
        "content": "<p>\"knowledge that will continuously be evolving\" - well,we have already been asked to fix the way it works for SCT and loinc. </p>",
        "id": 153829176,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463969771
    },
    {
        "content": "<p>If you can infer from Coding to CodeableConcept, then you can reason either way.  But if you need to do the reasoning at the COdeableConcept level, then why would you populate it somewhere else.</p>",
        "id": 153829177,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463970131
    },
    {
        "content": "<p>so that you can reason from it at the Coding level. Cause you can infer up, but not down</p>",
        "id": 153829178,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463970156
    },
    {
        "content": "<p>And SNOMED and LOINC are a small set of the terminologies people will want supported.  Everyone will ask us to add one more.  Or change to support how they do it in a new version or whatever.</p>",
        "id": 153829180,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463970178
    },
    {
        "content": "<p>so, that's what interoperability means. </p>",
        "id": 153829181,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463970212
    },
    {
        "content": "<p>You can infer it in the first place just from the data - given the code &amp; system, you can infer it at either level.  But if we're going to put it in the instance, put it where it needs to be.</p>",
        "id": 153829182,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463970223
    },
    {
        "content": "<p>But adding supplemental data that's necessary for specific processing should be done by post-processing by those who know what they actually need, not by us (and everyone else) continuously needing to update what's supposed to be a simple wire format conversion.</p>",
        "id": 153829183,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463970287
    },
    {
        "content": "<p>It's about separation of concerns.</p>",
        "id": 153829184,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463970299
    },
    {
        "content": "<p>Keep things simple for those who don't care about RDF, but are willing to at least expose it if we keep it low effort.  Put the complexity of managing all the differences between URIs for different code systems in the pre-processing software for those systems that actually care about it and need it.</p>",
        "id": 153829185,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463970351
    },
    {
        "content": "<p>to which you tie: 'and refuse to offer those systems any standardization'</p>",
        "id": 153829186,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463970391
    },
    {
        "content": "<p>?  We have standardized the property name to use.  Each terminology is responsible for standardizing the URL.  (We can publish the ones we know of in either the CodeSystem or NamingSystem).  Providing conversion code != standardization.</p>",
        "id": 153829187,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463970572
    },
    {
        "content": "<p>you just said we shouldn't. I can't keep up with you today. You keep changing your mind</p>",
        "id": 153829188,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463970594
    },
    {
        "content": "<p>\"You can infer it in the first place just from the data - given the code &amp; system, you can infer it at either level. But if we're going to put it in the instance, put it where it needs to be\" - I can see we're just not going to agree. I tried. You can take it up with committee. But my opinion is that you're not making sense. and just trying to drown the actual point with too much noise. </p>",
        "id": 153829189,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463970653
    },
    {
        "content": "<p>We *should* standardize the name of the property.  We *should* include a subsection of the spec that declares that and shows where it goes.  We *shouldn't* put it in the specification anywhere other than that spot or in the example instances we generate.  That ensures that the conversion process between XML/JSON/RDF is simple and low-maintenance and also ensures implementers don't come to rely on something that won't necessarily be supported.</p>",
        "id": 153829190,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463970944
    },
    {
        "content": "<p>Is that sufficiently clear?</p>",
        "id": 153829191,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463970957
    },
    {
        "content": "<p>we've also been asked to say what the right representation of the fhir:concept predicate is for SCT and LOINC as well, based on their published ontologies. I don't see why we shouldn't do that</p>",
        "id": 153829192,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463971146
    },
    {
        "content": "<p>Sure - happy to include that on the terminology page for each of those code systems</p>",
        "id": 153829193,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463971219
    },
    {
        "content": "<p>And in general, I'd expect it to be an optional descriptive property or extension on either NamingSystem or CodeSystem.</p>",
        "id": 153829194,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463971257
    },
    {
        "content": "<p>don't know that it can be computable</p>",
        "id": 153829195,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463971296
    },
    {
        "content": "<p>It can't.  That why I said \"descriptive\" - it'd be a textual explanation</p>",
        "id": 153829196,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463971727
    },
    {
        "content": "<p>good. So the only point of contention is the original one! you can take that up with committee. </p>",
        "id": 153829197,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463972339
    },
    {
        "content": "<p>Do you agree that reasoners will need the concept at the attribute level in all cases?</p>",
        "id": 153829198,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463972378
    },
    {
        "content": "<p>nup. I don't agree. It belongs on the Coding, where it can inferred up if appropriate. </p>",
        "id": 153829199,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463972422
    },
    {
        "content": "<p>you probably have to infer it up 2 levels, actually, in general, to the resource itself </p>",
        "id": 153829200,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463972444
    },
    {
        "content": "<p>gad</p>",
        "id": 153829202,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463983793
    },
    {
        "content": "<p>bit lost...</p>",
        "id": 153829204,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463984205
    },
    {
        "content": "<p>instance of what?</p>",
        "id": 153829205,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463984224
    },
    {
        "content": "<p>Inferring two levels up can't work in general.  In theory you can with the .code elements, but that doesn't apply to everything else.  You can't say that the Observation \"is a\" Observation.value or \"is a\" Observation.site.  And it's tenuous to say the Observation \"is a\" Observation.code.  So pushing the concepts anywhere other than the attribute is generally inappropriate.  While it being on the Coding as well isn't necessarily harmful, it's not helpful unless the attribute has a type of Coding.  That's the only time where it makes sense to reason on a concept at the Coding level.</p>",
        "id": 153829206,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463984385
    },
    {
        "content": "<p>if it helps <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> I can say I am completely not following you either</p>",
        "id": 153829207,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463984517
    },
    {
        "content": "<p>sorry I'm a complete FHIR noob - but I get semantic networks and relational databases...</p>",
        "id": 153829208,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463984556
    },
    {
        "content": "<p>perhaps some examples could help?</p>",
        "id": 153829209,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463984653
    },
    {
        "content": "<p>this smell a bit like one of those issues that arise when then notions of \"is a\" and \"part of\" are being conflated</p>",
        "id": 153829210,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463984703
    },
    {
        "content": "<p>because if you have a pure taxonomy or meronomy you can infer up and down as many levels as you like...</p>",
        "id": 153829211,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463984764
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192001\">@Erich Schulz</span> In this case, we definitely have a \"part of\" relationship, not an \"is a\" relationship.  Specifically, Observation.code is <em>part</em> of Observation and Coding is <em>part</em> of CodeableConcept.  So we can't, in general, infer that the Concept implied at one level exists at a higher level.  Things are a little bit different though for Coding and CodeableConcept.  You can argue that the Concept holds for the Coding as well as the CodeableConcept, but it's at the CodeableConcept level where the concept is relevant.  You want to test \"is the Observation.code a body weight?\", not \"Does the Observation.code contain any codings that are body weights\".</p>",
        "id": 153829212,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1463985007
    },
    {
        "content": "<p>mmm these are all a bit nested...</p>",
        "id": 153829213,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463985348
    },
    {
        "content": "<p>i'm just making screen shots of the three levels...</p>",
        "id": 153829214,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463985528
    },
    {
        "content": "<p>memory like seive</p>",
        "id": 153829215,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463985555
    },
    {
        "content": "<p>ok</p>",
        "id": 153829216,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463985745
    },
    {
        "content": "<p>ok so I get your comment at 4:30 now</p>",
        "id": 153829217,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463985837
    },
    {
        "content": "<p>so what's the issue then?</p>",
        "id": 153829218,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463985892
    },
    {
        "content": "<p>(picture here btw <a href=\"https://docs.google.com/document/d/1SJrjKq4ljfkDpNDtRxI4UHMMxRwTq6LZGMXU63Fsoc4/edit?usp=sharing\" target=\"_blank\" title=\"https://docs.google.com/document/d/1SJrjKq4ljfkDpNDtRxI4UHMMxRwTq6LZGMXU63Fsoc4/edit?usp=sharing\">https://docs.google.com/document/d/1SJrjKq4ljfkDpNDtRxI4UHMMxRwTq6LZGMXU63Fsoc4/edit?usp=sharing</a>)</p>",
        "id": 153829219,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463985948
    },
    {
        "content": "<p>it seems to me that the meaning of <code>observation.code</code>, <code>observation.code.coding</code>and (<code>observation.code.coding.system</code>, <code>observation.code.coding.version</code> and <code>observation.code.coding.code</code>) *should* be the same</p>",
        "id": 153829221,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463986441
    },
    {
        "content": "<p>(if Lloyd's earlier comments about multiple coding being synonyms is correct)</p>",
        "id": 153829222,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463986477
    },
    {
        "content": "<p>but the real meaning is expressed (potential in several forms) at the level of <code>observation.code.coding</code></p>",
        "id": 153829223,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463986559
    },
    {
        "content": "<p>the existance of sobservation.code<code>s with just a</code>text<code>attribute and no</code>coding` is a bit of speed-bump tho...</p>",
        "id": 153829224,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463986758
    },
    {
        "content": "<p>or existance where <code>coding</code> and <code>text</code> have divergant means (have to love users)</p>",
        "id": 153829225,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463986788
    },
    {
        "content": "<p>But <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> first you said that you can't infer partOf relationships, then you said you could. Now I am confused ;-)</p>",
        "id": 153829226,
        "sender_full_name": "Renato Iannella",
        "timestamp": 1463986800
    },
    {
        "content": "<p>sometimes you can <span class=\"user-mention\" data-user-id=\"191833\">@Renato Iannella</span> </p>",
        "id": 153829227,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463987024
    },
    {
        "content": "<p>\"does this person have an arm injury\"?</p>",
        "id": 153829228,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463987043
    },
    {
        "content": "<p>finger is part of arm, therefore fracture finger is arm injury...</p>",
        "id": 153829229,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463987068
    },
    {
        "content": "<p>the thing about this topic is that <code>codeableconcept</code> defines a set of ways that should have the same meaning...</p>",
        "id": 153829230,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463987191
    },
    {
        "content": "<p>so in a way the parts should all equal the whole...</p>",
        "id": 153829231,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463987213
    },
    {
        "content": "<p>but <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> i'm just reading \"The different codings may have slightly different granularity due to the differences in the definitions of the underlying codes. \" from <a href=\"http://rhausam.no-ip.org/fhir/datatypes.html#CodeableConcept\" target=\"_blank\" title=\"http://rhausam.no-ip.org/fhir/datatypes.html#CodeableConcept\">here</a></p>",
        "id": 153829232,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463987304
    },
    {
        "content": "<p>CodeableConcept is the \"type-system\" for FHIR Resources?</p>",
        "id": 153829233,
        "sender_full_name": "Renato Iannella",
        "timestamp": 1463987366
    },
    {
        "content": "<p>it is a FHIR data type used by FHIR resources</p>",
        "id": 153829234,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463987432
    },
    {
        "content": "<p>but i'm still not sure what Llyod and Grahame's debate was about</p>",
        "id": 153829235,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1463987554
    },
    {
        "content": "<p>Then...*semantically* you want to infer (or express) that the *Observation* is a \"body weight\" ?? (not that part of the Observation is a \"body weight\")</p>",
        "id": 153829236,
        "sender_full_name": "Renato Iannella",
        "timestamp": 1463988015
    },
    {
        "content": "<p>right. Lloyd is confusing is-a with reasoning, so far as I can tell. </p>",
        "id": 153829265,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463997424
    },
    {
        "content": "<p>Observation.code is a CodeableConcept - so it can have one more codes, or just text. Obviously, it would be greatly easier to reason with if it was just a code, instead of the messy loose structure that is CodeableConcept. But we know from long hard experience that life cannot be so simple in many cases</p>",
        "id": 153829266,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463997490
    },
    {
        "content": "<p>so <br>\nObservation has-defining-code Observation.code<br>\nObservation.code has-parts Observation.code.coding</p>\n<p>where the coding is the actual link to the terminology. (I nearly wrote ontology there...)</p>",
        "id": 153829267,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463997540
    },
    {
        "content": "<p>we've agreed that one of one of the RDF properties of Coding is fhir:concept, which is a URI that links to the ontological representation of the terminology - if that is defined. </p>",
        "id": 153829268,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463997582
    },
    {
        "content": "<p>we debated making that relationship rdfs:type, but we say that it is not an rdfs:type relationship, at least not generically. A processor may find it useful to say that a fhir:concept relationship to a particular ontology is the same as an rdfs:type relationship, and elevate it accordingly, but we do not forcefully claim that this is so in all cases</p>",
        "id": 153829269,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463997756
    },
    {
        "content": "<p>Lloyd is arguing that because you have to reason about meaning at the Observation.code level, you must therefore explicitly assert the fhir:concept links at that level, but I argue that this is wrong - you should assert them on the coding, where they are actually established, and then a reasoner must understand the relationship between the CodeableConcept and it's parts and draw it's own inferences</p>",
        "id": 153829270,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463997845
    },
    {
        "content": "<p>Note that Lloyd and are switched around from our default positions - he's arguing for something that makes it easier for implementers, and I'm arguing for the harder but more correct option. In this, I do this because RDF is about correctness, not ease. </p>",
        "id": 153829271,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463997889
    },
    {
        "content": "<p>Lloyd has also argued that reasoners can't pull the relationship up from the parts to the container. That doesn't make sense to me, though the only 'reasoner' I work with is sparql. It's just another statement for me. But I argue that you can't reason with just the Observation.code anyway. You have to cross-consider the status at least. And possibly category, and probably dataAbsentReason, and maybe Observation.component.code</p>",
        "id": 153829272,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1463998098
    },
    {
        "content": "<p>There's no notion of \"has-defining-code\" in the model, so we can't distinguish between defining codes and all of the other coded attributes.  Unless and until we do that, we can't make an assertion that \"Observation 'is a' Body weight\".  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> argues for asserting the knowledge at the place in the instance where it's inferred as opposed to the place where it's needed for reasoning.  I don't understand why that's \"more correct\".  From a correctness perspective, the semantic of \"Observation.code 'is a' Body weight\" is absolutely true according to the semantics of how CodeableConcept is intended to work.  In the past, I've expressed concern not about the ability of reasoners to pull the semantic up, but rather to pull it up only when needed and not when not needed.  Sometimes the \"concept\" needs to live at the Coding level because there's no parent CodeableConcept.  Sometimes the \"concept\" needs to propagate up to the parent because there <em>is</em> a CodeableConcept - and the concept is going to be needed on the type that actually represents the notion of \"concept\"</p>",
        "id": 153829276,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1464009889
    },
    {
        "content": "<p>woah: the solution to 'rather to pull it up only when needed and not when not needed' is ... to push it up always!</p>",
        "id": 153829279,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464011699
    },
    {
        "content": "<p>but i said I wasn't going to pursue this anymore, so I won't. Argue with the committee.</p>",
        "id": 153829280,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464011769
    },
    {
        "content": "<p>Ultimately, I think the \"concept\" (in the broad sense, not necessarily fhir:concept) needs to be associated with (or \"live at\") the element level - the coded data type, whether it's CodeableConcept, Coding or code, is simply a means of making that association, via the binding.  It's actually at the element level that the reasoning should occur, but associating the \"concept\" at that level can be done (at least theoretically) by reasoning from the representation in the data type instance.  It will be really \"interesting\" when we try to do that from a CodeableConcept  with multiple Codings from different terminologies, that are supposed to be representing the same \"concept\", but are doing it with \"slightly different granularity\", as the spec states and Erich noted.  If the codings are actually in conflict (not sure if \"the intersection of all of the concepts represented by the codings\" is the correct notion here?), then ideally the reasoner would be able to detect the error (i.e. the class is unsatisfiable).</p>",
        "id": 153829302,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1464020515
    },
    {
        "content": "<p>ok so this debate is limited to how to tie <code>observations</code> to <code>RDF</code>?</p>",
        "id": 153829390,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464049723
    },
    {
        "content": "<p>or probably more accurately <code>CodeableConcept</code> to <code>RDF</code>?</p>",
        "id": 153829391,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464049756
    },
    {
        "content": "<p>in that case I would observe that I could write all I know of RDF on back of coffee receipt :-)</p>",
        "id": 153829392,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464049988
    },
    {
        "content": "<p>it would seem to me that the \"cleanest\" way to specify a link, however, would be to do it *once* at the <code>CodeableConcept</code> level - eg <code>Observation.code</code></p>",
        "id": 153829393,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464050105
    },
    {
        "content": "<p>in general health structures are complex and if any reasoner cant cope with that then perhaps they shouldn't be </p>",
        "id": 153829394,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464050165
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192001\">@Erich Schulz</span> Or even FHIR \"Resource\" to RDF</p>",
        "id": 153829404,
        "sender_full_name": "Renato Iannella",
        "timestamp": 1464052027
    },
    {
        "content": "<p>If we look at another Resource, say Specimen, it has a type property for the \"kind of material\" which is a CodeableConcept.<br>\nIn the RDF world, you would model this using rdf:type. That is, an Specimen individual would use a terminology URI as its rdf:type. Reasoners then do not have to use an arbitrary property (in this case \"type\", others \"code\", and \"category\"..) to make any inferences.</p>",
        "id": 153829406,
        "sender_full_name": "Renato Iannella",
        "timestamp": 1464052730
    },
    {
        "content": "<p>i'm well out of experience zone here...</p>",
        "id": 153829411,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464053327
    },
    {
        "content": "<p>but how much is RDF used for complex JSON feeds?</p>",
        "id": 153829412,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464053349
    },
    {
        "content": "<p>and is it even a relevant technology here?</p>",
        "id": 153829413,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464053396
    },
    {
        "content": "<p>what FHIR is modelling is far more complex than booking a hotel or hiring a car...</p>",
        "id": 153829414,
        "sender_full_name": "Erich Schulz",
        "timestamp": 1464053471
    },
    {
        "content": "<p>Renato, I do not think it's ever so simple as this. yes, Specimen has a property type which is of type CodeableConcept. but given the definition of rdf:type:</p>",
        "id": 153829417,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464054119
    },
    {
        "content": "<p>rdf:type is an instance of rdf:Property that is used to state that a resource is an instance of a class</p>",
        "id": 153829418,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464054119
    },
    {
        "content": "<p>it's wrong to state that \"a specimen with a type of 'urine'\" is \"an instance of the class of urine\". there are several respects in which I think that's not an accurate statement</p>",
        "id": 153829419,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464054222
    },
    {
        "content": "<p>I think it's appropriate to make reasoners work harder to grapple with what is really going on rather than to present them with a simplified - and wrong - view of the world which is only useful given a particular set of assumptions</p>",
        "id": 153829420,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464054513
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> happy to hear why you think this is not accurate:  \"a specimen with a type of 'urine'\" is \"an instance of the class of urine\".</p>",
        "id": 153829422,
        "sender_full_name": "Renato Iannella",
        "timestamp": 1464054840
    },
    {
        "content": "<p>first of all there's the difference between the record and the thing. The resource is the record of the specimen, not the specimen itself. Then the type might change without changing the actual specimen - a correction, say. Secondly, there's the potential gap between the definition of 'urine' and the thing that is the specimen that once was urine. Thirdly, what is the 'type' of a specimen? is it the physical type, or is it the way that it fits into the process in which it's being used? Further, with timed specimen, is it a type of time? Finally, the real question is, in your frame of reference, what are classes, and what then are instance of those classes. I don't believe that the standard terminologies for specimen type - which are classifications, actually - are the grounds on which you can make such statements with any confidence.</p>",
        "id": 153829423,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464055056
    },
    {
        "content": "<p>Hence, I believe that we should leave rdf:type as an interpretation based on context and specific decisions</p>",
        "id": 153829424,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464055075
    },
    {
        "content": "<p>Good to add some Existentialism into the discussion <img alt=\":smile_cat:\" class=\"emoji\" src=\"static/third/gemoji/images/emoji/smile_cat.png\" title=\":smile_cat:\">  <img alt=\":+1:\" class=\"emoji\" src=\"static/third/gemoji/images/emoji/+1.png\" title=\":+1:\"></p>",
        "id": 153829581,
        "sender_full_name": "Renato Iannella",
        "timestamp": 1464064587
    },
    {
        "content": "<p>I'll take that as a lack of disagreement to my point, I think. </p>",
        "id": 153829582,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1464068196
    },
    {
        "content": "<p>Inference correct <img alt=\":sunglasses:\" class=\"emoji\" src=\"static/third/gemoji/images/emoji/sunglasses.png\" title=\":sunglasses:\"> </p>",
        "id": 153829588,
        "sender_full_name": "Renato Iannella",
        "timestamp": 1464073423
    }
]