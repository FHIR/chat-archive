[
    {
        "content": "<p>We have discussed generating TestScripts from OpenAPI definitions.  This paradigm is used elsewhere in test script generation.  Consider this method for generating jmeter using openAPI.<br>\n<a href=\"https://gvasanka.medium.com/generating-jmeter-scripts-for-api-testing-using-swagger-openapi-specification-file-7a13d4934cb7\">https://gvasanka.medium.com/generating-jmeter-scripts-for-api-testing-using-swagger-openapi-specification-file-7a13d4934cb7</a></p>",
        "id": 231021439,
        "sender_full_name": "Richard Braman (FLY.HEALTH)",
        "timestamp": 1616160199
    },
    {
        "content": "<p>We generate our tests for US Core based on the US Core Server Capability Statement.  We started with hand-written tests back for the Argonaut Data Query Implementation Guide, but as profiles and search parameters kept being added and slightly tweaked, it became very difficult to maintain.  I'm not how typical US Core will end up being (maybe it is far more complex than the average IG), but in this particular case it became a requirement to have automated tooling write tests.</p>",
        "id": 236838278,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1619791195
    },
    {
        "content": "<p>Of course, you could have your test tool just read the capability statement and at runtime decide what to test, but that becomes extremely difficult to reason about, so it helps a lot to have tooling write to a common test format (like TestScript, or in our case a Ruby-based DSL).</p>",
        "id": 236838616,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1619791317
    }
]