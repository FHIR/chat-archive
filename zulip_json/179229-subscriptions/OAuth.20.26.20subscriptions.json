[
    {
        "content": "<p>Da Vinci is looking at using Subscription as a way to indicate that a response is ready (and so to come and get the result). We had a question about whether an OAuth token would be needed to establish the subscription and whether the OAuth token would need to still be valid for the subscription notification</p>",
        "id": 179093440,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572041494
    },
    {
        "content": "<p>Hey Lloyd, at least a handful of us have thought alot about authnz and subscriptions.</p>",
        "id": 179106229,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1572059485
    },
    {
        "content": "<ul>\n<li>An OAuth token should definitely be required to establish a subscription</li>\n<li>Authn for the subscription notification is murky. The simple technical/security approach is to use a <code>[channel.payload.content](http://build.fhir.org/subscription)</code> of either <code>empty</code> or <code>id-only</code>. (Meaning that an OAuth token would be required to retrieve PHI).</li>\n</ul>",
        "id": 179106231,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1572059489
    },
    {
        "content": "<p>Ultimately, the perception is that anOAuth token is trivial to acquire using the SMART Backend Services/OAuth2 client credentials flow in B2b scenarios and therefore we shouldn't shy aware from it.</p>",
        "id": 179106232,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1572059491
    },
    {
        "content": "<p>The backend services OAuth doesn't involve any patient authorization though.  So the question is: once a patient gives authorization for data to flow, when does it time out (or how does a patient cancel it)?</p>",
        "id": 179106869,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572060617
    },
    {
        "content": "<p>Lloyd, apologies, I didn't understand that this was a patient-mediated flow. Generally, the same advice applies --</p>\n<ul>\n<li>An OAuth token should definitely be required to establish a subscription</li>\n<li>A \"callback\" following a subscription notification would require patient authorization. Patient authorized apps will have long-term OAuth refresh tokens and patient portals should provide the ability for patients to revoke authorization.</li>\n</ul>",
        "id": 179107021,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1572060952
    },
    {
        "content": "<p>So the notion is that the patient portal would continue to refresh the token until/unless the patient tells it to stop?</p>",
        "id": 179107721,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572062270
    },
    {
        "content": "<p>Yes, generally, the patient would preserve a refresh token</p>",
        "id": 179107847,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1572062502
    },
    {
        "content": "<p>It's probably not realistic for the patient to be involved on an ongoing basis, so some third party would have to manage renewing the token on the patient's behalf.</p>",
        "id": 179133894,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572110363
    },
    {
        "content": "<p>I am not sure I understand the full impact, it is Murky...   A Subscription involves three legs, yet  I see only two being discussed so I am not sure if the second or third leg is being forgotten (or assumed to be okay).  ( 1 ) request to subscribe, ( 2 ) notification, and ( 3 ) get of new data.  There are subscription types that combine 2 and 3; that if that is what you are talking about then that needs to be discussed.</p>",
        "id": 179228199,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572267903
    },
    {
        "content": "<p>The act of subscribing seems clear, but is not universally understood.  The discussion around subscription usually does need to address the time-to-live difference between the token at subscription from how long the subscription stays active. This is usually resolved in that the request to subscribe is/was valid at the time the request was made, so all parameters of the subscription must be checked at that time. This check needs to also involve the notification pathway mechanics. This is not obvious to everyone, so does need to be expressed.</p>",
        "id": 179228234,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572267945
    },
    {
        "content": "<p>The notification, if only a notification, can be risk-assessed to not need client authentication at all. As ( a ) the subscription said to use that notification mechanics, and ( b ) as purely a notification does not include any data outside the fact that something happened.</p>",
        "id": 179228416,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572268074
    },
    {
        "content": "<p>I'll preface with a note that I don't feel this area is fully resolved.</p>\n<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>, the three legs you specify do cover the basic flow.  That said, there is sometimes a request for security on the second leg.  So far, the approach has been to add an <code>Auth</code> header to a Subscription, which is passed along with notifications (e.g., so a destination can validate the notification is genuine).<br>\nIt has some as-yet-unresolved issues (e.g., who can read/write the header, etc.), but does allow for basic validation on the notification (which could also be achieved with a parameter in the URL, but we felt this was more explicit).<br>\nAs for the notification pathway, that is checked at the time a <a href=\"http://build.fhir.org/subscription.html#rest-hook\" target=\"_blank\" title=\"http://build.fhir.org/subscription.html#rest-hook\">REST-hook</a> subscription is created (e.g., set to requested and checked before being moved to active).  Is there more clarity/description necessary there, or are you thinking of something else?<br>\nFor other channels (e.g., websocket, email, etc.), the process would be different and we will likely punt to an implementer on what their process is (e.g., send an email asking to verify the address, ask the client to make a connection, or just move to active, etc. - just require it is described somewhere).</p>\n<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>, for renewing the token - our current recommendation is to use the <code>Subscription.end</code> field to time-out subscriptions (e.g., a Must Support for the Argonaut IG).  If the subscription should be renewed, someone with the proper authorization needs to update the record with a new <code>end</code> date/time.  This allows for an interested application to confirm that the user still wants the subscription active and there is no need for managing a refresh token on behalf of the user.  Is this enough functionality, or is there something missing?</p>",
        "id": 179240420,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572275836
    },
    {
        "content": "<p>I think the desired from the patient's perspective is that they're involved in the initial authorization and that the patient doesn't have to do anything unless they want the authorization to end.  If they want the authorization to end, they would interact with one of the systems and subsequent requests would fail.</p>",
        "id": 179240994,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572276136
    },
    {
        "content": "<p>It's not reasonable for the patient to be involved every time a request needs to flow or even on an intermittent basis</p>",
        "id": 179241043,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572276163
    },
    {
        "content": "<p>The patient would not <em>need</em> to be involved, as long as the application managing the subscription had a token.  It would just be maintenance that an application would need to do (and conversely, if the patient wanted to stop receiving notifications, the application could go an disable/delete the subscription).</p>",
        "id": 179242582,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572276999
    },
    {
        "content": "<p>(And this dovetails well with ONC's proposal that patient-authorized apps should be able to request refresh tokens that maintain access over time, or until a patient revokes.)</p>",
        "id": 179242624,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572277031
    },
    {
        "content": "<p>The use-case isn't a patient receiving notifications.  This is a patient authorizing data to flow from system A to B.  Essentially the patient needs to be involved in turning on the switch, after which the subscription should function either until a pre-determined end point (6 months, 1 year) or until the patient decides to end it sooner.</p>",
        "id": 179242937,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572277226
    },
    {
        "content": "<p>My question is what the revocation process would look like</p>",
        "id": 179242960,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572277246
    },
    {
        "content": "<p>The use case here is \"any patient-authorized app\" (which in you case would be the \"system B\" app.</p>",
        "id": 179242967,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572277248
    },
    {
        "content": "<p>There's two paths to revocation, I think:</p>\n<ul>\n<li>\n<p>If a patient trusts system B to revoke its own access, they just indicate to System B that they want it to stop all access</p>\n</li>\n<li>\n<p>Otherwise a patient uses system A's portal to review current access grants, and revoke (each patient portal has functionality like this built-in). After revocation, system A should stop allowing system B to access the patient's data.</p>\n</li>\n</ul>",
        "id": 179243148,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572277347
    },
    {
        "content": "<p>Portal = non-standard interface?  I.e. there isn't a 'standard' way to revoke access, you just go to a website, navigate as that site dictates and click on the relevant buttons?</p>",
        "id": 179243963,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572277858
    },
    {
        "content": "<p>the standards based model I heard explained is to revoke authorization at the oauth authority (which is usually a browser experience the patient has, call this a portal if you want, but humans must interact at the html level, not at the oauth transaction level), which relies on the notifiying app always having to renew the token prior to notification. That is the standards model... right?</p>",
        "id": 179247488,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572279827
    },
    {
        "content": "<p>long-term tokens, that are renewed upon use, are the model oauth is based on. we should not try to invent FHIR specific security standards.</p>",
        "id": 179247592,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572279899
    },
    {
        "content": "<p>I believe what Josh is referring to is standard auth revocation...  Whatever application was used to create the subscription can disable/delete a subscription on behalf of its user on its way out.  If a user is requesting that in the app, it should honor that request.  This would be the 'best' way, since it is the only process that allows every party to know that a subscription was removed and clean up their resources immediately.</p>\n<p>If the user no longer wants to use the app even to delete access, then the user would need to use some other interface (e.g., the EHR portal, another app which can manage access, etc.) to revoke access.</p>\n<p>In the cases where notifications do not contain PHI, removing the client is sufficient since the application will no longer be able to resolve a notification into anything useful.  In time, the server will remove the subscription as well, which disables even the 'clean' notifications.</p>\n<p>In the cases where a subscription notification contains PHI (e.g., full-resource), then there is currently no way to know that a subscription was created by a specific client and should be removed.  I would assume that a portal could ask about items like that (e.g., you are revoking access, is there anything else that needs to be cleaned up), but it hasn't come up to my knowledge.</p>\n<p>If you are asking about adding something to link a subscription to the client which created it, I'm happy to bring it up for discussion.  We do have to be careful of putting fields on the subscription with things like 'which client created this' since knowing client IDs makes <a href=\"https://www.oauth.com/oauth2-servers/client-registration/client-id-secret/\" target=\"_blank\" title=\"https://www.oauth.com/oauth2-servers/client-registration/client-id-secret/\">phishing attacks easier</a>.</p>\n<p>I feel like anything more than having the ID would be beyond the scope of subscriptions (and into security).</p>\n<p>Or, are you asking for clarifying/guidance text on the issue to be included on this topic?</p>",
        "id": 179247621,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572279911
    },
    {
        "content": "<p>agree that management of the subscription is done using FHIR Subscription CRUD. The authorization model needs to enhance this, not be used in place of this.</p>",
        "id": 179247933,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572280097
    },
    {
        "content": "<p>Lloyd, what subscription type are you looking at... because we need to solve ONE model, not continue to circle around all possible subscription types</p>",
        "id": 179247997,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572280147
    },
    {
        "content": "<blockquote>\n<p>...the notifiying app always having to renew the token prior to notification...</p>\n</blockquote>\n<p>This has not been discussed (to my knowledge).  Adding this to the workflow would require servers save the refresh token, which also has security implications (e.g., can other users read my subscription and now impersonate me).</p>",
        "id": 179248021,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572280172
    },
    {
        "content": "<p>you do not need (and should not) save the refresh token INSIDE the subscripiton resource. You save it someplace safe... that is to say I am assuming good systems design and that you are truely a confidential client (as a subscripiton manager server)</p>",
        "id": 179248206,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572280276
    },
    {
        "content": "<p>right? surely we can set expectations for good systems design... We have plenty of these good systems design expectations on the fhir core security pages and the fhir core safety pages.</p>",
        "id": 179248397,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572280355
    },
    {
        "content": "<p>Yes, had a discussion offline here with Josh, and here's what we're leaning towards.</p>\n<p>In the Subscription spec, put a notice in the Security section that:<br>\n- Auth should be checked prior to sending a notification<br>\n- Client ID / access tokens / refresh tokens / etc. cannot be stored in the subscription resource</p>\n<p>In the Argonaut IG, we will draft out more of a workflow showing how an EHR can actually do this (e.g., when the subscription is created, track the client / user id in a secure manner, then validate prior to sending out a notification that the client and user are still valid, finally, when access is revoked, the subscription should be removed, etc.).</p>\n<p>How does that sound?</p>",
        "id": 179250572,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572281400
    },
    {
        "content": "<p>when the subscription type if web-hook.... right? As websocket, email, sms, and message would be different... right?</p>",
        "id": 179251746,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572282038
    },
    {
        "content": "<p>Subscription would either be websocket or message</p>",
        "id": 179251855,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572282098
    },
    {
        "content": "<p>websocket resolves itself, as all interactions are by the client... right?</p>",
        "id": 179251950,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572282145
    },
    {
        "content": "<p>as in the websocket must prove that it is authorized to access the Subscription... normal client side request security</p>",
        "id": 179252344,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572282395
    },
    {
        "content": "<p>messaging is more complex: messaging could be simple system-to-system messaging security; but I presume you want more specifics there too... seems an opportunity that needs a general solution... one general solution where message target is a user and not just an organization is just like rest-hook... as a message can be pushed just like anything can be pushed. All push models presume some pre-known knowledge on the target based on some trust-framework, so all start with a trust-framework... yeah, all possible models of complexity are in messaging without some trust-framework constraint.</p>",
        "id": 179252814,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572282691
    },
    {
        "content": "<p>This starts to get back into why most servers aren't sending PHI in the notifications. If we're assuming the access token for the notification is the <em>same</em> as reading the data - I think that's something we haven't done so far</p>",
        "id": 179254186,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572283555
    },
    {
        "content": "<p>That assumes that there's not a central system that may know how to do its own proprietary notification publication to apps downstream</p>",
        "id": 179254256,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572283585
    },
    {
        "content": "<p>This also would imply, possibly, that you need to check the <em>context</em> of each subscription. IE: if the <em>user</em> still has access to the data (the user that was on the token)</p>",
        "id": 179254298,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572283623
    },
    {
        "content": "<p>This is not trivial</p>",
        "id": 179254303,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572283627
    },
    {
        "content": "<p>you still expose the ping... which says that for a GUID something happened.. so you do expose some pattern, but not much</p>",
        "id": 179254308,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572283630
    },
    {
        "content": "<p>but I would agree that the notificaiton should be nothing but a ping</p>",
        "id": 179254334,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572283656
    },
    {
        "content": "<p>In my scenario, I want the initial authorization to apply to the creation of the subscription <em>and</em> to subsequent reads (up until the expiry of the subscription or outright cancellation).</p>",
        "id": 179254338,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572283662
    },
    {
        "content": "<p>I think it's also an interesting assumption to assume the subscriber is the person reading data later</p>",
        "id": 179254363,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572283672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  for your case, that may be true. I'm not sure if it's always true</p>",
        "id": 179254452,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572283713
    },
    {
        "content": "<p>So you'd be authorizing one app to create the subscription and a different app to query the data after receiving pings?  (or possibly even a different 'set' of apps)  Yes, I can see that use-case, though you're correct that it's not the one I currently have</p>",
        "id": 179254789,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572283910
    },
    {
        "content": "<p>Sorry, was at lunch.</p>",
        "id": 179256289,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572284814
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>, yes and no.  For WebSockets, we are still tinkering with the way of mapping connections and subscriptions.  On first thoughts, disabling a subscription would have the same effect, and feels more consistent than trying to manage it at the channel layer.  The same holds true for arbitrary (extensible) channels in my mind.</p>",
        "id": 179256438,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572284901
    },
    {
        "content": "<blockquote>\n<p>So you'd be authorizing one app to create the subscription and a different app to query the data after receiving pings?  (or possibly even a different 'set' of apps)  Yes, I can see that use-case, though you're correct that it's not the one I currently have</p>\n</blockquote>\n<p>The model where the notification is just a ping: The receive of the updated data is just a REST retrieve of data new since the last time one looked. So it is indistinguishable from any REST query.</p>",
        "id": 179256715,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572285066
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span>, I can see what you are saying and I would prefer to leave that out of scope for this (e.g., it's a security issue, and thus needs different expertise to truly refine).  I think there needs to be guidance as to 'yes, this needs to be considered' in the standard, and 'here are some basic considerations' in the IG, but am wary of doing more since it would be implementation specific.  Does that work for you?</p>",
        "id": 179256732,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572285086
    },
    {
        "content": "<p>an IG could certainly pick a security model... the core spec needs to leave many things unsaid... so, which are we working on here?</p>",
        "id": 179256865,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572285166
    },
    {
        "content": "<p>I've been working on both - hence why I'm trying to draw the line  :-)</p>",
        "id": 179256963,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572285237
    },
    {
        "content": "<p>for example IHE used subscription for functionality similar to HL7 v2 ADT... the notification was defined to be messaging, and the security model is either system-to-system (TLS), system-to-system (OAuth), or SMART.    Given it was messaging, it is less likely anyone would try to group with SMART and have an interactive session on the notification transaction. Thus it is likely to be OAuth re-directed to a null endpoint and thus not authorized.</p>",
        "id": 179257146,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572285342
    },
    {
        "content": "<blockquote>\n<p>In my scenario, I want the initial authorization to apply to the creation of the subscription <em>and</em> to subsequent reads (up until the expiry of the subscription or outright cancellation).</p>\n</blockquote>\n<p>For your use-case where you are pushing the content in a FHIR Message, this is about all you can expect. The push of the FHIR Message would setup a security context for that messaging channel. Might be system-to-system using mutually-authenticated-TLS (Yes, this is very likely in organization to organization, where they already use this for v2 and soap). That is likely to not be a happy-path, so you want to use OAuth on the client, but OAuth can also be organizational (like bulk-data has spec). I would NOT expect this flow to use the user identity from the subscription requst, that is just strange, and requires so many bad security decisions.</p>",
        "id": 179257743,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572285680
    },
    {
        "content": "<p>yes, I can understand a perspective that has the subscripiton manager being delegated rights to callback.. and you can build that Rube Goldberg machine ...  just seems fought with opportunities for failure.</p>",
        "id": 179257975,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572285799
    },
    {
        "content": "<p>Yes.  In the R5 redesign, those are all still possible.  The specification allows for extensible channels, so any not already defined (REST-Hook, WebSocket, email) can be added (or if you want different behavior, define a new channel that uses the same type of channel).  Many of the security details depend on the channel layer, so are out of scope for either the core spec or the Argonaut IG.  Some of those could be notes in the area of  channel extensions (e.g., here are some security issues to consider when making a new channel).</p>\n<p>That said, I am hearing that there should be <em>some</em> expected behaviors for a subscription regardless of what the channel-specific details are.</p>\n<p>For me, I am actively drafting changes for each of those documents, so if there's feedback on what makes sense I can add some text to the pass for review.  Right now, there is nothing in either.  I feel that there is consensus that there needs to be more than nothing, so I am trying to figure out what that looks like.</p>",
        "id": 179258255,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572285965
    },
    {
        "content": "<blockquote>\n<p>I would NOT expect this flow to use the user identity from the subscription requst, that is just strange, and requires so many bad security decisions.</p>\n</blockquote>\n<p>How so (asking for clarification)?  If a client is authorized to create a subscription for a patient/group/resource/etc, the server tracking that information and validating it is still true before sending a notification doesn't feel wrong to me in any context.  What am I missing?</p>",
        "id": 179258487,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572286116
    },
    {
        "content": "<blockquote>\n<p>yes, I can understand a perspective that has the subscripiton manager being delegated rights to callback.. and you can build that Rube Goldberg machine ...  just seems fought with opportunities for failure.</p>\n</blockquote>\n<p>I don't think this has been proposed here (or if it has, I cannot see it).<br>\nThe user/app which has received the notification would need to authenticate to perform its query the same way it would for any other query.</p>",
        "id": 179258719,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572286267
    },
    {
        "content": "<blockquote>\n<p>as in the websocket must prove that it is authorized to access the Subscription... normal client side request security</p>\n</blockquote>\n<p>This is one of the challenges we are working to resolve.  Websockets are often not part of 'normal client side security', and even when they are still face issues like revocation (e.g., was valid when I opened my socket, not anymore).  It's a complicated issue that I don't think has enough real-world experience to check off yet.</p>",
        "id": 179259168,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572286527
    },
    {
        "content": "<p>The security wg welcomes this discussion. Please feel free to approach us.</p>",
        "id": 179259527,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572286722
    },
    {
        "content": "<blockquote>\n<p>The security wg welcomes this discussion. Please feel free to approach us.</p>\n</blockquote>\n<p>If there is a call/thread/etc. for this, please let me know and I would be happy to participate.</p>",
        "id": 179260096,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572287054
    },
    {
        "content": "<p>see <a class=\"stream\" data-stream-id=\"179247\" href=\"/#narrow/stream/179247-Security-and-Privacy\">#Security and Privacy</a></p>",
        "id": 179266272,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572290772
    },
    {
        "content": "<p>and the workgroup at <a href=\"https://confluence.hl7.org/display/SEC/Security+Work+Group\" target=\"_blank\" title=\"https://confluence.hl7.org/display/SEC/Security+Work+Group\">https://confluence.hl7.org/display/SEC/Security+Work+Group</a></p>",
        "id": 179266302,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572290812
    },
    {
        "content": "<p>From today's Argonaut discussion, it's unclear whether existing server implementations have a good way to propagate access revocations across all the relevant subscriptions (in a fast/scalable fashion). The open design question that <span class=\"user-mention\" data-user-id=\"191936\">@Michael Donnelly</span>  <span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span> and others are going to noodle on: </p>\n<h2>(How) can servers implement a Subscription/notification mechanism that..</h2>\n<ol>\n<li>Allows long-term (month-long) subscriptions without further client interaction</li>\n<li>Allows user revocation that takes effect \"quickly\" (within, say, 1 hour)</li>\n<li>Is scalable / workable across real-world EHR implementations</li>\n</ol>",
        "id": 179459540,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572458563
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span>  - just to clarify since we zoomed in on the <em>patient</em> app use case...</p>",
        "id": 179459998,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572458847
    },
    {
        "content": "<p>Specifically the authorization we're tying to this is the specific user session?</p>",
        "id": 179460042,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572458875
    },
    {
        "content": "<p>IE: if both I and my husband requested subscriptions on our family data using \"MyCoolPhoneApp\" - it's that the subscription is still authorized for <em>me</em> ?</p>",
        "id": 179460133,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572458919
    },
    {
        "content": "<p>This is where I keep getting tripped up</p>",
        "id": 179460154,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572458930
    },
    {
        "content": "<p>Since the app is authorized to see little bobby drop tables data from that same app, by different users...</p>",
        "id": 179460184,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572458958
    },
    {
        "content": "<p>And none of those users is little Bobby.</p>",
        "id": 179460219,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572458995
    },
    {
        "content": "<p>If so, this starts to imply that the authorization context by which the app subscribed is specifically tied to that instance of the subscription (something we had avoided to date)</p>",
        "id": 179460341,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572459068
    },
    {
        "content": "<p>I'm not saying we shouldn't, but that we should agree this is the implication</p>",
        "id": 179460365,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572459088
    },
    {
        "content": "<p>And if it is: is that restriction to any authorization of that application, or does it start to intersect with the session scope in SMART (offline, online, none)</p>",
        "id": 179460543,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572459226
    },
    {
        "content": "<p>For subscription <em>clients</em> - what would your expectation be? What is the least surprising behavior here?</p>",
        "id": 179460619,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572459266
    },
    {
        "content": "<p>I could likely look up if an app was still authorized for a specific site relatively easily before sending out subscriptions</p>",
        "id": 179460787,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572459366
    },
    {
        "content": "<p>But I don't think that's the level of functionality that is being requested</p>",
        "id": 179460815,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572459384
    },
    {
        "content": "<p>Looking up if any instance of a patient app is still authorized for a specific patient is more tricky</p>",
        "id": 179460849,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572459409
    },
    {
        "content": "<p>And then tying that subscription to the specific <em>user</em> or specific <em>session</em> (this goes back to the refresh token conundrum) start to get even more complicated</p>",
        "id": 179460908,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572459461
    },
    {
        "content": "<p>I guess from my perspective, the model is something like: each Subscription is created in the context of a specific authorization (knowable at creation time by looking at the access token used to create it). If that authorization is subsequently revoked for any reason, how do we make sure this propagates to subscription notifications?</p>\n<p>To take your \"MyCoolPhoneApp\" example <span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span> , </p>\n<blockquote>\n<p>if both I and my husband requested subscriptions on our family data using \"MyCoolPhoneApp\" - it's that the subscription is still authorized for me ?</p>\n</blockquote>\n<p>Are you saying there's <em>one</em> subscription here for the whole family, like \"All encounters for Patient 123,456,789\"? If so, then either you created it, or your husband created it. If the creator revokes MyCoolPhoneApp's access, then the subscription should stop working. I might not be understanding your example , though.</p>",
        "id": 179465475,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572462003
    },
    {
        "content": "<p>I was implying that there were likely 2 sessions - maybe 2 subscriptions, it would depend on how the app was planning on implementing it. What we determine here would guide how that app MUST behave</p>",
        "id": 179466810,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572462780
    },
    {
        "content": "<p>To date, we only tracked the alert endpoint on a subscription, and what filters/topic</p>",
        "id": 179466837,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572462803
    },
    {
        "content": "<p>it's possible that the subscription I described above for a mobile device could be sent to the actual device <em>system</em> and then sent to the appropriate device(s) via that phone's alerting mechanism - at least today</p>",
        "id": 179466937,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572462858
    },
    {
        "content": "<p>And it could have been smart enough to know that I have 10 devices, and don't necessarily need 10 subscriptions</p>",
        "id": 179467006,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572462896
    },
    {
        "content": "<p>since it's all 1 client id (this assumes we aren't registering specific instances of applications via dynamic reg, for eg)</p>",
        "id": 179467052,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572462925
    },
    {
        "content": "<p>If, however, we tie it to the refresh token in play when the subscription is created, that implies that all 10 instances of the app for me would need to create and manage a unique subscription</p>",
        "id": 179467168,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572462986
    },
    {
        "content": "<p>Tying it to just the filters/app isn't enough</p>",
        "id": 179467198,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572463011
    },
    {
        "content": "<p>Tying it to just the patient id isn't enough</p>",
        "id": 179467205,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572463020
    },
    {
        "content": "<p>It would have to be at least user, client, and then likely patient?</p>",
        "id": 179467324,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572463106
    },
    {
        "content": "<p>So far, if we're assuming this is something the server takes on, it will also have implications/limitations on how the client app will need to behave. I'm trying to find a \"not surprising behavior\" middle ground</p>",
        "id": 179467495,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572463210
    },
    {
        "content": "<blockquote>\n<p>Jenni Syed: If, however, we tie it to the refresh token in play when the subscription is created, that implies that all 10 instances of the app for me would need to create and manage a unique subscription</p>\n</blockquote>\n<p>I'm not sure I agree; the decision about how many endpoints to create and how many Subscriptions to create is up to the client. (But of course, the client must have permissions to create the Subscription, and must be prepared to deal with the consequences of revocation.)</p>",
        "id": 179467696,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572463343
    },
    {
        "content": "<p>On the revocations side, there's a spectrum of \"conservative\" things you could do to handle revocations (which presumable are relatively infrequent events, compared with approvals). I wouldn't want to specify too much about how this works.. but internally you might have a rule like \"any time a user revokes any access from an app, all of the Subscriptions for that {app, user} are set to <code>inactive</code>.\"  That's \"conservative\" because it might invalidate some subscriptions that don't <em>need</em> to be, but an app may be able to come back and re-enable them in response, after seeing missed heartbeats. (If you can fine-tune the inactivations, so much the better.)</p>",
        "id": 179467970,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572463545
    },
    {
        "content": "<p>For a client app, one expectation is to track heartbeats and <em>notice</em> (and take appropriate steps) when they stop.</p>",
        "id": 179468118,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572463653
    },
    {
        "content": "<p>I see this as a tuple for the authorization - a user and an app (acting on behalf of that user).</p>\n<p>If a user account responsible for a subscription is disabled, I would expect notifications to halt.<br>\nIf a user revokes access for an application, I would expect notifications to halt.</p>\n<p>In the 'MyCoolPhoneApp' scenario, if the application is consolidating subscriptions and rebroadcasting (users 'A' and 'B' are linked in the app):</p>\n<ol>\n<li>'A' creates subscription, 'MyCoolPhoneApp' access revoked on the EHR, no more notifications (feels fair)</li>\n<li>'A' creates subscription, 'B' revokes access for 'A' on the EHR, no more notifications (feels fair, 'B' needs to setup a subscription)</li>\n<li>'A' creates subscription, 'A' revokes access for 'B' on the EHR, 'MyCoolPhoneApp' still sharing (accounts were linked in the app, need to manage in app, feels fair)</li>\n</ol>\n<p>There could be some confusion around 2., in that 'B' may not remember that 'A' was the primary user and revoking their access disabled the subscription, but I (personally) feel like this is a fair process (or at least better than arbitrarily allowing 'A' to continue receiving notifications).</p>\n<p>I am confused about your comment about tying it to the patient id (<span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span>).  Isn't this process for evaluating access to a resource 'owned' by a patient based on the other two (e.g., this notification is for 'patient/123', does user 'A':'MyCoolPhoneApp' have access)?</p>",
        "id": 179469223,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572464473
    },
    {
        "content": "<p>Ok, so be ready to delve into \"user auth\" since you tied it up there by \"user account is disabled\"</p>",
        "id": 179469301,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464530
    },
    {
        "content": "<p>We specifically and purposefully avoided requiring this in subscriptions today :)</p>",
        "id": 179469314,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464546
    },
    {
        "content": "<p>because that is just... a mess</p>",
        "id": 179469320,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464556
    },
    {
        "content": "<p><em>puts on fins and mask</em></p>",
        "id": 179469328,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572464565
    },
    {
        "content": "<p>There are so very many reasons the user can loose auth, and most of them aren't that the user isn't part of the system anymore :)</p>",
        "id": 179469358,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464602
    },
    {
        "content": "<p>I agree that it's a mess.  I don't think that we are trying to set out such concrete details here though.  I am thinking on these as general security guidelines that need to be mentioned.</p>",
        "id": 179469397,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572464634
    },
    {
        "content": "<p>The reason I said patient: In our system, we tie a <em>consumer</em> authorization (not practitioner, since they aren't authorizing the app) to a set of patients that they saw and confirmed they wanted to grant the app access to</p>",
        "id": 179469449,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464651
    },
    {
        "content": "<p>So even if I have access to my whole family, and the app uses \"user\" level scopes, the auth is locked down to who I had access to at the time of the auth request</p>",
        "id": 179469521,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464717
    },
    {
        "content": "<p>Since that is all I saw and authorized at the time</p>",
        "id": 179469536,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464731
    },
    {
        "content": "<p>Similarly, even if I have access to my whole family, the app may use \"patient\" level scopes, so I may choose myself or someone in my family specifically</p>",
        "id": 179469560,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464760
    },
    {
        "content": "<p>IE: from an oauth scope perspective, that session for a consumer is locked down to some set of patient ids</p>",
        "id": 179469673,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464830
    },
    {
        "content": "<p>So, I can have 5 people in my family. I could have 5+ different authorizations for that app to have access to different sets of patients on my behalf</p>",
        "id": 179469722,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464871
    },
    {
        "content": "<p>(this likely depends on how the underlying resource and auth server behaves)</p>",
        "id": 179469782,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464888
    },
    {
        "content": "<p>But that is just the auth viewable level</p>",
        "id": 179469800,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464900
    },
    {
        "content": "<p>In realtime access, we put many other authorization checks into play</p>",
        "id": 179469817,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464915
    },
    {
        "content": "<p>The easy ones: do you have access to this specific piece of data (either via scope or other privacy concerns)</p>",
        "id": 179469850,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464943
    },
    {
        "content": "<p>That makes sense.  My question would be, that during the course of adding subscription support, is it onerous to ask that a 'user' be checked at the time of the notification being sent (e.g., if the user was logging in now, would they be able to access that patient)?  Or something like a check that runs once per hour (a delay in revocation would be expected in my mind) to disable a subscription, etc.?</p>",
        "id": 179469909,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572464992
    },
    {
        "content": "<p>But, at any time during the lifetime of that offline access session, someone can lose access for many reasons</p>",
        "id": 179469917,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572464998
    },
    {
        "content": "<p>1) revoked by the patient (actual action in the system), <br>\n2) minor aged out (no actual action in the system), <br>\n3) something happened to their account link (may have happened in the IDE and not in the local system)</p>",
        "id": 179470036,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465076
    },
    {
        "content": "<p>4) general system level privs were changed. IE: a specific facility is now marked as \"psychiatric\" - no direct action happened at the user config level</p>",
        "id": 179470149,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465125
    },
    {
        "content": "<p>We've seen all of the above in prod with consumer access today</p>",
        "id": 179470341,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465184
    },
    {
        "content": "<p>many times over</p>",
        "id": 179470345,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465187
    },
    {
        "content": "<p>so they're not \"rare\"</p>",
        "id": 179470353,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465192
    },
    {
        "content": "<p>And the \"field\" level data restrictions are even more difficult - you have partial access to a patients data. That can be resource level (all allergies) or instance level (some allergies) or even field level (reason for thing - eg: Diagnoses)</p>",
        "id": 179470488,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465286
    },
    {
        "content": "<p>And all of our favorites: Patient merge and unmerge/combine and uncombine</p>",
        "id": 179470623,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465367
    },
    {
        "content": "<p>All of these complexities are the main reason we have the no body or id only notification mechanisms today</p>",
        "id": 179470692,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465417
    },
    {
        "content": "<p>(also the concern with the endpoint you're calling getting hijacked/losing their domain/MITM/etc, but the user viewing it was a huge driver)</p>",
        "id": 179470747,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465463
    },
    {
        "content": "<p>Practitioner has similar concerns/complications, but in our system the added complexity of there being no concept of what \"patients\" are authorized (today) for access when the authentication dance happens, unless the app requested 1 patient only (launch/patient scope)</p>",
        "id": 179470861,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465540
    },
    {
        "content": "<p>This is why I'm trying to decide how deep we want to go here</p>",
        "id": 179470919,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572465587
    },
    {
        "content": "<p>Yep.  These are all difficult/tedious to work through.  I guess my preference would be for us to set out some basic expected behaviors as guidelines, and go from there.</p>\n<p>My concern is that even with 'no' PHI, the notification can still be considered as such.  To use one of your examples, if a parent/guardian/etc receives a notification of activity from Planned Parenthood and they didn't go, it's easy to put together it is their now not-minor child that went.</p>\n<p>My expectation would be that if a person can't access the resource in question, they shouldn't receive a notification.  I would prefer not to go any deeper than that (beyond the minimum qualifications for that statement, like 'a server can specify how long before this takes effect', etc.).</p>\n<p>Does that make sense?  Or too far?</p>",
        "id": 179471828,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572466107
    },
    {
        "content": "<blockquote>\n<p>Yep.  These are all difficult/tedious to work through.  I guess my preference would be for us to set out some basic expected behaviors as guidelines, and go from there.</p>\n<p>My concern is that even with 'no' PHI, the notification can still be considered as such.  To use one of your examples, if a parent/guardian/etc receives a notification of activity from Planned Parenthood and they didn't go, it's easy to put together it is their now not-minor child that went.</p>\n<p>My expectation would be that if a person can't access the resource in question, they shouldn't receive a notification.  I would prefer not to go any deeper than that (beyond the minimum qualifications for that statement, like 'a server can specify how long before this takes effect', etc.).</p>\n<p>Does that make sense?  Or too far?</p>\n</blockquote>\n<p>I think that should be something that is checked upon setting up the subscription, not something expected prior to sending the notification... right?</p>",
        "id": 179471937,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572466190
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>, I would make the argument that both should be applied.</p>\n<p>A user should not be able to successfully create a subscription for resources they don't have access to.  A user should also not receive notifications for resources they no longer have access to.</p>\n<p>I do not think it is realistic at scale to do the full verification on every access .  If access is checked every hour/day/etc. and revoked, that would meet my expectations (as long as the user is notified - this may take a few hours to propagate).</p>",
        "id": 179473272,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572467134
    },
    {
        "content": "<p>So the question here is: do EHR vendors have some reasonably efficient way to provide some close approximation to making revocations work on subscriptions. So far I'd summarize discussion as:</p>\n<ol>\n<li>It's complicated, with a lot of edge cases</li>\n<li>It's hard to enforce revocations <em>immediately</em> but there could be an opportunity to enforce them over a timescale of minutes to hours</li>\n<li>It's okay for servers to behave \"conservatively\" by invalidating subscriptions in some cases where it's not strictly necessary, as long as clients can detect/correct</li>\n<li>At the level of the standard or even an Argonaut IG, we don't want to describe all the edge cases; we'd describe general expectations and leave it up to server discretion to nail down the behaviors</li>\n</ol>",
        "id": 179474363,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572467834
    },
    {
        "content": "<p>^^^ Any deep concerns with the summary so far?</p>",
        "id": 179474379,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572467841
    },
    {
        "content": "<p>For #3, clients detecting should be straight-forward.  Not clear on how they can 'correct' if the initial authorization was provided by a patient and that patient is no longer avaialble.</p>",
        "id": 179475579,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572468585
    },
    {
        "content": "<p>(Yes, re #3 we should say \"detect and, if applicable, correct\". Like if a server conservatively knocked out all of a user's subscriptions in response to a narrow revocation.)</p>",
        "id": 179476068,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572468876
    },
    {
        "content": "<p>I think what Jenni is pointing out is that there might need to be many models. Where the notification is just a poke, the notification is identified as a risk, a risk only of pattern.   Where the notification is the content of the notificaiton then there MUST certainly be access control check pror to sending it.</p>",
        "id": 179476151,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572468950
    },
    {
        "content": "<p>These are risk based... security geeks like that... while they are also setting a set of patterns that are reasonable, which architects like to choose from.</p>",
        "id": 179476220,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572468981
    },
    {
        "content": "<p>That makes sense John; is it inconsistent with my summary above?</p>",
        "id": 179476281,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572469025
    },
    {
        "content": "<p>I am not sure it is always (1) complected... unless you are just saying that \"security\" is always complecated...</p>",
        "id": 179476434,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572469090
    },
    {
        "content": "<p>if one is just poking in the notification, then the access control falls back to normal REST access control.. if you call normal REST access control hard to enforce immediately... then okay.</p>",
        "id": 179476508,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572469134
    },
    {
        "content": "<p>I mean, the complications seemed evident to me from the discussion above ;-)</p>",
        "id": 179476511,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572469136
    },
    {
        "content": "<p>yup</p>",
        "id": 179476542,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572469148
    },
    {
        "content": "<p>\"just poking\" doesn't necessarily mitigate concerns when the presence of a poke is deeply revealing/undesirable (see Gino's examples above).</p>",
        "id": 179476566,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572469166
    },
    {
        "content": "<p>that was my point on 'risk'</p>",
        "id": 179476824,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572469300
    },
    {
        "content": "<p>you identify this as a risk of the poke model...</p>",
        "id": 179476853,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572469319
    },
    {
        "content": "<p>some uses will find that risk very acceptable, others will not (like the given subscripiton from planned-parenthood)</p>",
        "id": 179476932,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572469354
    },
    {
        "content": "<p>whle there i also a risk of sending the PHI in the notification.. usually quite a bit higher... but if the notification content is mundaine (valueset of loinc codes has revised)... then that risk might be acceptable too</p>",
        "id": 179477027,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572469408
    },
    {
        "content": "<p>security/privacy considerations section is often just a list of 'considerations'... aka identification of risks without mitigation</p>",
        "id": 179477126,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572469450
    },
    {
        "content": "<p>one never gets risk to zero... especially in an interop specification.</p>",
        "id": 179477154,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572469475
    },
    {
        "content": "<p>Yes -- I think we're saying the same thing here.</p>",
        "id": 179477160,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572469478
    },
    {
        "content": "<p>(dancing)</p>",
        "id": 179477172,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572469492
    },
    {
        "content": "<p>Right - my point was that invalidating, for example, when the app itself is removed or access is revoked for that app is probably doable consistently. Once you start saying things like \"or the user loses access\" that is when it starts to become pretty tough to do consistently or completely</p>",
        "id": 179545216,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572537131
    },
    {
        "content": "<p>And that use case is generally where the other security mechanisms come into play: one which we're missing is even limiting what type of subscriptions a system can support (since the poke itself can give info away to varying degrees)</p>",
        "id": 179545356,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572537207
    },
    {
        "content": "<p>The guidance we were getting into was pretty targeted and \"the server will do\" vs more of a general security guidance and considerations section</p>",
        "id": 179545477,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572537255
    },
    {
        "content": "<p>But we should definitely say that the security context under which the subscription was created is assumed to be the context of the lifetime of the subscription. That is something that was not clear before, and has been discussed at other connectathons</p>",
        "id": 179545572,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572537337
    },
    {
        "content": "<p>Interestingly, for those sending full bodies of data, there is really no way for them to actually enforce that</p>",
        "id": 179545601,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572537360
    },
    {
        "content": "<blockquote>\n<p>Jenni Syed: Interestingly, for those sending full bodies of data, there is really no way for them to actually enforce that</p>\n</blockquote>\n<p>Wait, no way for these servers to enforce ... what ?</p>",
        "id": 179878426,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1572902858
    },
    {
        "content": "<p>That the data is only used under the same authorization context as it was originally subscribed with</p>",
        "id": 179884946,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572907250
    },
    {
        "content": "<p>Seems we are getting upside-down. The requester OAuth token is authorizing the requester to have access to the data. The subscription manager checks that authorization applies to the requested subscription. If that same token is used to push the updated PHI to the notification endpoint provided by the requester; then one could present this as authorized. This because the subscription manager is simply enforcing the decision it was given. <br>\nMy worry with this kind of token reuse is that the subscription notification endpoint can't validate that the data are from an authentic data holder, as that endpoint is never given identity of the sending side of that notification transaction. Thus it can't differentiate these notifications from unauthentic notifications.<br>\nThis is why I am not a fan of using the requester OAuth token on the notification pathway (that is when the notification is carrying PHI and not just a poke)</p>",
        "id": 179885872,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572908095
    },
    {
        "content": "<p>I understand that since this is based on an extension of standard OAuth, it may not be a solution we're looking for, but in a similar (non-healthcare) project involving webhook-based subscriptions, we tweaked the authorization service (at the endpoint equivalent to OAuth Introspection) to return (among other things) the expiry date of the client's refresh token and then ensured that the webhook subscription is set to be valid no later than the expiry date of the client's refresh token. For example, if a client provided an access token which was valid for 10 minutes, and the authorization server records also noted that that the client is in possession of a refresh token valid until the end of the month, the latter date was used as the expiry date of the subscription.</p>\n<p>I think if we think of a subscription as a form of pre-authorization for access instances scheduled for future, the main access control requirement here is to make sure the client is not able to schedule any access beyond the date-time at which its current authorization expires. I think the refresh token's expiry is a reasonable and practical upper bound for a client's authorization. The client can <em>renew</em> the subscription by an <code>UPDATE</code> or <code>PATCH</code> and by providing a new access token backed by a newer refresh token.</p>",
        "id": 179894385,
        "sender_full_name": "Mohammad Jafari",
        "timestamp": 1572917466
    },
    {
        "content": "<p>Would like to memorialize some of these discussions, so am starting a confluence page as an informal place to write these. This is not to take the place of Change Requests, or formal Implementation Guide. Rather it is a way to get consensus to jumping to those solutions.  Please contribute, and question content.   (Note that I am proposing that this is a broader topic of callbacks, not just \"Subscription\" resource)<br>\n<a href=\"https://confluence.hl7.org/display/SEC/FHIR+subscriptions+security\" target=\"_blank\" title=\"https://confluence.hl7.org/display/SEC/FHIR+subscriptions+security\">https://confluence.hl7.org/display/SEC/FHIR+subscriptions+security</a></p>",
        "id": 179962881,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572979529
    },
    {
        "content": "<p>To be clear: I am <em>not</em> stating that the OAuth token originally used is sent anywhere to the original caller. I think what is being discussed here is that the token/user/app in use (and all privs) when the subscription is created governs the data that can be sent/notified for that subscription</p>",
        "id": 179963740,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572979983
    },
    {
        "content": "<p>That doesn't require storage or maintenance of that token - but likely would require storage of metadata around the context it represented</p>",
        "id": 179963774,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572980010
    },
    {
        "content": "<p>that is what I too was proposing.    This does bring up a question about how the manager does identify to the callback endpoint... Easy would be by way of the manager TLS certificate, but many in http/REST hate client certificates</p>",
        "id": 179964156,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572980226
    },
    {
        "content": "<p>For validating the server, one idea we've started throwing around is having the server (optionally) sign messages with a public/private key pair (e.g., public key discoverable via capabilities statement).</p>",
        "id": 179965285,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572980776
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> </p>\n<blockquote>\n<p>Easy would be by way of the manager TLS certificate, but many in http/REST hate client certificates</p>\n</blockquote>\n<p>Can you summarize why it is hated?</p>",
        "id": 179967059,
        "sender_full_name": "Eric Haas",
        "timestamp": 1572981840
    },
    {
        "content": "<p>Certificate management requires quite a bit of infrastructure.  It means installing certificates on every client, updating those certificates when they expire, etc.  In closed, tightly managed environments it can be practical (though not necessarily easy).  In open, loosely managed environments, it's near impossible.</p>",
        "id": 179968007,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1572982338
    },
    {
        "content": "<p>Hence why fhir messaging is so loathsome to many?</p>",
        "id": 179968081,
        "sender_full_name": "Eric Haas",
        "timestamp": 1572982402
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>  can I steal your explanation?</p>",
        "id": 179968214,
        "sender_full_name": "Eric Haas",
        "timestamp": 1572982462
    },
    {
        "content": "<p>Lloyd, I was very clear that the subscription manager will already have a TLS certificate, thus all the management is DONE. It is just using it in client mode for th ecallback</p>",
        "id": 179968222,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572982468
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>  are you suggesting is not a housekeeping pain but a technical issue?</p>",
        "id": 179968434,
        "sender_full_name": "Eric Haas",
        "timestamp": 1572982585
    },
    {
        "content": "<p>yes, client certs in TLS do cause a problem at the server side... if you are using an API gateway or TLS acceleration.</p>",
        "id": 179968576,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572982682
    },
    {
        "content": "<p>what I am saying is that the subscription manager must have a TLS cert so that it can have a HTTPS endpoint to receive the POST/GET of the Subscripiton request.</p>",
        "id": 179968677,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572982730
    },
    {
        "content": "<p>John, I don't think that's always true (that the manager will have a TLS certificate).  If the server responsible for sending notifications is not the same as the server receiving external calls, there would be no reason to have one there.</p>\n<p>It's also common to have a proxy handle the TLS and forward unencrypted requests within an internal network - in which case none of the servers have a cert installed.</p>",
        "id": 179968721,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572982765
    },
    {
        "content": "<p>agreed</p>",
        "id": 179969453,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572983195
    },
    {
        "content": "<p>I never said it was a good general solution. I don't think there are good general solutions.. just a bunch of options that each have a tradeoff</p>",
        "id": 179969494,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572983224
    },
    {
        "content": "<p>Fair enough.  I think the challenge will be in what we can suggest as generally useful (low bar for broad adoption) vs what we would like to have but know is out of reach.</p>",
        "id": 179970498,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572983880
    },
    {
        "content": "<p>bestcase is that this need for callback is solved in the general IT OAuth space and we just use that. Seems like we are inventing far too much</p>",
        "id": 179972158,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572984893
    },
    {
        "content": "<p>That would be great!  Unfortunately, I think it's out of scope for them.  <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 179972886,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572985332
    },
    {
        "content": "<p>how is the general http/OAuth world not having a need for callback?</p>",
        "id": 179974318,
        "sender_full_name": "John Moehrke",
        "timestamp": 1572986156
    },
    {
        "content": "<blockquote>\n<p>OAuth 2.0 focuses on client developer simplicity while providing specific authorization flows for web applications, desktop applications, mobile phones, and living room devices.</p>\n</blockquote>\n<p>I don't see anything that involves a third-party or subsequent outgoing requests.</p>\n<p>The 'hammer approach(1)' I can see (right now) using OAuth would be to have the user authenticate with the Subscription server as the client, which would then give the server a token and refresh token that it could maintain/use.  Then, the token could be checked prior to sending out notifications.</p>\n<p>Actually, after typing this I'm not sure I hate it.</p>\n<p>(1) When your only tool is a hammer, all your problems look like nails.</p>",
        "id": 179976443,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572987297
    },
    {
        "content": "<p>What you just described is what was currently described in the spec, except that it snuck that in via the headers field (we raised concerns about that trick before). Though it didn't really allow for the refresh - it assumed the token was long lived. Which could be problematic :)</p>",
        "id": 179976608,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572987389
    },
    {
        "content": "<p>I would love for whatever we land on to be more explicit and less easy to miss :)</p>",
        "id": 179976631,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1572987408
    },
    {
        "content": "<p>In the current spec, it just has a place for an Auth Header.</p>\n<p>What I'm thinking right now would be that as part of creating a subscription, there would be a step where the Subscription server needs to perform the OAuth workflow to the Endpoint.</p>\n<p>It means that the endpoint would be <em>required</em> to support OAuth (instead of just accepting a JWT token), and I would keep the token out of subscription.</p>\n<p>It feels a little convoluted, and I'm not convinced I love requiring OAuth on Endpoints... but it feels much more secure and reliable.</p>",
        "id": 179977198,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572987680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> <span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span> to clarify, is the concern you're trying to address here, the authorization for the callback (from the subscription server to the client's registered callback endpoint)? I'm trying to understand why the subscription server needs an oauth token for the call back to the client. Usually for webhooks, the concern is authenticity, i.e. whether the call back is indeed coming from the subscription server which can be addressed with simpler solutions (e.g. a common approach I have seen is an hmac signatures using a shared secret provided by the client and recorded with the subscription context).</p>",
        "id": 179987662,
        "sender_full_name": "Mohammad Jafari",
        "timestamp": 1572995258
    },
    {
        "content": "<p>Hi Mohammad, I think this has turned into a general 'security on subscriptions' thread, unfortunately.</p>\n<p>If I am sorting through everything correctly, I see two main topics:<br>\n- How does a server know if it should send a notification (authorization window of subscription)?<br>\n- How does an Endpoint know that it should accept a notification (authorization of server to send notification)?</p>\n<p>I am trying to synthesize what the opinions are around the two into proposals (as far as what needs to go into the resource specs, what needs to go in the security docs, what needs to go into the Argonaut IG, and what needs to be noted as not listed and why (e.g., we feel the bar is too high for mutual TLS to be adopted - so considered and excluded).</p>",
        "id": 179988166,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1572995742
    },
    {
        "content": "<p>Do we think the requirements on auth change are based on the subscription type (ping, id-only, full content)? I'm hoping yes and want to make sure we don't end up mandating the receiving server needs to dance the OAuth dance in order to receive pings. :)</p>",
        "id": 180003811,
        "sender_full_name": "Pascal Pfiffner",
        "timestamp": 1573017509
    },
    {
        "content": "<p>I agree with <span class=\"user-mention\" data-user-id=\"191339\">@Pascal Pfiffner</span> . This full bi-directional OAuth use would only be needed when the notification carries PHI. So the client requesting the subscription is in-charge of which type of subscription they are asking for. Thus if that client asks for full content, then it must also recognize that the endpoint it provides must support the OAuth responsibilities.</p>",
        "id": 180032561,
        "sender_full_name": "John Moehrke",
        "timestamp": 1573047493
    },
    {
        "content": "<p>we all should remember that the client can always cancel the Subscription by updating the Subscripiton. So the OAuth checks are necessary but not the typical way to cancel a subscription. The OAuth is primarly going to catch the cases Jenni pointed out much earler in the stream, when the user or app has a security revocation. If the user / app want the subscription to be cancled they would update Subscription</p>",
        "id": 180032802,
        "sender_full_name": "John Moehrke",
        "timestamp": 1573047679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191339\">@Pascal Pfiffner</span> as of right now, I believe that's an implementation detail.  Servers are on the hook for what they do, so they will impose those types of restrictions (e.g., some servers may not allow <code>full-resource</code> at all).</p>\n<p>With these discussions, I am trying to make sure the mechanisms in place are reasonably secure and that there is guidance on what should be looked at so implementers aren't broadcasting PHI by using it 'out of the box'.</p>\n<p>I would prefer more security, but am realistic enough to know it's too high a barrier for adoption (e.g., end-to-end encryption, key exchanges, etc.).</p>\n<p>I <em>am</em> hopeful that some additional channel types eventually 'win' and can be moved into the standard with those types of security, but this likely needs to be in production for a while before that can be properly discussed.</p>",
        "id": 180041727,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1573053333
    }
]