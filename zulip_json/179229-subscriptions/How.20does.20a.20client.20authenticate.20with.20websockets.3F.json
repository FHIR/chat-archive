[
    {
        "content": "<p>Browser-based websocket libraries don't generally support sending HTTP headers during the creation of a websocket connection. (See heroku's excellent <a href=\"https://devcenter.heroku.com/articles/websocket-security\" target=\"_blank\" title=\"https://devcenter.heroku.com/articles/websocket-security\">explanation of websocket security</a>, <a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc6455\">RFC 6455</a>, and <a href=\"https://fhircast.hl7.org/security-considerations/#experimental-websockets-support\" target=\"_blank\" title=\"https://fhircast.hl7.org/security-considerations/#experimental-websockets-support\">FHIRcast's security considerations page</a> and proposed resolution to this problem).</p>",
        "id": 168512185,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1560954907
    },
    {
        "content": "<p>Since there's a single url on the FHIR server that all websocket clients connect to, the FHIR server only identifies clients through the <a href=\"https://build.fhir.org/subscription.html#2.46.8.2\" target=\"_blank\" title=\"https://build.fhir.org/subscription.html#2.46.8.2\">bind/bound exchange</a> of the Subscription resource id. This isn't authentication.</p>",
        "id": 168512194,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1560954911
    },
    {
        "content": "<p>The Subscriptions spec currently has this bullet, which I don't fully understand:</p>\n<blockquote>\n<p>Client authenticates to server using a server-specified Web socket protocol (e.g. OAuth bearer token presentation).</p>\n</blockquote>",
        "id": 168512201,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1560954915
    },
    {
        "content": "<p>Can anyone explain to me what the \"OAuth bearer token presentation using a server-specified Web socket protocol\" means? I think this probably means that the client should pass it's bearer access_token in the <code>Sec-WebSocket-Protocol</code> http header during the request.</p>",
        "id": 168512208,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1560954919
    },
    {
        "content": "<p>Should the server respond with the token in the same header in the response? What else should be in this header?</p>",
        "id": 168512210,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1560954922
    },
    {
        "content": "<p>It's a hack to authenticate via this header, but supporting browser websockets doesn't give many options.</p>",
        "id": 168512214,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1560954925
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216906\">@Amy Ballard</span>  Was able to do secure websockets with Grahame's server, I believe (at the last connectathon)</p>",
        "id": 168514064,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1560956205
    },
    {
        "content": "<p>Which would also imply that <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> has implemented websocket security from a server perspective :)</p>",
        "id": 168514125,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1560956272
    },
    {
        "content": "<p>client auth could be done via mutual-authenticated-TLS...    but, that is often not an optimal solution.</p>",
        "id": 168514205,
        "sender_full_name": "John Moehrke",
        "timestamp": 1560956316
    },
    {
        "content": "<p>Or it's possible she tried and wasn't able to get connected...</p>",
        "id": 168514221,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1560956333
    },
    {
        "content": "<p>I'm not entirely sure when mutual auth <em>is</em> the optimal solution ;)</p>",
        "id": 168514238,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1560956353
    },
    {
        "content": "<blockquote>\n<p>I'm not entirely sure when mutual auth <em>is</em> the optimal solution ;)</p>\n</blockquote>\n<p>when no other solution is available..  :-)</p>",
        "id": 168514281,
        "sender_full_name": "John Moehrke",
        "timestamp": 1560956395
    },
    {
        "content": "<p>non-user situations in b-2-b...</p>",
        "id": 168514377,
        "sender_full_name": "John Moehrke",
        "timestamp": 1560956439
    },
    {
        "content": "<p>aka messaging... especially hl7 v2, v3, DICOM, etc... but also FHIR messaging... The main point is that the server doesn't need to make any decision about the client except that they are authorized to connect to this endpoint. That is to say there is no application level business rules (User Role, App, context, etc).</p>",
        "id": 168514529,
        "sender_full_name": "John Moehrke",
        "timestamp": 1560956535
    },
    {
        "content": "<p>which might be considerted the case in the subscription use of websockets as the notification channel.</p>",
        "id": 168514584,
        "sender_full_name": "John Moehrke",
        "timestamp": 1560956576
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span> I tired and was not able to connect securely. I tried passing the Authorization header with the bearer token, which didn't work. As <span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span> mentioned, passing HTTP headers is not supported by browsers anymore so not really a viable option anyway. Other than <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>'s server, al other servers allowed me to connect by creating the connection with wss:// url with no additional authorization, so although the connection was secure anyone could connect.</p>",
        "id": 168520506,
        "sender_full_name": "Amy Ballard",
        "timestamp": 1560960515
    },
    {
        "content": "<p>It does seem that Grahame's server has something in place for authorization for secure websockets since is was returning a 401 when I attempted to connect</p>",
        "id": 168520881,
        "sender_full_name": "Amy Ballard",
        "timestamp": 1560960821
    },
    {
        "content": "<p>I'll have to investigate. it worked without security?</p>",
        "id": 168549886,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1560982007
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> for your server I could connect with ws:// without security as expected. I didn't figure out how pass the auth token to get connected with  wss:// . I was getting 401 as you'd expect for not getting the authorization correct. All the other servers at the connectathon had no authorization protecting their wss:// endpoints.</p>",
        "id": 168555991,
        "sender_full_name": "Amy Ballard",
        "timestamp": 1560989281
    },
    {
        "content": "<p>I've been researching/thinking about this since the call yesterday as well.  From what I can see, the standard header-type authentications won't work because:<br>\n    1) While headers are supported on ws/wss connections, implementation support for them is spotty at best.<br>\n    2) Long-running connections (which these may be) have no way to re-authenticate (e.g., someone authorized today may not be tomorrow)<br>\nIt appears that common practice is to setup some sort of challenge/response.<br>\nBased on yesterday's call, we were looking to define handshake and heartbeat messages (so far I have been leaning towards transaction bundles with extensions), and I thought that we could add an extension for authorization to these as well (e.g., a field to pass the equivalent headers).<br>\nSince we are looking at sending transaction bundles over the wire already, everyone should have tooling for this and I believe it meets all the requirements for auth.<br>\nThoughts?</p>",
        "id": 169150162,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1561652734
    },
    {
        "content": "<p>May make more sense visually:<br>\n<a href=\"/user_uploads/10155/wZJcvv9srhDqYuxWBGoTsySY/WebsocketAuthIdea.png\" target=\"_blank\" title=\"WebsocketAuthIdea.png\">WebsocketAuthIdea.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/wZJcvv9srhDqYuxWBGoTsySY/WebsocketAuthIdea.png\" target=\"_blank\" title=\"WebsocketAuthIdea.png\"><img src=\"/user_uploads/10155/wZJcvv9srhDqYuxWBGoTsySY/WebsocketAuthIdea.png\"></a></div>",
        "id": 169159296,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1561658851
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span> We had talked back in Montreal about WS clients in <a class=\"stream\" data-stream-id=\"179271\" href=\"/#narrow/stream/179271-FHIRcast\">#FHIRcast</a> using a <code>protocol</code> header to pass along an OAuth token; did this get assessed and turned down?</p>",
        "id": 169255526,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561750573
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> ,</p>",
        "id": 169262716,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561756355
    },
    {
        "content": "<p>It did get assessed and turned down, but just by me because I think it's ugly. Passing the access token in the protocol header (and subsequent problems/questions) is what I was trying to refer to in the seminal post of this topic.</p>",
        "id": 169262719,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561756360
    },
    {
        "content": "<p>Note that websockets defines the <code>Sec-WebSocket-Protocol</code> http header, which the client specifies during the initial request and which the server is supposed to echo back. Fundamentally, it's a hack to authenticate via this header, but supporting browser websockets doesn't give many options.</p>",
        "id": 169262725,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561756364
    },
    {
        "content": "<p>I'd encourage you to read heroku's excellent <a href=\"https://devcenter.heroku.com/articles/websocket-security\" target=\"_blank\" title=\"https://devcenter.heroku.com/articles/websocket-security\">explanation of websocket security</a>, and <a href=\"https://fhircast.hl7.org/security-considerations/#experimental-websockets-support\" target=\"_blank\" title=\"https://fhircast.hl7.org/security-considerations/#experimental-websockets-support\">FHIRcast's security considerations page</a> and proposed resolution to this problem) (Also <a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" title=\"https://tools.ietf.org/html/rfc6455\">RFC 6455</a>).</p>",
        "id": 169262730,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561756368
    },
    {
        "content": "<p>I think that the current Argo proposal -- putting the access token in the body of the FHIR bundle is better than hacking the protocol, but still weird in that it puts an access token in a FHIR resource (how should logging work? why does my security layer now have to understand FHIR?)I like the single-use \"ticket\" url method that's drafted in FHRcast.</p>",
        "id": 169262735,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561756371
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span>, I don't know that I'd call what I put above as a proposal yet, more just trying to understand what people have and what is desired.<br>\nThat said, part of my concern in using a header on the connection is that the only way to re-auth is to kill the connection (e.g., the connection has been open 24 hours, and I want to revalidate the token).  In the case of subscriptions, that can result in missed notifications.<br>\nOn the other hand, you are right (and Josh brought it up also), that having it inside the message has odd implications as well.</p>",
        "id": 169263153,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1561756777
    },
    {
        "content": "<p>It feels like there is no \"perfect\" solution, so I would like to fully understand the trade-offs before proposing something.</p>",
        "id": 169263285,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1561756897
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> !</p>",
        "id": 169266052,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759266
    },
    {
        "content": "<blockquote>\n<p>I don't know that I'd call what I put above as a proposal yet, </p>\n</blockquote>\n<p>Ah, I misunderstood then. I missed the argo call this week <span aria-label=\"embarrassed\" class=\"emoji emoji-1f633\" role=\"img\" title=\"embarrassed\">:embarrassed:</span>  on this and reading the notes/your post; it sounded like a done deal.</p>",
        "id": 169266054,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759272
    },
    {
        "content": "<blockquote>\n<p>In the case of subscriptions, that can result in missed notifications.</p>\n</blockquote>",
        "id": 169266060,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759283
    },
    {
        "content": "<p>Again, note the <a href=\"https://fhircast.hl7.org/security-considerations/#experimental-websockets-support\" target=\"_blank\" title=\"https://fhircast.hl7.org/security-considerations/#experimental-websockets-support\">FHIRcast proposed resolution</a> to this problem, is not a hack of the websockets header, but indeed does have the flaw of potential missed notifications during session re-connections.</p>",
        "id": 169266063,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759286
    },
    {
        "content": "<p>I hadn't understood that the goal was actual guaranteed message delivery. That's a hard problem for push notifications! Your handshake and heartbeat messages (and acknowledgements) are the beginnings of a full blown protocol, but even that doesn't completely prevent missed notifications.</p>",
        "id": 169266064,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759288
    },
    {
        "content": "<p>Hey back <span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span><br>\nI know that I keep drifting into reliable delivery, but that's not the goal.  We want to have a best-effort, but allow for the clients to detect/discover errors, and make sure there is a reasonable way to rebuild (other than wipe and start over).</p>",
        "id": 169266165,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1561759401
    },
    {
        "content": "<blockquote>\n<p>The client opens the WebSocket connection, and sends along this “ticket” as part of an initial handshake.</p>\n</blockquote>\n<p>This ticket might as well be an OAuth access token -- but how is it sent? What is \"the initial handshake\"? Are you saying in fhircast the handshake just \"connect to a URL\" (and visible to anyone logging HTTP GET traffic)?</p>",
        "id": 169266172,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759417
    },
    {
        "content": "<p>I am just trying to flesh out the result of \"Needs to be defined\" and want to understand what people have been doing already, along with the pros and cons.</p>",
        "id": 169266236,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1561759463
    },
    {
        "content": "<blockquote>\n<p>HIRcast describes a \"ticket\"-based authentication system, in which the hub.topic url provided to the subscriber as part of the secured SMART app launch serves not only as a unique session identifier, but also as an \"authorization ticket\". This authorization ticket effectively acts as a bearer token. The Hub should therefore take care to generate opaque and unique hub.topic values.</p>\n</blockquote>\n<p><a href=\"https://fhircast.hl7.org/security-considerations/#experimental-websockets-support\" target=\"_blank\" title=\"https://fhircast.hl7.org/security-considerations/#experimental-websockets-support\">https://fhircast.hl7.org/security-considerations/#experimental-websockets-support</a></p>",
        "id": 169266246,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759486
    },
    {
        "content": "<p>If FHIRcast embeds the authenticate secret into the URL, what's the Subscription equivalent? Would we define... an operation like <code>GET /Subscription/:id/$websocket-ticket</code> that returned a URL to connect to? Would we define a protocol to manage session renewal / expiration?</p>",
        "id": 169266273,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759515
    },
    {
        "content": "<p>Indeed, I was reading that text from fhircast -- that's what my questions are about.</p>",
        "id": 169266289,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759536
    },
    {
        "content": "<blockquote>\n<p>what's the Subscription equivalent? </p>\n</blockquote>\n<p>Yes. I imagined a 201 on the create with a wss:// url returned to the client.</p>",
        "id": 169266354,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759585
    },
    {
        "content": "<p>Or maybe the closer analogy is to say that when a SMART app launches, it receives a generic \"Websocket connection URL\" that it can connect to as many times as it wants, and bind to different subscriptions in each connection.</p>",
        "id": 169266375,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759629
    },
    {
        "content": "<blockquote>\n<p>Would we define a protocol to manage session renewal / expiration?</p>\n</blockquote>\n<p>No. Session/subscription end when the access token expires. Full stop. Create a new subscription.</p>",
        "id": 169266376,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759630
    },
    {
        "content": "<p>Wait, subscriptions persist well across sessions though.</p>",
        "id": 169266385,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759646
    },
    {
        "content": "<p>They can turn on and off, etc.</p>",
        "id": 169266387,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759649
    },
    {
        "content": "<p>not in FHIRcast</p>",
        "id": 169266400,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759663
    },
    {
        "content": "<p>Understood.</p>",
        "id": 169266402,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759667
    },
    {
        "content": "<p>but, okay</p>",
        "id": 169266406,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759672
    },
    {
        "content": "<p>I'm thinking about whether/how we could use that as a model in Subscriptions.</p>",
        "id": 169266407,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759677
    },
    {
        "content": "<p>On the websocket side in fhircast, do I understand right that the \"secret\" is just the URL that a client does a <code>GET</code> on to start the websocket connection?</p>",
        "id": 169266465,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759695
    },
    {
        "content": "<p>yup. So, a Subscription gets turned off when an access token expires.</p>",
        "id": 169266468,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759697
    },
    {
        "content": "<p>In the case of Subscriptions, Josh, I believe the access token would just be a transient token value.  It would only have meaning in the context of connecting to the wss:// url</p>",
        "id": 169266474,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1561759707
    },
    {
        "content": "<blockquote>\n<p>On the websocket side in fhircast, do I understand right that the \"secret\" is just the URL that a client does a GET on to start the websocket connection?</p>\n</blockquote>\n<p>Yes</p>",
        "id": 169266475,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759708
    },
    {
        "content": "<p>The client would then need to post another request, get the secret, and continue</p>",
        "id": 169266502,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1561759747
    },
    {
        "content": "<p>Okay -- so generally in SMART we've avoided embedding secrets in URLs. It's not a hard prohibition, obviously... but we've avoided it.</p>",
        "id": 169266509,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759764
    },
    {
        "content": "<p>the alternatives are:</p>\n<ul>\n<li>embedding the secret in a FHIR resource</li>\n<li>embedding the secret in the name of a sub-protocol</li>\n</ul>",
        "id": 169266520,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759791
    },
    {
        "content": "<ul>\n<li>embedding the secret in a newly created protocol layer wrapping all your websocket traffic</li>\n</ul>",
        "id": 169266579,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759815
    },
    {
        "content": "<ul>\n<li>not supporting browser-based clients using native websocket libraries in FHIR Subscriptions</li>\n</ul>",
        "id": 169266665,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561759924
    },
    {
        "content": "<blockquote>\n<p>embedding the secret in a newly created protocol layer wrapping all your websocket traffic</p>\n</blockquote>\n<p>I don't understand that one.</p>\n<p>OTherwise, yes agree with this list.</p>",
        "id": 169266684,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561759953
    },
    {
        "content": "<p>i.e., put the secret in the url, headers, or body.</p>\n<p>Those are the places.</p>",
        "id": 169266772,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561760044
    },
    {
        "content": "<blockquote>\n<p>a newly created protocol layer wrapping your websocket traffic</p>\n</blockquote>\n<p>This would be dividing the body into an auth header and the FHIR body -- like SOAP. The HTTP body is a SOAP header and a SOAP body.</p>",
        "id": 169266842,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1561760132
    },
    {
        "content": "<p>OK -- makes sense and it's a sub-flavor of \"body\".</p>",
        "id": 169266938,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1561760238
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 169267513,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1561760800
    },
    {
        "content": "<p>\"missed notifications\"  -- can a FHIR Client request the 'current state' of the context when it reconnects?  Is that sufficient?   Are we're talking about the 'small window of time' when the Client's session is timing out and reestablishing a new session or are we talking about a FHIR client that 'went away' and then came back, e.g. the user exited an app and then restarted it on same desktop?  (I assume the former)</p>",
        "id": 169296434,
        "sender_full_name": "John Silva",
        "timestamp": 1561813285
    },
    {
        "content": "<p>What has been discussed is the handshake including the Subscription state information (but no way to pull back events).  The reason for not forcing the events to be available is because that would be proscribing message-queuing, etc. to all servers wanting to implement.  I can see that some servers may allow the behavior.<br>\nMy original concern was around the time gap of re-authenticating (e.g., server times out token, client gets new one, client reconnects).  Otherwise the client may need to rebuild every time a token expires, which does not feel like a robust process to me.<br>\nTalking through, there appear to be remedies for this, so it shouldn't be an issue.</p>",
        "id": 169417356,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1562004448
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"194183\">@John Silva</span> , also note that fhir subscriptions is describing a backend data integration and doesn't communicate the user session-type context as handled by FHIRcast. (I wanted to start this conversation to point out the gaps in the backend subscriptions websockets support that FHIRcast has already considered).</p>",
        "id": 169532335,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1562116594
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193551\">@Marco Visser</span>  - OK, thanks</p>",
        "id": 169552234,
        "sender_full_name": "John Silva",
        "timestamp": 1562146420
    },
    {
        "content": "<p>Just found this thread.  We’ve been running FHIR resources over websockets for 3 or 4 years now via the Data Distribution Protocol (defined by MIT alumni).  The general idea is protocol hoisting, which would be “embedding the secret in a newly created protocol layer”, and that newly created layer being DDP.</p>\n<p><a href=\"https://github.com/meteor/meteor/blob/devel/packages/ddp/DDP.md\" target=\"_blank\" title=\"https://github.com/meteor/meteor/blob/devel/packages/ddp/DDP.md\">https://github.com/meteor/meteor/blob/devel/packages/ddp/DDP.md</a></p>",
        "id": 175720626,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1568499319
    },
    {
        "content": "<p>Is that in prod?</p>",
        "id": 175720677,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1568499368
    },
    {
        "content": "<p>Very much so.  It works great, and we’ve done probably 40 or 50 prototypes and pilots with it.  We have two instance (that I know of) published into the Apple App Store.</p>",
        "id": 175720853,
        "sender_full_name": "Abbie Watson",
        "timestamp": 1568499709
    },
    {
        "content": "<p>Excellent.</p>",
        "id": 175720857,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1568499721
    }
]