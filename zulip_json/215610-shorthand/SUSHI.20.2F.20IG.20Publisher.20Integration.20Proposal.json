[
    {
        "content": "<p>We've been thinking about how to improve the SUSHI / IG Publisher integration.  Here is a proposal to start some discussion.  We'd love your feedback.  <em>Full Disclosure: I am going on two weeks vacation tomorrow, but please discuss anyway -- <span class=\"user-mention\" data-user-id=\"191447\">@Mark Kramer</span> and others on the SUSHI/FSH team can engage.</em></p>\n<p><strong>Goal</strong>: To allow FHIR Shorthand (FSH) to be more easily integrated into FHIR Implementation Guides using the <em>standard FHIR IG template</em> project structure, avoiding the need for special folders like <code>ig-data</code>.</p>\n<p><strong>BLUF:</strong></p>\n<ul>\n<li>Authors maintain <code>.fsh</code> files in <code>input/fsh</code></li>\n<li>The <code>config.yaml</code> is maintained in the root folder (but is <em>optional</em> for FSH-only users)<ul>\n<li>If <code>config.yaml</code> is provided, SUSHI will generate the <code>ImplementationGuide</code> JSON and other IG files (as indicated in the <code>config.yaml</code> file), in addition to the FHIR definitions</li>\n<li>If <code>config.yaml</code> is <em>not</em> provided, SUSHI will generate FHIR definitions only and will use the provided <code>ImplementationGuide</code> JSON to determine the <code>canonical</code>.</li>\n</ul>\n</li>\n<li>SUSHI writes all output to the locations IG Publisher expects. This means that some generated files may be intertwined with author-maintained (non-generated) files.</li>\n<li>SUSHI provides two new capabilities to help authors manage generated files:<ul>\n<li><code>sushi --clean</code> deletes all generated files, allowing authors to perform \"clean builds\"</li>\n<li><code>sushi --update-ignore</code> updates the <code>.gitignore</code> file to ignore all generated files (so they aren't checked in)</li>\n</ul>\n</li>\n</ul>\n<p><strong>PLEASE FOLLOW THIS LINK FOR EXAMPLES AND DETAILS -----&gt;</strong> <a href=\"https://gist.github.com/cmoesel/af6c05e008f726a89dd55505a8190f4b\">https://gist.github.com/cmoesel/af6c05e008f726a89dd55505a8190f4b</a></p>",
        "id": 205978827,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1596589564
    },
    {
        "content": "<ol>\n<li>How are generated files? how does sushi detect them for the --clean?<br>\nFor example I was using sushi to generate a first codesystem, but then had to update it separately to create translations.</li>\n</ol>",
        "id": 205989901,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1596605703
    },
    {
        "content": "<ol start=\"2\">\n<li>I would prefer a post-processing step rather , but that is probably because I don't understand the .gitignore. I do want my committed files to look exactly like those I have in my local build</li>\n</ol>",
        "id": 205990276,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1596606342
    },
    {
        "content": "<ol>\n<li>If the file is defined as FSH, sushi would consider that a generated file. I think in your case of the CodeSystem, sushi would detect it and try to <code>clean</code> it. The separate updates would be overwritten. But in this context, couldn't you solve that problem by letting sushi generate the CodeSystem once, and then commenting out that section of FSH?</li>\n<li>I'm not sure what you mean by preferring  a \"post-processing\" step. You prefer this in comparison to what?</li>\n</ol>",
        "id": 206252647,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1596804671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239822\">Nick Freiter</span> <a href=\"#narrow/stream/215610-shorthand/topic/SUSHI.20.2F.20IG.20Publisher.20Integration.20Proposal/near/206252647\">said</a>:</p>\n<blockquote>\n<ol>\n<li>If the file is defined as FSH, sushi would consider that a generated file. I think in your case of the CodeSystem, sushi would detect it and try to <code>clean</code> it. The separate updates would be overwritten. But in this context, couldn't you solve that problem by letting sushi generate the CodeSystem once, and then commenting out that section of FSH?</li>\n</ol>\n</blockquote>\n<p>Thanks. I can comment it out, but how can I use it in a valueset? I think I would have to copy the codesystem.json to my input folder (ig-data) as a BYOJ.</p>",
        "id": 206258084,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1596807940
    },
    {
        "content": "<p>i guess I just don't see what is the .gitignore doing. Is it just telling github to ignore some local files and not push them to github?</p>",
        "id": 206258230,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1596808004
    },
    {
        "content": "<p>If so, that will likely get the local build and CI build misaligned more often than not... which I think is a bad idea.</p>",
        "id": 206258318,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1596808051
    },
    {
        "content": "<p>by post-processing I mean something like: </p>\n<ol>\n<li>sushi should do its work as a parser in a constant way - always same behaviour - fsh +BYOx in, json out.</li>\n<li>after that processing, sushi should generate the ig content in sushi's --output folder, (called <code>input</code> folder)</li>\n<li>finally, what was already defined in the IG (BYOx and ig.ini etc) should just (optionally) be carried over to the sushi's --output folder</li>\n</ol>",
        "id": 206258848,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1596808355
    },
    {
        "content": "<p>I'm just looking for a way that sushi can be working to create a part of an already existing IG. I don't know exactly how this should work but my concernsare :</p>\n<ul>\n<li>command line parameters cannot be used in the CI build or it's hard to pass them via the IG publisher. all should be autonomous.</li>\n<li>sushi can be run standalone or be part of the IG chain. like most tools, the hard part is to support the latter</li>\n</ul>",
        "id": 206266472,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1596811988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191832\">Jose Costa Teixeira</span> <a href=\"#narrow/stream/215610-shorthand/topic/SUSHI.20.2F.20IG.20Publisher.20Integration.20Proposal/near/206258230\">said</a>:</p>\n<blockquote>\n<p>i guess I just don't see what is the .gitignore doing. Is it just telling github to ignore some local files and not push them to github?</p>\n</blockquote>\n<p>Yes.  and most repositories use the .gitignore both FHIR and non-FHIR.  As an example, I don't check in any of the temp directories or any of the .DS_Store files that Macs create.  I put that in the .gitignore.</p>",
        "id": 206275185,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1596816082
    },
    {
        "content": "<p>Sorry, I meant I know what it does. I don't know what good will bring 'ignore all generated files'</p>",
        "id": 206277015,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1596817013
    },
    {
        "content": "<p>Just seems to create a nice setup for people to go asking 'this works on my machine but the ci publisher says it's missing a file. Must be something with the publisher, because my machine works fine' - and those issues will be very hard to help debug, right?</p>",
        "id": 206277270,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1596817139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191832\">Jose Costa Teixeira</span> <a href=\"#narrow/stream/215610-shorthand/topic/SUSHI.20.2F.20IG.20Publisher.20Integration.20Proposal/near/206277270\">said</a>:</p>\n<blockquote>\n<p>Just seems to create a nice setup for people to go asking 'this works on my machine but the ci publisher says it's missing a file. Must be something with the publisher, because my machine works fine' - and those issues will be very hard to help debug, right?</p>\n</blockquote>\n<p>Well, the idea would be that the .gitignore file would only ignore JSON files generated by sushi. When the IG Publisher runs sushi locally and those files are present, they will be overwritten. When the IG Publisher runs sushi on the ci, those files would not be present, since they would be ignored, so they would be generated freshly by sushi.</p>",
        "id": 206287773,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1596822328
    },
    {
        "content": "<p>Ok, I see it now. I think this is a complicated way and a small in rent - I'd rather se a more robust (redesign)</p>",
        "id": 206289920,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1596823232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191832\">Jose Costa Teixeira</span> <a href=\"#narrow/stream/215610-shorthand/topic/SUSHI.20.2F.20IG.20Publisher.20Integration.20Proposal/near/206289920\">said</a>:</p>\n<blockquote>\n<p>Ok, I see it now. I think this is a complicated way and a small in rent - I'd rather se a more robust (redesign)</p>\n</blockquote>\n<p>Which aspects of this approach do you feel aren't robust? Is it the part with <code>.gitignore</code> excluding generated files from being checked in? To be clear, that is an optional feature. If someone wants their generated files to be checked into source control, they do not have to use the <code>--update-ignore</code> script.</p>",
        "id": 206454309,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1597062214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239822\">Nick Freiter</span> <a href=\"#narrow/stream/215610-shorthand/topic/SUSHI.20.2F.20IG.20Publisher.20Integration.20Proposal/near/206454309\">said</a>:</p>\n<blockquote>\n<p>Which aspects of this approach do you feel aren't robust? Is it the part with <code>.gitignore</code> excluding generated files from being checked in? To be clear, that is an optional feature. If someone wants their generated files to be checked into source control, they do not have to use the <code>--update-ignore</code> script.</p>\n</blockquote>\n<p>Thanks. First, by \"small in rent\" i meant \" small increment\" - I mean that the ig-data feels like it was designed for sushi to be fully autonomous in providing the entirety of the content, and not designed for the fact that sushi is one component in the IG publishing chain. So these seem like local optimisations, but I would rather step back and see would be a way to do fsh parsing and IG preparation - if we did not have that ig-data folder, would we do things the same way?</p>",
        "id": 206457518,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597064529
    },
    {
        "content": "<p>I do not know why .gitignore thing - I'm sure there are legitimate use cases, but this may create a big confusion between local build and remote build.</p>",
        "id": 206457616,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597064608
    },
    {
        "content": "<p>Well to us, this proposal does seem like a way of making SUSHI a part of the IG Publisher chain. If someone does not want to manage IG Publisher files via SUSHI, they would only have to put FSH files in <code>input/fsh</code>, and SUSHI would use the <code>ImplementationGuide</code> JSON file to get the information it needs to process those FSH files into JSON. That seems like it is essentially as minimally invasive as possible.</p>",
        "id": 206460536,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1597066410
    },
    {
        "content": "<p>I appreciate the direction. What I've been experiencing is that it's not as simple as putting fsh file in the input/fsh. Those are my challenges.<br>\nIt's ok to have some command line options, but in a CI build the user will not be able to add those.</p>",
        "id": 206471847,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597072174
    },
    {
        "content": "<p>the .gitignore I fail to see the purpose, honestly.</p>",
        "id": 206471978,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597072232
    },
    {
        "content": "<p>concrete improvement suggestions:</p>\n<ol>\n<li>\n<p>in the integration, we could use the -o parameter to let sushi write its output to a \"sushi-generated\" folder - we don't have to mix them with the existing files in the <code>input/*</code> folder. That additional folder is quite easy to manage by any of the tools.<br>\n1.1. instead of gitignore on file level, we can just -gitignore that folder.</p>\n</li>\n<li>\n<p>Would it be interesting to we add a parameter to sushi for \"additional folder for BYOx\"? <br>\n2.1 Perhaps that would even have <code>input/</code> as default, and not need this at all all sushi stuff is in a separate folder</p>\n</li>\n</ol>",
        "id": 206476964,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597074632
    },
    {
        "content": "<p>Your second suggestion is a part of this proposal, SUSHI would just look in the surrounding <code>input/</code> folders for the BYO content, so we agree that something along those lines could be useful.</p>",
        "id": 206477896,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1597075131
    },
    {
        "content": "<p>The first suggestion would also be simpler than a complicated.gitignore and --clean, I think. But if this starts working I can propose to put this in the template for example</p>",
        "id": 206478967,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597075644
    },
    {
        "content": "<p>We are also wary of requiring other parts of the IG Publisher toolchain to do more work to support sushi. The proposal above would only require that the IG Publisher runs sushi if it sees an <code>input/fsh</code> folder (as opposed to the current behavior of running sushi if it sees a <code>fsh</code> folder), and then sushi would take care of the rest, and the IG Publisher could run as normal. If we were to make a <code>sushi-generated</code> folder, the IG Publisher would now have to look through that folder for definitions.</p>",
        "id": 206490151,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1597081356
    },
    {
        "content": "<p>Looking in an additional folder is easy - it's one parameter that can be added to the template.</p>",
        "id": 206498552,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597085624
    },
    {
        "content": "<p>I'm looking for the minimal changes to sushi that provide the ease for most users but reserve power to advanced users</p>",
        "id": 206498862,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597085771
    },
    {
        "content": "<p>Sushi would only need to implement something like my suggestion 2. #1 we can do in the integration - you don't need to mess with .gitignore or perhaps even the -clean option.</p>",
        "id": 206500283,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597086384
    },
    {
        "content": "<p>It could be a <em>bit</em> confusing to have a <code>sushi-generated</code> folder, because some people will still use sushi  to generate things like <code>ImplementationGuide</code> JSON,<code>ig.ini</code>, and <code>menu.xml</code> based on <code>config.yaml</code>, and those will not be in that folder. That being said, it would provide a more clean separation between author maintained (non-generated) files and generated files, which is an admitted weakness of Chris's proposal above. If it is easy enough for the IG Pub to just look in one more folder, I can't speak for the rest of the team, but to me it seems that is more simple than intermixing definitions among non-generated resource. If any other users have feedback on how this could influence their usage of sushi, we would love to hear it as well.</p>",
        "id": 206501835,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1597087191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191469\">Chris Moesel</span> <a href=\"#narrow/stream/215610-shorthand/topic/SUSHI.20.2F.20IG.20Publisher.20Integration.20Proposal/near/205978827\">said</a>:</p>\n<blockquote>\n<p>We've been thinking about how to improve the SUSHI / IG Publisher integration.  Here is a proposal to start some discussion.  We'd love your feedback.  <em>Full Disclosure: I am going on two weeks vacation tomorrow, but please discuss anyway -- <span class=\"user-mention silent\" data-user-id=\"191447\">Mark Kramer</span> and others on the SUSHI/FSH team can engage.</em></p>\n</blockquote>\n<p>I really like this proposal.  I have a couple of questions but overall this makes complete sense to me and goes much further towards a decent IGPublisher integration.</p>\n<p>1) I don't understand what the line \"In addition, the --clean flag can be used when building FSH source to establish a clean build.\" is referring to in the section on sushi --clean.<br>\n2) Would it be possible, if I wanted to segregate my FSH files that way, to put FSH files in the various input directories?  i.e. if myfile1.fsh only has profiles, could I put it in input/profiles and have SUSHI generate appropriate JSONs from that?  That's not how I currently build my FSH files but I can see someone wanting a one-to-one correspondence between artifacts and FSH files.</p>",
        "id": 206501919,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1597087225
    },
    {
        "content": "<p>1) I am also unsure about this actually. I think what this is meant to mean is that you can do <code>sushi --clean</code> to delete all sushi generated files, or you can do <code>sushi --clean /path/to/project</code> to delete and then rebuild all sushi generated files. But, since sushi overwrites files anyway, I'm not sure why you would need to delete all the files and then rebuild, as opposed to just overwriting.<br>\n2) We've considered structures like this in the past. On the sushi end, sushi already works by recursively looking for <code>.fsh</code> files, so it would not be hard for sushi to just search through a set of folders for <code>.fsh</code> files instead of a single folder. But I think this would complicate things for the Publisher. Instead of triggering a sushi run if there is a <code>fsh</code> (or <code>input/fsh</code>) folder, the Publisher would have to search through all folders for <code>.fsh</code> files, and trigger a run of sushi based on that.</p>",
        "id": 206503629,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1597088139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239822\">Nick Freiter</span> <a href=\"#narrow/stream/215610-shorthand/topic/SUSHI.20.2F.20IG.20Publisher.20Integration.20Proposal/near/206501835\">said</a>:</p>\n<blockquote>\n<p>It could be a <em>bit</em> confusing to have a <code>sushi-generated</code> folder, because some people will still use sushi  to generate things like <code>ImplementationGuide</code> JSON,<code>ig.ini</code>, and <code>menu.xml</code> based on <code>config.yaml</code>, and those will not be in that folder. </p>\n</blockquote>\n<p>Depends. If we want to be thorough, we could make <code>sushi-generated</code> contain a <code>input</code> folder for the generated conformance resources only, and the other files in the parent folder.<br>\nIn my view, those other files don't need to be regenerated every time that sushi runs. For me, creating those files is something that you do once on setup or every time you change the corresponding input. I'd suggest separating that (setup file generation) from the conformance resource generation. (check <span class=\"user-mention\" data-user-id=\"192166\">@Jean Duteau</span> 's suggestion a few weeks ago to have sushi default to FSHOnly or accept it as a command line parameter)</p>",
        "id": 206503751,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597088182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239822\">Nick Freiter</span> <a href=\"#narrow/stream/215610-shorthand/topic/SUSHI.20.2F.20IG.20Publisher.20Integration.20Proposal/near/206503629\">said</a>:</p>\n<blockquote>\n<p>But I think this would complicate things for the Publisher. Instead of triggering a sushi run if there is a <code>fsh</code> (or <code>input/fsh</code>) folder, the Publisher would have to search through all folders for <code>.fsh</code> files, and trigger a run of sushi based on that.</p>\n</blockquote>\n<p>If sushi can get all the *.fsh files in the --input folder and subfolders, I don't see why the publisher needs to do something.</p>",
        "id": 206505051,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597088895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191832\">Jose Costa Teixeira</span> <a href=\"#narrow/stream/215610-shorthand/topic/SUSHI.20.2F.20IG.20Publisher.20Integration.20Proposal/near/206505051\">said</a>:</p>\n<blockquote>\n<p>If sushi can get all the *.fsh files in the --input folder and subfolders, I don't see why the publisher needs to do something.</p>\n</blockquote>\n<p>How would the IG Publisher know to run sushi in the first place? Currently as far as I know, the running of sushi is triggered by the presence of the <code>fsh</code> folder. If <code>.fsh</code> files are all spread out, the Publisher needs to look through all folders to see if any <code>.fsh</code> files are present, so that it can know sushi should even run.</p>",
        "id": 206506006,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1597089459
    },
    {
        "content": "<p>can we not safe-run sushi and have sushi exit with \"0 - nothing to do\" ?</p>",
        "id": 206506154,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597089538
    },
    {
        "content": "<blockquote>\n<p>We are also wary of requiring other parts of the IG Publisher toolchain to do more work to support sushi</p>\n</blockquote>\n<p>I don't mind if it makes for a better experience for users</p>",
        "id": 206519714,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597097552
    },
    {
        "content": "<p>From what I learned today, a few changes that I think would make for a better integration:</p>\n<ol>\n<li>Make sushi work by default (or via command line option) in FSHOnly mode.</li>\n<li>Make the <code>ig-data</code> folder a command line parameter (remains the folder that contains non-fsh stuff like the BYOx, or the ig.ini, ig.xml, or package.json(?)...)</li>\n<li>Get sushi to exit gracefully if there are no fsh folders in the input folder (so that you can always run sushi without having to detect an fsh folder)</li>\n<li>Eventually add more input folders? Not sure if needed.</li>\n<li>Change the command line in the publisher accordingly: sushi [-FSHOnly] [-ig-data=.] ./input [-o sushi-generated]</li>\n<li>Change the template to add \"sushi-generated\" as a resource folder</li>\n</ol>",
        "id": 206521329,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597098928
    },
    {
        "content": "<p>One other thing we considered is trying to rename files that are generated by sushi to indicate as such. Aka a StructureDefinition generated by sushi may be in a file called <code>StructureDefinition-Foo-generated.json</code> instead of <code>StructureDefinition-Foo.json</code>. Is something like that possible with the IG Publisher? In experimenting it seems we couldn't do this, due to the Publisher requiring files to follow the format <code>resource-id.json</code> (or a related format).</p>",
        "id": 206600440,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1597165107
    },
    {
        "content": "<p>yes, that will be an issue. see<br>\n<a href=\"#narrow/stream/215610-shorthand/topic/Resource.20filename.20prefix\">https://chat.fhir.org/#narrow/stream/215610-shorthand/topic/Resource.20filename.20prefix</a></p>",
        "id": 206604101,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597166759
    },
    {
        "content": "<p>(sorry, sent wrong link before)</p>",
        "id": 206604242,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597166822
    },
    {
        "content": "<p>using a separate folder would be easy on both sides, I guess. I don't know if it has significant downsides.</p>",
        "id": 206604292,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1597166853
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239822\">@Nick Freiter</span> I could modify the IG publisher to support that, but I'm not convinced it's the right solution</p>",
        "id": 206619111,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1597173682
    }
]