[
    {
        "content": "<p>It seems like there should be a way for Sushi to generate capability statements for actors with some additional syntax.<br>\nEach StructureDefinition that applies to a resource could indicate: CreatedBy/For, UpdatedBy/For, ReadBy/For, SearchedBy/For, DeletedBy/For followed by a comma separated list of actor names.  Each OperationDefinition could indicate: ImplementedBy/For, followed by a comma separated list of actor names.</p>\n<p>The CapabilityStatement could be generated by Actor: followed by the name of the actor for which the capability statement applies.<br>\nIt would contain appropriate read/create/update/delete etcetera operation declarations based on what was declared for each StructureDefinition/OperationDefinition in the Fish Tank, where CreatedBy indicates a server operation, CreatedFor indicates a client operation.</p>\n<p>Ideally, the search capabilities would also be able to be grouped so that you could say: Must support this combination of search parameters and prefix/modifiers, but I think that would require a breaking change to CapabiltyStatement so that ship may have already sailed.</p>",
        "id": 188609432,
        "sender_full_name": "Keith Boone",
        "timestamp": 1582172743
    },
    {
        "content": "<p>That's a really interesting idea, <span class=\"user-mention\" data-user-id=\"191387\">@Keith Boone</span>.  TBH, we haven't really thought much about CapabilityStatements at all.  We know that we want to try to generate them if we can (since they're pretty tedious to write by hand) -- but hadn't yet thought about the actual approach.  I think that what you describe gives us something really good to think about! Unfortunately, I can't say for sure <em>when</em> we'll be ready to work it out more -- as we're still working out some of the basics of other stuff -- but I'd love to hear what others think as well.</p>",
        "id": 188610014,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1582173797
    },
    {
        "content": "<p>Yeah, I know <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> has some dreams about this.</p>",
        "id": 188610078,
        "sender_full_name": "Keith Boone",
        "timestamp": 1582173861
    },
    {
        "content": "<p>To be specific. these are CapabilityStatement of requirements kind, used to define the Actors in an Implementation Guide. Need this for all kinds of actors, not just the server.</p>",
        "id": 188637489,
        "sender_full_name": "John Moehrke",
        "timestamp": 1582206108
    },
    {
        "content": "<p>I like that <span class=\"user-mention\" data-user-id=\"191387\">@Keith Boone</span> . I think <span class=\"user-mention\" data-user-id=\"192302\">@May Terry</span> will be enthusiastic about it, as well. Any implementers out there ready to help out?</p>",
        "id": 188650669,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1582214241
    },
    {
        "content": "<p>help how?</p>",
        "id": 188673129,
        "sender_full_name": "David Hay",
        "timestamp": 1582229451
    },
    {
        "content": "<p>Great idea - what do we do with search parameters?</p>",
        "id": 188961356,
        "sender_full_name": "Bas van den Heuvel",
        "timestamp": 1582575106
    },
    {
        "content": "<p>My thoughts on search parameters:<br>\nGenerally, you'd list the set of search parameters supported.  Unfortunately, implementations vary on what sets are allowed to be used together.  For example, I generally require patient/subject to be specified unless searching by _id, and some combinations just aren't easily implemented.  Generalized search is HARD.  What I'd do there is define a named search operation that describes a combination of search parameters.  For my implementation framework, using named sets of search parameters is not all that hard, but not so for others, and how to define a combination without requiring someone to implement a named query is also challenging.   I use text descriptions to indicate these kinds of limits, but they should be computable.  Unfortunately, CapabilityStatement is normative, so I dunno how to fix this easily.  I'd probably add an extension to searchParam that allowed one to specify a list of possibly groupings, where each searchParam can be used with any others in the same named group.  That extension would also apply to searchInclude and searchRevInclude and to allow one to specify what groups can support which includes.</p>\n<p>HAPI could generate that extension in it's CapabilityStatement by looking at @Search operation signatures.</p>",
        "id": 188974629,
        "sender_full_name": "Keith Boone",
        "timestamp": 1582584505
    },
    {
        "content": "<p>I did work that out using <a href=\"http://hl7.org/fhir/StructureDefinition/capabilitystatement-search-parameter-combination\">http://hl7.org/fhir/StructureDefinition/capabilitystatement-search-parameter-combination</a></p>",
        "id": 201188564,
        "sender_full_name": "Keith Boone",
        "timestamp": 1592421838
    },
    {
        "content": "<p>I spent a lot of time creating tooling that creates cap statements centering on search for us core.  I use the combo extension and conformance expectation extensions on pretty near everything and refined all the  searchparameters with conformance expectations so you know exactly what is supported. Not sure anybody actually looks at them though.  I suspect they are ignored.</p>",
        "id": 201927389,
        "sender_full_name": "Eric Haas",
        "timestamp": 1593053365
    },
    {
        "content": "<p>I have found them extremely useful <span class=\"user-mention\" data-user-id=\"191401\">@Eric Haas</span></p>",
        "id": 201927639,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1593053762
    },
    {
        "content": "<p>Would be interested in more details myself...</p>",
        "id": 202008060,
        "sender_full_name": "David Hay",
        "timestamp": 1593110334
    }
]