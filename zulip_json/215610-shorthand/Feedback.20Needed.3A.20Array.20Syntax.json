[
    {
        "content": "<p>FHIR Shorthand uses indexes to support building multi-item arrays.  For example, consider this person with three variations of his given names:</p>\n<div class=\"codehilite\"><pre><span></span><code>* name[0].given[0] = &quot;William&quot;\n* name[0].given[1] = &quot;Robert&quot;\n* name[1].given[0] = &quot;Willy&quot;\n* name[1].given[1] = &quot;Robby&quot;\n* name[2].given[0] = &quot;Will&quot;\n* name[2].given[1] = &quot;Rob&quot;\n</code></pre></div>\n\n\n<p>This approach <em>works</em> but it is brittle because you (the author) must keep track of the indexes.</p>\n<ul>\n<li>If you want to add \"Billy Bob\" as the second name, you need to add it with index <code>1</code> and then manually increment the index of every name after it.</li>\n<li>Similarly, if you want to <em>remove</em> one of the names, you need to then decrement every index after it</li>\n<li>God help you if it's an array with 50 items and you realize you mistakenly repeated index 7 (it's happened before).</li>\n</ul>\n<p>As part of ballot reconciliation, we have the opportunity to fix this.  Here is an approach we've come up with.  We welcome your thoughts and suggestions.  If you have a better idea, we want to hear it!</p>\n<blockquote>\n<p><strong>KEY:</strong><br>\n<code>list[ ]</code> --&gt; last item in list; when list is empty, the equivalent of [+]<br>\n<code>list[+]</code> --&gt; add a new item to list<br>\n<code>list[n]</code> --&gt; the n+1 item ([0] is first element)</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><code>* name[0].given[0] = &quot;William&quot;\n* name[ ].given[+] = &quot;Robert&quot;\n* name[+].given[0] = &quot;Willy&quot;\n* name[ ].given[+] = &quot;Robby&quot;\n* name[+].given[0] = &quot;Will&quot;\n* name[ ].given[+] = &quot;Rob&quot;\n</code></pre></div>\n\n\n<p>This then allows you to add or remove an element in the middle without having to modify all the elements after it.  We would still support omitting the index as a shortcut for <code>[0]</code>, but I've used <code>[0]</code> above because it actually makes for better alignment (and easier reading).</p>",
        "id": 203963085,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594823663
    },
    {
        "content": "<p>I'm attaching a slightly more complex example with a snippet of a CapabilityStatement (attaching before and after).<br>\n<a href=\"/user_uploads/10155/IfbuH7RsRzc-lNJahY4H6HY7/index-example-before.fsh\">index-example-before.fsh</a> <br>\n<a href=\"/user_uploads/10155/dG1V02WNT_VPkyR6pi9TJ6Uy/index-example-after.fsh\">index-example-after.fsh</a></p>",
        "id": 203963322,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594823791
    },
    {
        "content": "<p>Also note that eventually we would want to marry this with a syntax for more easily working with deeply nested paths (such as the <a href=\"#narrow/stream/215610-shorthand/topic/shorthand.20for.20deeply.20indented.20.2Fnested.20elements/near/203331180\">with syntax</a> that <span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> suggested) -- but that seemed a bit too far from what was balloted to justify slipping it in as a reconciliation.</p>",
        "id": 203963647,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594823929
    },
    {
        "content": "<p>My concern is trading a compiler error and annoyance for a run-time error and annoyance.  Specifically, if you swap any two lines in the example you get incorrect output without any warnings:</p>\n<div class=\"codehilite\"><pre><span></span><code>* name[+].given[0] = &quot;Willy&quot;\n* name[+].given[0] = &quot;Will&quot;\n* name[ ].given[+] = &quot;Robby&quot;\n</code></pre></div>\n\n\n<p>In this short example, it's easy to see because of the pattern and formatting - but if there are more fields (or an inconsistent number of fields) you now have incorrect output that builds without errors.</p>",
        "id": 203967542,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1594825738
    },
    {
        "content": "<p>I don't like that this proposal is adding procedural logic to a statement based language.<br>\nHow about you do this with aliases? Have a different alias for each name the person has, manage the increments in the alias file. <br>\nEven if we had to add procedural increment support ONLY in the alias declaration file, that would be less of a violation of statement based language from procedural based language.</p>",
        "id": 203969372,
        "sender_full_name": "John Moehrke",
        "timestamp": 1594826511
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> -- I understand your concern, but to be clear -- it's also quite possible to mess up explicit indices and not receive any compiler errors. I guess it's a question of which type of a mistake are authors more likely to make?</p>\n<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> -- this is probably silly, but does it feel less procedural if we define <code>item[ ]</code> as \"the same item as the previous rule\" and <code>item[+]</code> as \"the next item\" (essentially removing the \"verbs\" from the descriptions)?</p>",
        "id": 203973928,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594828365
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> -- I'm not sure I understand what you're suggesting regarding the aliases.  If you have a moment, could you flesh that out for me?</p>",
        "id": 203974198,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594828453
    },
    {
        "content": "<p>I agree that it is possible, but I believe it is less likely.  I believe something in the toolchain now flags if you skip an element.  As for redefining one twice, I'm not sure if anything does today, but if nothing does, it should be straightforward to add.</p>\n<p>These checks can even be implemented with UI notifications (e.g., flag element redefinition, flag array indexes out of order (check for same index or higher in a block)).</p>\n<p>There are still issues from copy pasta, since we know that's how repetitive blocks get added, but with everything implicit I don't believe these errors can be detected anymore.</p>",
        "id": 203974897,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1594828771
    },
    {
        "content": "<p>One thing that I like about sushi is that I can say today (top of file) say <code>name[0]=Alice</code> <code>name[1]=Bob</code> <code>name[2]=Chuck</code> and then 300 lines later I can go \"forget that, <code>name[1]=Bart</code></p>",
        "id": 203977244,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1594829778
    },
    {
        "content": "<p>If we want to keep that, I'd think that this approach is a special case. <br>\nSome suggestions:</p>",
        "id": 203977503,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1594829922
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>* name[0].given[0] = &quot;William&quot;\n* name[ ].given[+] = &quot;Robert&quot;\n* name[+].given[0] = &quot;Willy&quot;\n* name[ ].given[+] = &quot;Robby&quot;\n* name[+].given[0] = &quot;Will&quot;\n* name[ ].given[+] = &quot;Rob&quot;\n</code></pre></div>\n\n\n<p>this should not be allowed. Either you're iterating the inner loop or the outer loop.</p>",
        "id": 203977620,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1594829994
    },
    {
        "content": "<p>I can imagine you could do this</p>\n<div class=\"codehilite\"><pre><span></span><code>* with name[] do\n**   given[] = &quot;Robert&quot;\n**   given[] = &quot;Robby&quot;\n**   given[] = &quot;Rob&quot;\n\n* with name[] do\n**   given[] = &quot;William&quot;\n**   given[] = &quot;Willy&quot;\n**   given[] = &quot;Will&quot;\n</code></pre></div>",
        "id": 203980352,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1594831161
    },
    {
        "content": "<p>(notice the subtle suggestion to remove the + or the space inside the [])</p>",
        "id": 203980431,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1594831202
    },
    {
        "content": "<p>I like Jose's syntax.  FHIR Shorthand is supposed to be easy to write, which also means it needs to be easy to read.  Having to keep track of the numbers makes it challenging to write, and I can't tell you how many times I've had to add complex logic to keep track of where I started and where I finished in code that should be compartmentalized.  I have a set of things to add (extensions) which are for different reasons, and have to pass along how many extensions I've already added to another routine that depending on thee situation could add more, and both of these separate routines have to return somehow back to the caller the total count of what they've added.  That's impossible to do in some programming constructs (e.g., declarative languages like XSLT don't let you pass back anything other than the result of the transform, and you cannot modify state [Yes, I've written FSH from an XSLT].  This would make my life so much simpler.</p>",
        "id": 204030405,
        "sender_full_name": "Keith Boone",
        "timestamp": 1594858993
    },
    {
        "content": "<p>Yeah, I like the <code>with</code> syntax as well... I just don't think we can/should introduce something like that in the reconciliation phase without balloting it.  I thought the proposed array syntax would not be very controversial (and is similar enough to existing syntax) that it might be appropriate for STU1... but I'm starting to have 2nd thoughts about that as well!  It may be that we just work with you (the community) on getting these right early on and put them in the next ballot (and have them available in SUSHI prior to that -- just like we did w/ pre-STU1 features).  I'll have to talk with <br>\n<span class=\"user-mention\" data-user-id=\"191447\">@Mark Kramer</span> and the team about this.</p>",
        "id": 204033455,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594861770
    },
    {
        "content": "<p>Chris, while YOU CAN do something like that in the reconciliation phase, it introduces a new requirement for a system interpreting the language.  As a result, according to existing HL7 rules, you would need to reballot that particular item (and any other breaking change).  If the syntax change were small, you might successfully argue it was a technical correction, but I don't think the with syntax is small as you say.  So I'd probably classify that as \"consider for future release\", even though I like it very much.</p>",
        "id": 204102185,
        "sender_full_name": "Keith Boone",
        "timestamp": 1594914279
    },
    {
        "content": "<p>That's only true if you're going normative.  It's totally fine to make substantive changes during reconciliation and not go back to ballot.  The base question is whether the changes are so significant that the validity of the ballot result would be called into question.  (I.e. you can't ballot one spec and publishing something that looks totally different and say it passed STU.)</p>",
        "id": 204102734,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1594914498
    },
    {
        "content": "<p>Thank you for that clarification.  I wasn't aware of that subtlety.  That actually helps me in another DSTU ballot where we added a requirement.</p>",
        "id": 204105424,
        "sender_full_name": "Keith Boone",
        "timestamp": 1594915630
    },
    {
        "content": "<blockquote>\n<p>The base question is whether the changes are so significant that the validity of the ballot result would be called into question.</p>\n</blockquote>\n<p>Right, and that's why I felt comfortable considering <code>[ ]</code>/<code>[+]</code> array indexers in reconciliation, but less so something more significant like a nested syntax.  But as I noted above, we're leaning toward holding off on the array indexers too...  We don't want to introduce something that is controversial.</p>",
        "id": 204106098,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1594915911
    },
    {
        "content": "<p>What is the status of the proposal? I would certainly support the use of [ ]/[+] array indexers.  I am currently implementing questionnaire instances, so some implementation of auto-increment would come in handy :-)</p>",
        "id": 208226583,
        "sender_full_name": "Kirstine Rosenbeck Gøeg",
        "timestamp": 1598539643
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"194347\">@Kirstine Rosenbeck Gøeg</span> -- that proposal has been folded into an updated proposal that includes support for parameterized RuleSets.  See the slides from the most recent FSH Telecon for details: <a href=\"https://confluence.hl7.org/display/FHIRI/FHIR+Shorthand+Minutes+2020-08-13?preview=/91981964/91981967/FHIR%20Shorthand%20Conference%20Call-2020-08-13.pptx\">https://confluence.hl7.org/display/FHIRI/FHIR+Shorthand+Minutes+2020-08-13?preview=/91981964/91981967/FHIR%20Shorthand%20Conference%20Call-2020-08-13.pptx</a></p>\n<p>If you don't want to go through the slides, the array syntax proposal is almost the same as what was proposed, except instead of <code>[ ]</code> to represent the current element, you use <code>[=]</code> instead.  So it's <code>[+]</code> and <code>[=]</code>.  As for implementation, we're currently focused on the FHIR Shorthand 1.0.0 spec finalization and a corresponding release (in the next 2 weeks) and then we'll move on to new features like the array syntax.</p>",
        "id": 208234271,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598542570
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span> , how does the proposal handle “resetting” sub indexes? Does it recognize that if we have a[0].b[7], when we go to a[1], that we need to go back to b[0]?</p>",
        "id": 208244155,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598546900
    },
    {
        "content": "<p>Also, for the parameterized macros proposal, are there concerns with the $ notation conflicting with the code system $ notation?</p>",
        "id": 208244329,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598546979
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191380\">@Elliot Silver</span>  Yes... bumping a higher-level index resets all indexes on childpaths to <code>0</code>.  As for the argument notation (<code>$</code>), that was discussed while I was on vacation, but I assume that we'll change it to something else if we determine it's an issue.  But it's probably ok because you would never use an alias in a RuleSet declaration (only in the rules inside the RuleSet itself).</p>",
        "id": 208246334,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598547843
    },
    {
        "content": "<p>what happened to the with syntax?</p>",
        "id": 208246540,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1598547934
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> -- nothing yet.  I think the <code>with</code> syntax is complementary to these other proposals -- not a replacement for them.</p>",
        "id": 208246701,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598548000
    },
    {
        "content": "<p>I think the fact that you can change indexing on several levels in one line makes it complicated.  - <code>a[+].b[+]</code> is confusing, perhaps only to me...</p>",
        "id": 208246761,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1598548041
    },
    {
        "content": "<p>Ok, so that means we don’t need an explicit “set to zero”.<br>\nYou wouldn’t define an alias inside a rule set, but I can certainly see you using one, or passing it as a parameter. Can one rule set invoke another?</p>",
        "id": 208246826,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598548081
    },
    {
        "content": "<p>the reason for me asking about <code>with</code> is that i'd feel safer nesting <code>with</code>s than this <code>a[+].b[+]</code> thing.</p>",
        "id": 208246998,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1598548173
    },
    {
        "content": "<p>I can see how it’s two different issues. One doesn’t eliminate the need for the other.</p>",
        "id": 208247187,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598548244
    },
    {
        "content": "<p>It's not the syntax, but the fact that we have two increments to different levels in one line.</p>",
        "id": 208251243,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1598550248
    },
    {
        "content": "<p>I think a[+] is fine, a[1].b[+] is fine. just a[+].b[+] (and possible variations) may be too flexible and hard to debug when something goes wrong.</p>",
        "id": 208251418,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1598550342
    },
    {
        "content": "<p>No, that wouldn’t happen, I assume. Only one index gets increments on each line.</p>",
        "id": 208251435,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598550351
    },
    {
        "content": "<p>I'm looking at the ppt, page 9</p>",
        "id": 208251565,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1598550399
    },
    {
        "content": "<p>Agree. a[].b[+] is ok.</p>",
        "id": 208251571,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598550401
    },
    {
        "content": "<p>Ah, I see. No, we shouldn’t have that, it’s confusing.</p>",
        "id": 208251916,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598550575
    },
    {
        "content": "<p>I’d rather see an empty array mean 0 or last value, and + be increment (along with reset sub counters).</p>",
        "id": 208252142,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598550681
    },
    {
        "content": "<p>Thanks, that is my feedback indeed (that it is confusing).</p>",
        "id": 208252199,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1598550706
    },
    {
        "content": "<p>But it is a separate issue from ‘with’.</p>",
        "id": 208252362,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598550783
    },
    {
        "content": "<p>yes.</p>",
        "id": 208252374,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1598550792
    },
    {
        "content": "<p>I think that <code>[+]</code> means <code>[0]</code> if the array is empty because you are essentially adding an element to the array.  You had a zero-length array before, so using <code>[ ]</code> or <code>[=]</code> to access the <em>current</em> element is meaningless when there are zero elements.  You need the <code>[+]</code> just to create that first element at index <code>0</code>.</p>",
        "id": 208255745,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598552262
    },
    {
        "content": "<p>It is also what allows a <code>RuleSet</code> to be used to define arbitrary elements on an array via <code>insert</code>s (see the PPT I linked above if you're not familiar w/ this use).  The <code>[+]</code> has to work equally as well at initializing an array and referencing the first element as it does at appending a new element to an existing array.</p>",
        "id": 208255989,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598552377
    },
    {
        "content": "<p>hmm, right.</p>",
        "id": 208256107,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598552415
    },
    {
        "content": "<p>Also note that you can still use numeric indexers.  We don't need a \"reset\" indexer; we already have one: <code>[0]</code>.</p>",
        "id": 208256189,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598552454
    },
    {
        "content": "<p>So aside from the RuleSet use case I noted above, if authors are more comfortable explicitly using <code>[0]</code> on the first element of an array and then using <code>[+]</code> for subsequent elements, that's totally OK.</p>",
        "id": 208256305,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598552511
    },
    {
        "content": "<p>A line with multiple + on it needs to be interpreted as \"increment the first counter, reset the others\"?  it doesn't look intuitive, but I can understand the logic.</p>",
        "id": 208256455,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598552571
    },
    {
        "content": "<p>I understand <span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span>'s concern that managing subcontext of each nested array can be confusing -- but I'm not sure a great way around that aside from using <code>[0]</code> explicitly if you want to and/or using his <code>with</code> idea.  But even with <code>with</code>, I think we'd want to <em>allow</em> the more compact syntax.</p>",
        "id": 208256645,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598552666
    },
    {
        "content": "<blockquote>\n<p>A line with multiple + on it needs to be interpreted as \"increment the first counter, reset the others\"?</p>\n</blockquote>\n<p>The way I think of <code>a[+].b[+].c[+]</code> is that once you increment <code>a</code> to <em>n</em>, then <code>a[n].b</code> is empty -- so the <code>b[+]</code> adds that first <code>a[n].b</code> element.  And once you have a new <code>a[n].b[0]</code> element, its <code>c</code> array is also empty, so you need the <code>c[+]</code> to add and reference its first element.  That's probably a terrible way to describe it, but it's actually quite consistent if you think about it.</p>",
        "id": 208257075,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598552904
    },
    {
        "content": "<p>Actually, rereading the above --  I don't think RuleSets depend on the + notation. I think my suggestion of [] meaning zero or last would address the issue equally.</p>",
        "id": 208257087,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598552911
    },
    {
        "content": "<p>Right, I  agree that it makes a certain sense, but isn't intuitive.</p>",
        "id": 208257148,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598552960
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>RuleSet: Foo\n* bar[ ] = &quot;hello&quot;\n\nInstance: Something\nInstanceOf: SomeResource\n* insert Foo\n* insert Foo\n* insert Foo\n</code></pre></div>\n\n\n<p>If <code>[ ]</code> means <code>0</code> or last, then you keep overwriting <code>bar[0]</code> -- because the first time it sets <code>bar[0]</code>, then the next two times the <em>last</em> is still <code>bar[0]</code> (since there is nothing to increment it).</p>",
        "id": 208257538,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598553141
    },
    {
        "content": "<p>Ah, I hadn’t considered that use.</p>",
        "id": 208257778,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598553244
    },
    {
        "content": "<blockquote>\n<p>Right, I agree that it makes a certain sense, but isn't intuitive.</p>\n</blockquote>\n<p>OK.  So then maybe best practice is: <code>a[+].b[0].c[0]</code>.</p>",
        "id": 208257846,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598553270
    },
    {
        "content": "<p>Best practise, but not required, otherwise it messes with your use case.</p>",
        "id": 208257960,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598553336
    },
    {
        "content": "<p>Or maybe we could make a rule that once you declare a <code>[+]</code> in a path, you can't declare another one in the same path.  We'd have to think about if that excludes any meaningful use cases.  It might be fine -- and if so, then we need to think about if it is a restriction that makes things more user-friendly or less user-friendly.  It sounds like you and <span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> would consider it more user-friendly.</p>",
        "id": 208258194,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598553446
    },
    {
        "content": "<p>Hmm gets interesting when you get to ‘insert RuleSet(a[+])’.</p>",
        "id": 208258840,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598553786
    },
    {
        "content": "<p>Ha.  Yeah.  I guess so.  But given that parameters are currently defined as doing just straight up string substitution, that would be kind of weird.  But I guess you could write your ruleset that way.</p>",
        "id": 208260991,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598554766
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>RuleSet foo(x):\n* $x$[=].value1 = &quot;bar&quot;\n* $x$[=].value2 = &quot;baz&quot;\n\nProfile: ...\n\n* insert  foo(a[+])\n* a[=].value3 = &quot;first value&quot;\n*  insert foo(a[+])\n* a[=].value3 = &quot;second value&quot;\n</code></pre></div>\n\n\n<p>Doesn't look all that weird to me.</p>",
        "id": 208264521,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598556446
    },
    {
        "content": "<p>No, just weirder.  It's all relative I guess. ;-)</p>",
        "id": 208264645,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598556504
    },
    {
        "content": "<p>That ends up being this...</p>\n<p>a[+][=].value1 = \"bar\"<br>\na[+][=].value2 = \"baz\"<br>\na[=].value3 = \"first value\"<br>\na[+][=].value1 = \"bar\"<br>\na[+][=].value2 = \"baz\"<br>\na[=].value3 = \"second value\"</p>",
        "id": 208265204,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1598556811
    },
    {
        "content": "<p>Ah, oops, try without the “[=]” inside the ruleset.</p>",
        "id": 208266516,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1598557543
    },
    {
        "content": "<p>i liken RuleSets to C macros - there are going to be some best practices that even come directly over from the world of macros.  One of the rules that I remember is be careful of having operators in your macro parameters.  Even without the '[=]', that still might not be doing what you think it's doing:</p>\n<p>a[+].value1 = \"bar\"<br>\na[+].value2 = \"baz\"<br>\na[=].value3 = \"first value\"<br>\na[+].value1 = \"bar\"<br>\na[+].value2 = \"baz\"<br>\na[=].value3 = \"second value\"</p>\n<p>This would end up with (I used XML notation to show that there are four a's in the array):<br>\n&lt;a&gt;&lt;value1 value=\"bar\"/&gt;&lt;/a&gt;<br>\n&lt;a&gt;&lt;value2 value=\"baz\"/&gt;&lt;value3 value=\"first value\"/&gt;&lt;/a&gt;<br>\n&lt;a&gt;&lt;value1 value=\"bar\"/&gt;&lt;/a&gt;<br>\n&lt;a&gt;&lt;value2 value=\"baz\"/&gt;&lt;value3 value=\"second value\"/&gt;&lt;/a&gt;</p>",
        "id": 208267028,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1598557815
    },
    {
        "content": "<p>Good point, <span class=\"user-mention\" data-user-id=\"192166\">@Jean Duteau</span>.  I hadn't caught that, but you're right (of course)!</p>",
        "id": 208271777,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1598560138
    },
    {
        "content": "<p>btw, my point is not that we should add in checks to detect this.  I think that, like C macros, we are providing a powerful mechanism for IG FSH authors, but with \"great power comes great responsibility\".</p>",
        "id": 208272309,
        "sender_full_name": "Jean Duteau",
        "timestamp": 1598560427
    },
    {
        "content": "<p>Having written about 5 pages of IG text illustrating a Measure definition using <span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span>'s  <strong>with </strong>syntax.  I find myself much in favor of it over the [+][=] syntax.  The reason for this is that it creates much more human readable content with less dense code, and shorter lines.  It has a hugely meaningful impact on my productivity to a) not have to read all the repetitive gunge, and b) to NOT have to type it.</p>\n<p>I'll post a link later today showing how it looks.</p>",
        "id": 209347978,
        "sender_full_name": "Keith Boone",
        "timestamp": 1599544284
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"191387\">@Keith Boone</span>.  I imagine you still need to use <em>some</em> <code>[+]</code>/<code>[=]</code> syntax, right?  I mean, the <code>with</code> construct doesn't fix the issue regarding needing to add or remove something in the middle of an existing long array...  But it does make you not need to repeat <code>[=]</code> so many times (or maybe allows you to avoid <code>[=]</code> altogether).</p>",
        "id": 209381929,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1599569974
    },
    {
        "content": "<p>Yeah, somewhat, but not often.  If I had to prioritize the two, <strong>with</strong> is more important than [+][=].  I think [=] is still useful b/c copy/paste is faster than setting up a with for a two-three line case.</p>",
        "id": 209411328,
        "sender_full_name": "Keith Boone",
        "timestamp": 1599582600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191387\">@Keith Boone</span> when we get to macros, the \"with\" doesn't have as much power as [+] and [=].  If you consider the CapabilityStatement example in the PPT that Chris mentions above, the ability to combine soft indexing with macros is when serious magic happens. I don't <em>think</em> you can get the same power with \"with\" but I'm willing to be proven wrong.</p>",
        "id": 209538253,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1599670704
    },
    {
        "content": "<p>I don't know what is the  status for this, but I'd suggest: </p>\n<ol>\n<li>using element[0] and element[+] makes sense,  I am not so sure we need element[=] or if that can be omitted as default.</li>\n<li>for the first time a repeating element is used, element[+] is equivalent to element</li>\n<li>the <code>with</code> syntax or a syntax like </li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><code>* (with) identifier :\n** system  =\n** value =\n</code></pre></div>\n<p>woud be most interesting for example when handling logical models - it allows us to write exactly what we mean (i.e. indented elements). <br>\nCombining both we'd have a powerful way to add a lot of content just by copy-pasting and only changing what is needed:</p>\n<div class=\"codehilite\"><pre><span></span><code>* with identifier[+] :\n** system = http://snomed.ct/info\n** value = 12345\n\n* with identifier[+] :\n** system = http://snomed.ct/info\n** value = 12345\n\n* with identifier[+] :\n** system = http://snomed.ct/info\n** value = 23456\n\n* with identifier[+] :\n** system = http://snomed.ct/info\n** value = 34567\n</code></pre></div>",
        "id": 217939360,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1606338353
    },
    {
        "content": "<p>basically the <code>with</code> is an inline macro declaration but cleaner (IMO).</p>",
        "id": 217939522,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1606338433
    },
    {
        "content": "<p>the example above could perhaps be made leaner, i'm not sure. I don't see what could make my copy-paste easier than this nested/indented syntax</p>",
        "id": 217939695,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1606338532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> (and anyone else playing along), check out the \"Wicked FHIR\" presentation over in the <a href=\"https://fshschool.org/downloads/\">FSH School Downloads</a> to see the latest on the soft-indexing, parameterized rulesets, and \"with\" proposals.</p>",
        "id": 217940123,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1606338796
    },
    {
        "content": "<p>I didn't realize you still had all three of auto-indexing, parameterized rulesets and \"with\" still under consideration. I thought you had decided that parameterized rulesets eliminated the need for at least one of the others.</p>\n<p>One thing that may potentially be useful for parameterized rulesets is the ability to specify (part of) the item in the parameters. Consider a Questionnaire where you can have item[] or item[].item[] or item[].item[].item[]. It would be helpful to be able to say:</p>\n<div class=\"codehilite\" data-code-language=\"fsh\"><pre><span></span><code>Ruleset ChooseFromValueSet(myItem, myValueSet)\n* {myItem}.type = #choice\n* {myItem}.answerValueSet = Canonical({myValueSet})\n</code></pre></div>\n<p>We should be explicit about how soft indexing works in this case. (Is the index evaluated only once on invocation, or does it repeat every time?) </p>\n<p>Your capability statement example in the presentation increments the index in the first ruleset, and all other rulesets just reuse that index. Is there a need to be able to increment the index without using it?</p>\n<div class=\"codehilite\"><pre><span></span><code>RuleSet Support Resource(resource, expectation)\n* rest.resource[=].type = {resource} ...\n\n...\nrest.resource[+]\nSupportResource(MyResource, MyExpectation)\n</code></pre></div>",
        "id": 217947159,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1606343680
    }
]