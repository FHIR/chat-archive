[
    {
        "content": "<p>On July 31, <span class=\"user-mention\" data-user-id=\"192611\">@Kurt Allen</span> wrote:</p>\n<blockquote>\n<p>Mark, here is what MFSH (Macro FSH) currently does.<br>\nLets talk about this and see what parts make sense to move into FSH.</p>\n</blockquote>\n<p>Macros</p>\n<p>Macros are inserts with the following additions.<br>\na) Named parameters.<br>\nWhen the macro is defined, named parameters are defined. When called, each of those<br>\nparameters must contain a value.<br>\n#macro XXYYZ(alpha, beta, delta)<br>\n#apply XXYYZ(\"alpha value\", \"beta value\", \"delta value\")<br>\nAnywhere in the code that 'alpha' is found, it is replaced with 'alpha value'.<br>\nb) Global parameters.<br>\nThere are parameters that are defined globally, such as</p>\n<ul>\n<li>the id of the current profile</li>\n<li>the url of the current profile.</li>\n<li>parameters that can be set on command line<br>\nmany others<br>\nThese can be referenced in any macro just as if it was a named parameter.</li>\n</ul>\n<p>c) Redirection<br>\nThe output of a macro can be redirected to a non-fsh file.<br>\nThe output file name can contain global and named parameters which will get expanded when the macro is called/executed (not when it is<br>\nfirst defined)<br>\nI use this to collate info such as node graph commands I process externalluy to generate svg images, and also to allow embedded<br>\nmacros to generate the --intro implementation guide files for each profile.</p>\n<p>#macro XXYYZ() &gt; 'redirection path'<br>\nd) Once flags<br>\nThe once flag allows a macro to be called only once, even if it is executed multiple times.<br>\nExample of how this can be used:<br>\nSeveral macros are defined that add distinct sliced Observation.component items. These macros are sometimes used in a profile together, and<br>\nin some profiles separately.<br>\nEach macro calls a common macro to add component slicing; this should only be called once per profile.<br>\nOne way to handle this is to force the user to call this macro separately, once per profile, but this requires the user to<br>\nmanually add this and allows opportunities to not call it.<br>\nSo a macro is defined that implements the required slicing commands, and it is called with the once flag set, so it<br>\nonly generates FSH output the first time it is called.<br>\nThere are two flavors of the once flag.</p>\n<ul>\n<li>restrict calls to once per profile</li>\n<li>restrict the calls to once period.<br>\nNamed Parameters can be a problem here, as multiple calls can be made with difference named parameter values, and only<br>\nthe first call will create output with its unique parameter values.</li>\n</ul>\n<p>// this is expanded once per profile.<br>\n#macro once XXYYZ()<br>\n#end</p>\n<p>// this is expanded once, no matter how many times it is called.<br>\n#apply once XXYYZ()</p>\n<p>Fragments</p>\n<p>A fragment is kinda a cross between a profile and a macro.<br>\nThe purpose of a fragment is to define a profile fragment that<br>\na) can be added to multiple profiles (like a macro)<br>\nb) is intended to signal to code generators that each fragment can be treated like a separate 'thing' (class or interface).<br>\nc) breaks the output profile into separate pieces that are functionally unique, implemented in multiple profiles, and documented as separate 'thing'.</p>\n<p>Example.<br>\nI create a fragment 'f' that is three Observation.component items.<br>\nI include the fragment in multiple profiles 'a', 'b', and 'c'.</p>\n<p>I generate a c# project that implements a class to process these profiles.<br>\nI can generate a method 'm' that can accept an interface 'f' that mimics the fragment 'f'.<br>\nClasses are created that mimic profiles 'a', 'b', and 'c', each of which implements interface 'f'.<br>\nI can call method 'm' with an instance of 'a', 'b', or 'c'.</p>\n<p>So a fragment is a part of a profile that is to be implemented in multiple profiles but treated like a 'distinct' item<br>\nin generated artifacts (including implementation guide).</p>\n<p>The fragment would have a parent class (like Observation).<br>\nIt should generate an item in the implementation guide showing exactly what it implemented.<br>\nIt should generate documentation in the documentation guide indicating what profiles implement it.</p>\n<p>A profile can include one or more fragments just like a macro.<br>\nNo named parameters are allowed in a fragment call.</p>\n<p>The fragments generate structure definition and other meta data allowing external code generation tools to recognize<br>\nwhen a fragment has been defined, and where it is used. Programming artifacts can be generated from this info.</p>\n<p>#Fragment: Observation.Component.NotPreviouslySeenFragment<br>\n#Parent: Observation<br>\n#Title: \"NotPreviously Seen Fragment\"<br>\n#Description: \"\"\"</p>\n<p>Adds NotPreviously Seen Component slice.<br>\n\"\"\"<br>\n#apply Observation.Component.Add(\"notPreviouslySeen\", \"0..*\", \"Not Previously Seen\", \"Not Previously Seen\",</p>\n<h1>\"\"\"</h1>\n<h1>This slice contains the optional components that define prevous encounters in which this abnormality was not seen.</h1>\n<h1>The value of this component is a codeable concept chosen from the NotPreviouslySeenVS valueset.</h1>\n<h1>\"\"\",</h1>\n<h1>\"ObservationComponentSliceCodesCS#notPreviouslySeen\")</h1>\n<h1>#apply Observation.Component.SetConcept(\"notPreviouslySeen\", \"1..1\", \"NotPreviouslySeenVS\")</h1>\n<p>#end</p>\n<p>Conditional compilation</p>\n<p>This is completely experimental and I have not found it to be useful so far, but there may be instances where it may become useful.<br>\nThis is identical to conditional compilation in c++, c3, etc.<br>\nWe may want to ignore adding this to FSH. Not sure if it will ever be usefull, though we still need some way to implement<br>\ndifferent countries using similar profiles.</p>\n<p>i.e.</p>\n<p>#if (value1==\"true\")<br>\nif value1 is true, then include all text here.<br>\n#else if (value2==\"false\")<br>\nif value1 is false, then include all text here.<br>\n#else<br>\notherwise include all text here.<br>\n#end</p>\n<p>The original purpose of conditional compilation was to allow a profile to be made that could be compiled for different countries.</p>\n<p>i.e.<br>\nProfile: Hello<br>\nParent: Observation<br>\n#if Country == \"US\"</p>\n<p>greeting = \"Hello\"<br>\n#else if Country == \"CA\"</p>\n<p>greeting = \"Hello, eh\"<br>\n#else if Country == \"NO\"</p>\n<p>greeting = \"Uff da\"<br>\n#else if Country == \"AU\"</p>\n<p>greeting = \"G'Day\"<br>\n#end</p>",
        "id": 206475732,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1597073958
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192611\">@Kurt Allen</span> Chris is out for the next week and a half, and I would like to wait for him before we have a discussion. In the meantime, I have captured your suggestions and some initial questions/responses in the attached MS Word document (I find it easier to comment on particular aspects of your proposal in that format): <a href=\"/user_uploads/10155/lrb0O1iPV6RoMLWt5lmgCzuy/Macros-Kurt-Design-Document.docx\">Macros-Kurt-Design-Document.docx</a></p>",
        "id": 206475963,
        "sender_full_name": "Mark Kramer",
        "timestamp": 1597074079
    }
]