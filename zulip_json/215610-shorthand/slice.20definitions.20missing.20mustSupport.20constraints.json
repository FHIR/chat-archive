[
    {
        "content": "<p>Here is a snippet of a slice declaration and first slice definition on <a href=\"http://CodeSystem.property\">CodeSystem.property</a> in FSH (generated by GoFSH):</p>\n<div class=\"codehilite\"><pre><span></span><code>* property ..6 MS\n* property ^slicing.discriminator[0].type = #value\n* property ^slicing.discriminator[0].path = &quot;code&quot;\n* property ^slicing.rules = #open\n* property ^short = &quot;Additional information supplied about each concept&quot;\n* property ^definition = &quot;A property defines an additional slot through which additional information can be provided about a concept.&quot;\n* property ^comment = &quot;To cover through slices: Component, Property, Time, System, Scale, Method.&quot;\n* property.code 1..1 MS\n* property.code ^short = &quot;Identifies the property on the concepts, and when referred to in operations&quot;\n* property.code ^definition = &quot;A code that is used to identify the property. The code is used internally (in CodeSystem.concept.property.code) and also externally, such as in property filters.&quot;\n* property.uri 0..1\n* property.uri ^short = &quot;Formal identifier for the property&quot;\n* property.uri ^definition = &quot;Reference to the formal meaning of the property. One possible source of meaning is the [Concept Properties](codesystem-concept-properties.html) code system.&quot;\n* property.uri ^mustSupport = false\n* property.description 1..1 MS\n* property.description ^short = &quot;Why the property is defined, and/or what it conveys&quot;\n* property.description ^definition = &quot;A description of the property- why it is defined, and how its value might be used.&quot;\n* property.type 1..1 MS\n* property.type only code\n* property.type = #string (exactly)\n* property.type ^short = &quot;code | Coding | string | integer | boolean | dateTime&quot;\n* property.type ^definition = &quot;The type of the property value. Properties of type \\&quot;code\\&quot; contain a code defined by the code system (e.g. a reference to anotherr defined concept).&quot;\n* property contains ln_component 1..1 MS\n* property[ln_component] ^short = &quot;Additional information supplied about each concept&quot;\n* property[ln_component] ^definition = &quot;A property defines an additional slot through which additional information can be provided about a concept.&quot;\n* property[ln_component] ^comment = &quot;To cover through slices: Component, Property, Time, System, Scale, Method.&quot;\n* property[ln_component].code 1..1 MS\n* property[ln_component].code only code\n* property[ln_component].code = #COMPONENT (exactly)\n* property[ln_component].code ^short = &quot;Identifies the property on the concepts, and when referred to in operations&quot;\n* property[ln_component].code ^definition = &quot;A code that is used to identify the property. The code is used internally (in CodeSystem.concept.property.code) and also externally, such as in property filters.&quot;\n</code></pre></div>\n\n\n<p>And here is the \"translation\" of that into the StructureDefinition json file in the fsh-generated/resources folder:</p>\n<div class=\"codehilite\"><pre><span></span><code>      {\n        &quot;id&quot;: &quot;CodeSystem.property&quot;,\n        &quot;path&quot;: &quot;CodeSystem.property&quot;,\n        &quot;slicing&quot;: {\n          &quot;discriminator&quot;: [\n            {\n              &quot;type&quot;: &quot;value&quot;,\n              &quot;path&quot;: &quot;code&quot;\n            }\n          ],\n          &quot;rules&quot;: &quot;open&quot;\n        },\n        &quot;comment&quot;: &quot;To cover through slices: Component, Property, Time, System, Scale, Method.&quot;,\n        &quot;min&quot;: 6,\n        &quot;max&quot;: &quot;6&quot;,\n        &quot;mustSupport&quot;: true\n      },\n      {\n        &quot;id&quot;: &quot;CodeSystem.property.code&quot;,\n        &quot;path&quot;: &quot;CodeSystem.property.code&quot;,\n        &quot;mustSupport&quot;: true\n      },\n      {\n        &quot;id&quot;: &quot;CodeSystem.property.uri&quot;,\n        &quot;path&quot;: &quot;CodeSystem.property.uri&quot;,\n        &quot;mustSupport&quot;: false\n      },\n      {\n        &quot;id&quot;: &quot;CodeSystem.property.description&quot;,\n        &quot;path&quot;: &quot;CodeSystem.property.description&quot;,\n        &quot;min&quot;: 1,\n        &quot;mustSupport&quot;: true\n      },\n      {\n        &quot;id&quot;: &quot;CodeSystem.property.type&quot;,\n        &quot;path&quot;: &quot;CodeSystem.property.type&quot;,\n        &quot;short&quot;: &quot;code | Coding | string | integer | boolean | dateTime&quot;,\n        &quot;definition&quot;: &quot;The type of the property value. Properties of type \\&quot;code\\&quot; contain a code defined by the code system (e.g. a reference to anotherr defined concept).&quot;,\n        &quot;fixedCode&quot;: &quot;string&quot;,\n        &quot;mustSupport&quot;: true\n      },\n      {\n        &quot;id&quot;: &quot;CodeSystem.property:ln_component&quot;,\n        &quot;path&quot;: &quot;CodeSystem.property&quot;,\n        &quot;sliceName&quot;: &quot;ln_component&quot;,\n        &quot;min&quot;: 1,\n        &quot;max&quot;: &quot;1&quot;\n      },\n      {\n        &quot;id&quot;: &quot;CodeSystem.property:ln_component.code&quot;,\n        &quot;path&quot;: &quot;CodeSystem.property.code&quot;,\n        &quot;fixedCode&quot;: &quot;COMPONENT&quot;\n      },\n</code></pre></div>\n\n\n<p>The 'property:ln_component' and 'property:ln_component.code' elements in the slice definition aren't picking up the mustSupport flags from the fsh.  Note that other items like the cardinality and type constraints and the 'short', 'definition' and 'comment' text also aren't being carried forward, but in this case I think that all of those are just duplicated from the base resource, so that's not really a problem (and could even be a design decision/feature?).  But the missing mustSupport flags are, of course, only available in the profile and they clearly do need to be in the json.</p>",
        "id": 213733169,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1603066685
    },
    {
        "content": "<p>This is actually an expected behavior from SUSHI. Since the <code>mustSupport</code> flag has been applied on <code>CodeSystem.property</code>, SUSHI does not add it to the differential for <code>CodeSystem.property:ln_component</code>, since the flag is indicated by <code>CodeSystem.property</code>. It comes down to a question of how we generate a differential on a slice element. Currently, we generate the differential by comparing to the sliced element (<code>CodeSystem.property</code> here) on the profile you are generating, so since <code>mustSupport</code> is already on that element, we do not add it to the differential of the <code>ln_component</code> slice. I don't think we have ever been entirely clear on if there is a single \"correct\" way to generate this differential according to the spec, but let us know if you think the current method is insufficient and how we could improve it.</p>",
        "id": 213779611,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1603111802
    },
    {
        "content": "<p>Right.  I guess it's a fair question.  If you say that implementors <em>must support</em> <code>CodeSystem.property</code>, is it necessary to say they <em>must support</em> specific slices of <code>CodeSystem.property</code>?  If so, what does it mean for a slice that <em>doesn't</em> have the MS flag when the thing being sliced <em>does</em>?</p>",
        "id": 213779673,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1603111818
    },
    {
        "content": "<p>Maybe relevant to know that SUSHI does add flags defined on a sliced element to the slices of that element. So for example:</p>\n<div class=\"codehilite\"><pre><span></span><code>Profile: MyCodeSystem\nParent: CodeSystem\n* property ^slicing.discriminator[0].type = #value\n* property ^slicing.discriminator[0].path = &quot;code&quot;\n* property ^slicing.rules = #open\n* property contains ln_component 1..1\n* property MS\n</code></pre></div>\n\n\n<p>That <code>property MS</code> rule will apply a <code>MS</code> flag on <code>property</code> and on the <code>ln_component</code> slice. And that is definitely an intentional choice. So SUSHI adopts the idea that a flag on a sliced element implies that same flag on the slices of that element.</p>",
        "id": 213780629,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1603112285
    },
    {
        "content": "<p>These statements seem mutually exclusive to me:</p>\n<blockquote>\n<p>Since the mustSupport flag has been applied on <a href=\"http://CodeSystem.property\">CodeSystem.property</a>, SUSHI does not add it to the differential for CodeSystem.property:ln_component, since the flag is indicated by <a href=\"http://CodeSystem.property\">CodeSystem.property</a>. </p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p>Maybe relevant to know that SUSHI does add flags defined on a sliced element to the slices of that element. So for example... That property MS rule will apply a MS flag on property and on the ln_component slice.</p>\n</blockquote>\n<p>Are you just talking about what SUSHI does internally, but by the time it generates the differential it strips out the flag on the slices?</p>",
        "id": 213781317,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1603112612
    },
    {
        "content": "<p>Or is the difference the ordering of the statements? (That if you apply MS to a sliced element after slices have been declared, then (and only then) it applies the flag to all slices?  If so, we may want to consider if that type of order dependence is what we actually want...</p>",
        "id": 213781539,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1603112713
    },
    {
        "content": "<p>No, not just internally, in the example I showed, SUSHI will output JSON that has a <code>mustSupport</code> flag on both <code>property</code> and <code>ln_component</code>.  The difference is the ordering of statements as you say. It comes down to the fact that to generate a differential, SUSHI compares the slice element to the sliced element on that profile. So if you have already made constraints on the sliced element, those constraints will <em>not</em> be on the differential of the slice element.</p>",
        "id": 213782016,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1603112960
    },
    {
        "content": "<p>OK. I'm not sure how I feel about that behavior...</p>",
        "id": 213782373,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1603113143
    },
    {
        "content": "<p>Yeah.  It seems to me that it would be easier (and better) to just be able to put MS in FSH on whatever you want to be mustSupport and have it show up that way in the rendering. :)  I'm not sure how smart SUSHI should try to be with this to figure out what the author thought they really wanted or what they should have been thinking that they wanted?</p>",
        "id": 213805501,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1603122361
    },
    {
        "content": "<p>Are we thinking of going anywhere with this?  <span class=\"user-mention\" data-user-id=\"239822\">@Nick Freiter</span> <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span></p>",
        "id": 213872470,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1603165201
    },
    {
        "content": "<p>Since the actual definition of \"must support\" is left up to the individual IGs to determine and describe, then I think the use and placement of the mustSupport flags in the final profile renderings needs to be under the full control of the IG and profile authors.  They need to be able to specify and show the mustSupport flag on any element that they want, whether or not it occurs inside or outside of a slice.  That's my take on it.</p>",
        "id": 213872842,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1603165691
    },
    {
        "content": "<p>Here is a question... If I put MS on something (say, <code>identifier</code>) and then I slice it into different identifiers (NPI, etc), should the slices automatically get the MS too?  Again, I don't know what it means for something to be MS but for its slices not to be MS.  But as you said, the definition of MS is left up to authors, so maybe I'm not supposed to know what that means?</p>",
        "id": 213911981,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1603197515
    },
    {
        "content": "<p>As I understand it, a slice is marked as MS or not.  But if the base element has MS, then that element must be supported.  A slice only needs to be supported if marked MS.</p>",
        "id": 213912208,
        "sender_full_name": "David Pyke",
        "timestamp": 1603197632
    },
    {
        "content": "<p>Is there a difference between how this should work for <code>property</code> vs <code>property.code</code>? For example, if <code>property.code</code> is <code>MS</code>, does that also imply that <code>property:someSlice.code</code> is <code>MS</code>? I think in that case the answer is yes, since the <code>MS</code> on <code>property.code</code> applies to all slices.</p>",
        "id": 213921903,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1603202047
    },
    {
        "content": "<p>I would think that the behavior would not change based on if it is the sliced element itself or a nested path of the sliced element.  To me, either any and all MS get inherited from the base element(s) or none do.</p>",
        "id": 213930568,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1603205529
    },
    {
        "content": "<p>From my experimenting, the IG Publisher seems to make the decision that if a <code>MS</code> is applied to a nested path of a sliced element, then that <code>MS</code> applies to all slices as well. I tested out letting the IG Publisher generate a snapshot from a resource that had <code>property.code</code> set to MS, but made no constraints on <code>property:ln_component.code</code>, and the Publisher generated a snapshot that looks like:<br>\n<a href=\"/user_uploads/10155/GVfxSo2djtWz-Hycq_uV4wEm/image.png\">image.png</a> <br>\nNote that the <code>MS</code> is specified on <code>All Slices</code>.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/GVfxSo2djtWz-Hycq_uV4wEm/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/GVfxSo2djtWz-Hycq_uV4wEm/image.png\"></a></div>",
        "id": 213947996,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1603213008
    },
    {
        "content": "<p>OK, but does that only come through in the rendering of the documentation?  If you look at the SD itself, do you see the <code>MustSupport</code> applied anywhere else or is it still only on the base <code>property.code</code> element?</p>",
        "id": 213955783,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1603216317
    },
    {
        "content": "<p>Hm yeah, the <code>MustSupport</code> is just applied on the <code>property.code</code> element.</p>",
        "id": 213957559,
        "sender_full_name": "Nick Freiter",
        "timestamp": 1603217010
    },
    {
        "content": "<p>OK.  This was <a href=\"#narrow/stream/179177-conformance/topic/Slicing.20and.20Must-Support/near/213997847\">discussed some</a> over in the <code>#conformance</code> stream and then in a MnM meeting.  It resulted in <a href=\"https://confluence.hl7.org/display/FHIR/Guide+to+Designing+Resources\">this guidance</a>:</p>\n<blockquote>\n<p>If an element is marked as 'Must Support' and is then sliced, that does not imply that each of the slices is 'Must Support'.  If the intention is that a slice must be supported, then that slice should be marked as 'Must Support'.  As an example, if Medication.identifier is marked as 'Must Support', and is then sliced to specify different types of identifiers, unless marked otherwise, the different slices are not 'Must Support'.  This implies that a system must support Medication.identifier but can choose to support any of the slices, unless those slices were intentionally marked as 'Must Support'.</p>\n<p>If an element is marked as 'Must Support' in its parent's slicing base, that does imply that the element is 'Must Support' in each of the slices.  As an example, if Medication.identifier.system was marked as 'Must Support', and then Medication.identifier was sliced, the identifier.system would be 'Must Support' in each of those slices.  NOTE: This means that if you do not intend an element to be 'Must Support' in every slice, that you should not mark it as 'Must Support' in the slicing base.</p>\n</blockquote>",
        "id": 214043172,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1603283753
    },
    {
        "content": "<p>So, I've filed <a href=\"https://github.com/FHIR/sushi/issues/647\">#647</a> on SUSHI for us to fix this.</p>",
        "id": 214043256,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1603283796
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"191469\">@Chris Moesel</span>.  I've added some further questions in the conformance topic about how the IG Publisher is expected to handle this in the profile rendering.</p>",
        "id": 214139608,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1603336310
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> -- I just wanted to let you know that this has been fixed in the just-announced SUSHI 1.0.0 Beta 4 release!</p>",
        "id": 215636760,
        "sender_full_name": "Chris Moesel",
        "timestamp": 1604521612
    },
    {
        "content": "<p>Thanks, Chris.  That's great!</p>",
        "id": 215637409,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1604521926
    }
]