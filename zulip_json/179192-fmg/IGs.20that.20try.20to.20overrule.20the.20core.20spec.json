[
    {
        "content": "<p>I learned today that the most recent US Core publication (which we recently approved) attempts to loosen the rules on Extensible bindings (relevant language is <a href=\"http://build.fhir.org/ig/HL7/US-Core/conformance-expectations.html#extensible-binding-for-codeableconcept-datatype\">here</a>).  I've got a serious problem with that.  Methodologically, it's not allowed.  And for it to even be attempted is a serious process issue.  </p>\n<p>The problem is that if there's an extensible binding to a value set that includes an overarching SNOMED (or other) concept that completely encompasses the space, then there can <em>never</em> be a situation where one of the codes won't apply and thus a code from the value set must always be present.  The issue is that the main EHR implementers object to sending something like a generic SNOMED code for 'procedure' when they're sending free text or a local code that they don't have an ability to translate.</p>\n<p>The thing is that the current rules for 'Extensible' don't say \"make your best effort\" or \"if you can do so automatically\".  The rule is \"if a mapping is possible, the value set code must be used\".  It's not intended to be used at all in the way US Core is trying to use it.  It's intended to be used in such situations as \"all NDC codes\" where if a drug happens to not have an NDC code, you're free to use just text or a local code.</p>\n<p>I understand that the existing binding strengths don't really give the US core implementers an ability to say what they'd like to say (which, as I understand it, is essentially \"for net new content you control, you SHALL use a fine-grained code from our value set, for legacy or external content, you SHOULD map to the value set.  While doing so, totally ignore all of the high level SNOMED codes we inherit from our high-level intensional definition because it's too impractical to try to exclude them\").  In practice, they <em>could</em> establish a 'preferred' binding and set those rules with text, but they don't want to do that because then tools wouldn't spit out warnings.  (Technically, they could get around that with a warning invariant.)</p>\n<p>In any event, we shouldn't be publishing IGs that try to say that the rules in the base spec don't apply - <em>especially</em> when it's being done by an IG that's as foundational as US Core.  And I'm particularly concerned that even though the authors of the IG understood the rules, they didn't seek any vetting by MnM, Vocab or the FMG when they decided to write language that ignores those rules.</p>",
        "id": 243990004,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624674585
    },
    {
        "content": "<p>Two things, and both about the specifics of this case rather than a management perspective on whether it's okay...</p>\n<ol>\n<li>\n<p>Practically speaking, is this just an issue because the values in the target ValueSets include certain overarching terms that they shouldn't? I don't know how to actually review this value set, because I can't find a FHIR representation of it and I just see a bunch of blank template type stuff on the the vsac page. (Why do we allow IGs to reference value sets in this way??)</p>\n</li>\n<li>\n<p>\"Also for CodeableConcept if only text is available, then just text may be used.\" -- irrespective of the ValueSet we're binding to, is this language consistent with FHIR's definition of extensible?</p>\n</li>\n</ol>",
        "id": 244017453,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1624717417
    },
    {
        "content": "<ol>\n<li>\n<p>That's one of the problems, but not the only one and realistically not the main one.  In most cases, whatever local code or text is present from an external or legacy source <em>will</em> have a translation to a fine-grained code (SNOMED or otherwise).  Even if all the high-level codes were removed, an extensible binding says that if a code from the value set applies, it must be present.  That would mean that all legacy and external codes would need to be mapped.  The real issue is that US Core wants 2 sets of rules - one for new content authored by the conformant system and one for all other content.  However, there's nothing in the instances that differentiates the two cases.  Also, there's nothing in current regulation that deals with differentiating them.</p>\n</li>\n<li>\n<p>Text vs. code doesn't matter.   The specific wording for extensible is \"To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated.\" - it doesn't matter whether the concept being communicated by the CodeableConcept is in CodeableConcept.text, CodeableConcept.coding or CodeableConcept.extension.  So the wording in the IG is absolutely not consistent with the SHALL rule in the core spec.</p>\n</li>\n</ol>",
        "id": 244034416,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624741578
    },
    {
        "content": "<p>I'm not sure what this sentence means:</p>\n<blockquote>\n<p>For data not captured by the system transmitting the information, the coded data should be automatically converted to a fine-grained code from the specified value set.</p>\n</blockquote>",
        "id": 244034674,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624741980
    },
    {
        "content": "<p>I note that the passage doesn't actually say what Lloyd says it says. </p>\n<p>it says:</p>\n<blockquote>\n<p>US Core guidance provides more flexibility for situations where implementers cannot fully comply with the FHIR base guidance</p>\n</blockquote>\n<p>But the guts of the advice says:</p>\n<blockquote>\n<p>If this is not possible, the system can provide the existing code or the free text, and a high-level abstract code, such as SNOMED CT ‘Procedure’, to remain conformant with the extensible binding</p>\n</blockquote>\n<p>This appears to me to meet the technical requirements of extensible even if it does not meet the spirit of the rule</p>",
        "id": 244034785,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624742128
    },
    {
        "content": "<blockquote>\n<p>I don't know how to actually review this value set, because I can't find a FHIR representation of it and I just see a bunch of blank template type stuff on the the vsac page. (Why do we allow IGs to reference value sets in this way??)</p>\n</blockquote>\n<p>I'm not sure why you can't reference this value set - the vsac reference should work and take to a list of codes. it does for me </p>\n<p>And we let IGs reference value sets this way because that's the right value set to reference, and we're still trying to move VSAC towards a better approach</p>",
        "id": 244034953,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624742321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> are we sure they didn't talk to vocab?</p>",
        "id": 244034961,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624742346
    },
    {
        "content": "<p>I didn't see any discussion about it on the list or Zulip.  <span class=\"user-mention\" data-user-id=\"191405\">@Rob Hausam</span> might know if this language was approved on a call (in which case, there's an issue with Vocabulary's actions as well...)</p>\n<p>Providing a high-level abstract code would be fine.  Unfortunately, the section also says<br>\n<code>Also for CodeableConcept if only text is available, then just text may be used.</code> - which isn't true for any of the elements where high-level SNOMED codes are in the value set and is only true for others if the text can't be mapped.  (Not 'system isn't capable of mapping' but 'no human, taking enough time, can map it'.)</p>\n<p>The US Core spec also says <br>\n<code>Although the FHIR guidance for extensible bindings indicates that all conceptual overlaps including free text be mapped the coded values in the bindings, US Core guidance provides more flexibility for situations where implementers cannot fully comply with the FHIR base guidance. This flexibility is sometimes necessary and expected for legacy and text only data. For newly recorded, non legacy data, a system SHOULD meet the conformance of the value set.</code></p>\n<p>It's non-conformant to soften a SHALL in the core spec to a SHOULD in an IG.  (And in this case, they're saying that the SHOULD doesn't even apply to all cases.)</p>",
        "id": 244035332,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624742952
    },
    {
        "content": "<p>so your issue is text only?</p>",
        "id": 244035908,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624743905
    },
    {
        "content": "<p>My issue is both quotes.  Text only breaks the rules.  So does softening SHALL to SHOULD and saying that binding only applies to some types of instances that claim conformance with the profile, not all.</p>",
        "id": 244038551,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624748477
    },
    {
        "content": "<blockquote>\n<p>saying that binding only applies to some types of instances that claim conformance with the profile</p>\n</blockquote>\n<p>how did they do that?</p>",
        "id": 244038558,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624748506
    },
    {
        "content": "<p>This text: \"Although the FHIR guidance for extensible bindings indicates that all conceptual overlaps including free text be mapped the coded values in the bindings, US Core guidance provides more flexibility for situations where implementers cannot fully comply with the FHIR base guidance. This flexibility is sometimes necessary and expected for legacy and text only data. For newly recorded, non legacy data, a system SHOULD meet the conformance of the value set.\"</p>",
        "id": 244038692,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624748752
    },
    {
        "content": "<p>That's not a type of flexibility they can add.  And they can't make a SHALL a SHOULD.</p>",
        "id": 244038742,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624748778
    },
    {
        "content": "<p>but then they said, </p>\n<blockquote>\n<p>the system can provide the existing code or the free text, and a high-level abstract code, such as SNOMED CT ‘Procedure’, to remain conformant with the extensible binding</p>\n</blockquote>\n<p>so I think you're jumping at a shadow on that one. That's legally compliant, even they imply it's not.</p>",
        "id": 244039621,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624749940
    },
    {
        "content": "<p>At minimum, the language is unclear.  With the number of SHOULDs and exclusions, it's certainly not clear that every single Procedure.code and AllergyIntolerance.code SHALL have a code from the value set present, no matter what.</p>",
        "id": 244044485,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624758686
    },
    {
        "content": "<p>I don't recall that anyone representing US Core has come directly to Vocab with this (or other) language.  We have been having considerable recent discussions on extensible binding, though, and there is some considerable sentiment from some to change the extensible rules and guidance.  Some of the use cases and considerations being discussed as reasons for doing that I think have some of the US Core guidance and experience in mind as examples, or at least it's describing the issues in a similar way, but that connection is only indirect.  I think I can say with a high degree of certainty that in Vocab we have never approved the US Core language - but I also have to say that I don't know what would have happened if we had actually addressed it.</p>",
        "id": 244045057,
        "sender_full_name": "Rob Hausam",
        "timestamp": 1624759748
    },
    {
        "content": "<p>if the source only has text, like from a legacy environment that allowed data entry as simple text... then how is it to do current deterministic and perfect code matching?   -- Might these cases be something that we recognize as not compliant with us-core, while recognizing that they might be returned from a search? Is this what they are trying to do? To try to pull these results that are clearly not capable of being compliant into somehow seeming to be compliant, while not compliant... this very much devalues an IG compliance claim.  Better that everyone recognize that some search results will not be us-core compliant.   Which begs the question, is there some indication of all the results that are compliant vs not? Surely profile tagging is possible.</p>",
        "id": 244072520,
        "sender_full_name": "John Moehrke",
        "timestamp": 1624809010
    },
    {
        "content": "<p>Implementers are providing feedback that a strict interpretation of extensible can not be met.  They also expressed strong reservations about investing in a mapping exercise that adds little or no value.  US Core's approach is pragmatic and addresses these real world concerns.  My primary concern is that a strict adherence to modeling rules will be an unnecessary burden and therefore a barrier to further adoption of US Core.  My secondary concern is that after 5 months of discussions and ballot reconciliation, following the HL7 balloting processes,openly discussing all these issues including the contentious ones, striving to provide straightforward  clear guidance where the practice may not toe the line with the spirit of the FHIR Specifications, documenting these changes better that anybody else, and only now on the cusp of publication  this issue  being brought up to derail it.</p>",
        "id": 244075507,
        "sender_full_name": "Eric Haas",
        "timestamp": 1624813556
    },
    {
        "content": "<p>It's not being brought up to derail it, it's being brought up to ensure it doesn't get derailed later. Lloyd hasn't expressed any issue with what you've agreed, only how you expressed it. Of course, the challenge is that what you'e agreed is bound up in how you expressed it, and changing that would send you back to square one on the agreement. </p>\n<p>And this is not the only non-compliance, so it's not clear to me that it's a prima facie reason to derail the process. And <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> it's not like the rules around extensible are that water-tight. it's always been an argument and a matter for human interpretation</p>",
        "id": 244082000,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624823554
    },
    {
        "content": "<p>The arguments about Extensible have been about it not doing what people would like it to do, not so much about what the words in the spec clearly say.  The reality is that 'Extensible' is useful - as defined - but only works when you're talking about net new data.  You're essentially saying \"you must code data if it fits in this space and you must code it this way if the codes provided cover the concept\".  That's a legitimate (and desirable) thing to say.  And it can be essential to drive interoperability.  If you relax the constraint, then anyone can send whatever the heck they feel like and interoperability goes away.  </p>\n<p>The problem is that Extensible isn't appropriate for what US Core is trying to do - which is essentially \"please make your best efforts\".  But that's really hard to conformance test. </p>\n<p>I'm totally fine with US Core relaxing their constraints to whatever they think is achievable.  I'm not comfortable with them saying that those rules constitute what Extensible means.</p>",
        "id": 244089511,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624834981
    },
    {
        "content": "<p>It seems US Core wants to use preferred bindings for legacy data and extensible bindings for new data. That seems to want a pair of profiles.</p>",
        "id": 244102383,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1624856426
    },
    {
        "content": "<blockquote>\n<p>The issue is that the main EHR implementers object to sending something like a generic SNOMED code for 'procedure' when they're sending free text or a local code that they don't have an ability to translate.</p>\n</blockquote>\n<p>Not true. They object because their customers see no value in sending 'high-level' procedure code. They could hard code procedure and be 'conformant' ...</p>",
        "id": 244143179,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1624886594
    },
    {
        "content": "<p>I haven't going through my notes but it definitely <strong>feels</strong> like we have discussed US Core extensible binding in every ballot. There are several zulip chains + trackers. Pretty extensive chat on this topic on <a href=\"#narrow/stream/179166-implementers/topic/USCDI.20US.20core\">Implementers March 2</a>.</p>",
        "id": 244143850,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1624886888
    },
    {
        "content": "<p>While I don't think it will happen for this publication -- it would be great to have a fully blessed approach for 'we sometimes have free text'. It may be as simple in the future as saying sometimes instance will be 'non-conformant' and that is ok.</p>",
        "id": 244145406,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1624887549
    },
    {
        "content": "<p>...then of course systems will default high-level  concepts to be conformant.</p>",
        "id": 244148236,
        "sender_full_name": "Brett Marquard",
        "timestamp": 1624888754
    },
    {
        "content": "<p>Agreed -- summarizing my take:</p>\n<ol>\n<li>\n<p>Sending high level concepts in place of specific codes doesn't help implementers, even if it's \"valid\". We should steer away from the unhelpful / trivially valid.</p>\n</li>\n<li>\n<p>US Core doesn't intend to apply by-the-core-spec extensible binding to old/externally sourced data</p>\n</li>\n<li>\n<p>Generating errors or warnings on poorly coded data is important, which is one motivation for the US Core profiles to apply extensible binding even though it's not technically accurate -- leveraging tooling! </p>\n</li>\n</ol>\n<p>I think <span class=\"user-mention\" data-user-id=\"191682\">@Richard Townley-O'Neill</span> 's summary is right in descriptive terms, but if you provide an \"escape hatch profile\" it might become much harder to raise awareness about data quality gaps.</p>",
        "id": 244152879,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1624890535
    },
    {
        "content": "<p>I'm happy to steer away from trivially valid - but I don't want to steer toward technically invalid.</p>\n<p>I think the issue is that regulation doesn't provide an out for old/external data, so there's a \"need\" for that old/external data to be 'valid' against US Core.  Question - are there <em>any</em> impositions that US Core seeks to impose on legacy/external data?  And do they have a clear definition of what constitutes legacy/external such that tight conformance testing could still be performed on 'new' data?</p>\n<p>I don't think multiple profiles makes it harder to raise awareness about quality gaps.  You can still validate against the 'tight' profiles (and perhaps soften errors to warnings).</p>",
        "id": 244165310,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624895435
    },
    {
        "content": "<p>Businesses would and perhaps should , if given this choice of profiles, always choose the loosest one.</p>",
        "id": 244169882,
        "sender_full_name": "Eric Haas",
        "timestamp": 1624897361
    },
    {
        "content": "<p>They're going to do that regardless of expression mechanism if you don't set rules for when certain profiles must be used.  That's a problem you have with the current approach too.  (In addition to being non-conformant with the core spec <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 244176900,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624900657
    },
    {
        "content": "<p>While writers of data may want to do the minimum, readers may prefer more.<br>\nBusinesses that want to process the data can test against the tight profile to see how hard it will be to process the data.<br>\nThey can even whinge about sub-standard data with an objective standard of quality.</p>",
        "id": 244262988,
        "sender_full_name": "Richard Townley-O'Neill",
        "timestamp": 1624964216
    },
    {
        "content": "<p>You're correct.  One of the key uses of profiles is to tell client apps what they can count on when dealing with the data.  That's why Extensible exists - so that an app can look at code or text it doesn't and understand and be able to  at least reason \"I know this isn't one of the concepts in the value set\".  If the source system can't guarantee that it either doesn't expose the instance or doesn't declare the profile. </p>\n<p>Profiles aren't expected to apply to all data.  The problem here is that US Core is trying to make everything fit in one profile - which results in a profile that can't enforce anything and that clients can't rely on for anything.</p>",
        "id": 244272167,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624969809
    },
    {
        "content": "<blockquote>\n<p>Profiles aren't expected to apply to all data.</p>\n</blockquote>\n<p>Well, there's no much other choice in this case. And clients can't rely on anything... that's the real world, I believe.</p>",
        "id": 244274148,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1624970789
    },
    {
        "content": "<p>Certainly the real world is that all instances won't comply with the desired constraints - but the methodological solution to that is \"not all instances will comply with the profile\".  It's not to create a profile that covers the lowest common denominator of all instances.  At least not if you expect the profile to have much value - either from setting a target or giving clients data they can count on.</p>",
        "id": 244278571,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624972742
    },
    {
        "content": "<p>More importantly, in environments where profiles are being used to say \"this data follows the desired rules\", Extensible functions exactly as you'd like it to.</p>",
        "id": 244278837,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1624972869
    }
]