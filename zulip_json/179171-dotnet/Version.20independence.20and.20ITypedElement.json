[
    {
        "content": "<p>Hi Guys, I have been playing around with the ISourceNode and ITypedElement as described here in the documentation for the .NET FHIR API <a href=\"http://docs.simplifier.net/fhirnetapi/parsing/elementmodel-overview.html\" target=\"_blank\" title=\"http://docs.simplifier.net/fhirnetapi/parsing/elementmodel-overview.html\">http://docs.simplifier.net/fhirnetapi/parsing/elementmodel-overview.html</a><br>\nI managed to get ITypedElement from  ISourceNode to work where I can provide the type information either from a POCO instance or the specification.zip and the ZipSource as an IResourceResolver. So it all worked as it was documented.</p>\n<p>However, I seem to be missing the use-case for all this. I had thought I could use ITypedElement as a way of making my implementation FHIR version agnostic where I would provide the appropriate Stu3 or R4  specification.zip depending on which version of a resource I wanted to parse and work with. However, it now occurs to me that when supplying the Stu3 specification.zip to the R4 tooling that the R4 tooling expects R4 FHIR resources (StructuredDefinitions) in the specification.zip. </p>\n<p>I guess the end game I was hoping to achieve was to be able to use ISourceNode and ITypedElement to run FHIRPath statements to get the search parameter index data in a way that was FHIR version independent. I'm now not sure that this goal is achievable. I was wondering if   <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span>  or <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> could comment on this? <br>\nAm I chasing Unicorns?</p>",
        "id": 172276041,
        "sender_full_name": "Angus Millar",
        "timestamp": 1564709280
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191391\">@Angus Millar</span>, our Vonk server developers <span class=\"user-mention\" data-user-id=\"191757\">@Christiaan Knaap</span> and <span class=\"user-mention\" data-user-id=\"193551\">@Marco Visser</span> can probably give you some guidance, as they are facing similar challenges. However, both are currently on a well deserved holiday break. I'll ask my colleagues to respond when they are back in the office.</p>",
        "id": 172489149,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1564995638
    },
    {
        "content": "<p>Hi Angus - yes, the <code>ITypedElement</code> and <code>ISourceNode</code> related functionality is there to support working with data that has no precompiled POCO's, and thus would be one part of the solution to work with multiple versions of FHIR.  In fact, the parsers and more and more parts of the API are working with these classes and have recently moved to a new repository (fhir-net-common) that has NO dependency on a specific FHIR version.</p>\n<p>Then why is there a dependence on StructureDefinition?   Well, there's not, there's a dependency on <code>IStructureDefinitionSummaryProvider</code>. I'll elaborate:</p>\n<ul>\n<li>You can read data with <code>ISourceNode</code> (in fact, that's what the xml and json parsers implement).  This does not know ANYTHING about FHIR versions and has no type information.  Hence, when you use ISourceNode to parse, you'll work with strings, and element names like \"Observation.valueQuantity\"</li>\n<li>One level up, there's <code>ITypedElement</code>, this is useful when you DO need type information, e.g. you need to know that a certain element is a bool or a HumanName.  Almost all higher-level functionality (like the validator, and the FhirPath engine) need type information and run on top of ITypedElement.</li>\n</ul>\n<p>How does a type-info-less ISourceNode turn into an ITypedElement?  By adding type information.  This is supplied by the aforementioned <code>IStructureDefinitionSummaryProvider</code>.  This interface itself has no dependency on a specific FHRI release.  We currently ship two implementations of this interface:   one which implements this interface by getting information using reflection from POCO's and one that reads this information from StructureDefinition resources in specification.zip (or any other source).</p>\n<p>So, both these implementations of the interface <em>do</em> depend on POCO's.   This is what we figured most people needed first.  But the fact that all of this is hidden behind this interface enables us to supply concrete implementations that do not depend on POCO's (e.g. by reading it directly from the StructureDefinition XML, or from a Protobuf-stored representation or -using ISourceNode- from a StructureDefinition in xml/json).  Also, you could choose to have the definitions for STU3 and R4 both present in R4 StructureDefinitions (;-)) - in which case you would depend on the R4 POCO's only.</p>\n<p>What Vonk (and others) have done, is use the StructureDefinition POCO-based implementations. They use both implementations in one AppDomain by loading both versions of the assembly. That's another possible solution.</p>\n<p>So in summary, no you're not chasing Unicorns - you have correctly understood what these interfaces are meant for.  It's just that at some point you might need type information - and the only two sources we currently have support for are POCO's and StructureDefinitions (which itself are POCO's)....but principally in the design, this need not be the case.  </p>\n<p>If you look at the implementation using StructureDefinition (I think it's called StructureDefinitionSummaryProvider), you can imagine how this could be done by just reading raw json files, or just the very thin ISourceNode-based parsers).</p>\n<p>At little bit more background on this can be found here: <a href=\"http://docs.simplifier.net/fhirnetapi/parsing.html\" target=\"_blank\" title=\"http://docs.simplifier.net/fhirnetapi/parsing.html\">http://docs.simplifier.net/fhirnetapi/parsing.html</a></p>",
        "id": 173016796,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1565610649
    },
    {
        "content": "<p>Thank you very much for your help Ewout.  I seem to be making progress. I have gone with two separate projects R4 and STU3 within my solution where each has a  dependency on the corresponding hl7.fhir.Specification (R4 &amp; STU3). Each of these implements an interface called <code>IFhirR4SpecificationServices</code> and <code>IFhirSTU3SpecificationServices</code>  which both inherit from a third interface called <code>IFhirSpecificationServices</code>.  The third interface just allows simple registering of services in my Dependency Injection library. These then provide the methods: </p>\n<p><code>public ITypedElement ToTypedElement(ISourceNode resourceSourceNode);</code><br>\n<code> public List&lt;Hl7.Fhir.Utility.ExceptionNotification&gt; GetErrors(ITypedElement resourceTypedElement);</code><br>\n<code> public IEnumerable&lt;ITypedElement&gt; GetFhirPathItem(ITypedElement resourceTypedElement, string FhirPathExpression);</code></p>\n<p>Then with this, I can do this logic in my main app domain to get the appropriate ITypeElement based on the required FHIR Version :</p>\n<div class=\"codehilite\"><pre><span></span>if (command is UpdateResourceCommand UpdateResourceCommand)\n      {\n        switch (UpdateResourceCommand.FhirVersion)\n        {\n          case Smoke.Common.FhirVersion.R4:\n            {\n              ITypedElement resourceTypedElement = this.IFhirR4VersionSchemaService.ToTypedElement(UpdateResourceCommand.ResourceSourceNode);\n              UpdateResourceCommand.SchemaExceptionList = this.IFhirR4VersionSchemaService.GetErrors(resourceTypedElement);\n              break;\n            }\n          case Smoke.Common.FhirVersion.STU3:\n            {\n              ITypedElement resourceTypedElement = this.IFhirStu3VersionSchemaService.ToTypedElement(UpdateResourceCommand.ResourceSourceNode);\n              UpdateResourceCommand.SchemaExceptionList = this.IFhirStu3VersionSchemaService.GetErrors(resourceTypedElement);\n              break;\n            }\n          default:\n            break;\n        }\n      }\n</pre></div>\n\n\n<p>I did this to avoid the  <code>extern alias R4;</code> and <code>extern alias STU3;</code> all over the place. I plan on working with the ITypedElement throughout my main Domain for resource manitpulations.</p>\n<p>Still, a work in progress but I'm beginning to see my Unicorn may not have a horn.</p>",
        "id": 173507334,
        "sender_full_name": "Angus Millar",
        "timestamp": 1566172667
    },
    {
        "content": "<p>This is certainly close the way we've done things in our software too!</p>",
        "id": 173528093,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1566205914
    },
    {
        "content": "<p>So I have now run into the problem of updating the resource. I had incorrectly thought I could manipulate a given resource using ISourceNode or possibly ITypedElement interfaces. I can certainly create a new resource using <code>SourceNode.Resource()</code> &amp; <code> SourceNode.Node()</code> &amp; <code>SourceNode.Valued()</code>. However, I have just discovered that both interface only allow <code>get;</code> and not <code>set;</code>. For instance, I wanted to set the resource.meta.lastUpdated value, something like below.<br>\nAre there any options here without going to the POCOs? </p>\n<div class=\"codehilite\"><pre><span></span>    ISourceNode metaSourceNode = resource.Children().FirstOrDefault(x =&gt; x.Name == &quot;meta&quot;);\n      if (metaSourceNode != null)\n      {\n        ISourceNode lastUpdatedSourceNode = metaSourceNode.Children().FirstOrDefault(x =&gt; x.Name == &quot;lastUpdated&quot;);\n        if (lastUpdatedSourceNode != null)\n        {\n          lastUpdatedSourceNode = SourceNode.Valued(&quot;lastUpdated&quot;, dateTime.ToString());\n        }\n      }\n</pre></div>",
        "id": 173773304,
        "sender_full_name": "Angus Millar",
        "timestamp": 1566375029
    },
    {
        "content": "<p>Yes, ITypedElement is read-only, since it can represent json/xml files - in fact it will not read them into memory completel, but as you navigate through them it will parse them element by element. So, that's why you cannot write to an ITypedElement.  There is an updateable implementation of ITypedElement however, it is called <code>ElementNode</code>.   This represents a DOM-like tree of data in-memory, so it can be updated.  Also, you can clone any ITypedElement into it, and then manipulate the tree and then serialize or whatever!</p>",
        "id": 175248589,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1568040587
    },
    {
        "content": "<p>Wow, thank you very much <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> . I will go investigate this ElementNode implementation.</p>",
        "id": 175400072,
        "sender_full_name": "Angus Millar",
        "timestamp": 1568175615
    }
]