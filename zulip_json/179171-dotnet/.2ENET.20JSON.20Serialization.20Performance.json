[
    {
        "content": "<p>I noticed it takes a second the first time I serialize a bundle to JSON, no matter the method via FhirJsonSerializer.  Wondered if anybody has seen this prior and ways to help avoid that first time cost. Haven't profiled yet to see what's going on.</p>",
        "id": 204100708,
        "sender_full_name": "Louis Gordon",
        "timestamp": 1594913681
    },
    {
        "content": "<p>ex: <br>\n        [TestMethod()]<br>\n        public void JsonSerialization_TestEmptyBundle()<br>\n        {<br>\n            //arrange<br>\n            var bundle = new Bundle();<br>\n            var jsonSerializer = new Hl7.Fhir.Serialization.FhirJsonSerializer();</p>\n<div class=\"codehilite\"><pre><span></span><code>        //act\n        var watch = Stopwatch.StartNew();\n        var resourceStr = jsonSerializer.SerializeToString(bundle);\n        watch.Stop();\n\n        //assert\n        Assert.IsTrue(true, $&quot;{watch.ElapsedMilliseconds}&quot;);\n    }\n</code></pre></div>",
        "id": 204104118,
        "sender_full_name": "Louis Gordon",
        "timestamp": 1594915072
    },
    {
        "content": "<p>The first time it has to generate a whole lot of data - basically a complete description of all the classes - and that takes time</p>",
        "id": 204107619,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1594916616
    },
    {
        "content": "<p>That's right - I am working on speeding things up, but there's a lot of reflection going on initially before you can serialize.  More or less that same thing going on when using .NET's BinarySerializer.</p>",
        "id": 204404942,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1595239454
    },
    {
        "content": "<p>I'm wondering if the latest versions on the xml serializer are performing as well?<br>\nI've started experimenting in a pre-generated serializer that has none of these drawbacks (but is version specific) and the speed and simplicity is far better.</p>",
        "id": 208476150,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1598778781
    },
    {
        "content": "<p>Once it's a little more accurate will start measuring them apples to apples.</p>",
        "id": 208476158,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1598778807
    },
    {
        "content": "<p>Anyone else tried this, or even thought about it?</p>",
        "id": 208476162,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1598778820
    },
    {
        "content": "<p>Oh size of the serialization assembly is about 260kb</p>",
        "id": 208476203,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1598778847
    },
    {
        "content": "<p>Yes, we implemented a pre-generated serializer (both JSON and XML) in our fork. It is &gt; 10 times faster than the current one and it does not require all that initial reflection time</p>",
        "id": 208547847,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1598875472
    },
    {
        "content": "<p>Thanks, can you point me to your fork?<br>\nThat's about the same factor that I'm seeing too.</p>",
        "id": 208620025,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1598910823
    },
    {
        "content": "<p><a href=\"https://github.com/CareEvolution/fhir-net-api/commit/bdb76e6388920e0f6b0a988140f8c582a65fbb7c\">https://github.com/CareEvolution/fhir-net-api/commit/bdb76e6388920e0f6b0a988140f8c582a65fbb7c</a></p>",
        "id": 208624895,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1598914008
    },
    {
        "content": "<p>Thanks</p>",
        "id": 208663095,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1598952065
    },
    {
        "content": "<p>We actually had generated C# serializers back in the days when we generated the C# library using Java.  That was painful, writing and debugging java, then running it, taking the C#, hoping it would compile.  If it did, parse and serialize and then debugging. And that over and over again.  At some point I figured I could make it work with 1 single reusable component hahaha.</p>\n<p>But sure, certainly with <span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> 's generator framework, we'd also have a nice basis to re-introduce this.  For the 2.0 version of the API, we switched to code generation based on that framework (<a href=\"https://github.com/microsoft/fhir-codegen\">https://github.com/microsoft/fhir-codegen</a>), so it would be possible to integrate everything into the API build process....</p>",
        "id": 209285155,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1599478172
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191912\">@Michele Mottini</span> , did you do a streaming parser too, or just the serializer?</p>",
        "id": 210362850,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600332376
    },
    {
        "content": "<p>Just the serializer. Parser is considerably more difficult (we had a stab at it nut dropped for the moment being)</p>",
        "id": 210384669,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1600347405
    },
    {
        "content": "<p>Just for awareness, I'm tinkering with this when I need a break from meetings/documentation too.<br>\nEdit: nothing to post yet, will update if/when it gets that far.</p>",
        "id": 210411293,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600358600
    },
    {
        "content": "<p>I've now got the xml side done. And up to testing stage.</p>",
        "id": 210456040,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600379413
    },
    {
        "content": "<p>Nice!  I'm working on testing System.Text.Json for the json side right now (almost have parsing working so that I can test performance).</p>",
        "id": 210456413,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600379654
    },
    {
        "content": "<p>Will be interested to compare...<br>\n<a href=\"https://github.com/brianpos/fhir-net-web-api/commit/edef9d2097336da71af687aeb9098747ead7a253\">https://github.com/brianpos/fhir-net-web-api/commit/edef9d2097336da71af687aeb9098747ead7a253</a></p>",
        "id": 210457984,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600380743
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/p_axSYxog77n00kc8MHnDAtU/image.png\">image.png</a> <br>\n10,000 resources parsed/serialized</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/p_axSYxog77n00kc8MHnDAtU/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/p_axSYxog77n00kc8MHnDAtU/image.png\"></a></div>",
        "id": 210458062,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600380810
    },
    {
        "content": "<p>Gino, is that code you are pushing to github?<br>\nI'd love to get that into the same tree.</p>",
        "id": 210458137,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600380852
    },
    {
        "content": "<p>Right now I'm just testing locally.  I'm figuring out the shape of what I need to put in the codegen so that it gets added to the generated content automatically.</p>",
        "id": 210458360,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600381042
    },
    {
        "content": "<p>If you've got the shape, I can push it into this code gen and you'll have both <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 210458399,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600381081
    },
    {
        "content": "<p>It's a bit slow going since I haven't done all the custom stuff with System.Text.Json before, but it's <em>supposedly</em> faster and the future... I should (hopefully) have a comparison to newtonsoft in not too long</p>",
        "id": 210458465,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600381108
    },
    {
        "content": "<p>It'll all be pushed when it's working, but I'm using <a href=\"https://github.com/microsoft/fhir-codegen\">fhir-codegen</a> instead of the TT templates.</p>",
        "id": 210458562,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600381194
    },
    {
        "content": "<p>No dramas.</p>",
        "id": 210458634,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600381234
    },
    {
        "content": "<p>For curiosity, what are you using for the performance testing?</p>",
        "id": 210459010,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600381547
    },
    {
        "content": "<p>Nothing special yet, just the unit tests in a loop.<br>\n<a href=\"https://github.com/brianpos/fhir-net-web-api/blob/edef9d2097336da71af687aeb9098747ead7a253/src/Test.WebApi.AspNetCore/CustomSerializers.cs#L75\">https://github.com/brianpos/fhir-net-web-api/blob/edef9d2097336da71af687aeb9098747ead7a253/src/Test.WebApi.AspNetCore/CustomSerializers.cs#L75</a><br>\nNext step is to grab the all examples unit test from the core spec and use those in direct comparison and also for accuracy to compare them to eachother.</p>",
        "id": 210459197,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600381698
    },
    {
        "content": "<p>doing scale of 10k means that even the startup time for the parsing of the reflection etc blends away</p>",
        "id": 210459262,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600381759
    },
    {
        "content": "<p>Also, the memory overhead between the parsers is 30MB vs 70MB (just looking at the unit test debugger memory usage results)</p>",
        "id": 210459332,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600381805
    },
    {
        "content": "<p>Thanks.  I have a little playground app (doing the same type of thing) but was thinking of trying to make my tests consistent with yours while I'm tinkering (for frame of reference)</p>",
        "id": 210459589,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600381987
    },
    {
        "content": "<p>Will update you when I get the all examples test in there too.<br>\nAs you can use it to cross reference against the core one for accuracy.</p>",
        "id": 210462001,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600383868
    },
    {
        "content": "<p>Got the parser working in a test environment (custom Pocos, not the standard ones yet), but results look promising (10,000 loops of parsing Patient-example.json from memory):</p>\n<div class=\"codehilite\"><pre><span></span><code>Results of file: Patient-example.json, 3909 bytes\nFHIR Net API, R4: 1.9.0.0:\n       Setup: 0s\n First Parse: 1.138s\nLooped Parse: 7.57s (avg: 0.000757)\n\nResults of file: Patient-example.json, 3909 bytes\nCSharpBasic-Newtonsoft:\n       Setup: 0s\n First Parse: 0.171s\nLooped Parse: 1.18s (avg: 0.000118)\n\nResults of file: Patient-example.json, 3909 bytes\nCSharpBasic-SystemTextJson:\n       Setup: 0s\n First Parse: 0.039s\nLooped Parse: 0.367s (avg: 3.67E-05)\n</code></pre></div>\n\n\n<p>I'll note that neither 'Setup' nor 'First Parse' times are included in the loops (I list them for reference, but don't want to throw off the averages).</p>\n<p>I'm going to figure out the serialization piece next, then port them from the 'basic' pocos over to the Firely models.</p>",
        "id": 210465958,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600387406
    },
    {
        "content": "<p>So that's looking pretty good then!</p>",
        "id": 210468119,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600389610
    },
    {
        "content": "<p>I think I'll definitely be doing that SystemTextJson thing, can't wait to see your generated code...</p>",
        "id": 210468233,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1600389744
    },
    {
        "content": "<p>Yeah, there will be a penalty for creating the more complex objects, but I'm excited to see where it ends up.</p>",
        "id": 210472397,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600394845
    },
    {
        "content": "<p>Would be cool to integrate it in such a way into the existing parser framework that we can run the generated stuff for known resources, and reflection-based code for custom resources.</p>",
        "id": 210790898,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1600717873
    },
    {
        "content": "<p>Maybe the generated parsers can register themselves in some way?</p>",
        "id": 210790922,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1600717897
    },
    {
        "content": "<p>Yeah, I'm still playing with the shape based on the Basic language Poco's right now(different annotation styles, etc.)... trying to get everything both correct and 'nice'.  Once I'm confident I have something that works well, I'll look at how to mirror in the Firely classes and post something as a starting point to review/play with on GH.</p>",
        "id": 210791715,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1600718341
    },
    {
        "content": "<p>Ok, have a pass of everything working with basic Poco's for testing.  The exported R4 files are on <a href=\"https://github.com/microsoft/fhir-codegen/tree/dev/test/perfTestCS/Test\">GitHub</a>.  I tested round-tripping various files from the R4 examples and everything appears to work fine.</p>\n<p>These are bare-bones objects, which obviously do not do the validation that the standard library does, so the performance delta won't be quite as high.</p>\n<p>That said, the parser runs about 7x (Bundle-resources.json) to 21x (Patient-example.json) faster.  Initial parse time is slightly penalized (loading memory), but tends to range from 10ms to 100ms on my box.</p>\n<p>So.. questions/notes:</p>\n<ul>\n<li>The best performance came from complete custom serializers / parsers on each object, but this adds a fair bit of code and compile time.  There's still a good gain from adding annotations directly to each field and letting the serializer/parser figure it out, but the difference was pretty significant..  I am inclined to add in the additional code, but would like other people's opinions.</li>\n<li>I haven't gone through the reflection code (or indeed anything around custom resources) - would the preferred outcome be to enable reflection, or to enable export of the same files?  (e.g., loading the custom resource exports identical files as the core resources)</li>\n<li>Should I be testing in <code>CSharpFirely2</code>, or does this need to be applied to version 1 as well?</li>\n</ul>\n<p>Thanks!</p>",
        "id": 211555052,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601329881
    },
    {
        "content": "<p>Why are the reader and writer <code>ref</code> ?</p>",
        "id": 211559197,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1601332518
    },
    {
        "content": "<p>We'll try to use this in our fork, thanks!</p>",
        "id": 211559228,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1601332545
    },
    {
        "content": "<p>Those Serializer routines, is there actually a need for them to be inside the class, or even have the attributes?<br>\nIt's really just the Converter registration that needs to be done isn't it, along with the class?<br>\nWon't be able to look into it today, but will try get to it later in the week.<br>\nGreat stuff!</p>",
        "id": 211562580,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1601334922
    },
    {
        "content": "<p>A bit tangential, but RC1 of .NET 5 apparently has some improvements to JSON handling, and a new <code>record</code> datatype. Has anyone looked at how that may impact the .NET reference implementation (if at all)?</p>",
        "id": 211566401,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1601337856
    },
    {
        "content": "<p>I don't remember when I started tagging them <code>ref</code>, I'll see if they need to be.</p>",
        "id": 211570078,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601341399
    },
    {
        "content": "<p>I'm planning generating output compatible with the FHIR Net APIs directly - these are using some primitive POCO's so that I could make sure everything actually works as advertised.</p>",
        "id": 211570155,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601341454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191367\">Brian Postlethwaite</span> <a href=\"#narrow/stream/179171-dotnet/topic/.2ENET.20JSON.20Serialization.20Performance/near/211562580\">said</a>:</p>\n<blockquote>\n<p>Those Serializer routines, is there actually a need for them to be inside the class, or even have the attributes?<br>\nIt's really just the Converter registration that needs to be done isn't it, along with the class?<br>\nWon't be able to look into it today, but will try get to it later in the week.<br>\nGreat stuff!</p>\n</blockquote>\n<p>The <code>JsonConverter</code> decoration allows use of the standard System.Text.Json routines on any resource or component.  The only downside is that you want a couple of options for expected behavior, and the current version does not allow for defaults (hence the <code>Serialization.FhirSerializerOptions</code> class).</p>\n<p>You don't need the decorations if you manually apply the converters to the options, but then anyone who <em>doesn't</em> apply those converters get incorrect behavior.</p>\n<p>There's no need for them to be in the classes, it just lined up with the models.  I had static functions on each class at one point, but the traversal code was (IMHO) ugly.</p>",
        "id": 211570509,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601341772
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"192685\">Vassil Peytchev</span> <a href=\"#narrow/stream/179171-dotnet/topic/.2ENET.20JSON.20Serialization.20Performance/near/211566401\">said</a>:</p>\n<blockquote>\n<p>A bit tangential, but RC1 of .NET 5 apparently has some improvements to JSON handling, and a new <code>record</code> datatype. Has anyone looked at how that may impact the .NET reference implementation (if at all)?</p>\n</blockquote>\n<p>Yes.  I was read through <a href=\"https://github.com/dotnet/runtime/issues/41313\">this tracker</a> for core changes, and <a href=\"https://trampster.blogspot.com/2020/09/jsonsrcgen-corert-pure-magic-in-my.html\">this article</a> about using the .Net 5 source generators.  It looks exciting, but I figure that using System.Text.Json is a good step for now and we can revisit once .Net 5 is out in the wild.</p>",
        "id": 211570823,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601342122
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222054\">Gino Canessa</span> <a href=\"#narrow/stream/179171-dotnet/topic/.2ENET.20JSON.20Serialization.20Performance/near/211570078\">said</a>:</p>\n<blockquote>\n<p>I don't remember when I started tagging them <code>ref</code>, I'll see if they need to be.</p>\n</blockquote>\n<p>Ah, the <code>JsonConverter.Read</code> function is <code>ref</code> and since the <code>IFhirJsonSerializable</code> goes back and forth with that function, it needs to be tagged <code>ref</code> as well.</p>",
        "id": 211571021,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601342379
    },
    {
        "content": "<p>The writer doesn't need to be, so I'll change that.</p>",
        "id": 211571099,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601342448
    },
    {
        "content": "<p>If the mark up can make them work, then awesome. Wasn't expecting that due to the way extensions work, and how things are a little wacky due to having to do xml and json on the same model.</p>",
        "id": 211573915,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1601345816
    },
    {
        "content": "<p>Resource.contains and parameters.parameter.resource are 2 fields that if take a close look at in the mapping.<br>\nLooking forward to doing the detailed review <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 211573984,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1601345887
    },
    {
        "content": "<p>Yeah, the markup style can work as long as you write custom converters to handle all the polymorphic stuff (e.g., a common resource converter, etc.).</p>",
        "id": 211622368,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601387103
    },
    {
        "content": "<p>As an implementation note working through the actual fhir-net-api stuff now, the annotation style looks to be more trouble than it's worth.. particularly around converting enums to/from strings (on required-binding fields), you end up doing much of the same code-generation anyway.</p>",
        "id": 211769562,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601476729
    },
    {
        "content": "<p>Blah.  Extended testing edge cases - really should have forced <code>resourceType</code> to be the first property in JSON.  Sorting out, but if you're looking through the code note that it currently fails when <code>resourceType</code> is <em>not</em> the first property.</p>",
        "id": 211797355,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601488499
    },
    {
        "content": "<p>I agree with you there whole heartedly.</p>",
        "id": 211858245,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1601513669
    },
    {
        "content": "<p>Brian: jumping back in time a bit (tinkering brought it back to mind).. putting the functions on the models (and non-static) means I can use an interface to signal compatibility and work with the standard serialize/deserialize functions (e.g., with the generic JsonComponentConverter).</p>\n<p>Should be able to do the same with extensions or partial classes, but joining them means that logic can be inspected alongside the class (e.g., how is it converting strings to enums).</p>",
        "id": 211920259,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601563132
    },
    {
        "content": "<blockquote>\n<p>really should have forced resourceType to be the first property in JSON.</p>\n</blockquote>\n<p>at that point, why not require that all properties be present in-order, just like XML? (I don't like this idea, to be clear -- I think FHIR does the right thing by not attaching semantics or requirements to the order of JSON properties.)</p>",
        "id": 211951802,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1601576261
    },
    {
        "content": "<p>Because without the type hint first, you cannot* implement stream-based parsing.  Since the type information is needed from the models, there's no way to parse a resource until you have the type.</p>\n<p>*Right now I'm dithering between implementing my own cache-based reader (e.g., when the type doesn't come first, queue every token read until we find one, then empty the queue) or disabling the standard parsers, since they are based on forward-only streams.</p>\n<p>Edit: there are other patterns possible, but it comes down to either an extra copy of the values or looping over the data twice (or at least looping over once, building a map, and then parsing it after - either way, the data has to all be read before parsing can actually happen).</p>",
        "id": 211952784,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601576619
    },
    {
        "content": "<p>I'll note that a common pattern to avoid this is to nest everything an extra level with the type-hint outside it:</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span> <span class=\"nt\">\"resourceType\"</span><span class=\"p\">:</span><span class=\"s2\">\"Patient\"</span><span class=\"p\">,</span> <span class=\"nt\">\"id\"</span><span class=\"p\">:</span><span class=\"s2\">\"123\"</span><span class=\"p\">,</span> <span class=\"err\">...</span> <span class=\"p\">}</span>\n</code></pre></div>\n\n<p>becomes</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span> <span class=\"nt\">\"resourceType\"</span><span class=\"p\">:</span><span class=\"s2\">\"Patient\"</span><span class=\"p\">,</span> <span class=\"nt\">\"contents\"</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"nt\">\"id\"</span><span class=\"p\">:</span><span class=\"s2\">\"123\"</span><span class=\"p\">,</span> <span class=\"err\">...</span> <span class=\"p\">}</span> <span class=\"p\">}</span>\n</code></pre></div>",
        "id": 211953493,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1601576933
    },
    {
        "content": "<p>So, getting back to the fun stuff  :-).  I have a pass on the basic version round-tripping with examples, so I've started going through the fhir-net-api specifics to change.</p>\n<p>Unfortunately, I forgot that the FHIR-Net-API exposes parts of the NewtonSoft libraries (e.g., JObject, JsonReader, JsonWriter).  So, while System.Text.Json has better performance, there is no way to keep the API compatible switching to it.</p>\n<p>Generating code to support both likely wouldn't be <em>terrible</em>, but would be 2x the code for each class plus the additional overhead of sorting out which to use at runtime.  My gut is that it isn't worth it.</p>\n<p>So, unless there's something I missed I'm going to work on static functions for NewtonSoft next.  Thoughts?</p>",
        "id": 212750869,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1602192067
    },
    {
        "content": "<p>Question - working through some serialization edge cases (yes, still) and am trying to figure out the 'correct' behavior for the <code>Text</code> and <code>Count</code> summary types.</p>\n<p>Specifically, the MaskingNode settings for those types flag to include all mandatory elements (which makes sense).  However, in playing with <code>Observation-2minute-apgar-score.json</code> from the R4 examples I see two different behaviors:</p>\n<ul>\n<li>if <code>Observation.code.text</code> is present, then the output includes <code>Observation.code</code>.</li>\n<li>if <code>Observation.code.text</code> is removed, then the required element <code>Observation.code</code> is not present.</li>\n</ul>\n<p>Is that the expected / desired behavior?</p>",
        "id": 213971616,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1603223867
    },
    {
        "content": "<p>That really is an edge case. I'd suggest asking that  in the implementers stream, as that's not specific to us. And test what HAPI does there too.</p>",
        "id": 213992127,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1603236735
    },
    {
        "content": "<p>Looking through a bunch of implementations (HAPI, Grahame's server, IBM, etc..), it looks like a <code>fhir-net-api</code> specific issue.  HAPI has some unique behavior (asking on the right stream), but the general implementation is to include all of the element if it's a top-level mandatory element (in any form of summary).</p>\n<p>I'm going to implement that way for now, and it can be reviewed once a full pass is complete.</p>",
        "id": 214094522,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1603305276
    },
    {
        "content": "<p><a href=\"/user_uploads/10155/Y1ByIeWt2Xwez3ixGvpY1F39/image_2021_02_02T06_53_14_902Z-1.png\">image_2021_02_02T06_53_14_902Z-1.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/Y1ByIeWt2Xwez3ixGvpY1F39/image_2021_02_02T06_53_14_902Z-1.png\" title=\"image_2021_02_02T06_53_14_902Z-1.png\"><img src=\"/user_uploads/10155/Y1ByIeWt2Xwez3ixGvpY1F39/image_2021_02_02T06_53_14_902Z-1.png\"></a></div>",
        "id": 224835220,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1612249468
    },
    {
        "content": "<p>Not the json serialization, but have made some great progress with the Xml parser. My XmlDocument code generated one yields around twice as quick as the default, and the XmlReader version is looking a little over 10x faster, though still has a few issues yet.</p>",
        "id": 224835266,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1612249551
    },
    {
        "content": "<p>Nice!</p>",
        "id": 224894327,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1612282708
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> The custom XmlReader based XML Parser is now more or less complete, and have a branch on github, with the parsing error messaging now included, so this resource<br>\n<a href=\"https://github.com/brianpos/fhir-net-web-api/blob/feature/r4-xml-performance/src/Test.WebApi.AspNetCore/TestPatientWithErrors.xml\">https://github.com/brianpos/fhir-net-web-api/blob/feature/r4-xml-performance/src/Test.WebApi.AspNetCore/TestPatientWithErrors.xml</a><br>\nwill produce this OperationOutcome when trying to parse it<br>\n<a href=\"https://sqlonfhir-r4.azurewebsites.net/fhir/OperationOutcome/validation-test?_format=json\">https://sqlonfhir-r4.azurewebsites.net/fhir/OperationOutcome/validation-test?_format=json</a></p>\n<p>Interestingly, when the resource is clean, the validation essentially costs nothing, however when there are errors, the routine is slowed down heaps.<br>\n<a href=\"/user_uploads/10155/1qE4JYQ40vt35t-UnloEaQNv/image.png\">image.png</a> <br>\nWhere the regular Fhir Parser is fast (as it bails on first issue, at the cost of not reporting all the issues)</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/1qE4JYQ40vt35t-UnloEaQNv/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/1qE4JYQ40vt35t-UnloEaQNv/image.png\"></a></div>",
        "id": 227148550,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1613891003
    }
]