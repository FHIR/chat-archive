[
    {
        "content": "<p>Hi all,</p>\n<p>Using the .NET Validator I now get the message: </p>\n<div class=\"codehilite\"><pre><span></span>    [ERROR] Profile xyz does not include a snapshot.\n</pre></div>\n\n\n<p>I have tried teh following Validationsettings:</p>\n<div class=\"codehilite\"><pre><span></span>            ValidationSettings ctx = new ValidationSettings()\n            {\n                ResourceResolver = sResourceresolver,\n                GenerateSnapshot = true,\n                EnableXsdValidation = true,\n                Trace = false,\n                ResolveExteralReferences = true,\n            };\n</pre></div>\n\n\n<p>Also with  the additional </p>\n<div class=\"codehilite\"><pre><span></span>   GenerateSnapshotSettings = new Hl7.Fhir.Specification.Snapshot.SnapshotGeneratorSettings() { \n    GenerateSnapshotForExternalProfiles = true }\n</pre></div>\n\n\n<p>the error persists.</p>\n<p>So is the rule that each profile always includes the snapshot, or is there a way to make the Validator generate the Snapshots itself?</p>",
        "id": 153897051,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1500290763
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"192814\">@Theo Stolker</span>, please make sure that you are using a <em>CachedResourceResolver</em>, so  the generated snapshots are actually persisted.</p>",
        "id": 153897053,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1500291386
    },
    {
        "content": "<p>By default, the resolvers create and return a new object instance on each request. Use a wrapping CachedResourceResolver in order to persist all resolved resources in memory.</p>",
        "id": 153897055,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1500291497
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> , I am using that:</p>\n<div class=\"codehilite\"><pre><span></span>            sResourceresolver = new CachedResolver(\n                new MultiResolver(\n                    new DirectorySource(@&quot;...\\specification&quot;),\n                    new DirectorySource(@&quot;...\\StructureDefinition&quot;, true)\n                    )\n                );\n</pre></div>\n\n\n<p>Should that work as well, having the Multiresolver output cached?</p>\n<p>The StructureDefinition it complains about is in the second directory.</p>",
        "id": 153897056,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1500291618
    },
    {
        "content": "<p>That should work...?</p>",
        "id": 153897057,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1500291748
    },
    {
        "content": "<p>I guess I know what's the problem, there is a missing part it needs for generating the snapshot. Let me first fix that one.</p>",
        "id": 153897058,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1500292335
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191336\">@Michel Rutten</span> , that indeed solved the problem!</p>\n<p>A related question is: Can I Enumerate over all resources that I have found using a CachedResolver? I would like to offer a dropdown in the UI, e.g. for all available StructureDefinitions or OperationDefinitions when editing a CapabilityStatement. I do not see an enumeration interface on the Resolvers...</p>",
        "id": 153897192,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1500369191
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"192814\">@Theo Stolker</span>, the API provides a separate IConformanceSource interface that allows enumeration. The DirectorySource class implements this interface. So you can enumerate the wrapped DirectorySource itself, but not the CachedResolver wrapper.</p>",
        "id": 153897193,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1500370614
    },
    {
        "content": "<p>(motivation: you can also wrap a CachedResolver around a source that is not enumerable, e.g. an online source).</p>",
        "id": 153897194,
        "sender_full_name": "Michel Rutten",
        "timestamp": 1500370651
    },
    {
        "content": "<p>Great, thanks!!!</p>",
        "id": 153897195,
        "sender_full_name": "Theo Stolker",
        "timestamp": 1500370700
    }
]