[
    {
        "content": "<p>Hi, <br>\nI am currently in a discussion with a security expert of my team that is new to FHIR. He is wondering why in FHIR there are so many fields with an infintie cardinality (like 0..* or 1..*). His argumentation is that any data structure allowing infinite entries is a potential security risk or potential attack vector for at least DOS attacks or XML bombs.<br>\nI was trying to mention that in my opinion these security risk have to be handled on application level (or server in that case) but not on the semantic level (like FHIR). I couldn't fully convince him as we were looking at a resource having a name field whereas it would be allowed to have 1..* first names. Obviously no one is having an infinite list of first names, or to be more on the medically reasonable level: no one would ever have an infinite number of diagnoses.<br>\nI wasn't able to give him proper argumentation to not artificially restrict the cardinality on FHIR level and therefore like to ask you: Do you know of any risks or attack vectors related to an infinite cardinality in FHIR? Or do you know if discussion on this topic can be found somewhere else?</p>\n<p>Any help is appreciated. I mean, could he also be right? And when it comes down to profiling resources for certain use cases we should always aim to get rid of an infinite cardinality?</p>",
        "id": 255690051,
        "sender_full_name": "Peter Osburg",
        "timestamp": 1633064068
    },
    {
        "content": "<p>well, obviously no system is going to support infinite anything.</p>",
        "id": 255690097,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633064123
    },
    {
        "content": "<p>so infinite means, defer to system judgment. Clearly a system should protect itself against denial of service attacks.</p>",
        "id": 255690157,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633064165
    },
    {
        "content": "<p>he sounds like a good security guy: obsessed about everything. But the standard won't solve that particular problem for him</p>",
        "id": 255690183,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1633064192
    },
    {
        "content": "<p>Thx for the compliment :)<br>\nBut am I reading you correctly that you would not suggest to artificially restrict the upper limits while creating profiles for certain use cases?</p>",
        "id": 255690582,
        "sender_full_name": "Peter Osburg",
        "timestamp": 1633064502
    },
    {
        "content": "<p>If you're defining a profile for a specific system that has particular limitations, or you've got community agreement that \"We will not support more than 5 given names for a person\", you <em>could</em> specify a max.  However, specifying maxes in many places interferes with interoperability.  If you set a max of 2 given names, and some real person has 5 and a sending system needs to send all 5 because other recipients want and need all 5, they're suddenly faced with building a separate interface for your system that blows up if there's more than two.  On the other hand, if you create a profile with a sanity max of 100, then everyone panics about the fact you said they need to support up to 100 given names (and some certifier out there will probably try to fail you if you don't display all 100).  </p>\n<p>General guidance is \"accept what you can handle, don't blow up if there's more than you need if it's safe to ignore the extras, and protect yourself against whatever you deem to be a dangerous quantity.\"  (Dangerous for a smartphone app might be different than a back-end server.)</p>",
        "id": 255691165,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1633064996
    },
    {
        "content": "<p>All of this is well-known in the security community as \"Robustness Principle\". Any system design will make decisions on upper limits, and they need to be defensive against attacks to that upper limit. Some will choose a hard integer, others will choose a buffer-space limit. It is a system-design choice on how one is Robust.</p>",
        "id": 255755515,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633099566
    },
    {
        "content": "<p>Your security expert is right to point this out. I would simply leverage this point into Systems-Design discussions.<br>\nSee point #11 on the security page - <a href=\"http://hl7.org/fhir/security.html\">http://hl7.org/fhir/security.html</a></p>",
        "id": 255755705,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633099660
    },
    {
        "content": "<p>FHIR as a core-standard is simply a standard. As Lloyd and Grahame have expressed, any upper limit we place will have equal negative reactions (that is too big, that is too small). The only way to get this right in a core-standard is to leave it unbounded and encourage good Implementation Guide considerations, and good systems-design.</p>",
        "id": 255755957,
        "sender_full_name": "John Moehrke",
        "timestamp": 1633099765
    },
    {
        "content": "<p>I'd expect that the limitation is not in the single element cardinality (usually) but in the message (or request/response) size as a whole instead. Which is set at the infrastructure layer.</p>",
        "id": 255982901,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1633298370
    }
]