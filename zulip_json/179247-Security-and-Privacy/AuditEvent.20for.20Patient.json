[
    {
        "content": "<p>I have noticed that in FHIR we have not made clear a rule that we have had in IHE for 15 years. That rule is that when recording any security / privacy relevant event, WHEN YOU KNOW the patient identity, include the patient identity as another .entity. This rule has \"when you know\" because there are plenty of times that you don't know. But when doing operations on patient relevant resources in FHIR the patient id is right there in the patient relevant resource (e.g. Observation.subject), or clear on query where a ?patient parameter is used...   Thus the existance of an .entiity of the Patient becomes a required-if-known.  If we did that, then the AuditEvents would show up in the patient compartment, and be more easy to find.<br>\nSeems we should have a profile in the core specification on AuditEvent to define this... right?</p>",
        "id": 174505610,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567125894
    },
    {
        "content": "<p>Patient as a user -- note that accesses by the patient would all be audited with the patient's user identity in the auditEvent.agent; so these are all fully covered and the situation context is understood.   It is possible that their delegated agent might also be understood...</p>",
        "id": 174541372,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567169877
    },
    {
        "content": "<p>We do record the patient being accessed in our audit - and the audit is searchable by patient<br>\nNot sure about a profile: how (and which) event are recorded does not seem something a FHIR profile could specify</p>",
        "id": 174541694,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1567170101
    },
    {
        "content": "<p>Query/Search/Operations -- these are not fully covered in a simple \"reasonable effort\" rule, so might need special handling that is not today recommended in IHE (often). In IHE a query/search or operation are just logged as an Execute with the parameters encoded. with an exception where the query specifically identifies the patient. So the cases that are not covered are those search/query/operations where there is not a patient identified in the request. This is seen as a gap caused by it being too hard to properly handle the result. This gap is not a problem when the audit analysis is occasional deep inspection (user is suspected of bad behavior, patient complains of bad behavior, malpractice suit needs evidence, law asks for specific evidence); these cases can re-create the results. The problem is that this solution does not work well for Patient Access/Accounting of Disclosures function.  The solution is to tell the server audit logging agent to wait until the response is known, then iterate through the response for all indications of patient(s). In these cases one needs to log as many auditEvent records as there were patients exposed in that one search/query/operation. This is done in a few cases in IHE that were seen as specifically Privacy problems, and we could leave this to specific FHIR IG too.  The need to make many audit events is because of the privacy use-case.</p>",
        "id": 174542261,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567170430
    },
    {
        "content": "<blockquote>\n<p>We do record the patient being accessed in our audit - and the audit is searchable by patient<br>\nNot sure about a profile: how (and which) event are recorded does not seem something a FHIR profile could specify</p>\n</blockquote>\n<p>Im just wondering how to drive everyone to include the patient when they can... vs today where it is not said, and thus I have found audit logs with no patient.. and because there is no patient, then the patient user can't see those audit logs.. so looking for a mechanism to drive better logging. So I think the profile would simply be a generic AuditEvent that has a .entity that is a Patient with the entity.role of \"1\" - Patient</p>",
        "id": 174542543,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567170653
    },
    {
        "content": "<p>Only some AuditEvent in a system could match such a profile though . . .so what would be gained to create it?</p>",
        "id": 174543009,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1567171011
    },
    {
        "content": "<p>true statement, but isn't that true about all profiles? The point of a profile is not always to tag compliant or tag non-compliant; but rather to set a good pattern that is highly encouraged to follow...</p>",
        "id": 174543124,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567171116
    },
    {
        "content": "<p>the easy solution is to add a section to the AuditEvent narrative (like 6.4.4.7 - Identify Patient whenever possible). Add the above explanation and exceptions. -- hopefully others help with that text.</p>",
        "id": 174543307,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567171260
    },
    {
        "content": "<p>Note that this solution would also solve a problem identified that the Patient \"Compartment\" doesn't include the AuditEvent records...</p>",
        "id": 174544061,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567171753
    },
    {
        "content": "<p>But mostly this will enable a Privacy Empowering feature of knowing where and when your data is used. <br>\n<a href=\"https://healthcaresecprivacy.blogspot.com/2019/06/patient-engagement-access-log.html\" target=\"_blank\" title=\"https://healthcaresecprivacy.blogspot.com/2019/06/patient-engagement-access-log.html\">https://healthcaresecprivacy.blogspot.com/2019/06/patient-engagement-access-log.html</a></p>",
        "id": 174544175,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567171804
    },
    {
        "content": "<blockquote>\n<p>but isn't that true about all profiles?</p>\n</blockquote>\n<p>Uh, no? The way I always understood it is that if a server complies with a profile for a specific resource all instances of that resource must conform to that profile</p>",
        "id": 174544809,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1567172213
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>but isn't that true about all profiles?</p>\n</blockquote>\n<p>Uh, no? The way I always understood it is that if a server complies with a profile for a specific resource all instances of that resource must conform to that profile</p>\n</blockquote>\n<p>there are those religions.. but too far off the audit event topic</p>",
        "id": 174544971,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567172311
    },
    {
        "content": "<p>Note that this proposal to add patient entity to auditEvent records is independent of the decision to make auditEvent records available to the Patient. I think they should be available to the Patient, but THIS thread is more about getting useful AuditEvent records. The addition of a Patient entity, where ever possible, enhances all use-cases for AuditEvent and not just Patient access.</p>",
        "id": 174555773,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567179512
    },
    {
        "content": "<p>I do not think that this is something that the core specification should rule on, but it is something it can describe and make suggestions about.</p>",
        "id": 174587254,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567203694
    },
    {
        "content": "<p>I will update my server but I'm having trouble imagining how to decide which operations to match to a patient when more than one patient is in scope for an operation</p>",
        "id": 174587307,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567203743
    },
    {
        "content": "<p>otoh, production servers, where the audit logs are driven off decisions lower down in the system than the FHIR API would not generally have this problem... right?</p>",
        "id": 174587335,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567203776
    },
    {
        "content": "<p>For transactions that return potentially different patients, you wait to log based on the results. Oh, and best to log one entry for every patient.</p>",
        "id": 174596403,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567216837
    },
    {
        "content": "<p>Created <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=23835\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=23835\">GF#23835</a> - likely to discuss on the FHIR Security call today.</p>",
        "id": 174796735,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567522818
    },
    {
        "content": "<p>any update?</p>",
        "id": 174821582,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567539040
    },
    {
        "content": "<blockquote>\n<p>Created <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=23835\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=23835\">GF#23835</a> - likely to discuss on the FHIR Security call today.</p>\n</blockquote>\n<p>security wg approved</p>",
        "id": 174822803,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567540035
    },
    {
        "content": "<p>ok so I've just been looking at this. Some decisions for <a href=\"http://test.fhir.org\" target=\"_blank\" title=\"http://test.fhir.org\">test.fhir.org</a>: </p>\n<ul>\n<li>I'm not logging the fact that a patient result was included in a search unless the resource was actually returned to the client (e.g. based on paging)</li>\n<li>it's a big hit on my search performance since I now actually have to process the object (can't send out pre-prepared byte streams without parsing)  (that's an implementation issue specific to me)</li>\n<li>I'm not logging transactions and batches; I already log the individual operations in them, so patients won't see the transaction/batch </li>\n<li>I am logging hits on the history too, but I think that must patients won't see that</li>\n</ul>",
        "id": 174849388,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567569517
    },
    {
        "content": "<p>what a patient won't see is which resources were returned in search/history</p>",
        "id": 174849398,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567569544
    },
    {
        "content": "<p>also: i do not know how to log a history response that includes a deleted patient record against the patient for the deleted record because I no longer know which patient  the deleted record used to reference before it was deleted</p>",
        "id": 174851310,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567572736
    },
    {
        "content": "<blockquote>\n<p>also: i do not know how to log a history response that includes a deleted patient record against the patient for the deleted record because I no longer know which patient  the deleted record used to reference before it was deleted</p>\n</blockquote>\n<p>in the case of Delete, wouldn't you capture the Patient being affected prior to the delete? Yes you would still need to wait to log until you knew success/failure... Given this is obvious, I am wondering what I a am missing. Or is this just code workflow that gets in your way?</p>",
        "id": 174907604,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567621119
    },
    {
        "content": "<blockquote>\n<p>what a patient won't see is which resources were returned in search/history</p>\n</blockquote>\n<p>correct. The results of query/search/operation are not logged. just the parameters of the request; but this new guidance does ask that an audit event is recorded with an .entity of the patient affected.</p>",
        "id": 174907674,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567621184
    },
    {
        "content": "<blockquote>\n<p>I'm not logging the fact that a patient result was included in a search unless the resource was actually returned to the client (e.g. based on paging)<br>\nah, I guess it is privacy best-practice to record that they asked, even if no results were found... But I do understand the technical approach of only looking at results. These two alternatives are likely correct for different environments... I hate to always fall back to \"policy\", aka configurable.</p>\n</blockquote>",
        "id": 174907889,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567621326
    },
    {
        "content": "<blockquote>\n<p>in the case of Delete, wouldn't you capture the Patient being affected prior to the delete?</p>\n</blockquote>\n<p>yes, that's what I do. But if then, later, someone syncs using a history request and is informed that this resource has been deleted, I can no longer link that to the patient since I no longer know what the resource said</p>",
        "id": 174920226,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567629195
    },
    {
        "content": "<p>what response would you give to that request? would that not include the old Patient version? And thus, have the id?   <br>\nNot sure this is all that realistic, but thanks for the detail</p>",
        "id": 174936863,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567646380
    },
    {
        "content": "<p>to the history request? the deleted resource will look something like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nt\">&lt;entry&gt;</span>\n    <span class=\"nt\">&lt;request&gt;</span>\n      <span class=\"nt\">&lt;method</span> <span class=\"na\">value=</span><span class=\"s\">&quot;DELETE&quot;</span><span class=\"nt\">/&gt;</span>\n      <span class=\"nt\">&lt;url</span> <span class=\"na\">value=</span><span class=\"s\">&quot;observation/2123123&quot;</span><span class=\"nt\">/&gt;</span>\n    <span class=\"nt\">&lt;/request&gt;</span>\n    <span class=\"nt\">&lt;response&gt;</span>\n      <span class=\"nt\">&lt;lastModified</span> <span class=\"na\">value=</span><span class=\"s\">&quot;2014-08-20T11:05:34.174Z&quot;</span><span class=\"nt\">/&gt;</span>\n    <span class=\"nt\">&lt;/response&gt;</span>\n  <span class=\"nt\">&lt;/entry&gt;</span>\n</pre></div>\n\n\n<p>There's no resource, and my server no longer has the link to the patient. The system getting the history only gets the note that the resource that used to exist no longer does</p>",
        "id": 174937460,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567647359
    },
    {
        "content": "<p>well, that doesn't look like it is exposing data, so that reason for logging is not present. It is however that someone is 'trying' to get at the data, which is interesting to privacy or security office. I suspect simply logging the request is sufficient. Makes me wonder how you would indicate it was a request for something that has been deleted. Not exactly success, nor failure. I guess you could use \"Minor Failure\", although the description for that is that it is like 4xx responses. Is there OperationOutcome encoding?</p>",
        "id": 174976917,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567692586
    },
    {
        "content": "<p>what I am trying to define is how this gets logged such that a security office audit of the logs would see this 'unusual' interaction, as potential attack.</p>",
        "id": 174977229,
        "sender_full_name": "John Moehrke",
        "timestamp": 1567692782
    },
    {
        "content": "<p>this is <em>not</em> unusual. This is an inevitable consequence of the history operation - you might listen to a resource type. It's a request that says 'let me know of all changes to Observation since X' where X is the time from the header last time I made the request. You get all added / updated resources, and a note about any deleted resources so you know to delete them too. But all you get is the id of the deleted resource, so you can find it and delete it. </p>\n<p>In this case, the patient audit trail will note that the resource was sent in a history when the history picks up it's creation/update, but won't when the history picks up the fact that it was deleted</p>",
        "id": 175011364,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567714991
    },
    {
        "content": "<p>ok I upgraded my server so it implements all this (I hope). Please play with it and let me know how it goes</p>",
        "id": 175037057,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1567748015
    },
    {
        "content": "<p>I have drafted an IG on Basic Audit for REST operations. I welcome review, comments, discussion, and help. This is not a sanctioned project anywhere, it is my own effort, which I also welcome interest in making it more formal. <br>\n<a href=\"http://build.fhir.org/ig/JohnMoehrke/BasicAudit/branches/main/index.html\">http://build.fhir.org/ig/JohnMoehrke/BasicAudit/branches/main/index.html</a></p>",
        "id": 225021533,
        "sender_full_name": "John Moehrke",
        "timestamp": 1612362117
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> and <span class=\"user-mention\" data-user-id=\"191319\">@James Agnew</span> I would be interested in your comments relative to the support your reference implementations include.</p>",
        "id": 225021636,
        "sender_full_name": "John Moehrke",
        "timestamp": 1612362149
    },
    {
        "content": "<p>cool, thanks for sharing.  one thing i've always wondering is whether we should enumerate the specific resource that come back from a given search.  this seems to stop short of that and instead just documents which patients had resources that were returned by the search, right?</p>",
        "id": 225062126,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1612378110
    },
    {
        "content": "<p>correct. a AuditEvent for a Query event just records the query that it responded to, with success vs failure. The presumption is that the results are deterministic, and could be re-created historically if needed. That the query parameters are far more important.  </p>\n<p>There are some proposals to include some request id that is internally useful, or possibly a response id. </p>\n<p>Given REST, I could see an advanced version that enumerates just the id values of the resources returned. </p>\n<p>But certainly shall NOT replicate in the audit log the resources that were returned. Otherwise your audit log becomes a huge replication upon replication of your database. And further the audit log would then become very sensitive.</p>\n<p>I should explain this.. Ill add a TODO to explain this.</p>",
        "id": 225065757,
        "sender_full_name": "John Moehrke",
        "timestamp": 1612379568
    },
    {
        "content": "<blockquote>\n<p>The presumption is that the results are deterministic, and could be re-created historically if needed</p>\n</blockquote>\n<p>I wonder if this presumes too much.  The deterministic piece seems reasonable, but historically-accurate search requires something like time-travel query which not all datastores support, right?</p>\n<blockquote>\n<p>But certainly shall NOT replicate in the audit log the resources that were returned</p>\n</blockquote>\n<p>for sure</p>\n<blockquote>\n<p>Given REST, I could see an advanced version that enumerates just the id values of the resources returned.</p>\n</blockquote>\n<p>i was thinking resource type + id + version for each resource in the page that was retrieved</p>",
        "id": 225070168,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1612381289
    },
    {
        "content": "<p>maybe not needed for all use cases, but would make it much easier to answer questions like \"who/what/when accessed resource xyz in a given period\"</p>",
        "id": 225070373,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1612381372
    },
    {
        "content": "<p>Looking at this now <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span>:</p>\n<ul>\n<li>agree about type/subtype. </li>\n<li>weird to fix the outcount to 0. I might return 4 or 8 in cases of error</li>\n<li>isn't the server the source? what goes in source if server is an agent? (I'm using source)</li>\n<li>I don't have a device for the server. What would it say? </li>\n<li>and what's the network location for the server? it's public IP? which ?</li>\n<li>The server is quite likely not going to have a resource that describes the client. At a minimum, I will have an IP address. I may have an openID connect url if I used OAuth to identify the client - but no, you split that out to a different agent, so all I'll have for the client is an IP address, and possibly a secret that implies a software id </li>\n<li>the human - again, I may have an openIDConnect id, I may have a name, I may have an email address</li>\n<li>is it reasonable to fix the human to requester = true? how would the server know?</li>\n<li>you can't fix the cardinality of a the patient slice it 1..1 - there may not be a patient in context</li>\n</ul>",
        "id": 225254160,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612492581
    },
    {
        "content": "<p>Thanks for the comments <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> </p>\n<ul>\n<li>I only profiled success. I stated this in the sushi, but forgot to bring that forward in narrative. Errors would be reported as normal errors would be reported, I can add them. Is there specific errors ? I don't want to profile all possible errors.</li>\n<li>The server is the source, when the server is the one detecting and reporting the audit event. But the client can also record an audit event, and I would encourage the clients to also record the audit events. The reason is that it creates a pattern that  can be watched and deviations flagged for followup. Such as when the client stops recording an audit log, is likely a case where the client credentials have been stolen. You would notice this far sooner when both parties are recording. </li>\n<li>The Device resource just seems the closest thing , from the possible agents, that we have to a resource for identifying an app or a server. I imagine it is just described in terms of the identifier. Thus the degenerate form is to use who.identifier. I didn't go into all of these as they are generic auditEvent use, not specific to REST operations when a Patient is a subject.</li>\n<li>network can be the domain name, it does not need to be IP.</li>\n<li>I am fixing the patient to 1..1 because I am only profiling REST operations that involve a patient as the subject.</li>\n</ul>",
        "id": 225288206,
        "sender_full_name": "John Moehrke",
        "timestamp": 1612525249
    },
    {
        "content": "<p>I think that we certainly don't to profile all errors, but we do want to provide guidance around errors. In my server I have 3 kinds of errors - definitely client errors, definitely server errors, and unexpected errors (I'm not sure about). I log these 3 kinds differently in the AuditEvent</p>",
        "id": 225349367,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612555497
    },
    {
        "content": "<p>do we need different profiles for server and client?</p>",
        "id": 225349427,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612555530
    },
    {
        "content": "<p>In theory the difference between a client recording and a server recording the same fact is simply that the .source is different. All the other information would be profiled the same for both..   In fact something I should have included is that these AuditEvents could also be recorded by the OAuth authorization service. Thus in FHIR one might have three AuditEvents for the same event, although given OAuth token re-use this is likely to not be one-for-one, but would be visible over a session. I should add this?</p>",
        "id": 225541805,
        "sender_full_name": "John Moehrke",
        "timestamp": 1612790080
    },
    {
        "content": "<p>Client v Server logging is likely to be different in practice. When success happens, they are closest, but the client might know more about the reason the transaction was requested, like the context within an episode of care or care plan. Information that is not needed in the FHIR REST interaction. This could be put into the one AuditEvent from the client.   When failures happen, the client is at a disadvantage, the server is more likely to be able to elaborate on the detail.</p>",
        "id": 225542231,
        "sender_full_name": "John Moehrke",
        "timestamp": 1612790287
    },
    {
        "content": "<p>I am not sure if these differences are specific enough to end up in a Profile.</p>",
        "id": 225542287,
        "sender_full_name": "John Moehrke",
        "timestamp": 1612790321
    },
    {
        "content": "<p>IHE has historically defined both client and server audit messages. But these are in the context of the audit requirements given some other transaction (e.g. XDS Query). Thus the goal is to profile the AuditEvent more tightly to the expectations of that other transaction context. I think this kind of specialization will happen.</p>",
        "id": 225542763,
        "sender_full_name": "John Moehrke",
        "timestamp": 1612790549
    },
    {
        "content": "<p>On errors... I would like to start cataloging common errors and the resulting AuditEvent. I think that catalog might drive the profiling methods. I could see an IG that does nothing but profile this error catalog. No one would declare conformance to that IG. But other IGs could pull the profiled AuditEvents from this IG.</p>",
        "id": 225543033,
        "sender_full_name": "John Moehrke",
        "timestamp": 1612790676
    },
    {
        "content": "<p>i was talking about the difference between client caused error and server caused error there</p>",
        "id": 225620020,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1612823940
    },
    {
        "content": "<p>okay, then yes... when I get to errors there will likely be different groups of errors typical for clients and others typical for servers.</p>",
        "id": 225627075,
        "sender_full_name": "John Moehrke",
        "timestamp": 1612828520
    }
]