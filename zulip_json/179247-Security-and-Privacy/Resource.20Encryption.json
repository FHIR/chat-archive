[
    {
        "content": "<p>I've been doing a lot of research on resource-level encryption without much success, so I'd like to pose a question to this group.  The requirements are encryption of individual resources within a FHIR payload for delivery via proxies or distributions that may otherwise inspect unencrypted resources within the payload (e.g. <code>MessageHeader</code>).  Encryption is performed with pre-shared keys among FHIR servers, and payloads may contain a single resource from a single server or a bundle of resources from multiple servers (in the case of a distribution), each resource potentially encrypted using different keys and methods.</p>\n<p>I've seen mention of using the <code>Binary</code> resource type - however this would require custom functionality by both the sending and receiving server, but may provide a short-term solution.  I've also seen talk of using multipart MIME headers, however this seems even further from interoperability standards.</p>\n<p>Any guidance would be greatly appreciated.</p>",
        "id": 214975630,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1603982576
    },
    {
        "content": "<p>You are in advanced space that the FHIR community has not addressed.</p>",
        "id": 214987433,
        "sender_full_name": "John Moehrke",
        "timestamp": 1603986977
    },
    {
        "content": "<p>I would recommend you look at using transport standards that support this kind of end-to-end + multipart security, S/MIME comes to mind, as does SOAP+XML-Encryption.</p>",
        "id": 214987550,
        "sender_full_name": "John Moehrke",
        "timestamp": 1603987026
    },
    {
        "content": "<p>There is no mechanism, that I know of, where a Bundle is defined as having independently encrypted Resources. This is not beyond where we might go. It is just that the majority of people are working on far more simple point-to-point (aka https/RESTful) interactions.</p>",
        "id": 214987805,
        "sender_full_name": "John Moehrke",
        "timestamp": 1603987119
    },
    {
        "content": "<p>Even if a Bundle was to be enhanced to support this, I would want it to leverage XML-Encryption or JWE containers as the mechanism within the Bundle. Thus your outer Bundle is made up of resources you want the intermediary to see (MessageHeader) and 1..* Binary. Where the Binary.contentType holds the mime-type for XML-Encryption or JWE encryption as appropriate for the Bundle encoding; and the <a href=\"http://Binary.data\">Binary.data</a> holds the encrypted blob conforming to that standard. Inside the encrypted blob , once appropriately decrypted, is the contained Resource.   The XML-Encryption standard supports the administrative sugar needed. Not clear that JWE does, im just not that aware of JWE.  There would need to be some agreement on the end-to-end key-tryst. Not clear to me what more needs to be done.</p>",
        "id": 214989051,
        "sender_full_name": "John Moehrke",
        "timestamp": 1603987555
    },
    {
        "content": "<p>I think the Bundle approach did not really launch. We thought of doing that but we abandoned it.</p>",
        "id": 214989399,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1603987686
    },
    {
        "content": "<p>Excellent feedback <span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span> , so what did you do?</p>",
        "id": 214989682,
        "sender_full_name": "John Moehrke",
        "timestamp": 1603987801
    },
    {
        "content": "<p>I will ping the security experts, because I could not understand what they had.</p>",
        "id": 214991512,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1603988554
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"195699\">@Nick Hermans</span> do you know?</p>",
        "id": 214991552,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1603988570
    },
    {
        "content": "<p>there is the EC approved AS4 (which is a profile of SOAP+XML-Encryption+XML-Signature+SAML)... no reason why REST actions can be the ONLY actions allowed in the SOAP. Thus you are using RESTful SOAP (can't find a spec, no surprise as this is mixing religions).</p>",
        "id": 214993364,
        "sender_full_name": "John Moehrke",
        "timestamp": 1603989320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191832\">@Jose Costa Teixeira</span>  are you asking about the details on how the resources would be (besides the transport layer) encrypted or how we exchange public keys between parties?</p>",
        "id": 214993924,
        "sender_full_name": "Nick Hermans",
        "timestamp": 1603989597
    },
    {
        "content": "<p>Depending on your use case, might also look at some of the nascent community efforts like <a href=\"https://github.com/decentralized-identity/didcomm-messaging\">https://github.com/decentralized-identity/didcomm-messaging</a> for general-purpose distribution of encrypted/authenticated messages.</p>",
        "id": 214995002,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1603990090
    },
    {
        "content": "<p>Soap encryption and encrypted mime parts could work, but I think they couple encryption to the transport layer more than the application layer (message level).  Is that really ideal?  Just reading about  xml encryption syntax <a href=\"https://www.w3.org/TR/xmlenc-core/\">https://www.w3.org/TR/xmlenc-core/</a> and an RFC for JSON object signing and encryption. <a href=\"https://tools.ietf.org/html/rfc7520\">https://tools.ietf.org/html/rfc7520</a>.  These look like they would allow encryption of xml fragments and json fragments. So you could in theory encrypt the resource element of a bundle entry.  As <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> mentioned JSON Web Encryption, also known as JWE, is another Internet standard of the IETF and is defined in RFC7516 <a href=\"https://tools.ietf.org/html/rfc7516\">https://tools.ietf.org/html/rfc7516</a> might work.  I'm not sure if the JSON standards allow for fragments to be encrypted like xml encryption does, or if they require the entire object to be encrypted.</p>",
        "id": 214997215,
        "sender_full_name": "Jeremy Chapman",
        "timestamp": 1603991032
    },
    {
        "content": "<p>The only think I didn't like about the message level encryption is the bloat from base64 encoded data</p>",
        "id": 214997326,
        "sender_full_name": "Jeremy Chapman",
        "timestamp": 1603991058
    },
    {
        "content": "<p>The real issue with doing this in Bundle is bdl-5, which requires that resource be present if you don't have entry.request or entry.response - which means documents, messages, etc.  If we didn't have that constraint, we could theoretically have an extension that conveyed an encrypted view of the resource rather than the resource itself.  I don't think we could relax that at this point, but we <em>might</em> be able to add new bundle types - e.g. \"secured-message\" and introduce a new entry.encryptedResource or something like that.  The first step in doing something like this would be writing up an approach and finding a group of people who wanted to play with it at connectathon.  We could then considering introducing it in a future FHIR release.</p>",
        "id": 215002531,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1603993247
    },
    {
        "content": "<p>So are you saying that having something like the following example does not meet the constraints of a bundle?   And also, with your idea of secured-message and an entry.encryptedResource would an encrypted resource use an existing standard like xmlenc-core or would it choose something that isn't coupled to the payload content-type (xml vs json, etc).</p>\n<p>&lt;Bundle xmlns=\"<a href=\"http://hl7.org/fhir\">http://hl7.org/fhir</a>\"&gt;<br>\n    &lt;type value=\"message\"/&gt;<br>\n    &lt;entry&gt;<br>\n        &lt;fullUrl value=\"urn:uuid:e969238e-3044-470f-835c-5646c8d6bf50\"/&gt;<br>\n        &lt;resource&gt;<br>\n            &lt;MessageHeader&gt;<br>\n                &lt;destination&gt;<br>\n                    &lt;name value=\"Acme Message Gateway\"/&gt;<br>\n                    &lt;target&gt;<br>\n                        &lt;reference value=\"Device/example\"/&gt;<br>\n                    &lt;/target&gt;<br>\n                &lt;/destination&gt;<br>\n                &lt;sender&gt;<br>\n                    &lt;reference value=\"urn:uuid:e969238e-3044-470f-835c-5646c8d6bf50/Practitioner/sending\"/&gt;<br>\n                &lt;/sender&gt;<br>\n                &lt;source&gt;<br>\n                    &lt;endpoint value=\"dgf\"&gt;<br>\n                    &lt;/endpoint&gt;<br>\n                &lt;/source&gt;<br>\n                &lt;focus&gt;<br>\n                    &lt;reference value=\"urn:uuid:e969238e-3044-470f-835c-5646c8d6bf50/Patient/example\"/&gt;<br>\n                &lt;/focus&gt;<br>\n            &lt;/MessageHeader&gt;<br>\n        &lt;/resource&gt;<br>\n    &lt;/entry&gt;<br>\n    &lt;entry&gt;<br>\n        &lt;fullUrl value=\"urn:uuid:e969238e-3044-470f-835c-5646c8d6bf50/Practitioner/sending\"/&gt;<br>\n        &lt;resource&gt;<br>\n            &lt;Practitioner&gt;<br>\n                &lt;EncryptedData Type=\"<a href=\"http://www.w3.org/2001/04/xmlenc#Element\">http://www.w3.org/2001/04/xmlenc#Element</a>\"<br>\nxmlns=\"<a href=\"http://www.w3.org/2001/04/xmlenc\">http://www.w3.org/2001/04/xmlenc#</a>\"&gt;<br>\n                    &lt;CipherData&gt;<br>\n                        &lt;CipherValue&gt;A23B45C56&lt;/CipherValue&gt;<br>\n                    &lt;/CipherData&gt;<br>\n                &lt;/EncryptedData&gt;<br>\n            &lt;/Practitioner&gt;<br>\n        &lt;/resource&gt;<br>\n    &lt;/entry&gt;<br>\n&lt;/Bundle&gt;</p>",
        "id": 215009246,
        "sender_full_name": "Jeremy Chapman",
        "timestamp": 1603996277
    },
    {
        "content": "<p>Yup, that's definitely not conformant.  \"EncryptedData\" is not an allowed data element in Practitioner.  In principle, you could put an extension <em>inside</em> Practitioner that conveyed the encrypted content, but you'd still have to satisfy all mandatory elements and invariants on the Practitioner resource (or any other resource)</p>",
        "id": 215010790,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1603997119
    },
    {
        "content": "<p>As for how we'd encrypt the content, that'd be up to the group having the discussion :)</p>",
        "id": 215010868,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1603997162
    },
    {
        "content": "<p>hence why I suggested Binary be the container for the encrypted blob, where the encrypted blob is the container of the Resource</p>",
        "id": 215016121,
        "sender_full_name": "John Moehrke",
        "timestamp": 1603999617
    },
    {
        "content": "<p>Re: bundle requirements, <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> does a resource element with an extension (and no actual resource) not count as \"present\" ?</p>",
        "id": 215019608,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1604001433
    },
    {
        "content": "<p>I'm always confused on this; I know you can satisfy a <code>1..1</code> cardinality constraint with just extensions. Is the bdl-5 constraint different in this regard?</p>",
        "id": 215019731,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1604001488
    },
    {
        "content": "<p>A resource with an extension <em>and</em> that satisfies all the resource requirements (mandatory elements present, invariants satisfied) counts as 'present'.  So a Patient with just an extension would be fine.  However Observation would not - you'd also need Observation.code and Observation.status.</p>",
        "id": 215021221,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1604002238
    },
    {
        "content": "<p>I guess you could send an Observation with an extension and then throw extensions inside Observation.code and Observation.status, but that starts to fall down as you need to start satisfying all of the widely varying requirements of all the resources and is certainly more 'hack' than solution.</p>",
        "id": 215021315,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1604002314
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"225370\">@Jeremy Chapman</span> I like the idea of leveraging the built-in functionality of the messaging format (json/xml) to embed encrypted resources.  If we assume that the parsing layer transparently encrypts/decrypts these nodes and replaces them with their encrypted/decrypted values upon sending/receiving, and a fully decrypted payload forms a valid FHIR payload, would that allow us to dodge the need for FHIR to adopt any message-level encryption support?  Does the cardinality of the messaging format allow us to do that?  I'm thinking no but it's worth a shot.</p>",
        "id": 215021926,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604002673
    },
    {
        "content": "<p>The examples being discussed, with the exception of <code>Binary</code>, are exposing the identity of the resource type (<code>Practitioner</code>, <code>Observation</code>).  Going down the new resource type route, the <code>Bundle.entry</code> would need to allow for something like an <code>encryptedResource</code> that hides the resource identity and provides metadata properties similar to <code>EncryptedData</code> from the xml spec.  It sounds like <code>Binary</code> could be made to act that way via extensions - but again that's a very custom solution.</p>",
        "id": 215023257,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604003344
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215002531\">said</a>:</p>\n<blockquote>\n<p>The real issue with doing this in Bundle is bdl-5, which requires that resource be present if you don't have entry.request or entry.response - which means documents, messages, etc.  If we didn't have that constraint, we could theoretically have an extension that conveyed an encrypted view of the resource rather than the resource itself. ...</p>\n</blockquote>\n<p>One might be able to argue about where/when this constraint is validated. I could take the position that it isn't FHIR until I've reconstituted the bundle without encryption, and that the JSON or XML I was passing around before that doesn't have to meet any of the FHIR constraints.</p>",
        "id": 215027238,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1604005275
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"301882\">@Jason Eisenmenger</span> -  I originally thought using the built-in functionality of the format to embed encrypted resources was clever, but for some reason I did kind of overlook the obvious fact that the payload is non-conformant because it introduces elements that are not declared within the FHIR schemas.  That being said,  what you are talking about does make some sense where you effectively decrypt prior to the consumption of the FHIR message so the software that is consuming the message still sees it as a valid message.  This is effectively how mtom works, and xml libraries that support it - if you consume xml that contains mtom with compliant librarys the mtom part of the xml is abstracted away.  What I don't like is the coupling of the payload format to the encryption implementaiton because xml encoding may have different requirements than json object encryption, which means the decoding and encoding system may need multiple encryption/decryption implementations if they are to support multiple message formats.  I don't see that as Ideal although think it's certainly considerably better then going lower down in the stack and using soap or s/mime to handle the encryption/decryption.</p>\n<p>What you are talking about could certainly work around the constraint that Lloyd is talking about, at a technical level, but given that FHIR is an interop standard we'd really be not within the spirit of that even though it would still technically function.</p>",
        "id": 215027394,
        "sender_full_name": "Jeremy Chapman",
        "timestamp": 1604005343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191380\">Elliot Silver</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215027238\">said</a>:</p>\n<blockquote>\n<p>One might be able to argue about where/when this constraint is validated. I could take the position that it isn't FHIR until I've reconstituted the bundle without encryption, and that the JSON or XML I was passing around before that doesn't have to meet any of the FHIR constraints.</p>\n</blockquote>\n<p>Are you suggesting an outer layer that escapes the FHIR constraints?</p>",
        "id": 215027938,
        "sender_full_name": "Jose Costa Teixeira",
        "timestamp": 1604005578
    },
    {
        "content": "<blockquote>\n<p>A resource with an extension <em>and</em> that satisfies all the resource requirements (mandatory elements present, invariants satisfied) counts as 'present'.  So a Patient with just an extension would be fine.  However Observation would not - you'd also need Observation.code and Observation.status.</p>\n</blockquote>\n<p>So for example there's no way to provide a \"data absent reason\" instead of a typed resource in a bundle entry?</p>",
        "id": 215028651,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1604005906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191832\">Jose Costa Teixeira</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215027938\">said</a>:</p>\n<blockquote>\n<p>Are you suggesting an outer layer that escapes the FHIR constraints?</p>\n</blockquote>\n<p>I'm suggesting using something that looks like a Bundle, and contains resources, just like a bundle would, but that the content of the resources in encrypted, which is what I thought Jeremy was proposing until Lloyd shot it down with the fact that it doesn't meet constraints. My point was question at what point the constraints need to be met? Doing something like mtom, you would end up with non-compliant content at lower levels of the interface, but by the time it reaches higher levels, it has been turned into something compliant. (Yes, even if it does, and I'm doubtful of that,  meet the letter of the spec, there is a big question of whether it would meet the interoperable spirit of the spec.)</p>",
        "id": 215034006,
        "sender_full_name": "Elliot Silver",
        "timestamp": 1604008763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191380\">Elliot Silver</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215034006\">said</a>:</p>\n<blockquote>\n<p>I'm suggesting using something that looks like a Bundle, and contains resources, just like a bundle would, but that the content of the resources in encrypted, which is what I thought Jeremy was proposing until Lloyd shot it down with the fact that it doesn't meet constraints. My point was question at what point the constraints need to be met? Doing something like mtom, you would end up with non-compliant content at lower levels of the interface, but by the time it reaches higher levels, it has been turned into something compliant. (Yes, even if it does, and I'm doubtful of that,  meet the letter of the spec, there is a big question of whether it would meet the interoperable spirit of the spec.)</p>\n</blockquote>\n<p>I would think you could successful remain compliant, at a higher level (as you said), but non-compliant at the lower level.   I'm sure the interoperable standards checkbox remains empty.</p>",
        "id": 215039868,
        "sender_full_name": "Jeremy Chapman",
        "timestamp": 1604012757
    },
    {
        "content": "<p>You could do that, but you couldn't use $process-message and you couldn't claim a FHIR mime type</p>",
        "id": 215052786,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1604027508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"225370\">Jeremy Chapman</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215027394\">said</a>:</p>\n<blockquote>\n<p>What you are talking about could certainly work around the constraint that Lloyd is talking about, at a technical level, but given that FHIR is an interop standard we'd really be not within the spirit of that even though it would still technically function.</p>\n</blockquote>\n<p>I see where you're coming from, but to look at it from another angle <code>Binary</code> may pass the spirit argument but fail on the technical level since it doesn't provide guidance or standards around how encryption/decryption should be implemented.  I see two technically viable solutions discussed so far; 1) leveraging the built-in encryption features of the message format or 2) creating a new encrypted resource type and making encryption a first class citizen.  The former provides standards and guidance that have already been adopted (in the case of xml) but leaves open the question of whether decryption happens pre-validation and would potentially require a change in the FHIR schema to support it.  A new resource type, however, would require FHIR to shoulder re-implementing concepts similar to the xml standard / json rfc but would give FHIR the ability to conform them to its specific use case.</p>",
        "id": 215124211,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604078089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"301882\">Jason Eisenmenger</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215124211\">said</a>:</p>\n<blockquote>\n<p>I see where you're coming from, but to look at it from another angle <code>Binary</code> may pass the spirit argument but fail on the technical level since it doesn't provide guidance or standards around how encryption/decryption should be implemented.  I see two technically viable solutions discussed so far; 1) leveraging the built-in encryption features of the message format or 2) creating a new encrypted resource type and making encryption a first class citizen.  The former provides standards and guidance that have already been adopted (in the case of xml) but leaves open the question of whether decryption happens pre-validation and would potentially require a change in the FHIR schema to support it.  A new resource type, however, would require FHIR to shoulder re-implementing concepts similar to the xml standard / json rfc but would give FHIR the ability to conform them to its specific use case.</p>\n</blockquote>\n<p>I think that making encryption a first class citizen is ideal.  That requires inclusion into the FHIR specification, which sounds like an arduous process, and a process that is pretty unclear to me. How long does that process even take, and how does it get initiated and shepherded through to fruition?</p>",
        "id": 215124765,
        "sender_full_name": "Jeremy Chapman",
        "timestamp": 1604078346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"225370\">Jeremy Chapman</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215124765\">said</a>:</p>\n<blockquote>\n<p>How long does that process even take</p>\n</blockquote>\n<p>Well... the xml encryption syntax was proposed 12/2000 and adopted as a recommendation by the W3C on 01/2013, but maybe we can get <span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span> to crank it out with us in a connectathon?</p>",
        "id": 215126073,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604078924
    },
    {
        "content": "<p>Worth every penny, but here's my two cents  =)</p>\n<p>Adding encryption by adding a wrapping resource does not make encryption easy.  E.g., consider a <code>Bundle</code> and some content:</p>\n<ul>\n<li>Does the <code>Bundle</code> need to be encrypted?  If so, we need to allow returning the encrypted resource instead of <code>Bundle</code> everywhere (which is not likely to happen).</li>\n<li>If the <code>Bundle</code> isn't encrypted, what do we do about potentially sensitive data there (e.g., I don't want to expose <code>Bundle.entry.fullUrl</code>, but I'm not including full resources)?</li>\n<li>Needing to check each entry and determine if it needs to be decrypted will add runtime checking/logic to figure out what's present.</li>\n</ul>\n<p>Similar issues would exist for <code>contains</code>, etc. - any place a resource <em>could</em> be used, a developer will need to add handling for encryption.  The core specs would need also to be expanded to include it, since a Reference(Patient) could now be a Reference(Binary/EncryptedBinary/whatever) at runtime.</p>\n<p>That said, if you want to selectively encrypt parts of a message and remain FHIR-compliant at each step, I don't know that there is another option.</p>\n<p>But if you want to move forward with wrapping, I would suggest looking at <code>Binary</code> and seeing what can be done with extensions today (if an encrypted binary is added for R5 and useful, people will likely want a way to use it in R4 anyway).  My intuition is that there are only a couple of fields that would need to be added to <code>Binary</code> to get what you need.  As the details are fleshed out, it will be easier to figure out if the fields can be added to <code>Binary</code> (it is normative, but non-breaking changes can still be proposed) or if a new resource makes more sense (e.g., <code>EncryptedBinary</code>).</p>\n<p>However, if the goal is just to allow secure messages to be forwarded around, I would consider a new serialization format instead.  There are a few approaches here that feel like 'low hanging fruit':</p>\n<ul>\n<li><code>application/fhir+xmlenc</code> could be used for encrypted XML (not sure what would be best practice for JSON given all the issues around JWE/JOSE).</li>\n<li>Define an a new encrypted container format (e.g., <code>application/fhir+secure+xml</code> and <code>application/fhir+secure+json</code>) - this allows for adding metadata outside the encrypted contents, but would be more work.</li>\n<li>Use an existing container structure (e.g., Josh's example of <a href=\"https://github.com/decentralized-identity/didcomm-messaging\">DIDComm Messaging</a>, <a href=\"https://tools.ietf.org/html/rfc5652\">CMS</a>, etc.) to wrap the existing formats.</li>\n</ul>\n<p>Going this route loses the ability to have a 'FHIR' object without decoding it, but I think it would be simpler to work with (e.g., servers already handle MIME negotiation, encryption/decryption can only be in one place, etc.).</p>\n<p>I will also note (<strong>without</strong> any relevant experience in the FHIR community) that standards bodies often shy away from proscribing specific forms of encryption because they don't want to be accountable for it (e.g., algorithm 'xyz' has been found insecure and there is now a lawsuit over a data leak because of it).  In that context, the more that can be pointed to externally, the easier the sell will be.</p>",
        "id": 215136104,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1604083918
    },
    {
        "content": "<p>Encrypting on a per resource basis would mean that you're comfortable with exposing the full URL (and request and response if appropriate).  If you need all of that hidden, then you need to encrypt the whole thing and intermediaries wouldn't be able to see beans.  The notion of having entry.encryptedResource would be a bit better than Binary not just in that we could convey some encryption metadata (which we could probably do in Bundle.metadata or in additional extensions if necessary), but because references within the Bundle would actually work.  If one of the resources is pointing to Patient/3, then you wouldn't want the Bundle.entry to be a Binary - because if it was, the reference wouldn't work.</p>\n<p>My perspective is that you can't encrypt contained resources - they're inseparable from the containing resource.  However, we <em>could</em> potentially have a situation where there's a stripped/anonymized/'safe' version of the resource that hides a bunch of stuff and is fully viewable (at least by whoever has permission to see the Bundle) and a 'full' (but encrypted) version of the resource that would be readable only to those with the key.  That could potentially let you strip certain contained content and/or other elements from a resource from what the intermediary has access to (to allow appropriate routing/logging/whatever) while still conveying the whole thing to the target recipient</p>",
        "id": 215138545,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1604085157
    },
    {
        "content": "<p>As for Lloyd cranking this out for connectathon, my knowledge of what might be appropriate here is pretty limited.  I'd probably toss the actual write-up to <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> or someone else from the Security WG.  I'm just proposing a possible path forward that could theoretically work within the constraints we currently have.</p>",
        "id": 215138641,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1604085220
    },
    {
        "content": "<p>I am still standing on the use of Binary as an encapsulating FHIR compliant Resource. Where Binary.contentType is the mime-type for XML-Encryption, and the <a href=\"http://Binary.data\">Binary.data</a> is the encrypted blob. This means that there is NO metadata for the sensitive content that is exposed at the Bundle.entry, as the Bundle.entry is to the Binary, not to the sensitive Resource... Care must be taken when there is a non-encrypted Resource in the Bundle, as any of the elements in there that have a Reference datatype might leak that somewhere else in the Bundle is a sensitive Resource of that type.... but what I am proposing sure seems to me to not need any extensions and does not break FHIR R4 rules. (JSON is another kettle of fish, but one problem at a time, and it is mostly caused by the JSON community failure to have a standard as complete as XML-Encryption... note, XML-Encryption could be used with JSON FHR encoding too, but not as smooth)</p>",
        "id": 215143944,
        "sender_full_name": "John Moehrke",
        "timestamp": 1604088179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> How would one go about referencing a resource in an encrypted binary?</p>",
        "id": 215146004,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604089291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215138545\">said</a>:</p>\n<blockquote>\n<p>Encrypting on a per resource basis would mean that you're comfortable with exposing the full URL (and request and response if appropriate).  If you need all of that hidden, then you need to encrypt the whole thing and intermediaries wouldn't be able to see beans.  The notion of having entry.encryptedResource would be a bit better than Binary not just in that we could convey some encryption metadata (which we could probably do in Bundle.metadata or in additional extensions if necessary), but because references within the Bundle would actually work.  If one of the resources is pointing to Patient/3, then you wouldn't want the Bundle.entry to be a Binary - because if it was, the reference wouldn't work.</p>\n<p>My perspective is that you can't encrypt contained resources - they're inseparable from the containing resource.  However, we <em>could</em> potentially have a situation where there's a stripped/anonymized/'safe' version of the resource that hides a bunch of stuff and is fully viewable (at least by whoever has permission to see the Bundle) and a 'full' (but encrypted) version of the resource that would be readable only to those with the key.  That could potentially let you strip certain contained content and/or other elements from a resource from what the intermediary has access to (to allow appropriate routing/logging/whatever) while still conveying the whole thing to the target recipient</p>\n</blockquote>\n<p>Yes.  My concern is that the model is (or perhaps, <em>can be</em>) leaky.  E.g., a response Bundle for a query of a specific condition, etc..  Bundle can contain quite a bit of meta-information (and presumably things like MessageHeader would be plain-text as well).  We can't stop people from shooting themselves in their feet, but we shouldn't give them shoes with targets on them either.</p>\n<p>I agree that references with a wrapped resource would be quite problematic.  But on the other hand, this means we are developing an encryption mechanism that only works with Bundles.  Maybe that's not terrible, but it feels like promoting Bundle into 'the' way of operating.</p>",
        "id": 215149261,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1604091374
    },
    {
        "content": "<p>@Gino, there is plenty of encryption that can encrypt the whole thing. TLS being one. That is not what is being asked for. What is being asked for is to allow some quasi-trusted intermediaries to see the MessageHeader and maybe some content, but hide other content from that quasi-trusted intermediary. That quasi-trusted intermediary does not need to walk the whole bundle, just the MessageHeader....</p>",
        "id": 215150503,
        "sender_full_name": "John Moehrke",
        "timestamp": 1604092100
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197227\">@Esteban Fuentealba</span> any Reference values inside the Bundle would need to be to the actual Resource id. Not the Binary. Hence why these references are potentially problematic.</p>",
        "id": 215150614,
        "sender_full_name": "John Moehrke",
        "timestamp": 1604092164
    },
    {
        "content": "<p>Thus only a fully trusted recipient that could decrypt everything could fully walk everything in the Bundle.</p>",
        "id": 215150757,
        "sender_full_name": "John Moehrke",
        "timestamp": 1604092203
    },
    {
        "content": "<p>this would fit the use-case of a qusi-trusted intermediary that needs only to route, and a fully trusted endpoint... the gap would be if there was a use-case where there was a quasi-trusted intermediary that needed to manipulate things beyond just looking at some content (e.g. MessageHeader).</p>",
        "id": 215150905,
        "sender_full_name": "John Moehrke",
        "timestamp": 1604092283
    },
    {
        "content": "<p>Binary won't work for links.  For example, if you have a query where you're seeking MedicationRequest and _include Patient, if you turn both into Binaries, your links aren't going to work - because either all of your fullURLs will have to be to Binary, and when you unencrypt, you won't have a way to recover your 'propery' fullURLs to recover the content.  I guess one option is for your Binary to actually include the encrypted version of the whole entry, not just the resource.  That could theoretically work. - so the fullUrl for the Binary would get replaced with the fullURL in the encrypted content.</p>",
        "id": 215153496,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1604093763
    },
    {
        "content": "<p>It is a valid use case for all metadata about a resource be encrypted, which breaks FHIR conformance w.r.t. references.  From a schema perspective it sounds like a difficult path around that, wrapper classes or not.</p>\n<p>I'm really liking the elegance of <code>application/fhir+xenc+xml</code>.  An additional step could be a <code>bool:encrypt</code> property on all resource types that requires encryption of the resource <em>and</em> references to it when serialized.</p>",
        "id": 215158424,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604097167
    },
    {
        "content": "<p>What is the actual use case, and what are the risks being mitigated? Before we start designing solutions, we should be clear on these two points.</p>",
        "id": 215158659,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1604097340
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"192685\">Vassil Peytchev</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215158659\">said</a>:</p>\n<blockquote>\n<p>What is the actual use case, and what are the risks being mitigated? Before we start designing solutions, we should be clear on these two points.</p>\n<p>I my case, we have EMR software that sends various messages into an exchange, which routes them to other EMR endpoints based on recipient information.  Similar to an email scenario I suppose.  Only the sender (person) and the receiver person should see the sensitive parts of the message.   The idea is that the sender is going to use the receivers public key to encrypt the sensitive parts of the message, but the exchange, and the emr need to see some of the parts so the exchange can route to the appropriate emr endpoint and the emr can route to the appropriate person.</p>\n</blockquote>",
        "id": 215159521,
        "sender_full_name": "Jeremy Chapman",
        "timestamp": 1604098136
    },
    {
        "content": "<p>My use case is very similar.  The key here is that this proxy / exchange needs to be transparent to the sender/receiver and provide a FHIR-compliant interface.</p>",
        "id": 215159799,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604098361
    },
    {
        "content": "<p>I would probably handle that use-case by using messaging (which is FHIR's primary mechanism for routing data) and propagating key routing data into the MSH segment as extensions (encrypted if necessary if certain routing nodes should see and not others) and have the focus of the message being an encrypted Bundle (which might be a REST transaction or another message).  That way you expose exactly what's needed for routing (and nothing more) and you don't mess up the semantics of a 'regular' Bundle, nor do you have to invent anything custom.</p>",
        "id": 215161602,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1604100068
    },
    {
        "content": "<p>Sender and receiver are relative terms. Since in my opinion one of the main strengths of FHIR is the RESTful API, I would rather find a solution where there is a notification from the data producer, going through the proxy/exchange to the data consumer, that there is information for them to consume, and then the consumer obtains the data directly from the producer, maintaining the confidentiality of the information.</p>",
        "id": 215161604,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1604100070
    },
    {
        "content": "<p>Those are both approaches to providing a similar end result, however what is needed is a proxy/exchange interfaced transparently via a FHIR REST API.  Messaging is an entirely different pattern, and with consumer/producer it may be the case that the value-add of the proxy/exchange is providing a route for parties to communicate that otherwise cannot.</p>",
        "id": 215164422,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604102963
    },
    {
        "content": "<p>A few key points from the xmlenc spec:</p>\n<p><strong>4. Processing Rules</strong><br>\n<a href=\"https://www.w3.org/TR/xmlenc-core/#sec-Processing\">https://www.w3.org/TR/xmlenc-core/#sec-Processing</a></p>\n<blockquote>\n<p>This section describes the operations to be performed as part of encryption and decryption processing by implementations of this specification. The conformance requirements are specified over the following roles:</p>\n<p><strong>Encryptor</strong></p>\n<ul>\n<li>An XML Encryption implementation with the role of encrypting data.</li>\n</ul>\n<p><strong>Decryptor</strong></p>\n<ul>\n<li>An XML Encryption implementation with the role of decrypting data.</li>\n</ul>\n<p>Encryptor and Decryptor are invoked by the Application. This specification does not include normative definitions for application behavior. However, this specification does include conformance requirements on encrypted data that may only be achievable through appropriate behavior by all three parties. It is up to specific deployment contexts how this is achieved.</p>\n</blockquote>\n<p><strong>4.1 Intended Application Model</strong><br>\n<a href=\"https://www.w3.org/TR/xmlenc-core/#sec-Intended-Processing\">https://www.w3.org/TR/xmlenc-core/#sec-Intended-Processing</a>:</p>\n<blockquote>\n<p>The processing rules for XML Encryption are designed around an intended application model that this version of the specification does not cover normatively.</p>\n<p>...</p>\n<p>Note that the intended Encryptor behavior will often cause the document with encrypted parts to become invalid with respect to its schema for the hosting XML format, unless that format is specifically prepared to be used with XML Encryption. An Encryptor or Decryptor that implements the intended processing model is <code>NOT REQUIRED</code> to ensure that the resulting XML is schema-valid for the hosting XML format.</p>\n</blockquote>\n<p><strong>4.5 XML Encryption</strong><br>\n<a href=\"https://www.w3.org/TR/xmlenc-core/#sec-Processing-XML\">https://www.w3.org/TR/xmlenc-core/#sec-Processing-XML</a></p>\n<blockquote>\n<p>Encryption and decryption operations are operations on octets. The <strong>application</strong> is responsible for the marshalling XML such that it can be serialized into an octet sequence, encrypted, decrypted, and be of use to the recipient.</p>\n<p>For example, if the application wishes to canonicalize its data or encode/compress the data in an XML packaging format, the application needs to marshal the XML accordingly and identify the resulting type via the <code>EncryptedData Type</code> attribute. The likelihood of successful decryption and subsequent processing will be dependent on the recipient's support for the given type. Also, if the data is intended to be processed both before encryption and after decryption (e.g., XML Signature [XMLDSIG-CORE1] validation or an XSLT transform) the encrypting application must be careful to preserve information necessary for that process's success.</p>\n</blockquote>",
        "id": 215348353,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604336954
    },
    {
        "content": "<blockquote>\n<p>what is needed is a proxy/exchange interfaced transparently via a FHIR REST API.</p>\n</blockquote>\n<p>Is it possible to expand on that? What are the assumptions about the purpose of the proxy/intermediary? What is the problem that needs to be solved?</p>",
        "id": 215375496,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1604349610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"192685\">Vassil Peytchev</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215375496\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>what is needed is a proxy/exchange interfaced transparently via a FHIR REST API.</p>\n</blockquote>\n<p>Is it possible to expand on that? What are the assumptions about the purpose of the proxy/intermediary? What is the problem that needs to be solved?</p>\n</blockquote>\n<p>Consider a hospital group/system where a central exchange is used to forward queries to all EMRs in the network and aggregate responses back into a single payload.  EMR access is configured at the exchange, however asymmetric keys shared between EMRs protect the messages from inspection by the proxy with the exception of allowed metadata.</p>",
        "id": 215451280,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604409450
    },
    {
        "content": "<p>is the return expected to be collated by the intermediary? If so, then it needs to see the results.. If not, then the set of results bundles (search sets) is just carried as encrypted blobs. Those encrypted blobs could be Binary resources as I have explained above.</p>",
        "id": 215455411,
        "sender_full_name": "John Moehrke",
        "timestamp": 1604411619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191404\">John Moehrke</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215455411\">said</a>:</p>\n<blockquote>\n<p>is the return expected to be collated by the intermediary? If so, then it needs to see the results.. If not, then the set of results bundles (search sets) is just carried as encrypted blobs. Those encrypted blobs could be Binary resources as I have explained above.</p>\n</blockquote>\n<p>It could be collated in the sense that it would be a bundle of bundles.</p>\n<p>If we continue down the <code>Binary</code> path:</p>\n<ul>\n<li>Senders would need to go through the validation/serialization pipeline twice, once for the encrypted payload and again for the wrapper.</li>\n<li>Receivers would need to go through the parsing/validating pipeline twice, once for the wrapper and again after decrypting the payload.</li>\n<li>Most off-the-shelf FHIR solutions have validation/(de)serialization as a built-in cross-cutting concern, so practically speaking this may be difficult to implement in application space.  If custom validation/serialization is used in application space it may be error prone due to differences/drift from built-in functionality in the outer layers.</li>\n<li>For this specific use case we may get FHIR conformant payloads on the wire, but that may not be true for use cases with references.</li>\n</ul>\n<p>I'm not seeing how FHIR conformance buys a lot here when you essentially have to re-implement a good portion of the stack within application space.</p>",
        "id": 215459690,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604413593
    },
    {
        "content": "<p>If you expect a FHIR client to do a RESTful search, and as a result it gets a Bundle of Bundles, the client will be quite surprised. Something, somewhere, must do the transformation from encrypted content to FHIR conformant payload. Might as well be the \"central exchange\", otherwise it seems like you are punting the issue elsewhere.</p>",
        "id": 215463809,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1604415443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"192685\">Vassil Peytchev</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215463809\">said</a>:</p>\n<blockquote>\n<p>If you expect a FHIR client to do a RESTful search, and as a result it gets a Bundle of Bundles, the client will be quite surprised. Something, somewhere, must do the transformation from encrypted content to FHIR conformant payload. Might as well be the \"central exchange\", otherwise it seems like you are punting the issue elsewhere.</p>\n</blockquote>\n<p>Sorry, that was an implementation detail miss I was just throwing out there.  Given that an EMR response would contain an unencrypted FHIR response with an encrypted <code>Binary</code> resource or resources, those encrypted resources would be collated into the main bundle in the aggregate response - so no bundle nesting.</p>",
        "id": 215466309,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604416536
    },
    {
        "content": "<p>In this case, the constraint is that the central exchange cannot do the transformation from encrypted content to FHIR conformant payload.  Encryption needs to be part of the FHIR specification either in the format, schema, or application layer so that resources can pass through securely.</p>",
        "id": 215467451,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604417036
    },
    {
        "content": "<p>Maybe I am misunderstanding, but I don't think you have established the <em>need</em> for a passthrough central exchange. Why can't the central exchange provide a service that will allow a FHIR client to get all the endpoints it needs to reach for a particular search, and let the client use FHIR search to get all the results it needs? Is this somehow considered more difficult than getting an encryption layer added to the specification?</p>",
        "id": 215469829,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1604418040
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"192685\">Vassil Peytchev</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215469829\">said</a>:</p>\n<blockquote>\n<p>Maybe I am misunderstanding, but I don't think you have established the <em>need</em> for a passthrough central exchange. Why can't the central exchange provide a service that will allow a FHIR client to get all the endpoints it needs to reach for a particular search, and let the client use FHIR search to get all the results it needs? Is this somehow considered more difficult than getting an encryption layer added to the specification?</p>\n</blockquote>\n<p>The central exchange is needed to centrally configure access as well as provide audit (of metadata) and metrics of communications between EMRs.</p>",
        "id": 215472279,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604418956
    },
    {
        "content": "<blockquote>\n<p>The central exchange is needed to centrally configure access as well as provide audit (of metadata) and metrics of communications between EMRs.</p>\n</blockquote>\n<p>If there are sufficient risk mitigations to allow for storing the access configuration and metadata, isn't it a relatively small step to have the appropriate risk mitigations to pass-through the requests and collate the responses without needing encryption of the data?</p>",
        "id": 215488301,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1604425846
    },
    {
        "content": "<p>the trust framework can be managed parellel to the technical communications. Do not conflate a trust framework with the communications path</p>",
        "id": 215498505,
        "sender_full_name": "John Moehrke",
        "timestamp": 1604430941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"192685\">Vassil Peytchev</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215488301\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>The central exchange is needed to centrally configure access as well as provide audit (of metadata) and metrics of communications between EMRs.</p>\n</blockquote>\n<p>If there are sufficient risk mitigations to allow for storing the access configuration and metadata, isn't it a relatively small step to have the appropriate risk mitigations to pass-through the requests and collate the responses without needing encryption of the data?</p>\n</blockquote>\n<p>It is not a small step - it would be a nonstarter.  Configuration/metadata is not (in this case) PHI.  Perhaps the concept of a hospital \"group\" or \"system\" gives the impression of unified governance and security posture without jurisdictional data boundaries.  Instead imagine that each hospital has their own distinct data and security policies, and to enable this communication they require an exchange that can be trusted to send and receive messages but not inspect them, while encryption ensures that only the intended receiver can read them.  The exchange provides audit and metrics of which systems are communicating with which others for compliance, etc.</p>",
        "id": 215499441,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604431468
    },
    {
        "content": "<p>That is why agreements like TEFCA exist...</p>",
        "id": 215500840,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1604432309
    },
    {
        "content": "<p>(In draft form, at any rate ;-))</p>",
        "id": 215502259,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1604433144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"192685\">Vassil Peytchev</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215500840\">said</a>:</p>\n<blockquote>\n<p>That is why agreements like TEFCA exist...</p>\n</blockquote>\n<p>I'd not heard of this, thanks!  I will give it a read.</p>",
        "id": 215503890,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1604433984
    },
    {
        "content": "<p>Take a look at the <a href=\"https://carequality.org/resources/\">Carequality agreement</a> as well. There are others, too...</p>",
        "id": 215504852,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1604434563
    },
    {
        "content": "<p>as to audit... you can always have all endpoints (clients and servers) report to a centerl audit repository all actions with success/failure. These audits would be about the event, not the data. so they would be limited sensitivity (not completely non-sensitive). These would be enough to track usage, patterns, abuse, problems, etc.... this is the idea behind the IHE - ATNA implementation guide. with the FHIR AuditEvent for FHIR use.</p>",
        "id": 215505159,
        "sender_full_name": "John Moehrke",
        "timestamp": 1604434739
    },
    {
        "content": "<p>audit messages only coming from servers, shows that there is a client out-of-compliance. clients and servers reporting different things shows that there is something worth investigating. etc.</p>",
        "id": 215505359,
        "sender_full_name": "John Moehrke",
        "timestamp": 1604434829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"192685\">Vassil Peytchev</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215500840\">said</a>:</p>\n<blockquote>\n<p>That is why agreements like TEFCA exist...</p>\n</blockquote>\n<p>I've just finished digging through the latest QHIN Technical Framework draft.  Although this is a similar infrastructure, because the use case is different it does not address the case where a QHIN should forward queries or messages without being able to inspect them.  In fact it even has requirements to log such requests for auditing.</p>",
        "id": 216249470,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1605031394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"192685\">Vassil Peytchev</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215504852\">said</a>:</p>\n<blockquote>\n<p>Take a look at the <a href=\"https://carequality.org/resources/\">Carequality agreement</a> as well. There are others, too...</p>\n</blockquote>\n<p>Carequality does not appear to have the concept of an exchange.  There is an optional Record Locator Service that returns systems that may contain a given patient for the requesting system to communicate with directly.  The string \"encrypt\" does not have any matches in the implementation guide.</p>",
        "id": 216266231,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1605038640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191404\">John Moehrke</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215505159\">said</a>:</p>\n<blockquote>\n<p>as to audit... you can always have all endpoints (clients and servers) report to a centerl audit repository all actions with success/failure. These audits would be about the event, not the data. so they would be limited sensitivity (not completely non-sensitive). These would be enough to track usage, patterns, abuse, problems, etc.... this is the idea behind the IHE - ATNA implementation guide. with the FHIR AuditEvent for FHIR use.</p>\n</blockquote>\n<p>Again, this would be one way to solution it if there wasn't the requirement that the exchange must transport all communication between clients.  I understand the desire to challenge requirements and assumptions, but this one is not going anywhere <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 216267791,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1605039353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191320\">Lloyd McKenzie</span> <a href=\"#narrow/stream/179247-Security-and.20Privacy/topic/Resource.20Encryption/near/215002531\">said</a>:</p>\n<blockquote>\n<p>The real issue with doing this in Bundle is bdl-5, which requires that resource be present if you don't have entry.request or entry.response - which means documents, messages, etc.  If we didn't have that constraint, we could theoretically have an extension that conveyed an encrypted view of the resource rather than the resource itself.  I don't think we could relax that at this point, but we <em>might</em> be able to add new bundle types - e.g. \"secured-message\" and introduce a new entry.encryptedResource or something like that.  The first step in doing something like this would be writing up an approach and finding a group of people who wanted to play with it at connectathon.  We could then considering introducing it in a future FHIR release.</p>\n</blockquote>\n<p>Lloyd I'm not following this.  <code>Binary</code>derives from <code>Resource</code>, giving it an <code>id</code> property, etc.  How does that not meet <code>bdl-5</code>?</p>",
        "id": 217297399,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1605804534
    },
    {
        "content": "<p>If you have a Patient that's pointing to a Practitioner and want to 'encrypt' the Practitioner, the Patient has to point to an entry of type Practitioner - and you can't stick a Binary into the resource.  The issue is that you don't actually want to send the resource, you want to send a new element (probably an extension) called 'encryptedResource' or something like that.  And bdl-5 wouldn't allow that to happen.</p>",
        "id": 217298648,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1605805077
    },
    {
        "content": "<p>I see, so it breaks down when there are references.  What about if it is simply a Bundle with a single Binary resource?</p>",
        "id": 217298940,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1605805186
    },
    {
        "content": "<p>Although I'm still not understanding how <code>bdl-5</code> applies in the case you described either.</p>",
        "id": 217300015,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1605805616
    },
    {
        "content": "<p>I can see how it would break referential requirements, but not <code>bdl-5</code> specifically.</p>",
        "id": 217300122,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1605805667
    },
    {
        "content": "<p>bdl-5 forces 'resource' to be present - when you don't actually want to convey the resource - you want to convey an encrypted view of the resource.  If you send a Transaction or a Batch with just binaries, that says \"store these Binary\" instances, not \"unencrypt these and store to the appropriate resource endpoints\".  And if you're using messages or documents, you have no choice but to follow references - and use the 'correct' resource types.  For example, the root resource for a document <em>must</em> be Composition - it can't be binary.  And other entries must be of the appropriate referenced resource type (Patient, Practitioner, Condition, etc.) </p>\n<p>The 'appropriate' solution therefore is to allow sending something <em>other</em> than the Bundle.entry.resource element.  But the bdl-5 constraint essentially prohibits us from doing that.</p>",
        "id": 217300839,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1605806004
    },
    {
        "content": "<p>I see, so it's not only requiring a <code>resource</code> in the technical sense, but in the logical sense as well?</p>",
        "id": 217407086,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1605882473
    },
    {
        "content": "<p>Within a Bundle, there are expectations about how resources resolve and what the actual content is.  If the resource path is for Patient, the resource can't be a Binary.</p>",
        "id": 217407273,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1605882555
    },
    {
        "content": "<p>I see, thank you for the clarification</p>",
        "id": 217408731,
        "sender_full_name": "Jason Eisenmenger",
        "timestamp": 1605883251
    },
    {
        "content": "<p>I am not disagreeing... but I don't think it is that dire. There are three classes of recipients. There are -A- those that have the keys to everything encrypted, and -B- those that have keys to some, and -C- those that have no keys at all.  If we look at the use-cases that drive resource level encryption (aka partial, vs just encrypt everything like is done with TLS), it is because there is something in that resource that is more sensitive (in some way) from the stuff that is not encrypted (or encrypted to a wider audience -B- types AND those resources available to -C- or -B- have a specific need for them.  If we look at realistic use-cases, and if FHIR is well designed RESTfully, these three classes of encryption will generally (surely there are exceptions) fall to be unlikely that the resources available do -C- have references to resources not available to -C- (same with -B-). That is to say that sensitive content tends to be at the leaf, not at branch; provided RESTful references tend to point from the leaf resources to the branch resources. <br>\nWhere this tendency fails, and I know it will fail a non-trivial number of times, those -B- and -C- class recipients should know that they are not -A- class, and thus when they get a relative reference that they can't access then they must assume it is because of their lesser privileges'.   THIS is why I want use-cases to be looked at, rather than designing a solution based purely on generic theory.<br>\nYes, this is a break from bdl-5; but it is a break with a describable purpose.</p>",
        "id": 217413698,
        "sender_full_name": "John Moehrke",
        "timestamp": 1605885483
    },
    {
        "content": "<p>I agree it's a desirable purpose.  But bdl-5 exists and is normative.  I think it's going to be really hard to get around it, though <em>maybe</em> if we introduce a new bundle type we could pull it off.  We could then make bdl-5 contingent on the bundle type not being the new type (or one of the new types if we need more than one)</p>",
        "id": 217509507,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1605978139
    },
    {
        "content": "<p>possibly. Seems some experimentation should be done first. These partial encryptions are more often just theory, not ever seen in reality.</p>",
        "id": 217639229,
        "sender_full_name": "John Moehrke",
        "timestamp": 1606144334
    }
]