[
    {
        "content": "<p>In DaVinci DTR we have a situation where a SMART app launched by an EHR is going to store patient identifiable and potentially sensitive information on a payer (because there's no ability as yet for the EHRs to store the information).  However, to protect against a compromised app from having access to the payer-stored information for <em>all</em> patients, we want the payer to be able to enforce that the SMART app only has access to information related to the same patient on the payer as it has access to on the EHR.  I.e. the app will be limited both in the time it has access and the patient has access to (which is the same mechanism used by EHRs to protect against compromised apps).</p>\n<p>To achieve this, the proposal is for the SMART app to pass the EHR's access token to the payer when requesting access.  The payer would then validate the token by attempting to query the Patient record based on the URL present in either the search URL or in the POSTed DocumentReference.  If the read was a success, that would mean that the application would have access to the data associated with that patient URL (and only that patient URL).</p>\n<p>In practice, this would <em>also</em> mean that the payer would be able to issue other queries against the EHR posing as the DTR SMART App.  We consider this to be a low risk:</p>\n<ul>\n<li>The payer is a covered party and would face serious consequences for misusing the token</li>\n<li>The EHR can (and would) log IPS addresses of TLS connections and thus there would be some degree of capability to trace back to a payer system</li>\n<li>The DTR app has the ability to query all of the information anyhow and embed the information in a QuestionnaireResponse that might be stored on the payer's server anyhow</li>\n</ul>\n<p>Are there other risks we should consider/be worried about?</p>",
        "id": 263669077,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638575952
    },
    {
        "content": "<p>What is the relationship between the app and the payer? Certainly an app should not be sharing access tokens with an external system, but if the app is managed <em>by</em> the payer, it's not passing a token anywhere, just using the token it received from the EHR.</p>",
        "id": 263674622,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638581693
    },
    {
        "content": "<p>In any case, a relying party should not make extra queries to test out the token when it can use token introspection for this purpose.</p>",
        "id": 263674841,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638581966
    },
    {
        "content": "<p>(It would be pretty neat if we had a variation of token introspection where the result is cryptographically signed with an issuance time, so it can be passed along safely as proof of the access you had.)</p>",
        "id": 263674927,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638582043
    },
    {
        "content": "<p>Apps will be registered with both the EHR and the payer.  However, apps will be shared across payers - and EHRs will have the choice of which app(s) they choose to use.  That app will be used for all payers.</p>",
        "id": 263680106,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638587963
    },
    {
        "content": "<p>Token introspection would allow confirmation that the EHR had issued it (and it hadn't been manufactured by the app)?</p>",
        "id": 263680120,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638588000
    },
    {
        "content": "<p>Passing bearer tokens around is never great, it just adds one more place to attack that can have sensitive secrets inside. The payer system certainly should not persist or log the token under any circumstances.</p>\n<p>This does sound like a case for token introspection - it's much more suitable than making a call to the resource server for a resource you don't actually want. The payer is asking the EHR auth server for the properties of the token the payer is holding, which will include the patient.</p>\n<p>Josh's additional idea is really interesting - what you really want is for the app to pass a different kind of signed proof token to the payer. But that would be breaking entirely new ground. Just thinking out loud, is there any way for the app to ask the EHR auth server for some kind of downscoped auth token so the risk of handing it over to the payer is less?</p>",
        "id": 263682764,
        "sender_full_name": "Paul Church",
        "timestamp": 1638591556
    },
    {
        "content": "<p>Good point -- We've talked about using <a href=\"https://datatracker.ietf.org/doc/html/rfc8693\">https://datatracker.ietf.org/doc/html/rfc8693</a> in SMART (but we'd still require some careful profiling to request a downscoped access token they preserves full contextual metadata like patient id and encounter id but conveys no API access; plus we'd still want something like regular SMARTv2 introspection or  to tell what the patient is).</p>",
        "id": 263683098,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638592073
    },
    {
        "content": "<p>Just to confirm, the token itself would be cryptographically verifiable by a client as having been signed by the EHR.  Certainly passing a more restricted one that still conveyed the necessary metadata would meet our use-case if that was possible.</p>",
        "id": 263685181,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638595222
    },
    {
        "content": "<p>Agree that prohibiting persistence or logging would be appropriate.  The log could store the introspected metadata, but not the token itself.</p>",
        "id": 263685205,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638595275
    },
    {
        "content": "<p>Do you have this drawn up in an interaction diagram? I am getting lost on the \"actors\" involved, as you are using terms like payor, and app, and EHR. Where at the payor there is the OAuth authorization actor, and the resource-server.   I think you are describing conversation with the payer authorization service. I think you are describing how that payer authorization service would confirm that the context of an access token request is legitimate?  It is not uncommon for a request for an access token to have context used in addition to the request parameters (scope, etc). I would expect that the payer authorization service would need to introspect, and understand the introspected format (i.e. SMART token format).</p>",
        "id": 263711537,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638628729
    },
    {
        "content": "<p>The payer doesn't have an OAuth authorization actor, necessarily.  The app is simply making a 'create', 'update' or 'search' request against a DocumentReference endpoint and passing a token in the header.  The intent is that the service at that endpoint would introspect the token and determine authorization itself.  If it chooses to delegate that responsibility to an authorization service, I suppose it could, but given that this will be a semi-custom workflow, I'm not sure that the complexity would be worth it.</p>",
        "id": 263713072,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638630557
    },
    {
        "content": "<p>so where does it get that token from? In SMART each resource-service endpoint has an OAuth authorization service endpoint</p>",
        "id": 263713274,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638630788
    },
    {
        "content": "<blockquote>\n<p>token itself would be cryptographically verifiable by a client as having been signed by the EHR. </p>\n</blockquote>\n<p>SMART does not define any access token format; you should be looking at token introspection if you need to evaluate whether a token is valid and what it's good for.</p>",
        "id": 263722176,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638640534
    },
    {
        "content": "<p>Jumping all the way back to the top of this discssion: I assuming you're already using OpenID Connect and getting an <code>id_token</code> from the EHR to represent the <em>user</em>, and already limiting access to any payer-backed storage based on this (so an app can only access data that a given <em>user</em> is allowed to see)?</p>",
        "id": 263722237,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638640584
    },
    {
        "content": "<p>It's important to understand where and how you expect all this new machinery to work. New profiles are easy to <em>write</em> for all of this, but getting agreement and implementation from real-world sytems takes buy-in, and this kind of \"net new\" protocol work should be happening in a framework-level IG so it's reusable, not tucked away in a use-case-specific IG.</p>",
        "id": 263722497,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638640898
    },
    {
        "content": "<blockquote>\n<p>However, apps will be shared across payers - and EHRs will have the choice of which app(s) they choose to use. </p>\n</blockquote>\n<p>These apps should <em>not</em> be passing bearer tokens around to payers, then. If payers don't trust the app to mediate the EHR connection, they should establish their own EHR connection <em>or</em> we should introduce new explicit delegation machinery.</p>",
        "id": 263722694,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638641048
    },
    {
        "content": "<p>App authenticates to the <em>EHR</em> using OpenID and OAuth.  App authenticates to the payer using TLS and a shared secret.  No user-based OAuth.  The intention is to pass the EHR's auth token to the payer to determine what access the payer should provide.</p>",
        "id": 263747335,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638676089
    },
    {
        "content": "<p>The payer doesn't need a connection to the EHR.  The payer just wants to ensure that the app is limited to reading and writing the same patient on <em>their</em> system that they can read from the EHR.  (The only thing they can read or write on the payer is stored \"work in progress\" previously saved by the app.)</p>",
        "id": 263747352,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638676175
    },
    {
        "content": "<p>so in trying to be more simple, you have setup the condition that you are trying to resolve now. In the simple world you describe, there is a SMART protected world between the App and the EHR, and a blanket trust (TLS and secret?) between the App and the Payor that presumes the App will not do anything wrong.  But now you are asking about a case where the Payor is not trusted that far.</p>\n<p>What I was suggesting is if the Payor has a OAuth authorization service protecting the Payor; then when the App requests a Payor access token the Payor's Authorization Service decision is based on the security context with the App. This security context can be based on many things. For example in the App-&gt;EHR it can be based on an Open-ID-Connect token. So in your case the Payors Authorization Service can require the App to get an access token from the EHR OAuth Authorization Service with the audience of the Payors Authorization Service. This Token would have be profiled to hold the important EHR context. Likely introspection would be needed by the Payor Authorization Service to the EHR Authorization Service. There clearly is a trust relationship between the Payor OAuth Authorization Service and the EHR OAuth Authorization Service.</p>\n<p>Given that your initial conditions are blanket trust between App and Payor; then just continue this and trust that the App won't do anything wrong. If you can't hold to this, then you can't trust the App this way at all. So your blanket trust either survives, or is totally discarded.</p>\n<p>I fear that there is some expectation that the App-&gt;EHR token can be passed in the App-&gt;Payor. This would possibly work, but would (a) require the token is issued with an audience that includes the Payor, and (b) there is a trust (introspection) between the Payor resource service and the EHR OAuth authorization service. Essentially the OAuth Authorization Service of the EHR also covers the Payor.</p>",
        "id": 263766710,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638708255
    },
    {
        "content": "<p>Agree with John -- your assumptions aren't holding up here. Best to step back and re-evaluate what you're trying to accomplish.</p>",
        "id": 263777350,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638723180
    },
    {
        "content": "<ol>\n<li>The EHR and payer aren't going to use the same auth server.  (If the payer has an auth server at all)</li>\n<li>We don't want the user to have to authenticate twice when launching the SMART app</li>\n<li>We can't trust the app to ask the payer for access to the same patient that it was granted access to on the EHR.  That's the threat we're trying to mitigate.<br>\nThe payer has <em>some</em> trust in the app, in that it's been certified for use.  However, the payer doesn't have control over the code.  If a malicious change is made to the app, it might start to do things it's not supposed to do.  This is similar to the trust relationship between EHRs and apps.  This 'partial trust' situation is mitigated by SMART's limited scope access tokens such that an app can't access beans unless a user asks it to and then can only access the specific patient (and scopes) that the user gives permission to.  So the damage it can do is limited.  We're trying to accomplish the same thing on the payer side - <em>without</em> requiring separate user authentication on the payer side.</li>\n</ol>",
        "id": 263778701,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638724647
    },
    {
        "content": "<p>Keep in mind that for these scenarios user authentication and authorization generally do not involve any actual clicks or choices; so the idea of \"authenticate twice\" is a misleading characterization (two times zero clicks is still zero clicks).</p>\n<p>In any case, I'd strongly recommend you avoid adding requirements in an IG specific fashion. And strongly recommend against sharing access tokens in the way you've suggested.</p>",
        "id": 263779450,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638725600
    },
    {
        "content": "<p>More specifically - the payer will have no clue who the user is and will not have a relationship with the auth server of the EHR that could reasonably validate the user identity.  The payer doesn't need to know the user.  It only needs to know what patient the EHR has authorized the app to access.</p>\n<p>So, given the lack of a shared auth server between payer and EHR, lack of any expectation that payer and EHR can talk to each other except with the untrusted app as an intermediary, and the lack of trust in the app to only ask the payer for data related to the current patient, how would you advise conveying the \"patient context\" restriction from the EHR to the payer if we <em>don't</em> share an auth token granted to the app?  (We could certainly have the app solicit a second auth token with no privileges that it could pass to the payer if this could be introspected to determine the patient and validated as having come from the EHR.)</p>",
        "id": 263781873,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638728785
    },
    {
        "content": "<p>How does the payer know that the patient in the EHR corresponds to a patient/member in the payer system?</p>",
        "id": 263782636,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1638729756
    },
    {
        "content": "<p>The record created on the Payer's system will include the EHR's patient URL in Reference.reference and the payer's member id (which the app will already have determined) in member.identifier.  Queries by the app will be based solely on Reference.reference.  The member identifier is only for the use of the app.</p>",
        "id": 263787338,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638736136
    },
    {
        "content": "<p>If the EHR isn't storing the additional data, then you have another resource location, and I guess what we're now talking about is what is the authentication mechanism on that resource server (storage)?<br>\nThat's what we've used <a href=\"https://datatracker.ietf.org/doc/html/rfc8693\">https://datatracker.ietf.org/doc/html/rfc8693</a> for on 2 of our projects quite successfully.</p>",
        "id": 263806782,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1638763434
    },
    {
        "content": "<p>Right.  The authentication mechanism from the app to the EHR is not user-specific.  We want to make it patient-specific.  And we want the selection of the patient to be completely controlled by the EHR, not the app.</p>",
        "id": 263806997,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638763723
    },
    {
        "content": "<p>My challenge is that we can't get the EHR (or the EHR's auth server) to do <em>anything</em> different.  (This whole \"let's store stuff on the payer\" is a work-around kludge that we plan to use for the 2-3 years it takes the EHRs to have the ability to handle storing the relevant information themselves.)  So something that requires revision of EHR authorization functionality won't fly.</p>",
        "id": 263807240,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638764137
    },
    {
        "content": "<p>it sounds to me like you want a JWT that grants access that's different to the OAuth token, and specific to this use</p>",
        "id": 263807899,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638765211
    },
    {
        "content": "<p>I'd suggest using existing available capabilities to mitigate threats.</p>\n<p>For example, a Payer can host an API where the application provides an <code>id_token</code> (signed by the EHR during SMART launch) as evidence of a recent launch, plus (perhaps if you really need it) a patient ID (simply asserted by the app), and ensure that no more than one patient per launch can be addressed.</p>\n<p>Keep in mind that apps might not actually scope their launches to a single patient though -- like, a \"dashboard of active cases\" for a clinical administrator or whatever wouldn't even fit this model, and I don't see why you'd rule it out.</p>",
        "id": 263807900,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638765214
    },
    {
        "content": "<p>patient ID + granted rights</p>",
        "id": 263807901,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638765217
    },
    {
        "content": "<blockquote>\n<p>it sounds to me like you want a JWT that grants access that's different to the OAuth token, and specific to this use</p>\n</blockquote>\n<p>This is what we were discussing above (signed introspection respond and/or token exchange would be technologies to accomplish this).</p>",
        "id": 263808025,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638765402
    },
    {
        "content": "<p>As described, the connection between the patient on the EHR server, and the reference to the patient on the payer server is at the FHIR layer, so looking at other layers to validate that link is unlikely to work.</p>\n<p>It seems to me that the essence of what is  asked for is to have the <a href=\"http://Patient.id\">Patient.id</a> that is used in querying the payer server, together with an expiration date, to be signed by the EHR.</p>\n<p>With a few extensions, the following might work (as crude and inelegant as it may be):</p>\n<ol>\n<li>App authenticates with EHR, for scope of patient P.</li>\n<li>App uses a special operation on the EHR with parameter the <a href=\"http://Patient.id\">Patient.id</a> that returns a Consent resource (with subject the full url of the patient resource, and expiration timestamp a few minutes in the future), and a Provenance resource with target the Consent resource and a signature that is trusted by the payer server.</li>\n<li>All queries on the patient server have to become operations, that will contain the Consent and Provenance resources as a parameter.</li>\n</ol>",
        "id": 263808087,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1638765492
    },
    {
        "content": "<p>The app will have access to the payer.  I don't really need access.  I want to <em>restrict</em> access to the payer.  I want the controller of that restriction to be the EHR.  But can't require anything of the EHR that it doesn't do today.</p>",
        "id": 263808101,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638765525
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192685\">@Vassil Peytchev</span> I don't expect the link to validate.  This isn't going to be a proper payer FHIR server.  This is a single-purpose FHIR interface dumping ground for EHR data.  <em>If</em> the payer actually exposes data over a FHIR interface (most don't), it would have a different base URL from this.</p>",
        "id": 263808128,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638765590
    },
    {
        "content": "<p>#2 fails - as it requires the EHR to implement a new operation.  That's not really an option for us.  Whatever we do has to work with the functionality that EHRs have today.</p>",
        "id": 263808193,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638765658
    },
    {
        "content": "<p>I was referring to this when talking about \"validating the reference\":</p>\n<blockquote>\n<p>The record created on the Payer's system will include the EHR's patient URL in Reference.reference</p>\n</blockquote>\n<p>But in general, yes, I expect that what is being asked is likely to require something different from the EHR...</p>",
        "id": 263808386,
        "sender_full_name": "Vassil Peytchev",
        "timestamp": 1638765941
    },
    {
        "content": "<p>We want it to be exactly what's on the EHR.  It's not for the payer's use, it's for the app's use.</p>",
        "id": 263808531,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638766139
    },
    {
        "content": "<p>I.e. the full URL from the EHR.  (Having a DocumentReference on one server that points to a Patient on another server is completely legal.)</p>",
        "id": 263808545,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638766172
    },
    {
        "content": "<p>If you're looking for a new capability from the EHR, you could have one of:</p>\n<ul>\n<li>\n<p>POST DocumentReference so no auxiliary storage or access control is required. For this use case, that'd be a win.</p>\n</li>\n<li>\n<p>Support for token exchange so apps could request a delegated token specific to a payer, including a token with no actual scopes, and just context. Useful as a general building block but introduces considerable complexity.</p>\n</li>\n</ul>",
        "id": 263808599,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638766213
    },
    {
        "content": "<p>I think Lloyd has said that he wants a new capability without any actual new functionality</p>",
        "id": 263808635,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1638766271
    },
    {
        "content": "<p>I agree with Lloyd's stated design goal not to rely on anything new from the EHR. In which case just trust the app to manage the data it creates. Which is reasonable since a compromised app will eventually leak all that data no matter where the data are stored (i.e. the compromised app will see them at some point).</p>",
        "id": 263808643,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638766289
    },
    {
        "content": "<p>Set good (i.e., eager to shred) data retention policies in the app, too. That feels doable.</p>",
        "id": 263808733,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638766399
    },
    {
        "content": "<p>I agree with Josh conclusion. Seems like you have enough limits that you must just trust the App.</p>",
        "id": 263847106,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638796234
    },
    {
        "content": "<p>Note there is a Permission resource that the security wg has been slowly working on that fits the flow that Josh was pointing out. These are B2B rules, so using Consent is not exactly proper. But Permission is intended to carry the kinds of things you are mentioning.. but of course Permission is a R5 (providing some use-cases... hint, hint.. come our way)</p>",
        "id": 263847375,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638796380
    },
    {
        "content": "<p>so Permission would be just an application layer declaration; where the similar discussion above using OAuth would be a security-layer \"trust\" based solution. These are two distinct layers that have pro and con regarding ease vs security.</p>",
        "id": 263847634,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638796527
    },
    {
        "content": "<p>In theory we have a requirement for the EHR to be able to switch apps and still access the work in progress.  However, if the \"share the token\" isn't viable, then we can assert that \"if the app changes, you lose all your work in progress\".  The only risk there is that a well-behaved app that becomes corrupted would have access to everything the app ever had access to (or at least the information that's still out there - 6-12 months worth).  Data retention is driven by how long from initial order to completion of billing.  We'll see what we can do to keep it tight.</p>",
        "id": 263864797,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638803983
    },
    {
        "content": "<p>well, sharing the token is worse. sharing the token is essentially the core of EVERY vulnerability Alissa reported.</p>",
        "id": 263903101,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638818764
    },
    {
        "content": "<p><em>IF</em> there were any token sharing, it seems like we'd want the auth server to have a registered list of allowed audiences for the tokens issued, and the client would only share the token with those audiences.  Right now, I think SMART on FHIR really only supports a single audience for tokens, but for other (unrelated) integrations, we've also had reason to want to enable <em>controlled</em> token sharing, where the sharing was controlled by pre-coordinating (including signing agreements, etc.) a list of trusted, allowed audiences for the token which the app is expected to respect.  I.e. the auth server always knows and controls which parties can get and use the token, and the app is only sharing the token with those trusted and known parties.</p>",
        "id": 263904786,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1638819268
    },
    {
        "content": "<p>correct</p>",
        "id": 263907036,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638819617
    },
    {
        "content": "<p>Lloyd I'm not follow your comments about losing work in progress. The app should not lose work in progress.</p>",
        "id": 263946690,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638838994
    },
    {
        "content": "<p>If you start with one app filling out the Questionnaire and it saves work in progress and then the EHR transitions to a different app (which doesn't have permission to see data written by the previous app), then you'd lose your work in progress.</p>",
        "id": 263954256,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1638847374
    },
    {
        "content": "<p>Can we formalize the launch tokens in SMART to carry context around (as in out of EHR)?</p>\n<p>At the minimum, the payer could use the opaque launch token (which the app can share) to establish a patient context in EHR and make authorization decisions.</p>",
        "id": 263989121,
        "sender_full_name": "Jeffy Mathew Jose",
        "timestamp": 1638877352
    },
    {
        "content": "<p>We \"can\" do anything, including defining a really poor security solution that will propagate forever. I am resisting defining poor security in a HL7 standard.</p>",
        "id": 263996588,
        "sender_full_name": "John Moehrke",
        "timestamp": 1638881964
    },
    {
        "content": "<p>Launch token is just a vehicle to carry patient context.<br>\nWe need just need to assume that launch tokens are bearer tokens. Unable to see how security is broken.</p>\n<p>EHR launch app using SMART launch workflow.<br>\nApp uses the launch token to complete authorization work flow and establish patient context.</p>\n<p>App uses the launch token as subject token (<a href=\"https://datatracker.ietf.org/doc/html/rfc8693\">rfc8693</a>) to Payer and get an access token in exchange.<br>\nPayer uses the launch token to establish patient context from EHR before issuing access tokens. </p>\n<p>Launch tokens seem to fit the bill of comments above without defining new behavior.</p>",
        "id": 264046650,
        "sender_full_name": "Jeffy Mathew Jose",
        "timestamp": 1638900897
    },
    {
        "content": "<p>Launch IDs are opaque to every party besides the EHR. If you are not the EHR, you can't (and shouldn't have to, and shouldn't try to) interpret one.</p>",
        "id": 264089612,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638919897
    },
    {
        "content": "<p>If we're introducing Token Exchange, access tokens would presumably be the input ...</p>",
        "id": 264089719,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1638919933
    },
    {
        "content": "<p>To me, this conversation sound like the Payer is a resource server that is trying to use the EHR as it's authorization server. Would using some of the guidance in <a href=\"https://datatracker.ietf.org/doc/html/rfc8707\">RFC8707</a> (which defines the \"aud\" parameter but named \"resource\") be a possible answer:</p>\n<blockquote>\n<p>The authorization server SHOULD audience-restrict issued access<br>\ntokens to the resource(s) indicated by the \"resource\" parameter.<br>\nAudience restrictions can be communicated in JSON Web Tokens<br>\n[RFC7519] with the \"aud\" claim and the top-level member of the same<br>\nname provides the audience restriction information in a Token<br>\nIntrospection [RFC7662] response.  The authorization server may use<br>\nthe exact \"resource\" value as the audience or it may map from that<br>\nvalue to a more general URI or abstract identifier for the given</p>\n</blockquote>",
        "id": 265308148,
        "sender_full_name": "adam strickland",
        "timestamp": 1639753938
    },
    {
        "content": "<p>I agree that is what it sounds like the payers want to do, but the providers don't want to. Thus deadlock.</p>",
        "id": 265315640,
        "sender_full_name": "John Moehrke",
        "timestamp": 1639756612
    },
    {
        "content": "<p>Not necessarily \"providers don't want to\", but more \"providers won't be technically capable in the desired timeline\".</p>",
        "id": 265317664,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1639756972
    },
    {
        "content": "<p>And the major distinction here is whether a <em>seconodary resource server</em> should be expected to receive access tokens that are valid at a <em>primary resource server</em>. When both resource servers are managed by the same organization and part of a coherent whole, there's no real concern. But when the \"secondary\" server is run by an outside organization without strong trust in place, there's no reason it should have to receive access tokens that confer privileges at any other server.</p>",
        "id": 265331355,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1639762346
    },
    {
        "content": "<p>With token exchange, an app could complete ean authz flow once, getting user approval... and then generate downscoped tokens intended for use at secondary resource servers.</p>",
        "id": 265331477,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1639762405
    },
    {
        "content": "<p>and there are thousands of possible payer audience</p>",
        "id": 265342077,
        "sender_full_name": "John Moehrke",
        "timestamp": 1639766931
    },
    {
        "content": "<p>Lets try using launch token again</p>\n<p>Context: App is trying is share context (specifically patient context) (as received from EHR) to Payer.<br>\nPayer has a way to contact EHR and do its business.<br>\nPayer trust on App is limited and the payer would like to contain App's access based on given consent at the EHR.<br>\n<span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span>, Please correct if these sound wrong</p>\n<p>Lets say the app was launched from EHR in SMART launch workflow.<br>\nThis means the app has an opaque launch token representing the patient in context.<br>\nThe app uses launch token in SMART workflow (OAuth authorize flow) and get its access token for EHR access.</p>\n<p>Now app needs to access something at the payer end.<br>\nApp should use launch token to establish subject context (per <a href=\"https://datatracker.ietf.org/doc/html/rfc8693\">rfc8693</a>) and request for access token at the Payer.<br>\nPayer can use the launch token, resolve it at the EHR to get the patient context and issue a access token to the app in context of the patient. (<span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> , launch token is still opaque and processed only by EHR)</p>\n<p>Obviously, this assumes that the launch token may be used by any entity (aka is a bearer token).<br>\nPayer get the patient context from EHR (via launch token) and manage authorizations accordingly. App cannot forge tokens and need not share access tokens.<br>\n<span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> , Thoughts?</p>\n<p>Launch tokens seem to fit just fine..</p>",
        "id": 266355875,
        "sender_full_name": "Jeffy Mathew Jose",
        "timestamp": 1640793180
    },
    {
        "content": "<p>Launch tokens are opaque to every entity except the EHR -- you've preserved this design feature (good!) but also need to keep in mind that a launch token is not an authorization grant, so can't be traded directly for an access token. If a payer was independently authorized to request data from an EHR, then it's indeed possible as you suggest that a recent launch token could be an auxiliary input into a new kind of access token request -- but at that point you're asking EHRs to create a new API for issuing access tokens (i.e. this is something net new, not something that works out of the box with existing implementations), so why not use a more \"vanilla\" token exchange protocol to accomplish this?</p>",
        "id": 266357271,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1640794012
    },
    {
        "content": "<p>I am not a SME on the smart launch token. I don't know to what extent the launch token is a formal security token, vs simply a token. If it is typically implemented as simply a token, then it is more likely that your expansion of the use will work.  I suspect it is already processed as if it was a bearer token, but don't know the current state.<br>\nYou mention \"Payer has a way to contact EHR and do its business\". I presume that this is a formal security trust framework. Meaning that the Payer is recognized as a trusted App, with defined authorizations (likely B2B rights to everything). That this trust is implemented with OAuth flows, which you leverage, specifically these OAuth flows constrict the broad B2B rights for a session scope.<br>\nWhat I would like to see is a threat-assessment. How might this be abused? Expanding the launch token, expands the threats. I understand the desire is to have sessions that are limited to legitimate patient scope. However the solution that comforts the Payer's, likely makes the EHR more at risk. Understanding that risk is important.</p>",
        "id": 266359659,
        "sender_full_name": "John Moehrke",
        "timestamp": 1640795977
    },
    {
        "content": "<p>What we landed on, for now, is just saying that payers must prevent apps from seeing data they have not, themselves, written.  This means that if a provider uses App A to start a work in progress, they won't be able to resume that work with App B.  However, that's not the end of the world.  It also means that if App A was well behaved initially and subsequently becomes corrupted and malicious, it'll have access to data created by the well-behaved version of itself, but we don't have a good way to stop this right now.</p>",
        "id": 266650906,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1641184390
    },
    {
        "content": "<p>then say that in the \"Security/Privacy Considerations\" section.</p>",
        "id": 266681886,
        "sender_full_name": "John Moehrke",
        "timestamp": 1641213978
    }
]