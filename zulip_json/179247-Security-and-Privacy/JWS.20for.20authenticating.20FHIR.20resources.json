[
    {
        "content": "<p>Work in SMART Health Cards has given us some experience creating JWS signatures over FHIR bundles. It'd be nice to have similar capabilities of signing over any resource that a REST API server returns, to make data verifiable when re-sharing downstream. There are some practical challenges though...</p>\n<p><a href=\"https://hackmd.io/1LG5WJfcTnGP8JtYIAAyFA\">https://hackmd.io/1LG5WJfcTnGP8JtYIAAyFA</a> has a brief write-up re: working with JWS in FHIR Signatures. No show-stoppers but it's a bit awkward. Issues include:</p>\n<ul>\n<li>Mandatory fields in the <code>Signature</code> datatype (<code>when</code>, <code>who</code>) overlap with JWS claims and aren't authenticated; why require non-authenticated elements, when they can get out of sync with the authenticated claims?</li>\n<li>Same story for <code>Provenance.agent</code> if the only purpose for a Provenance resource is to convey a signature</li>\n<li>Data needs to be base64binary, but a JWS is already encoded as a string (base64url segments separated by <code>.</code>), so this creates overhead and potential confusion</li>\n</ul>\n<p>Have others thought through some of these issues? (I have a proposal for a \"cheap hack\" alternative at the bottom of the doc ;-))</p>",
        "id": 254598901,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632428571
    },
    {
        "content": "<p>I was just going to ask about this topic...  Where is your  \"Work in SMART Health Cards has given us some experience creating JWS signatures over FHIR bundles\" documented.</p>",
        "id": 254649249,
        "sender_full_name": "Eric Haas",
        "timestamp": 1632457826
    },
    {
        "content": "<p>did the same issues you document above apply to bundle.signature...?</p>",
        "id": 254649568,
        "sender_full_name": "Eric Haas",
        "timestamp": 1632458102
    },
    {
        "content": "<p>Josh, I would love to discuss these. Seems these are questions againt the Signature datatype? Or is this questions about how to do JWS signatures over bundles? --- Note I want both. <br>\nI will respond expecting these are questions against the Signature datatype.</p>",
        "id": 254700514,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632488957
    },
    {
        "content": "<p>The elements in Signature are NOT expected to be covered by the non-repudiation of the signature. They are there in FHIR format using FHIR datatypes to make them easy to understand. For those use-cases that need to confirm they are valid, it is expected they will be in the signature blob. This is true of XML-Signatures, and as you note they are also inside the JWS content. Thus for someone needing non-repudiation, they should use the values inside the signature blobs. <br>\nNote that there is a comment on these elements indicating that \"This should agree with the information in the signature.\"<br>\nNote that the comment on the Signature element indicates that \" <br>\nThe elements of the Signature Resource are for ease of access of these elements. For digital signatures (Xml DigSig, JWS), the non-repudiation proof comes from the Signature validation, which includes validation of the referenced objects (e.g. Resources) (a.k.a., Content) in the XML-Signature Detached form.\"<br>\nThis should likely be more prominent, as today it is only viewable when hovering over \"Signature\" or clicking on \"Signature\"</p>",
        "id": 254701518,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632489330
    },
    {
        "content": "<p>the data element.... Yes, we likely should figure out a better and more friendly way to do this.  We didn't have much experience to base our datatype choice, and base64Binary is always going to be safe. But as you point out it is a bit inconvenient.</p>",
        "id": 254701879,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632489473
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> it seems a bigger problem to me. For a start, where is the JSON canonicalization method?</p>",
        "id": 254703294,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1632490036
    },
    {
        "content": "<p><a href=\"http://build.fhir.org/datatypes.html#JSON\">http://build.fhir.org/datatypes.html#JSON</a> ?</p>",
        "id": 254703333,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632490056
    },
    {
        "content": "<p>no. <a href=\"http://build.fhir.org/json.html#canonical\">http://build.fhir.org/json.html#canonical</a></p>",
        "id": 254703447,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1632490088
    },
    {
        "content": "<p>Why do you put the JWS in the resource, and not in an http header?</p>",
        "id": 254703513,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1632490119
    },
    {
        "content": "<p>are we discussing the Signature datatype, or the JWS signature method? I think they are both needed, but different.</p>",
        "id": 254703722,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632490208
    },
    {
        "content": "<p>well, I want to talk about the JWS itself first, because I want to know why Signature is relevant, and what the purpose of the signature is</p>",
        "id": 254703885,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1632490281
    },
    {
        "content": "<p>Sorry for the shorthand, when I wrote canonicalization I meant specifically <a href=\"https://datatracker.ietf.org/doc/rfc8785/\">https://datatracker.ietf.org/doc/rfc8785/</a></p>",
        "id": 254710117,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632492599
    },
    {
        "content": "<p>(this is a scheme with pretty broad library support and of course it is standardized.)</p>",
        "id": 254710274,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632492643
    },
    {
        "content": "<p>(the signatures could go in a resource or in a header or wherever. A challenge with headers in particular is that we don't have a good way to represent arbitrary headers in a bundle response today, so if I'm getting a bundle of resources back from a batch or a search, I don't have a way to provide specific headers for each one.)</p>",
        "id": 254710612,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632492767
    },
    {
        "content": "<p>do you need a signature for each resource in a bundle?</p>",
        "id": 254721359,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1632496865
    },
    {
        "content": "<p>And you missed the point with canonicalization. The question is what parts of the resource are you signing?</p>",
        "id": 254721432,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1632496894
    },
    {
        "content": "<p>I think it's pretty important for a lot of use cases to be able to mix and match resources; so if I do a search for all labs to pull data into a consumer app, I would like to have individual signatures on them so I can decide to share subsets of labs downstream.</p>",
        "id": 254735800,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632502330
    },
    {
        "content": "<p>For canonicalization, I don't have firm answers. My initial thought was just to include the full resource contents except for of course the element that contains the signature (whether that's a contained province resource or a tag or whatever -- details TBD). The idea would be if I'm giving you this resource together with a signature, there is some well-specified and not extremely complicated set of steps you can follow to verify the signature.</p>",
        "id": 254735952,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632502397
    },
    {
        "content": "<p>(of course with fhir graphs, the whole story of signatures across links is very complicated. I'm not trying to do anything on this front right now. This is a place where rdf might shine... But it's a problem I'm trying to avoid for now.)</p>",
        "id": 254736131,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632502460
    },
    {
        "content": "<p>I think what <span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> is / has suggesting it  wrap whatever you want in a signature envelope and point to the binary with docref.  Instead of the target type. Forget about bundle.sig  or provenance  or some meta element.  I may be misrepresenting him so I welcome his feedback.</p>",
        "id": 254846850,
        "sender_full_name": "Eric Haas",
        "timestamp": 1632582621
    },
    {
        "content": "<blockquote>\n<p>share subsets with signatures</p>\n</blockquote>\n<p>Well, you've got complicated right there. Have you got any references for other protocols doing anything like that?</p>",
        "id": 254972602,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1632700474
    },
    {
        "content": "<p>It's just a set of signed resources -- if you attach signature to each, you allow the recipient to select and re-share whatever subset they like. Of course many protocols do more complicated things (e.g., ISO mobile driver's license signs a set of hashes, so then you can selectively reveal a subset of pre-images).</p>",
        "id": 254976597,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632704279
    },
    {
        "content": "<p>The technology for signing can support anything you want. However each signing methodology has strengths and weaknesses. Eric is referring to the strength of a document signature, that is a signature where the thing being signed is fully self-contained, thus not relying on references to outside stuff. When you have a signature relying on references to outside resources, you have the risk that what you are pointing at is either originally wrong, or in the future wrong. With partial signatures, excluding the signature element from the signature because you need to put the signature blob there later, you leave room for unsigned elements to be inserted. Encapsulating signatures are handy when you know that all uses of the data must validate the signature first, where as detached signatures are more handy when the signatures are only needed occasionally. etc...</p>",
        "id": 255038426,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632745417
    },
    {
        "content": "<p>I look forward to the JWS signature method used in the vaccine credential to be made more broadly usable. I like it for use-cases where all/most uses of the data have business rules need to validate the signature. They should also inspect the signature element for unexpected elements.</p>",
        "id": 255038904,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632745665
    },
    {
        "content": "<p>I think the topic is moving toward signatures that are intentionally sub-sets of the data. Possible, but warning I think this will add risks and complexity that will not be justified by the use-cases. A blind prediction, yes. One based on many years of seeing gleam in geek eyes only to have reality kill the elegant solution due to overwhelming administrative overhead and complexity. (I worked on the project that digitally signed the original USA e-Sign act back in 2000) -- as one can imagine, stopping this with a prediction is neither possible or good. Yes, you can have many signatures in the blob, but they each must be a full signature including the exclusions. each with a who/what/when/why that can standalone.</p>",
        "id": 255040135,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632746259
    },
    {
        "content": "<p>I’m just saying use the Smart vaccine passport model  for any FHIR payload as envelope anything that needs to be signed…you want it signed? Fine, here it is but you get it as a docref reference binary where the payload is the FHIR object. I’m no authority but signing something that contains the signature is hard to get my head around.</p>",
        "id": 255097811,
        "sender_full_name": "Eric Haas",
        "timestamp": 1632767661
    },
    {
        "content": "<p>Signing something that contains the signature is straight-forward.  All that matters is that the canonicalization for the signature excludes the signature element.  You don't want to turn the data into a binary because that makes it difficult/impossible to use with search.  It also locks it into a single syntax, and there are times when you might need to share the content in alternative syntaxes.</p>",
        "id": 255099752,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1632768429
    },
    {
        "content": "<p>the problem with all this is that if you're signing subsets of data you assembled from elsewhere, then you might have to fiddle the ids for integrity, and the integrity of the links is exactly what you're trying to convey onwards</p>",
        "id": 255102692,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1632769515
    },
    {
        "content": "<p>signing linked pieces means you must hash the ids.</p>",
        "id": 255102758,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1632769541
    },
    {
        "content": "<p>correct. If you are signing individual Resources, you likely need to exclude other things like the .id and .meta.. once you start excluding these things you are getting less and less value out of the signature.</p>",
        "id": 255106069,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632770899
    },
    {
        "content": "<p>My initial question was about the ergonomics of Signature to convey a JWS over a single Resource version  in real-world usage. This might be a non-goal for Signature</p>",
        "id": 255107264,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632771387
    },
    {
        "content": "<p>I'll probably proceed with prototyping based on JWS in <a href=\"http://meta.security\">meta.security</a>; will continue to share experience here.</p>",
        "id": 255107935,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632771644
    },
    {
        "content": "<p>anything is possible. There is certainly a theory where all Create/Update will have a calculated signature added to the Provenance for that version. In this case I would expect the signature would cover THAT instance. In that case it does not need to exclude anything.</p>",
        "id": 255108014,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632771689
    },
    {
        "content": "<p>so you are looking to add a signature element as an extension on .meta.security that covers the rest of the resource?</p>",
        "id": 255108262,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632771801
    },
    {
        "content": "<p>I am still not clear on what it is you are trying to achieve. i think I understand how you are achieving it, but I don't know what \"it\" is that you are accomplishing.</p>",
        "id": 255108316,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632771836
    },
    {
        "content": "<p>\"it\" is providing a JWS to authenticate an individual FHIR resource. And yes, I'm looking at one approach which is to provide it in-line, so the approach can work with any method of sharing a FHIR resource (without depending on any specific envelope or package context).</p>",
        "id": 255113562,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632773963
    },
    {
        "content": "<p>as long as it is retrieved in json</p>",
        "id": 255113678,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774009
    },
    {
        "content": "<p>but what do you think the signature is conveying? if all you want is a hash, that is different than a signature. A signature needs to have a WHO signed it, WHY did they sign it, WHEN did they sign it...etc... all have a purpose. Hence why signature is not just a cryptographic hash, hence why I ask what you are trying to achieve.</p>",
        "id": 255113860,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774107
    },
    {
        "content": "<p>I fear, you are a kid with a tool, and you want to hit everything you can see with this tool (aka hammer).</p>",
        "id": 255113993,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774157
    },
    {
        "content": "<p>I am not saying I object to a signature being in the header of every resource. But I am unclear on why it should be there, who would put it there, when would it be put there, who is expected to validate it, what should be allowed to change without breaking the signature... etc... all things that a use-case analysis would define.</p>",
        "id": 255114521,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774387
    },
    {
        "content": "<p>Thanks :-) I want to convey information according to the JWT data model -- minimally the ability for a consuming application to pass along a non-repudiable authenticated resource such that a receiving party knows that it hasn't been altered since the intermediary received it.</p>",
        "id": 255114612,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632774429
    },
    {
        "content": "<p>note if you had this use-case analysis, it would be good to assess this on a general Proveance use... then, I think you are just looking for contained Provenance with signature.</p>",
        "id": 255114641,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774441
    },
    {
        "content": "<p>Not saying this is \"in every resource\" -- just saying that it's a common need and convenient to have an approach for.</p>",
        "id": 255114690,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632774467
    },
    {
        "content": "<p>I tried the contained Provenance with signature; that's what the majority of my write-up was focused on.</p>",
        "id": 255114768,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632774495
    },
    {
        "content": "<p>well, this broad set of use-cases are why Provenance.signature exists</p>",
        "id": 255114776,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774501
    },
    {
        "content": "<p>I was concerned with the ergonomics and the risk of conveying unauthenticated copies of signature metadata that are already in the JWS (it creates an opportunity for confusion if the values inside and outside are discordant).</p>",
        "id": 255114886,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632774558
    },
    {
        "content": "<p>are you refering to the Signature elements?</p>",
        "id": 255115029,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774620
    },
    {
        "content": "<p>Correct</p>",
        "id": 255115057,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632774632
    },
    {
        "content": "<p>they (.type, .when, .who, .onBehalfOf) are there for the convienence of the app that understands FHIR... and doesn't want to have to call upon a signature processing system. BUT they are not to be held as trusted, if you need the trustable who/what/where/why, then you must look inside the signature.</p>",
        "id": 255115216,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774718
    },
    {
        "content": "<p>these elements are useful to apps, especially those that will use a signature service to give a YES/NO on the signature.</p>",
        "id": 255115349,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774766
    },
    {
        "content": "<p>I'm just saying I wish they were optional</p>",
        "id": 255115365,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632774773
    },
    {
        "content": "<p>Because I'd like to be able to profile them out</p>",
        "id": 255115388,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632774783
    },
    {
        "content": "<p>well, put in a CR.</p>",
        "id": 255115407,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774789
    },
    {
        "content": "<p>I will; it'll also cover Provenance.agent</p>",
        "id": 255115467,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632774817
    },
    {
        "content": "<p>this is exactly why Signature is STU.</p>",
        "id": 255115483,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774829
    },
    {
        "content": "<p>how do you have any useful Provenance without an agent?</p>",
        "id": 255115567,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774849
    },
    {
        "content": "<p>in your CR, please explain. as so far we struggle with any useful Provenance without a \"WHO\".</p>",
        "id": 255115777,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774947
    },
    {
        "content": "<p>similarly, a signature without a reason for the signature, a timestamp, and a signer.... without these you just have a checksum</p>",
        "id": 255115904,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632774997
    },
    {
        "content": "<p>remember, some apps still use XML... so forcing them to have json capability just to read your JWS is not helpful.</p>",
        "id": 255116027,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632775045
    },
    {
        "content": "<p>that is why these elements exist in Signature</p>",
        "id": 255116060,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632775063
    },
    {
        "content": "<p>I am not discouraging you, just trying to get the 'persuasive' argument in the CR rather than not.</p>",
        "id": 255116460,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632775257
    },
    {
        "content": "<p>I'll explain in the CR -- essentially all the semantics are already covered in the JWS including the who.</p>",
        "id": 255116468,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632775263
    },
    {
        "content": "<p>but not if I ask for XML FHIR</p>",
        "id": 255116506,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632775284
    },
    {
        "content": "<p>or CSV FHIR</p>",
        "id": 255116542,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632775304
    },
    {
        "content": "<p>the replication is for the convenience of the preferred mime-type of the requester. JWS is only friendly to those that like json. Those that like JWS can ignore the values in these elements, and go right to the JWS.</p>",
        "id": 255116734,
        "sender_full_name": "John Moehrke",
        "timestamp": 1632775399
    },
    {
        "content": "<p>The point is that in this scheme, the other properties would be unreliable. It's not a question of what you like or what you don't, but a question of what you can count on as authentic. Absolutely within this kind of scheme there is a design choice that limits scope of usage. But it also provides a simplified developer experience, or at least it should. That's the nature of the trade-off.</p>",
        "id": 255122236,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632777655
    },
    {
        "content": "<p>Submitted <a href=\"http://jira.hl7.org/browse/FHIR-34021\">FHIR-34021</a></p>",
        "id": 255237797,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1632843547
    }
]