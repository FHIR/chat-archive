[
    {
        "content": "<p>I am working on an implementation using StructureMap. While doing so, I've realised that there's a missing feature.</p>",
        "id": 158959536,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550653558
    },
    {
        "content": "<p>so when you are writing a transformation, you are defining the relationship between the source and the destination structures. One (difficult but very useful) feature of the way the mapping language works is that there is no state - no variables that exist out of local context. All the rules define their dependency carefully, so that you know what inputs are required.</p>",
        "id": 158959664,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550653690
    },
    {
        "content": "<p>this makes for both efficient transforms - Rules can be run in series in any order, or in parallel, as long as dependencies are satisfied.  Also, it means that you can run the transforms, and given a known set of inputs, you can describe the possible set of outputs. That's pretty cool</p>",
        "id": 158959669,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550653719
    },
    {
        "content": "<p>but the mapping language assumes, when it's doing that, that the destination is empty, and the content is being pushed into the destination without overwriting anything.</p>",
        "id": 158959698,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550653760
    },
    {
        "content": "<p>actually, that's not quite true. We say:</p>",
        "id": 158959709,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550653778
    },
    {
        "content": "<p>.. no, apparently we don't say it. But there's no stated rule that the starting target has to be empty. If it's not, it really doesn't make any difference; the target is populated from the source, and any mapped fields in target will be ... changed...</p>",
        "id": 158959895,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550653984
    },
    {
        "content": "<p>it's obvious what to do if the cardinality of the target is ..1: you overwrite the existing value if you have one. (aside: is there any reason to want to say 'clear this element if there's nothing in the source'?)</p>",
        "id": 158959930,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654041
    },
    {
        "content": "<p>it's not so obvious if the cardinality is a ..* - you can just say that the mapping automatically adds new objects to the list... but that's actually not what you want</p>",
        "id": 158960025,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654155
    },
    {
        "content": "<p>take the case of transforming from a PID segment to a Patient resource, and processing the XTN entries in PID-17 (I think it is)</p>",
        "id": 158960115,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654243
    },
    {
        "content": "<p>you have a list of phone numbers and fax and email etc. It's ok to talk about the first time, when you transform from pid to Patient, and stick it in your database, no problems</p>",
        "id": 158960170,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654308
    },
    {
        "content": "<p>but what happens when you get an update?</p>",
        "id": 158960174,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654319
    },
    {
        "content": "<p>You can still talk about the mapping, but somewhere, you need to say criteria are so that home phone number replaces the existing home phone number, instead of just adding a new one. (assuming there's only one...)</p>",
        "id": 158960223,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654399
    },
    {
        "content": "<p>so it seems to me that you need some kind of match expression that specifies which target in a list the source transform into</p>",
        "id": 158960308,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654471
    },
    {
        "content": "<p>something like</p>",
        "id": 158960310,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654475
    },
    {
        "content": "<p><code>pid-17 where type= home and system = phone matching target.type=home and target.system= phone   -&gt; ContactPoint  then {  rules }</code></p>",
        "id": 158960427,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654584
    },
    {
        "content": "<p>(well, something like that - the v2 details are not quite right, but it serves to show the principle)</p>",
        "id": 158960444,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654616
    },
    {
        "content": "<p>so that's what I think the missing feature is: a rule to specify what matches</p>",
        "id": 158960533,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654698
    },
    {
        "content": "<p>but I ducked an issue: do you want to delete anything from the target list? (kind of like, do you want to delete the entry for a ..1 element?</p>",
        "id": 158960563,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654732
    },
    {
        "content": "<p>I don't think that the matching thing solves this....</p>",
        "id": 158960632,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654777
    },
    {
        "content": "<p>this has an interesting consequence, btw, because it also applies when you start from empty</p>",
        "id": 158960645,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654798
    },
    {
        "content": "<p>and what it means is the outcome, if you construct the rules the right  (wrong) way, is the outcome depends on the order in which the rules are executed. It may also, for the same reason, prove too hard to evaluate speculatively.</p>",
        "id": 158960702,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654876
    },
    {
        "content": "<p>An alternative to all this is to invent some new language that specifies the 'update rules' when committing an update to a resource.</p>",
        "id": 158960757,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654914
    },
    {
        "content": "<p>of course, on the RESTful api we have patch, but this is different - subtly, but importantly - from a transform rules</p>",
        "id": 158960785,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550654948
    },
    {
        "content": "<p>so having got this far, and maybe talked myself out of my original idea....  has anyone seen any language that deals with update semantics?</p>",
        "id": 158960882,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550655027
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193934\">@Keith Duddy</span> <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> I'd appreciate your opinions... thanks</p>",
        "id": 158960930,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550655098
    },
    {
        "content": "<p>We generally think of mapping on streaming data as a problem of f(new data, existing resources) -&gt; updated resources, as compared to the static mapping problem of f(data) -&gt; resources. This requires a prefetch step to figure out what existing resource(s) are relevant and retrieve them if they exist (else the mapping results in a create operation). Unfortunately this gives up a lot of the nice stateless properties, but trying to do f(new data) -&gt; \"description of mutations\" pushes a lot of complexity into how you encode update semantics and how the server applies them.</p>\n<p>Inside the mapping, any ..* field needs merge logic describing what field(s) are the primary key on which the old and new lists should be joined, which your matching rule handles. A deletion could look like type=X, system=Y, and all other non-primary-key fields null; when merging the lists any existing entry with type=X, system=Y should be dropped - although this carries a bunch of limiting assumptions, it hits some common use cases.</p>",
        "id": 159008357,
        "sender_full_name": "Paul Church",
        "timestamp": 1550692324
    },
    {
        "content": "<p>I think you're agreeing with where I ended up - the merging rules should be separate from the mapping rules</p>",
        "id": 159010703,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550693773
    },
    {
        "content": "<p>Yes and no - the merging rules either end up in the server as part of a patch-like operation that knows how to apply deltas, or they end up in the mapping framework (at least, attached to the mapping framework as a second step) in a way that prevents it from being stateless. It sounds like you're leaning towards the former as preferable?</p>",
        "id": 159029393,
        "sender_full_name": "Paul Church",
        "timestamp": 1550709975
    },
    {
        "content": "<p>well, they are dependent on the business rules of a particular input - how it manages ids etc. So they can't be in the server as a context-less operation.</p>",
        "id": 159029604,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550710268
    },
    {
        "content": "<p>and the rules have to be expressed somewhere. So they are paired with the mapping, since that's also tied to the context</p>",
        "id": 159029616,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550710291
    },
    {
        "content": "<p>I lean to the second option then, though I do not know what 'attached' means in that sense</p>",
        "id": 159029620,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1550710310
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span>  and <span class=\"user-mention\" data-user-id=\"197072\">@Paul Church</span> ,</p>\n<p>Paul, I think you nicely summarised what my first response would be to the question above (i.e. update is f(old-state, new-resources) -&gt; new-state. I have always worked with functional mappings, and so each model in or out of a transformation is immutable. That sounds very restrictive, but any two models can be related by a versioning link that says \"this is my [immutable] predecessor\", which automatically preserves the history of the updates made to any resource/model. Then a diff can be made on the two versions to see what changed (which is also invaluable when debugging complex mapping rules), or finer-grained traces can be stored, to avoid structural diffing - see below for why this might be useful.</p>\n<p>That said, there is <em>a lot</em> of research out there on bi-directional transformations and in-place updates which provide frameworks for thinking about your questions [Proceedings of the International Conference on Model Transformation - ICMT has dozens of articles over the years on these topics]. The answers are almost always not as simple as you'd like - i.e. cardinality of * may or may not have anything to do with the semantics of an update - this would need to be specified without relying on that to provide any assumptions. If 1 element is in a multi-valued slot, the * cardinality says nothing about whether it should be added to or replaced. That is in the semantics of the update, and would be explicitly specified in the mapping. (Conversely, a cardinality of 1 with a mapping rule that tries to add an additional element should raise an exception, rather than just be assumed to be a replacement for previous single element.) </p>\n<p>Another issue to think about is that a container with a simple value in it may change, based on new inputs, and a simple structural comparison may make it seem that no update was made, e.g. in the case: <br>\n{x:112[n:1, name:\"smith], x:113[n:3, name:\"jones]} -&gt; forall x.n set n=1 -&gt; {x:112[n:1, name:\"smith\"], x:113[n:1, name:\"jones]} <br>\nThe value of n in x:113 has clearly been updated from 3 to 1, but n in x:112 _has also_ been updated, from 1 to 1, and this should preferably be recorded in the transformation \"diff\"(or trace) rather than relying on simple structural comparisons. Implementations I have been involved in will keep a trace between each pair of changed values in 2 immutable versions of a model, regardless of whether the change resulted in a simple value update or not. </p>\n<p>Of course, the value of this trace information depends greatly on what the semantics of x and n are and why we want to know that they've been transformed, and when (even if it's incidentally an identity transformation). But in something as generic and wide ranging as a FHIR resource model, there will almost always be some use case for this.</p>",
        "id": 159033862,
        "sender_full_name": "Keith Duddy",
        "timestamp": 1550715593
    },
    {
        "content": "<p>[Aside to the in-place update approaches: my experience, at least in the group that worked on QVT at OMG was that the in-place-update people were mostly Telecoms or SCADA people who had to push tiny new bits of state into devices with limited expensive persistent memory, which could not possibly store all previous states, and would sometimes change state at mircosecond scale intervals... perhaps this will also be true of some medical equipment that will push out small resources using FHIR (or consume sensor data structures, or whatever). However, my impression in the main is that a FHIR resource will mostly be supported by a modern n-tier server, with the processing and storage capacity to keep all relevant [immutable copies of] state, and links between them at various granularities.]</p>",
        "id": 159035253,
        "sender_full_name": "Keith Duddy",
        "timestamp": 1550717287
    }
]