[
    {
        "content": "<p>During yesterday's FHIR-I call, we discussed issue <a href=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=22774\" target=\"_blank\" title=\"http://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&amp;tracker_item_id=22774\">GF#22774</a> (Document support for implicit casts in mapping language), which basically asks us to be explicit about what happens in mapping language statements like these</p>\n<p>tgt.active = true<br>\ntgt.url = '<a href=\"http://bla.org\" target=\"_blank\" title=\"http://bla.org\">http://bla.org</a>'</p>\n<p>Although these assignments look obvious (which is why we would love to keep them this way), they implicitly require a cast from a \"system\" primitive (a bool and a string here) and some datatype in the target model (here FHIR string and FHIR uri).  It's not obvious from the current documentation which casts are allowed (could you assign an integer value to a decimal for example?) and how the engine could ask the target model to 'execute' these casts .</p>\n<p>The current documentation suggests that the engine can ask the model to create an instance of any target type, but it would need more knowledge about the model to know that it represents a primitive value. It may then assume the target instance has a \"value\" that it can assign the primitive to. As I stated before, the alternative is that the target model itself runs the casts, which would require some kind of \"instantiate and initialize\" callback into the target model, passing in the primitive value.</p>\n<p>For now, my mapping engine requires you to explicitly call a constructor function like so:</p>\n<p>tgt.active = bool(true)<br>\ntgt.url = uri('<a href=\"http://bla.org\" target=\"_blank\" title=\"http://bla.org\">http://bla.org</a>')</p>\n<p>which assumes the target model installs these custom extension functions into the language.  I really don't like it, so I am interested to discuss better approaches.</p>",
        "id": 173097709,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1565687349
    },
    {
        "content": "<p>In CQL we support model-defined implicit conversions, so that we can say <code>tgt.url = 'http://bla.org'</code>. In the CQL case, that's an expression, so what's happening is the <code>tgt.url</code> is being implicitly converted to a string, so it's equivalent to saying <code>tgt.url.value = 'http://bla.org'</code>. It requires context for the compiler to be able to infer the appropriate conversion, so there are cases where it doesn't apply (e.g. in a sort clause) but in general it works quite well.</p>",
        "id": 173132890,
        "sender_full_name": "Bryn Rhodes",
        "timestamp": 1565716977
    },
    {
        "content": "<p>so I think that we should be explicit that in FHIRPath, assignments are allowed that involve implicit conversions between types, and that it's the underlying type definitions that define what type conversions are possible. </p>\n<p>Then, in FHIR, we'll have to figure out how to document what type conversions are possible, and how they work</p>",
        "id": 173259430,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1565834772
    },
    {
        "content": "<p>Internally in the .NET FHIR API I am introducing the difference between \"FHIR.string\" and \"System.String\", which was implicit so far.  I would be helpful if we could tag the 'value' attributes in the definitions of the FHIR primitives so it mentions \"System.String\".</p>",
        "id": 173526506,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1566204365
    },
    {
        "content": "<p>see the discussion on the <a class=\"stream\" data-stream-id=\"179177\" href=\"/#narrow/stream/179177-conformance\">#conformance</a> channel right now</p>",
        "id": 173530123,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1566207973
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"191328\">@Ewout Kramer</span> -- Maybe I am missing something obvious, but the grammar defines several types for literals (integer, number, string, datetime, time, bool). In my experimentation, I rely on the parser and use the appropriate type coercion in my engine's implementation language. So if the parser tells me the literal is a kind of BOOL, I don't think I need more explicit instructions... Currently there doesn't seem to be a literal for URI data type defined in the grammar.</p>",
        "id": 173670388,
        "sender_full_name": "Brian Kaney",
        "timestamp": 1566316657
    },
    {
        "content": "<p>You do need more information, since it is at present unknown how to get from a BOOL (which is of type System.Bool) to a FHIR Bool instance (of type FHIR.bool) - unless all your models target FHIR, in which case you can hard-wire these conversions.  E.g. if the target is V2, what would the assignment do?</p>",
        "id": 173671165,
        "sender_full_name": "Ewout Kramer",
        "timestamp": 1566317173
    },
    {
        "content": "<p>I see, I am thinking all FHIR atm.</p>",
        "id": 173671365,
        "sender_full_name": "Brian Kaney",
        "timestamp": 1566317343
    }
]