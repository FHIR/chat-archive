[
    {
        "content": "<p>Hi everyone, we are currently using the mapping language very extensively to map from different source formats to FHIR and back, for instance CSV, v2, vcf and custom json. During development of these maps, we ran into syntactic and semantic limits of the Mapping Language in quite a few cases. As far as I understood, the mapping language was originally intended to map from FHIR to FHIR so it comes as no surprise that this was the case. I was wondering whether this is still the desired use case or if there are some pushes to also use the language for other formats apart from FHIR?</p>\n<p>If so, I would be happy to share some of the experience from the past couple of months. We identified a few concepts that we needed in a lot of cases for the mappings.</p>",
        "id": 218991065,
        "sender_full_name": "Yannick Börner",
        "timestamp": 1607267839
    },
    {
        "content": "<p>we use the FHIR mapping language for CDA to FHIR (and back) and for other non-FHIR based formats to FHIR, so we would be very interested in your experiences!</p>",
        "id": 218991915,
        "sender_full_name": "Oliver Egger",
        "timestamp": 1607269220
    },
    {
        "content": "<p>Improvement is always welcome.  Share away!</p>",
        "id": 218992186,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1607269656
    },
    {
        "content": "<p>Eager for such experiences<span aria-label=\"clap\" class=\"emoji emoji-1f44f\" role=\"img\" title=\"clap\">:clap:</span></p>",
        "id": 219030088,
        "sender_full_name": "Lin Zhang",
        "timestamp": 1607297925
    },
    {
        "content": "<p>To start, I'll just share some key concepts that we needed in many cases:</p>\n<p><strong>1. Global and local let-statements</strong><br>\nThis is kind of the aforementioned let-statement discussed by <span class=\"user-mention\" data-user-id=\"193430\">@Alexander Zautke</span>  above. It is a variable you can store resources or primitive values in. We implemented it and it proved to be vital in quite a few situations. Currently, it is a local statement but an additional global statement would be even more helpful. A few use cases: </p>\n<ul>\n<li>Reusing extracted values in many different places (global and local)</li>\n<li>Defining constants (global)</li>\n<li>We currently use it to fake an if condition (see below) (local)</li>\n<li>Easy reuse of parameters between groups (global)</li>\n<li>Quickly creating copies of resources that are only slightly different from the original (local)</li>\n</ul>\n<p><strong>2. If condition</strong><br>\nThis was mainly used to check if a value exists and then proceed with some operation. The first question that might arise might be: \"Why didn't you just use 'where' conditions with FHIR Path?\" and the answer would be: \"These were situations where if one or more of multiple values  exists, it should proceed only once, for instance with creating a resource. The 'where' conditions would force a foreach-loop on us that executes for every true condition in a chained condition.\" This is our current workaround for this very case: </p>\n<div class=\"codehilite\"><pre><span></span><code>// Check whether resource should be created\nlet resourceShouldBeCreated = create(&#39;Boolean&#39;);\noperations then SetBooleanToFalse(operations, resourceShouldBeCreated);\n\noperations.data as data, data.values as values where &quot;blockindex = 0 and groupindex = 0 and itemid = &#39;id_ba_siteid&#39;\n                                    or blockindex = 2 and groupindex = 0 and itemid = &#39;id_2435&#39;\n                                    or blockindex = 2 and groupindex = 0 and itemid = &#39;id_2458&#39;&quot; then\n{\n    operations then SetBooleanToTrue(operations, resourceShouldBeCreated);\n};\n\noperations where &quot;%resourceShouldBeCreated.valueBoolean = true&quot; -&gt; ...\n</code></pre></div>\n<p>With an if-condition that executes a single time and evaluates if 'at least one of the conditions is true', this would be way more readable and maintainable and there would be no need for the let statement.</p>\n<p><strong>3. For loop with index</strong><br>\nIn real-world applications, you often use an index within data. Especially if the data has no hierarchy. The FHIR Mapping Language currently does not support something like this. Again, we used our let-statement as a workaround: </p>\n<div class=\"codehilite\"><pre><span></span><code>let index = create(&#39;RepeatIndex&#39;);\nsrc then InitIndex(src, index);\nsrc.fields as fields, fields where &quot;id = &#39;field-&#39; +  %index.Index.toString()&quot;\n{\n    src then IncrementCaseIndex(src, index);\n};\n</code></pre></div>\n<p>This works, however a proper for loop with a built-in index would be preferable for improved readability and less overhead with the let statement and inclusion of FHIR Path.</p>\n<p>What do you think about these issues? Have you encountered something similar? <span class=\"user-mention\" data-user-id=\"191478\">@Oliver Egger</span> Did you run into any limitations yet during CDA mappings?</p>",
        "id": 219057817,
        "sender_full_name": "Yannick Börner",
        "timestamp": 1607333749
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193934\">@Keith Duddy</span> interested in your comments</p>",
        "id": 219059609,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1607334908
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260054\">@Yannick Börner</span> the fact that there is no sequence in the language is key to a number of implementation features, including the ability to run the transform at the meta level</p>",
        "id": 219059668,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1607334945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> <a href=\"#narrow/stream/181579-mapping-framework/topic/FHIR.20Mapping.20language.20in.20real.20world.20applications/near/219059668\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"260054\">Yannick Börner</span> the fact that there is no sequence in the language is key to a number of implementation features, including the ability to run the transform at the meta level</p>\n</blockquote>\n<p>Explaining the presence of something with the absence of something else is nearly spiritual. And Yes, It’s easier to say what declarative programming is not than to say what it is. But does that really help? So are you saying that we are abusing the language by doing the things we are doing with it? do you see such cases covered with the approach taken with XSLT extensions? More generally: Where do you see this thing going? What's the plan?</p>",
        "id": 219179130,
        "sender_full_name": "Gustav Vella",
        "timestamp": 1607413633
    },
    {
        "content": "<p>Thanks for calling me out Grahame - I get emails when @ named, as I'd been out of touch with the Mapping Language's progress for some time.</p>\n<p>For context, I should first say that Grahame's ambition for the language was to allow for mapping between FHIR &amp; FHIR, but also to allow for any tree structured inputs and outputs to be possible, as long as the engine could deduce the correct structural match between a FHIR resource and, say, an XML document tree, or HL7 CDA document tree. Having come from the UML/MOF world, with my experience of the QVT language(s), I had limited myself to thinking only about transformations between metamodels expressed in the same (meta)language (effectively Eclipse Modelling Framework -EMF, which implements EMOF). But if source and target models are all structured as trees, then I could find no reason why an engine implementation couldn't create them with assumed equivalences between the element containment for the tree structure in any input or output format. I know one of Grahame's early prototypes allowed FHIR to XML mappings (and vice versa?).</p>\n<p><span class=\"user-mention\" data-user-id=\"260054\">@Yannick Börner</span> , I can see the usefulness of having \"let\" variable declarations. In the equivalent concept to \"group\" in the QVT language, e.g.</p>\n<p>group tutorial(source src : TLeft, target tgt : TRight)</p>\n<p>QVT has a \"relation\", and it allows for any number of variables to be declared, which would include both the source and target (or sometimes for building intermediate structure, not even any target, just a built up runtime relation that could be looked up in another rule). This example includes source, 2 variables and target: </p>\n<p>(this relation assumes that an \"empty\" T is already created for every S in a AnSforEachT relation/rule)</p>\n<p>relation PopLowerAndUpperTfromS(src : Tleft, var1 : int, var2 : int, tgt: TRight) {</p>\n<p>forall  S:SomeType in src, T:TgtType in tgt<br>\n    where AnSforEachT(S, T) and<br>\n                  S .interestingValue &lt; 10 and S.interestingValue &gt; 4<br>\n    make var1 = S .interestingValue and<br>\n                 var2 = interestingValue + 12 and<br>\n                 T.lower = var1 and         // or T.lower = S.interstingValue<br>\n                 T.upper = var2<br>\n}<br>\n[sorry for the poor psuedo-syntax for QVT - it's been a while]</p>\n<p>Then upon population of T.lower and T.upper, the engine would store a trace relation for each unique matching S:SomeType in src: </p>\n<p>[I use @ to mean \"pointer-to\"]</p>\n<p>(@SomeS, 6, 18, @Sometgt)<br>\n(@AnotherS, 4, 16, @Anothertgt)</p>\n<p>etc... so that after the transformation runs, you can see which S in src matched, and what values were transferred to the target, without having to follow the pointers in the S and T to see the results.</p>\n<p>As you can see, in the rule body, vaibles are really syntactic sugar, as I could have just spelled out the expressions assigned to var1 and var2 in each part of the rule expression - the main point was to store derived values calculated during execution in the traces. Then other rules/relations could make use of them later, by binding them to declared variables: [Here \"_\" means we don't care what the value in a stored relation trace is.]</p>\n<p>relation HighRangeKfromS(src : Tleft, tgt: TRight) {<br>\n    let upper: int;<br>\n    forall S:SomeType in src, K:RelatedType in tgt<br>\n    where SrelatedToK(S, K) and<br>\n                  PopLowerAndUpperTfromS(S, _, upper, _) and <br>\n                  upper &gt; 15<br>\n    make K.isHighRange = true<br>\n}</p>\n<p>We allowed declaration of as many variables as you wanted inside relations, with \"let\" declarations (like \"upper\" above). These also had to be used to check the index of a list, for example to make sure you didn't map the same element in a list twice. As there was no iteration, this was probably a bit clumsy, and had to rely on the index being embedded in a trace relation, but serves a similar purpose to your use of \"let\" declared variables.</p>\n<p>I can't recall any global variables - which may have been useful for constants, but because the engine determined the order of execution of rules, based on dependency analysis, I don't think we could have depended on the state of anything global if there were multiple possible rule execution orders implied by the structure. e.g. if \"SomeS\" was matched first, then setting a global variable based on the values of SomeS would yield a different outcome than if \"AnotherS\" was matched first.</p>\n<p>I don't know if that's helpful, as I'm afraid I don't know what the current engine implementations do, and I had a quick look at the latest state of the Tutorial, but Group if left TBD...</p>\n<p>cheers,<br>\n...|&lt;</p>",
        "id": 219180664,
        "sender_full_name": "Keith Duddy",
        "timestamp": 1607415065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> <a href=\"#narrow/stream/181579-mapping-framework/topic/FHIR.20Mapping.20language.20in.20real.20world.20applications/near/219059668\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"260054\">Yannick Börner</span> the fact that there is no sequence in the language is key to a number of implementation features, including the ability to run the transform at the meta level</p>\n</blockquote>\n<p>I see the point here but I fear this restriction could hinder wider adoption for the use cases I described above. Especially when dealing with larger datasets sometimes you simply have to be aware of your current position within the data. Could you elaborate on the transformation at the meta level? I have no experience regarding this and would like to understand the use case.</p>",
        "id": 219189112,
        "sender_full_name": "Yannick Börner",
        "timestamp": 1607421593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193934\">@Keith Duddy</span> That is an interesting take on the concepts I mentioned from the view of QVT. Global let statements would require the engine to employ delayed execution to make sure one already has an instance of the constant available on your syntax tree for example. There are quite a lot of strings attached to this, so let's throw this idea overboard for now. </p>\n<p>As far as I can tell, we both agree that local let statements are indeed helpful and you employed them as well in the QVT language. <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> Do you see any huge red flags that would prevent the local let statement from being added to the standard?</p>",
        "id": 219204558,
        "sender_full_name": "Yannick Börner",
        "timestamp": 1607433194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260054\">Yannick Börner</span> <a href=\"#narrow/stream/181579-mapping-framework/topic/FHIR.20Mapping.20language.20in.20real.20world.20applications/near/219204558\">said</a>:</p>\n<blockquote>\n<p>As far as I can tell, we both agree that local let statements are indeed helpful and you employed them as well in the QVT language. <span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> Do you see any huge red flags that would prevent the local let statement from being added to the standard?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"260054\">@Yannick Börner</span> since there seems to be some consensus here on the local let statement the best way to go is to submit a request: <a href=\"https://jira.hl7.org\">https://jira.hl7.org</a></p>",
        "id": 219580200,
        "sender_full_name": "Gustav Vella",
        "timestamp": 1607678116
    },
    {
        "content": "<p>there is already a ticket for that and was voted on and  set to resolved - change required ... see <a href=\"https://jira.hl7.org/browse/FHIR-21642\">https://jira.hl7.org/browse/FHIR-21642</a></p>",
        "id": 219702168,
        "sender_full_name": "Oliver Egger",
        "timestamp": 1607769456
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191478\">@Oliver Egger</span> The resolution of that ticket states that the let statement can only be used on top of the mapping file, meaning that we couldn't have local let statements. </p>\n<p>So what I'm reading from the messages above is that instead of introducing local let statements, they should rather be (primitive) targets of a group, correct? <span class=\"user-mention\" data-user-id=\"260054\">@Yannick Börner</span> What that work for you, too?</p>",
        "id": 219953895,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1608024647
    },
    {
        "content": "<p>Hi There, <span class=\"user-mention\" data-user-id=\"191478\">@Oliver Egger</span>  thanks. I was unsure whether I understood correctly but <span class=\"user-mention\" data-user-id=\"193430\">@Alexander Zautke</span> confirmed the scope of that ticket. Also thanks to <span class=\"user-mention\" data-user-id=\"193934\">@Keith Duddy</span> for that very insightful feedback. We at Healex were considering having a call to discuss the problematic cases  / limitations  encountered - <span class=\"user-mention\" data-user-id=\"260054\">@Yannick Börner</span> only shared one issue - and the specific suggestions proposed here coming Monday/Tuesday, December 21st/22nd 2020.  That would be Mo 21:00h (Berlin),   Mo 15:00h (Boston) and Tue 07:00h (Sydney). Would there be interest to join that call? If so just a thumbs up and I'll share the Teams invitation. The choice of timeslot is the only inclusive slot suitable a 3 continent call (leaving some chance for  <span class=\"user-mention\" data-user-id=\"191316\">@Grahame Grieve</span> joining)</p>",
        "id": 220031761,
        "sender_full_name": "Gustav Vella",
        "timestamp": 1608061504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"193430\">Alexander Zautke</span> <a href=\"#narrow/stream/181579-mapping-framework/topic/FHIR.20Mapping.20language.20in.20real.20world.20applications/near/219953895\">said</a>:</p>\n<blockquote>\n<p>The resolution of that ticket states that the let statement can only be used on top of the mapping file, meaning that we couldn't have local let statements. </p>\n</blockquote>\n<p>I agree, sorry, i didn't  note the subtle change in resolution ...</p>",
        "id": 220042028,
        "sender_full_name": "Oliver Egger",
        "timestamp": 1608066206
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"194020\">@Gustav Vella</span> Sounds good!</p>",
        "id": 220080026,
        "sender_full_name": "Yannick Börner",
        "timestamp": 1608097631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"193430\">@Alexander Zautke</span> With regards to the difficulties as discussed by Keith, I think local let statements are the way to go at first. They are easier to implement and introduce next to no issues. However, a global let statement would be great as well as it would allow for constants and shared variables between groups. It would need to be thought through meticulously though as previously mentioned.</p>",
        "id": 220080492,
        "sender_full_name": "Yannick Börner",
        "timestamp": 1608098177
    },
    {
        "content": "<p>Not answer to the question that I asked ;) We have now a ticket that has been voted on with a clear resolution. Before we try to add new features, I would like to evaluate the current limitations. What would not be possible if we use the empty target variables instead of local let statements?</p>",
        "id": 220241818,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1608211206
    },
    {
        "content": "<p>Regardless of how easy it seems to implement it...</p>",
        "id": 220241857,
        "sender_full_name": "Alexander Zautke",
        "timestamp": 1608211231
    },
    {
        "content": "<p>Ha, you're right <span class=\"user-mention\" data-user-id=\"193430\">@Alexander Zautke</span>! I do think the functionality could be substituted with target variables. However, for nested group calls, it'll become a parameter nightmare. You would have to pass a parameter for each target variable through the entire execution chain. Though it should work, it will make the maps extremely bloated. </p>\n<p>A target with a custom structure definition holding multiple variables at once could be feasible in this case. But that is not really a clean solution either.</p>",
        "id": 220253479,
        "sender_full_name": "Yannick Börner",
        "timestamp": 1608217312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"194020\">Gustav Vella</span> <a href=\"#narrow/stream/181579-mapping-framework/topic/FHIR.20Mapping.20language.20in.20real.20world.20applications/near/220031761\">said</a>:</p>\n<blockquote>\n<p>We at Healex were considering having a call to discuss the problematic cases  / limitations  encountered - <span class=\"user-mention silent\" data-user-id=\"260054\">Yannick Börner</span> only shared one issue - and the specific suggestions proposed here coming Monday/Tuesday, December 21st/22nd 2020.  That would be Mo 21:00h (Berlin),    Mo 15:00h (Boston) and Tue 07:00h (Sydney). Would there be interest to join that call? If so just a thumbs up and I'll share the Teams invitation. The choice of timeslot is the only inclusive slot suitable a 3 continent call (leaving some chance for  <span class=\"user-mention silent\" data-user-id=\"191316\">Grahame Grieve</span> joining)</p>\n</blockquote>\n<p>As promised, here's the link for tomorrow's call  <a href=\"https://teams.microsoft.com/l/meetup-join/19%3ameeting_ZDY5NmE0YzctZDM5My00OWYxLTlhNjctY2IyMDUzOThjM2Uy%40thread.v2/0?context=%7b%22Tid%22%3a%22f09354e8-9d00-42a1-98c8-58639e2a8f91%22%2c%22Oid%22%3a%227a865118-743f-4058-ab6a-0b9cae52d351%22%7d\">https://teams.microsoft.com/l/meetup-join/19%3ameeting_ZDY5NmE0YzctZDM5My00OWYxLTlhNjctY2IyMDUzOThjM2Uy%40thread.v2/0?context=%7b%22Tid%22%3a%22f09354e8-9d00-42a1-98c8-58639e2a8f91%22%2c%22Oid%22%3a%227a865118-743f-4058-ab6a-0b9cae52d351%22%7d</a>  </p>\n<p>Anyone wishing to can join.</p>",
        "id": 220532476,
        "sender_full_name": "Gustav Vella",
        "timestamp": 1608491187
    }
]