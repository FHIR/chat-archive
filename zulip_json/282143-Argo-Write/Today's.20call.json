[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"418896\">@Mike Lohmeier</span> would love to hear the comment you were starting to make on today's call!</p>",
        "id": 244464479,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625076205
    },
    {
        "content": "<p>lol, thanks. I didn't realize we were over time already.</p>\n<p>A lot of the discussion today was around the classic IoT problem of system responsiveness with device I/O. Generally speaking, most IoT systems disconnect the device I/O from the application API and make the interactions asynchronous for the following reasons:</p>\n<ol>\n<li>Devices are usually highly constrained and on unreliable hardware and networks. Rule of thumb is to get data off of small iron and onto big iron as fast and furious as possible. This is even true for mobile devices where carrier networks are unreliable and storage is compact flash.</li>\n<li>There are going to be issues in the field that are not instantaneously solvable. So, frameworks for resolving issues in the field server side for any combination of product, lot or firmware version are invaluable. Issues in mobile app code or firmware will be in the field until an update is installed where even the most optimistic path, mobile auto-update,  will be days to get a large percent of the user base updated and have a long tail in months or years.</li>\n<li>A single signal from device data will typically generate n number of application API writes and the rules powering writes change frequently. For example, the blood pressure cuff could not only write the Observation but a DetectedIssue if it passes a threshold. Typically, these rules change very frequently and are dynamic so embedding them into a mobile app or firmware will make it very difficult to change. Also, writing all of these records using a single transaction keeps the consistency either all correct or all incorrect in regards to the single device interaction.</li>\n<li>Scalability of the transaction processing is limited by the data store. Ingress device data adds up quick and even at very low numbers it will have a direct impact on the behavior of an Application API when using a shared datastore. For implementations on shared relational datastores that use ATOMIC writes, the penalty will be seen through higher API response times and eventually timeouts. Implementations using NoSQL, are already accepting async writes through eventual consistency and will have the correctness problem until all nodes are written. The NoSQL asynchronous writes are easier hidden but still there.</li>\n</ol>\n<p>These are some of the technical reasons that have lead to asynchronous IoT gateways that separate ingress data ACKing, workflows and robust device management frameworks. It looks like the indirect option is the start of an asynchronous IoT gateway that leverages the Task resource's workflow capabilities so it seems like it's on the right track.</p>\n<p>I'll also echo a lot of the comments from the gentleman from Duke about impedance mismatches with device data and providers. We saw similar things at Propeller where the standard of care for asthma did not match reality once it was measured. For example, most providers believed that asthmatics are having asthma attacks in low numbers between yearly visits. So, for integration they typically wanted all remotely sensed asthma attacks on the patient's chart. What they quickly learned was that asthmatics have a lot of asthma attacks and would walk back wanting all the records and wanted summaries instead.</p>",
        "id": 244471185,
        "sender_full_name": "Mike Lohmeier",
        "timestamp": 1625079213
    },
    {
        "content": "<p>Thanks for these thoughts! I'll note that the <em>technical use cases</em> for async behavior (e.g., desire for queue-based processing models) may be quite different than <em>clinical use cases</em> for async behavior (e.g., desire for review). Capturing details in a \"Task\" might make sense when there's a person / clinical workflow involved, but for \"purely techinical async handling\" we might want something lower level (e.g., negotiation with <code>Prefer: respond-async</code>, and a set of conventions around this; was discussing this with Gino and Carl from my team at MS earlier today).</p>",
        "id": 244474067,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625080639
    },
    {
        "content": "<p>No problem, it's awesome to see this get some traction. Let me know if there's anything I can help with.</p>",
        "id": 244485368,
        "sender_full_name": "Mike Lohmeier",
        "timestamp": 1625085992
    },
    {
        "content": "<p>The Devices workgroup should be involved.  They have projects like Mike is explaining that are spanning multiple standards bodies.</p>",
        "id": 245025125,
        "sender_full_name": "John Moehrke",
        "timestamp": 1625570949
    }
]