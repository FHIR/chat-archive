[
    {
        "content": "<p>We've talked about use cases that suggest functional requirement like:</p>\n<ul>\n<li>in some cases data should be reviewed before being finalized in the system of record; </li>\n<li>in some cases data should flow directly into the system of record</li>\n<li>in all cases, clients should be able to tell the status of their submission</li>\n<li>in all cases, authorized parties should be able to see submitted data and incorporate it into CDS, etc</li>\n</ul>\n<p>One example of flexible policy to support these requirements might be saying: some clients are only permitted to submit Observations with status=<code>preliminary</code>, or should expect the EHR to <em>reset</em> any submitted data to have status=<code>preliminary</code>; subsequently the EHR can transition these to <code>final</code> or <code>canceled</code> (which could be automatic/instantaneous, or could happen asynchronously). Other clients might be permitted to submit <code>final</code> results directly.</p>",
        "id": 237539203,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620237615
    },
    {
        "content": "<p>Using existing status properties would be overloading the meaning of those properties (at least in most cases I can think of).  You might have an Observation that moves from prelim to final to amended independent of the holding tank transition.</p>",
        "id": 237558436,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1620245758
    },
    {
        "content": "<p>I do get hung up on the point of making a clear line between system of record vs. holding tank.  We (Epic) do have that model today, but we are actively working to \"blur\" the lines in that model.  Our goal is to have data be displayed and used across the system regardless of which data store it is in.  The data is annotated differently for end users, and potentially weighted differently for automated processes.  Information automatically derived from unreviewed data may inherit annotations.  But it's all \"in the EHR\".</p>",
        "id": 237560858,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1620246901
    },
    {
        "content": "<p>Alternative functional requirements might be:</p>\n<ul>\n<li>Data submitted to an EHR MAY need review before it used for some purposes.</li>\n<li>Unreviewed data MAY be used or annotated differently within the EHR.</li>\n<li>Submitting clients SHOULD (SHALL?) be able to interact with submitted data normally over the API, regardless of review status.</li>\n<li>Non-submitter clients MAY  be able to interact with submitted (possibly annotated) data normally over the API.</li>\n</ul>",
        "id": 237561746,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1620247258
    },
    {
        "content": "<p>Yeah, I don't want to over-index on (or overload) existing statuses; just trying to sketch out the kind of interface we could provide (with existing or new properties to support it).</p>\n<p>Re: functional requirements you've listed, Cooper:</p>\n<ol>\n<li>\n<p>These would leave submitting clients with no way to tell the review status of their submissions -- do you want to add something to address this, or is the gap intentional?</p>\n</li>\n<li>\n<p>when you say \"interact... normally over the API\", is this <em>implying</em> that the API endpoints are the same? Like, the submitted resources are, right from the start, visible under \"GET Observation?patient=123\" in the same FHIR endpoint where US Core read access is supported?</p>\n</li>\n</ol>",
        "id": 237567191,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620248974
    },
    {
        "content": "<p>Assuming half of this doesn't matter to the client and most end user are going to send it and forget it.  I don't even know if we should try to enumerate all these fine-grained functional requirements upfront.   Why not just do the write and then get an operation outcome that points to a url that you can check on the status of these things, if you care. (kinda like what bulk does)</p>\n<p><a href=\"/user_uploads/10155/U50gINxlK_0Uj6a8ZVEk3E_L/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/10155/U50gINxlK_0Uj6a8ZVEk3E_L/image.png\" title=\"image.png\"><img src=\"/user_uploads/10155/U50gINxlK_0Uj6a8ZVEk3E_L/image.png\"></a></div><p>So if submitting clients SHOULD (SHALL?) be able to get the data.  if they can't  then they go \"what the hell?... oh s*** where is that url again???\"</p>",
        "id": 237591951,
        "sender_full_name": "Eric Haas",
        "timestamp": 1620264845
    },
    {
        "content": "<blockquote>\n<p>I don't even know if we should try to enumerate all these fine-grained functional requirements upfront.</p>\n</blockquote>\n<p>Agreeing on the requirements is how we'll assess whether an API proposal meets them ;-)</p>",
        "id": 237592229,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620265116
    },
    {
        "content": "<blockquote>\n<p>Why not just do the write and then get an operation outcome that points to a url that you can check on the status of these things, if you care. (kinda like what bulk does)</p>\n</blockquote>\n<p>Does \"do the write\" mean just \"POST Observation\" to the regular FHIR API endpoint? If so, we'd need to define new async semantics for POSTing a resource in FHIR, and define the status API, state machine, etc for how you \"check on the status\". That's all fine, if we need asynchronous pre-acceptance review. It's structurally <em>very</em> similar to using a Task (and indeed, if we were going to go this route, I'd suggest Task is a good fit).</p>",
        "id": 237592409,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620265278
    },
    {
        "content": "<blockquote>\n<p>That's all fine, if we need asynchronous pre-acceptance review. It's structurally very similar to using a Task (and indeed, if we were going to go this route, I'd suggest Task is a good fit).</p>\n</blockquote>\n<p>What I heard today was that yes we wanted to know the status on the write.  I don't  see how checking on status can be synchonrous or not require human intervention and I made the same point as above in two weeks ago in my notes on patterns.   But, I sense reluctance to using Task.</p>",
        "id": 237598692,
        "sender_full_name": "Eric Haas",
        "timestamp": 1620270597
    },
    {
        "content": "<blockquote>\n<p>Does \"do the write\" mean just \"POST Observation\" to the regular FHIR API endpoint?</p>\n</blockquote>\n<p>The survey showed nobody is doing this.   ( I thought it sounded reasonable but it went over like a lead balloon) and does it solve anything on status updates?</p>",
        "id": 237598997,
        "sender_full_name": "Eric Haas",
        "timestamp": 1620270869
    },
    {
        "content": "<p>Trying to define all the nuanced different write types is like catching a greased pig.  we come up with different variations each week.</p>",
        "id": 237599135,
        "sender_full_name": "Eric Haas",
        "timestamp": 1620271042
    },
    {
        "content": "<p>We kind of agreed that the writer should be able to fetch it. but beyond that I don't know what we got.</p>",
        "id": 237599203,
        "sender_full_name": "Eric Haas",
        "timestamp": 1620271094
    },
    {
        "content": "<ul>\n<li>sometimes it is reviewed, sometimes not</li>\n<li>sometimes it is accessible and used by others sometimes not</li>\n<li>it may be annoted as unreviewed</li>\n</ul>",
        "id": 237599421,
        "sender_full_name": "Eric Haas",
        "timestamp": 1620271285
    },
    {
        "content": "<p>I think the easiest way to say it is that clients need to be able to understand disposition -- if something has been incorporated into the EHR, or rejected from it, or is still in limbo.</p>",
        "id": 237601657,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620273403
    },
    {
        "content": "<p>AuditEvent or Provenance can do that.</p>",
        "id": 237648594,
        "sender_full_name": "John Moehrke",
        "timestamp": 1620303783
    },
    {
        "content": "<p>I think we should have a logical distinction between the read-from-EHR and the write-to-EHR. Some might have one endpoint, others different. but logically treating them that way will work for both kinds.</p>",
        "id": 237648679,
        "sender_full_name": "John Moehrke",
        "timestamp": 1620303840
    },
    {
        "content": "<p>Was there discussion of how it might look different when the holding-tank is a (a) stepping stone where the data are copied to a final resting place where clinicians use them and thus a patient read would find them, from (b) the final resting place where clinicians see/use them there.  REST should not care, but in the (a) case the write response location might not be the final location, so patient write app might get confused if it persists as full URLs the write response id.</p>",
        "id": 237649162,
        "sender_full_name": "John Moehrke",
        "timestamp": 1620304062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191404\">John Moehrke</span> <a href=\"#narrow/stream/282143-Argo-Write/topic/Write.20APIs.20for.20different.20functional.20requirements/near/237649162\">said</a>:</p>\n<blockquote>\n<p>Was there discussion of how it might look different when the holding-tank is a (a) stepping stone where the data are copied to a final resting place where clinicians use them and thus a patient read would find them, from (b) the final resting place where clinicians see/use them there.  REST should not care, but in the (a) case the write response location might not be the final location, so patient write app might get confused if it persists as full URLs the write response id.</p>\n</blockquote>\n<p>We only discussed the functional requirements</p>",
        "id": 237662673,
        "sender_full_name": "Eric Haas",
        "timestamp": 1620309734
    },
    {
        "content": "<p>I tried to explain the impact on the interface... in one case the result of a create is persistent, in the other things move.</p>",
        "id": 237665842,
        "sender_full_name": "John Moehrke",
        "timestamp": 1620310934
    }
]