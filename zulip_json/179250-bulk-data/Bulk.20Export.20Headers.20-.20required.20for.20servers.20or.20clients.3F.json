[
    {
        "content": "<p>In the export section, we list some <a href=\"http://hl7.org/fhir/uv/bulkdata/2021MAY/export.html#headers\">required headers</a>.  Are those requirements intended to be imposed on the client (the client is required to provide those values) or the servers (the server must reject requests that do not provide those headers).  I'd assume the former, where if the client doesn't provide them, the server could still accept the request and use server-defined default behavior.</p>",
        "id": 237170339,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1620052659
    },
    {
        "content": "<p>I think your interpretation is correct but we should say something about this. We should also explain what it means that only ndjson is \"supported\" (I think this means that it is the only format that a server is required to be able to produce).</p>",
        "id": 237173297,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620053775
    },
    {
        "content": "<p>Have you submitted ballot comment on this?</p>",
        "id": 237173334,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1620053792
    },
    {
        "content": "<p>Yes - I'll submit a ballot comment.  I was also asking because Inferno is validating that servers reject requests that don't have those headers, so while the ballot comment will apply to 1.1.0, I also wanted to get community input on the topic in general so that we have more information to inform my <a href=\"https://github.com/onc-healthit/inferno-program/issues/279\">github issue for Inferno</a> which applies to the 1.0.0 version.</p>",
        "id": 237175898,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1620054392
    },
    {
        "content": "<p><a href=\"http://jira.hl7.org/browse/FHIR-32062\">FHIR#32062</a></p>",
        "id": 237176871,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1620054629
    },
    {
        "content": "<p>I'm curious what others think, but since in the case of bulk export these headers are both fixed values that are there to align with FHIR patterns, it seems to me that the right behavior on the server side would be for the server to error if they're different from expected, but treat them as the defaults if omitted.</p>",
        "id": 237177807,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620054872
    },
    {
        "content": "<p>My understanding on client side requirement is that server MUST reject invalid client request if such request fails client side requirement. If we say server COULD still accept \"invalid\" client request, then such client side requirement itself is NOT required any more  For example, if we agree that if client send <code>Accept: application/xml</code>, server still shall return response using JSON format, then the requirement that client must send <code>Accept: application/json</code> does not stand anymore because server's behavior is not directly related to the validity of client request.</p>",
        "id": 237345543,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1620141809
    },
    {
        "content": "<p>In such case, we should remove these two requirement and add a requirement to kick off response section that the any response must be in JSON format.</p>",
        "id": 237346843,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1620142309
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191506\">@Yunwei Wang</span> I certainly agree that a server returning a response that's counter to the provided Accept header would be confusing.</p>",
        "id": 237354916,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620145071
    },
    {
        "content": "<p>I'm proposing a something a little different:</p>",
        "id": 237354928,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620145077
    },
    {
        "content": "<ol>\n<li>If an <code>Accept: application/fhir+json</code> header is provided, the server should return a json response as requested</li>\n<li>If no <code>Accept</code> header is provided, the server should assume the defaults and return a json response</li>\n<li>If an <code>Accept: application/fhir+xml</code> header is provided and the server supports xml (not required or described by the IG, but I don't think precluded?), the server should return an xml response </li>\n<li>If an <code>Accept: application/fhir+xml</code> header is provided and the server does not support xml, the server should return an error response</li>\n</ol>",
        "id": 237355029,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620145104
    },
    {
        "content": "<p>On #2, I guess the question is if there's a downside from following <a href=\"https://en.wikipedia.org/wiki/Robustness_principle\">Postel's law</a> here :).</p>",
        "id": 237355102,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620145139
    },
    {
        "content": "<p>Also, for all of these cases, the documentation could be clearer!</p>",
        "id": 237355449,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620145272
    },
    {
        "content": "<p>I like Dan's tree, but I do have a hesitation on 2; bulk export is an expensive operation - if the data format at the end isn't usable, I think it would be better to fail early.</p>",
        "id": 237355751,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1620145381
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222054\">@Gino Canessa</span> to clarify, this header should only impact the format for the kickoff response's optional OperationOutcome message. The output format for the bulk export is defined through the <code>_outputFormat</code> parameter.</p>",
        "id": 237357287,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620145932
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191414\">@Dan Gottlieb</span> d'oh.  I blame it on being Tuesday?   Withdrawn  =)</p>",
        "id": 237357701,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1620146060
    },
    {
        "content": "<p>Ha, of course, the <code>_outputFormat</code> param is explicitly defined in the IG as defaulting to <code>application/fhir+ndjson</code> so your comment is still valid :).</p>",
        "id": 237357854,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620146123
    },
    {
        "content": "<p>I think a distinction may be that given the empahsis placed on the ndjson format in the IG and early implementations, it's reasonable to assume that if a client can't handle that format it's going to explicitly submit a different _outputFormat value that the server can then reject if it's unsupported.</p>",
        "id": 237357922,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620146149
    },
    {
        "content": "<p>The response sections</p>\n<blockquote>\n<p>Response - Success</p>\n<div class=\"codehilite\"><pre><span></span><code>HTTP Status Code of 202 Accepted\nContent-Location header with the absolute URL of an endpoint for subsequent status requests (polling location)\nOptionally, a FHIR OperationOutcome resource in the body\n</code></pre></div>\n\n<p>Response - Error (e.g., unsupported search parameter)</p>\n<div class=\"codehilite\"><pre><span></span><code>HTTP Status Code of 4XX or 5XX\nThe body SHALL be a FHIR OperationOutcome resource in JSON format\n</code></pre></div>\n\n</blockquote>\n<p>states that Error MUST have a JSON formatted body but it does not say format for optional body if Success.</p>\n<p><span class=\"user-mention\" data-user-id=\"191414\">@Dan Gottlieb</span> You decision tree is good but I think it only make it complicated. The only requirement here is that server SHALL send kick-off response with (optional) JSON body.</p>",
        "id": 237364879,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1620148812
    },
    {
        "content": "<p>Good point - if we want to allow flexibility here we'd have to change that language to something like \"The body SHALL be a FHIR OperationOutcome resource <strong>in the format requested</strong>\".</p>",
        "id": 237374134,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620152311
    },
    {
        "content": "<p>I don't feel strongly about this since I think it's reasonable to require clients and servers to only use json, but allowing different optional serialization formats if servers and clients both want to support them seems a little more in line with how other FHIR transactions work.</p>",
        "id": 237374186,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620152336
    },
    {
        "content": "<p>I believe the original intention is to simplify implementation by dealing with only one content formatting. We could say that clearly as what we did in .well-known endpoint which states that server response SHALL be JSON format.</p>",
        "id": 237381572,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1620155271
    },
    {
        "content": "<p>Agreed, and definitely don't want to describe broad support for non-json formats in the IG or remove the requirement for bulk servers to support json.</p>",
        "id": 237386826,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620157537
    },
    {
        "content": "<p>If we can do some light tweaking to the docs though,  it might be worth continuing to require json support and explicitly default to json, while still allowing other formats if both the client and server choose to support them. Whether or not we allow xml, it seems like servers that don't support it will need to reject requests for it so don't think there's any additional burden for implementors.</p>",
        "id": 237386882,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1620157563
    },
    {
        "content": "<blockquote>\n<p>Whether or not we allow xml, it seems like servers that don't support it will need to reject requests for it so don't think there's any additional burden for implementors</p>\n</blockquote>\n<p>Do they need to reject it, or can they simply ignore it and send back application/fhir+json?  FHIR uses <a href=\"https://www.hl7.org/fhir/http.html#mime-type\">imprecise language</a> here \"406 Not Acceptable is the appropriate response when the Accept header requests a format that the server does not support\".  Is \"appropriate\" a SHALL or a SHOULD?  It points to <a href=\"https://tools.ietf.org/html/rfc7231#section-3.4\">RFC7231</a>, but that has language in multiple places stating that a server may decide to send back content that doesn't match what was requested in the Accept header, so the client needs to be prepared for that.</p>",
        "id": 237520757,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1620230446
    },
    {
        "content": "<p>With my EHR developer hat on, I wonder if it is reasonable to have some relaxed checks in Inferno (BDE-04 and BDE05) for this section of the Bulk FHIR spec, given it's ambiguity?    This thread so far has focused on what the right long term solution is, but that would involve an update to a future version (and SVAP).  For the purposes of validating Bulk FHIR 1.0.1, could/should we just use the most permissive interpretation of the ambiguous parts of the spec?</p>",
        "id": 242771570,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1623779020
    },
    {
        "content": "<blockquote>\n<p>For the purposes of validating Bulk FHIR 1.0.1, could/should we just use the most permissive interpretation of the ambiguous parts of the spec?</p>\n</blockquote>\n<p>This is something we had intended to do when we started writing tests, but have found that there are quite a few ambiguities in the specs when you look extremely closely at them.  And if you backed off testing anything that somebody thinks is ambiguous, you end up with “passing” implementations that clearly do not meet the intention of the spec.  So I think there needs to be some judgement involved.</p>",
        "id": 242909746,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1623862561
    },
    {
        "content": "<p>I’m not saying we shouldn’t remove these tests in this case, just that as a general practice we don’t immediately remove tests when presented different interpretations of what is written in the spec.</p>",
        "id": 242909831,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1623862587
    },
    {
        "content": "<p>For this case in particular, if there is consensus on the correct behavior here, and that differs than what we are doing, then as long as it doesn’t impact ONC’s needs for the spec we can probably just remove the test.  I’m not seeing consensus though.</p>",
        "id": 242909866,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1623862620
    },
    {
        "content": "<p>The consensus could be “it isn’t a requirement in this version, and will consider it for the next version”.  It helps us justify removing tests if there is some clarifying language in a later version of a spec, but I don’t think that is needed if there is an obvious flaw to our interpretation.</p>",
        "id": 242909913,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1623862648
    },
    {
        "content": "<p>Without looking too closely, I do think that us failing servers for not rejecting <code>Accept: application/fhir+xml</code> means that the Bulk Data IG provides that requirement (whether it is derived based on other content in the IG or explicitly stated), because I believe that this isn’t a requirement in base FHIR.  And it feels weird to me for Bulk Data to add a constraint like this -- what is special about that operation that makes it different that a normal FHIR operation?  So by that logic, I’d think we would want to assume Bulk Data didn’t mean to add that  constraint by default (unless it is very explicitly stated), which would have us remove the test.  But Dan’s comment up top about how it might be important makes me want to look closer.</p>",
        "id": 242910082,
        "sender_full_name": "Robert Scanlon",
        "timestamp": 1623862719
    },
    {
        "content": "<p>Never mind, I found the ticket: <a href=\"https://jira.hl7.org/browse/FHIR-32062\">https://jira.hl7.org/browse/FHIR-32062</a></p>",
        "id": 245863608,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1626199337
    },
    {
        "content": "<p>I am wondering if this resolution conflicts with FHIR Http spec that \"The correct mime type SHALL be used by clients and servers:\" <a href=\"http://hl7.org/fhir/http.html#mime-type\">http://hl7.org/fhir/http.html#mime-type</a> <span class=\"user-mention\" data-user-id=\"191414\">@Dan Gottlieb</span> <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span></p>",
        "id": 245865601,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1626200168
    },
    {
        "content": "<p>That's a good point. Perhaps it would be helpful to include a sentence in the bulk IG clarifying that while the base FHIR specification requires use of a mime type, since this operation only allows application/fhir+json, servers may treat that as intended if a client doesn't include the header?</p>",
        "id": 246094186,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1626356197
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191414\">@Dan Gottlieb</span>  I know this has been blocked voted last Monday but wondering if the team want to discuss this to get consensus? I don't have strong feeling for any changes but also don't want to introduce conflicts between two IGs. There are two questions need to be clarified: <br>\n1) Does Bulk Data export implementation have to follow FHIR HTTP spec, or say FHIR compliant?<br>\n2) What does the \"correct mime type SHALL be used by clients\" mean? Must request with correct Accept header or Must send payload with correct Content-type or something else?<br>\n<span class=\"user-mention\" data-user-id=\"191320\">@Lloyd McKenzie</span></p>",
        "id": 246225600,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1626443697
    },
    {
        "content": "<p>\"correct mime type shall be used by clients\" can't possibly mean that clients are required to provide a fhir specific accept header on all requests; we literally have conventions baked into the API for clients that can't or won't be able to do so (i.e., _format param, which exists specifically because we know clients won't always send an Accept header).</p>",
        "id": 246237613,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1626448968
    },
    {
        "content": "<p>So will it not be mandatory check for BDE-04 and BDE-05?</p>\n<p>Currently our FHIR server is sending 202 (Success) when the client set accept='application/fhir+xml' and prefer=return=representation for BDE-04 and BDE-05 respectively. Will this be acceptable after the new fix?</p>\n<p>Thanks<br>\nMahesh</p>",
        "id": 249982199,
        "sender_full_name": "Mahesh Dabi",
        "timestamp": 1629378005
    },
    {
        "content": "<p>Hi</p>\n<p>Another scenario for  bulk data status.</p>\n<p>A scenario while testing in Inferno</p>\n<p>Request URL: <br>\n<a href=\"https://fhir.secureit.co.in:9443/fhir-server/api/v4/$bulkdata-status?job=HRheZqFY_KT5TXhdXFuY7g\">https://fhir.secureit.co.in:9443/fhir-server/api/v4/$bulkdata-status?job=HRheZqFY_KT5TXhdXFuY7g</a></p>\n<p>Response Body:<br>\n {<br>\n\"transactionTime\": \"2021-08-18T10:21:53.82Z\",<br>\n\"request\": \"<a href=\"https://fhir.secureit.co.in:9443/fhir-server/api/v4/Group/17b58c31108-77f6763e-008b-4010-b428-c42ee061aa57/$export\">https://fhir.secureit.co.in:9443/fhir-server/api/v4/Group/17b58c31108-77f6763e-008b-4010-b428-c42ee061aa57/$export</a>\",<br>\n\"requiresAccessToken\": false,<br>\n\"output\": [{<br>\n\"type\": \"AllergyIntolerance\",<br>\n\"url\": \"_jVMAj-5zOenYBhcTN5pa5b6DvR2rsx2Cpv4l9wuXOY/AllergyIntolerance_1.ndjson\",<br>\n\"count\": 10<br>\n},<br>\n{<br>\n\"type\": \"CarePlan\",<br>\n\"url\": \"_jVMAj-5zOenYBhcTN5pa5b6DvR2rsx2Cpv4l9wuXOY/CarePlan_1.ndjson\",<br>\n\"count\": 2<br>\n}<br>\n]<br>\n}</p>\n<p>This test case is a pass, except that it needs few extra things in the response as mentioned below:</p>\n<p>1 - \"requiresAccessToken\": false. This parameter in the response is false, we need to return this in response as true. We have done all the required changes but are not able to get this. <br>\n   Could you please let us know how to achieve this?</p>\n<p>2 -   \"error\": [] . This request is a pass, but it is expected here that \"error\":[], should be a part of the response, even if there is no error in this request. Please help us in this.</p>\n<p>Also, we are getting \"An unexpected error has ocurred while deleting the job\", when a DELETE is initiated. Is it that we are missing any configuration?</p>\n<p>We are close to passing the Bulkdata test in Inferno, after we get all of these resolved.</p>\n<div class=\"codehilite\"><pre><span></span><code>Please let us know your thoughts.\n</code></pre></div>",
        "id": 249982886,
        "sender_full_name": "Mahesh Dabi",
        "timestamp": 1629378308
    },
    {
        "content": "<p>Coming in late to the party :)</p>\n<p>I see that <span class=\"user-mention\" data-user-id=\"191414\">@Dan Gottlieb</span>  mentioned the documentation could be clearer, but wondering where we landed on Accept header values.  <br>\nRight now for Bulk Data Kick-Off Request, the documentation says for Accept header \"Currently only application/fhir+json is supported.\"  Does that mean if blank - reject request with 406 and OperationOutcome?  what is Accept header is 'application/json' or 'application/json+fhir'?  Should both of those values also reject with 406 and OperationOutcome?  I'm taking the documentation with 'only' verbiage literally.  But should I be?</p>\n<p>As for Status Request the documentation says 'When requesting status, the client SHOULD use an Accept header indicating a content type of application/json.\"  Does this mean if blank, assume this is the default?  Dose this mean that other forms of the value (application/fhir+json or application/json+fhir) are acceptable?  Shouldn't this follow the same requirements as is expected for bulk data kick-off request?  Does this also apply to the Accept header on the Delete Request?</p>\n<p>As for the File Request - this one is clearer - or so I think.  Documentation states for Accept header \"(optional, defaults to application/fhir+json)\".  So, if blank default in this value; if valued to application/fhir+json- use it; if valued to anything else, reject with 406.  Right?</p>",
        "id": 250521969,
        "sender_full_name": "Michelle Vondercrone",
        "timestamp": 1629827409
    },
    {
        "content": "<p>The status request does not return FHIR, it returns a non-FHIR JSON response, hence <code>application/json</code> for the accept header</p>",
        "id": 250524087,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1629828360
    },
    {
        "content": "<p>Delete requests do not return anything, so accept is not really relevant</p>",
        "id": 250524160,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1629828380
    },
    {
        "content": "<p>Our server is strict: wants <code>application/fhir+json</code> for the kick off request, but I think a looser interpretation would be fine as well - default to that if not specified, accept also application/json etc</p>",
        "id": 250524424,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1629828516
    },
    {
        "content": "<p>File requests accept defaults to <code>application/fhir+ndjson</code>, not <code>application/fhir+json</code></p>",
        "id": 250524903,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1629828731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"258504\">Michelle Vondercrone</span> <a href=\"#narrow/stream/179250-bulk-data/topic/Bulk.20Export.20Headers.20-.20required.20for.20servers.20or.20clients.3F/near/250521969\">said</a>:</p>\n<blockquote>\n<p>Does that mean if blank - reject request with 406 and OperationOutcome?  what is Accept header is 'application/json' or 'application/json+fhir'?  Should both of those values also reject with 406 and OperationOutcome?  I'm taking the documentation with 'only' verbiage literally.  But should I be?</p>\n</blockquote>\n<p><a href=\"https://jira.hl7.org/browse/FHIR-32062\">https://jira.hl7.org/browse/FHIR-32062</a> clarifies that</p>\n<blockquote>\n<p>A client SHOULD provide this header. If omitted, a server MAY return an error or MAY process the request as if application/fhir+json was supplied.</p>\n</blockquote>\n<p>So it is up to the server to decide what to do. I think the same applies to other client requirement</p>",
        "id": 250527110,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1629829698
    },
    {
        "content": "<p>Generally speaking, the purpose of the <code>accept</code> request header is to tell the server something like: \"I only understand this format(s), so if you can reply in variety of ways please pick something that I will understand\". In Bulk Data this is typically about the responses in case of error. The server may return an error as text, or as <code>OperationOutcome</code> or anything else. It should consider the incoming accept header while deciding how to reply. However, a server that only knows how to reply with <code>OperationOutcome</code> errors might as well completely ignore the <code>accept</code> header because there is nothing to choose from.</p>\n<p>Some servers may decide to validate the accept header and reject unknown values (I'm not sure if that would be a correct behavior though).</p>\n<p>Finally, this applies to every request, except for the actual file download. There are endpoints that may not return anything, like the status endpoint while the job  is in progress, or the delete request to cancel the job. Those endpoints may still have to reply with an actual payload in case of error, or may even choose to reply with an informational <code>OperationOutcome</code> if everything is OK. In these cases they should respect the accept header.</p>",
        "id": 250530674,
        "sender_full_name": "Vladimir Ignatov",
        "timestamp": 1629831163
    },
    {
        "content": "<p>These two client requirements do not make sense. As <span class=\"user-mention\" data-user-id=\"193731\">@Vladimir Ignatov</span> mentioned, the <code>Accept</code> header is to let server know the preferred format that client could parse. But the following a successful response requires header only and the body of failed response ha<code>SHALL be a FHIR OperationOutcome resource in JSON format</code> So it doesn't matter what the format \"client prefers\", the IG already says that shall be application/fhir+json</p>\n<p>The <code>Preferred</code> header is the same. The IG already says that a successful response shall have content-location header for polling. So server has to use async response as required by IG. The client request header does not make any difference.</p>",
        "id": 250538390,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1629834442
    },
    {
        "content": "<p>Vladimir, I think you are mixing the <code>prefer</code> header and the <code>accept</code> header.  Prefer is used to specify what <em>type</em> of data you want back (when applicable, see <a href=\"https://www.hl7.org/fhir/http.html\">FHIR HTTP</a>), while Accept is used to specify the MIME type.</p>\n<p>I can say that I would prefer an <code>OperationOutcome</code>, and I would accept either <code>application/fhir+json</code> or <code>application/fhir+xml</code>, or that I would prefer nothing (<code>minimal</code>), and that I only accept <code>text/plain</code>.</p>\n<p>It is up to the server to determine if it can service the request or if it should be rejected.  Expectations for the Accept header are documented on the same page, in the <a href=\"https://www.hl7.org/fhir/http.html#mime-type\">Content Types and encodings</a> section (including responding with a <code>406: Not Acceptable</code> if the server cannot fulfil a client's request).</p>",
        "id": 250540215,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1629835204
    },
    {
        "content": "<p>That is expectation for FHIR server and Bulk Data server is not a FHIR server</p>",
        "id": 250541479,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1629835749
    },
    {
        "content": "<p>Probably I'm missing something, but I cannot figure out what.  The specification lays out what values each of these need in the different headers under each type of request, compliant with the relevant RFCs:</p>\n<ul>\n<li><code>accept</code> is part of <a href=\"https://datatracker.ietf.org/doc/html/rfc7231\">RFC7231</a> (<a href=\"https://datatracker.ietf.org/doc/html/rfc7231#section-3.4\">content negotiation</a>)</li>\n<li><code>prefer</code> is in <a href=\"https://datatracker.ietf.org/doc/html/rfc7240\">RFC7240</a> (<a href=\"https://datatracker.ietf.org/doc/html/rfc7240#section-4.2\">return preferences</a>)</li>\n</ul>\n<p>I pointed to the FHIR HTTP documentation since it's a bit less dense, given that it's around a specific use case.  That said, the intention behind the headers cannot be changed and still claim compliance with standards.</p>\n<p>For interoperability, Bulk Data restricts acceptable values in these headers.  Some guidance around acceptable behaviors for coercing or rejecting is also provided, but is a bit vague since it will vary by implementation (e.g., if your gateway filters for acceptable MIME types, your server will never even see the request to respond with an OperationOutcome).</p>\n<p>What am I missing?</p>",
        "id": 250545574,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1629837675
    },
    {
        "content": "<p>I am probably wrong but this is how I understand it:</p>\n<ul>\n<li>If <code>$export</code> operation is invoked on a FHIR server AND if that server is Bulk Data capable AND if the <code>prefer</code> header is \"respond-async\", then we enter into the Bulk Data spec</li>\n<li>A bulk data client can only send prefer header to the export kick-of endpoint and its value must be \"respond-async\" (optionally followed by <code>handling=lenient</code>). I personally find this part of the spec a little odd because it is basically saying that clients \"must prefer\" something specific...</li>\n<li>For the other requests in the flow the <code>prefer</code> header is not applicable</li>\n</ul>",
        "id": 250552504,
        "sender_full_name": "Vladimir Ignatov",
        "timestamp": 1629840915
    },
    {
        "content": "<p>I don't see anything wrong with your understanding, though I don't claim to be an expert on Bulk Data either =).  Requiring specific values is common to increase interoperability and restrict use cases.  Someone involved in writing the spec would be needed to know the exact details on this particular example.</p>\n<p>That said, I see it less as \"a client must prefer something\" and more of \"this is a thing clients can specify, and clients need to specify it in this particular way for this to work\".</p>\n<p>A similar type of example is if you are working with encryption.  There is often a field to specify an algorithm.  The lower level specifications may just say \"a value goes here\", but an interoperable specification would pick a very reduced set to support, likely one.</p>\n<p>edit: to finish the example, even if the algorithm is known, many formats require being explicit (e.g., JWT), so the value would be fixed.</p>",
        "id": 250554710,
        "sender_full_name": "Gino Canessa",
        "timestamp": 1629842092
    },
    {
        "content": "<p>Yes, you said it much better. I guess, because it does not make a lot of sense to require a header with fixed value, I have always imagined that this is just an extension point allowing other implementations. For example, if prefer is not \"respond-async\", then the server might process that synchronously somehow. I don't know if that is a thing but it would definitely justify the required header.</p>",
        "id": 250557479,
        "sender_full_name": "Vladimir Ignatov",
        "timestamp": 1629843664
    },
    {
        "content": "<p>If server process synchronously, then is it still a server conforms to Bulk Data IG?</p>",
        "id": 250571901,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1629855963
    },
    {
        "content": "<p>No. That was just an example from imagination. I don't think that is really possible right now. Maybe something similar to bulk data can be done with $everything and pagination, but that is completely different discussion... I only wanted to say that a server might offer alternative behavior if <code>prefer</code> is not <code>respond-async</code>.</p>",
        "id": 250611059,
        "sender_full_name": "Vladimir Ignatov",
        "timestamp": 1629893637
    },
    {
        "content": "<p>I'm reviewing this thread; lots of good discussion, and I'm trying to figure out if there's a specific set of improvements to the spec that someone would like to propose, beyond what you see in the CI build (<a href=\"http://build.fhir.org/ig/HL7/bulk-data/\">http://build.fhir.org/ig/HL7/bulk-data/</a>) reflecting ballot reconciliation.</p>",
        "id": 250625500,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1629900638
    },
    {
        "content": "<p>Specs are fine in my opinion</p>",
        "id": 250626217,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1629900977
    },
    {
        "content": "<p>My concern is that if such strong requirement on client request header has any effect since server's response is already regulated by IG itself. As an example about, no matter client prefers <code>async-response</code> or not, a Bulk Data server MUST respond asynchronously. I think it is more like client SHOULD request xxx and server MAY response differently.</p>",
        "id": 250630815,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1629902985
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191506\">@Yunwei Wang</span> think that's where we landed for STU2 - <a href=\"http://build.fhir.org/ig/HL7/bulk-data/export.html#headers\">http://build.fhir.org/ig/HL7/bulk-data/export.html#headers</a> ?</p>",
        "id": 250633555,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1629904184
    },
    {
        "content": "<p>I don't know if this is the right place but I would propose small addition to the Backend Services spec. Where it says:</p>\n<blockquote>\n<p>For consistency in implementation, the client’s JWK SHALL be shared with the FHIR server using one of the following techniques:<br>\n  URL to JWK Set (strongly preferred). This URL communicates the TLS-protected endpoint where the client’s public JWK Set can be found. This <br>\n  endpoint SHALL be accessible via TLS without authentication or authorization. Advantages of this approach are that it allows a client to rotate <br>\n  its own keys by updating the hosted content at the JWK Set URL, assures that the public key used by the FHIR server is current, and avoids the <br>\n  need for the FHIR server to maintain and protect the JWK Set.</p>\n</blockquote>\n<p>should we add a sentence saying that the JWKS URL can also be anywhere in the cloud? That would allow CLI clients to also use that type of auth if needed. Right now it sounds like it should be a client-hosted \"endpoint\" (assuming the client is also a server and is accessible on the same network).</p>",
        "id": 250645684,
        "sender_full_name": "Vladimir Ignatov",
        "timestamp": 1629909772
    },
    {
        "content": "<blockquote>\n<p>should we add a sentence saying that the JWKS URL can also be anywhere in the cloud?</p>\n</blockquote>\n<p>I think the language you quoted:</p>\n<blockquote>\n<p>This URL communicates the TLS-protected endpoint where the client’s public JWK Set can be found. This<br>\nendpoint SHALL be accessible via TLS without authentication or authorization.</p>\n</blockquote>\n<p>is unambiguous on this point -- the word \"endpoint\" here just means ...  a TLS-protected URL. <a href=\"https://security.stackexchange.com/questions/242382/what-is-an-endpoint-in-the-context-of-tls\">https://security.stackexchange.com/questions/242382/what-is-an-endpoint-in-the-context-of-tls</a> captures the sense pretty well.</p>",
        "id": 250651772,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1629912401
    },
    {
        "content": "<p>I wonder if I am the only one confused by this. Is it clear for everybody?</p>",
        "id": 250658687,
        "sender_full_name": "Vladimir Ignatov",
        "timestamp": 1629915357
    }
]