[
    {
        "content": "<p>I did a quick search and didn't find anything.  Feel free to redirect if this has already been discussed and landed.</p>\n<p>I'm wondering if there is a documented convention (and if not, if it's worth creating one) for a situation where a client is attempting a synchronous search or other operation, but the server decides \"nope, that's going to take too long, it needs to be asynch\" and returns an HTTP code or some other indicator that indicates to the client that they should retry their request with prefer=respond-asynch set.</p>",
        "id": 203780010,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1594679812
    },
    {
        "content": "<p>The rfc referenced in <a href=\"http://hl7.org/fhir/r4/async.html\">http://hl7.org/fhir/r4/async.html</a> allows for that</p>",
        "id": 203781702,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1594681165
    },
    {
        "content": "<p>Well, I thought it did... hrm</p>",
        "id": 203781726,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1594681193
    },
    {
        "content": "<p>There is a way to say the  operation takes too long today in operation outcomes and http status</p>",
        "id": 203781858,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1594681290
    },
    {
        "content": "<p>if we want to specify this, we could start from there?</p>",
        "id": 203781867,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1594681304
    },
    {
        "content": "<p>That was my thought.  We could either use a 408 HTTP (Request timeout) or a 400 + a \"too-long\" OperationOutcome code (or perhaps a brand-new OperationOutcome code?) to signal.  Do we think that would be a useful enhancement to the spec?</p>",
        "id": 203782527,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1594681808
    },
    {
        "content": "<p>To be clear Lloyd, you're not thinking about this as a specific enhancement for the $export operations but rather as a general enhancement for FHIR's async framework? (This channel has been mostly focused on $export/$import -- where we assume async.)</p>\n<p>Thinking about the general case: sure having some way to hints to the client that a specific response cannot be provided synchronously seems like a good idea to me.</p>",
        "id": 203836977,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594735523
    },
    {
        "content": "<p>Yes, this would be for asynch in general, not specific to $export (where you already <em>know</em> you want asynch).  I raised it here because I figured that's where most of the asynch-aware folks would hang out.</p>",
        "id": 203837152,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1594735620
    },
    {
        "content": "<p>(And I think this group is principally responsible for driving changes to the core async page)</p>",
        "id": 203837213,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1594735659
    },
    {
        "content": "<p>To the extent that changes are being driven, yes. But there's not actually a good process for keeping these things... in sync.</p>",
        "id": 203837306,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594735695
    },
    {
        "content": "<p>Does anyone have a preference for HTTP 408 vs. HTTP 400 + \"too-long\" vs. new OO code vs. something else?</p>",
        "id": 203837475,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1594735802
    },
    {
        "content": "<p>408 doesn't quite seem right to me because it implies the client May retry its request... and we would be saying that a client would be silly to do so without upgrading to asynchronous.</p>",
        "id": 203837678,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594735894
    },
    {
        "content": "<p>The existing \"too long\" code is about a client supplying too much input, on my reading.</p>",
        "id": 203837837,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594735989
    },
    {
        "content": "<p>So you would vote for a new OperationOutcome code, or is there something else we should leverage?</p>",
        "id": 203837920,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1594736040
    },
    {
        "content": "<p>I sure wish we had used coding and not code in operationOutcome.code</p>",
        "id": 203838005,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594736063
    },
    {
        "content": "<p>I think a new operation outcome code makes sense. We could also explore some kind of header.</p>",
        "id": 203838127,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1594736144
    },
    {
        "content": "<p>Actually, we typically use \"too-costly\" in the operation outcome for things that would take too long</p>",
        "id": 203853427,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1594743431
    },
    {
        "content": "<p>it looks like that's tied to 422 today, since it's a bit of a biz rule</p>",
        "id": 203853910,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1594743604
    },
    {
        "content": "<p>(again, just in our implementation - doesn't mean it's correct :) )</p>",
        "id": 203853924,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1594743618
    },
    {
        "content": "<p>Hello all</p>",
        "id": 203857799,
        "sender_full_name": "Vic Hindocha",
        "timestamp": 1594745546
    },
    {
        "content": "<p>Hello :)</p>",
        "id": 203858654,
        "sender_full_name": "Lloyd McKenzie",
        "timestamp": 1594745960
    },
    {
        "content": "<p>as opposed to the server deciding at the time of the request that a query is going to take too long and providing an async fallback, is there any good option pre-coordination, in particular in the case of frequently offline clients?  Something along the lines of a client (or set of clients) saying \"I am going to need an export with these parameters on a routine basis, but I dont know that I will have good enough connectivity to wait for an async operation or for a long running query to execute on the server, can you please go ahead and cache the export with these parameters and make sure it stays fresh?\"</p>",
        "id": 206048025,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596646532
    },
    {
        "content": "<p>The pre-coordination is what exists today - the app can say it prefers the respond-async response.</p>",
        "id": 206048512,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1596646750
    },
    {
        "content": "<p>It's the server saying \"I know you said you wanted sync, but you just asked me to do something that will take several minutes or more.. I'm going to respond async\" that seems to be missing</p>",
        "id": 206048575,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1596646790
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191356\">@Jenni Syed</span>  maybe to elaborate my understanding:  Let's say I have a set of parameters X for an export.   Right now, in the sync scenario, Client A would submit X, the server would then generate the export and then respond back.   If Client B wants that same export with X, then it would not know about Client A's request and would need to initiate it's own export operation.   It would be up to the server to decide if they want to implement something like, oh I have seen this request for export X before, let me reuse the results (with perhaps a refresh for new data).   There is no current way to declare to the server \"export under X parameters is going to be of high interest to several clients, please try to keep an export ready for immediate response to the clients.\"</p>",
        "id": 206056505,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596650301
    },
    {
        "content": "<p>have I misunderstood something here?</p>",
        "id": 206056542,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596650319
    },
    {
        "content": "<p>That's accurate - though I'm not sure a client is going to know when many apps will have access to the same data (security wise). I'm not sure it can be anyone other than the server that determines that. I assume you're referring specifically to the bulk spec? I think this was originally a question that was a bit broader/more general than bulk export (but reusing the parts of the spec that added that async response functionality)</p>",
        "id": 206066365,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1596655199
    },
    {
        "content": "<p>this is for bulk spec.   maybe more context would help..... we support a number of mobile apps that work in largely offline environments (sub-Saharan Africa).   many of these deployments include where there is no network connectivity and the devices need to be taken on a weekly/monthly basis to sync data.  this seek window can sometimes be  small.  there may be several health workers working out of the same clinic and so would, for example, need the same patient cohort identified by a Group to pull in any updated information on the patients/clients.   I would like to avoid a situation where they miss a sync window because the server is still processing.</p>",
        "id": 206071375,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596657773
    },
    {
        "content": "<p>The server can keep the exported data always up to date (independently from bulk export requests), and when a bulk export request for that set comes in just return the links to the files? Does not seem to need any change in the bulk export specs</p>",
        "id": 206071985,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1596658093
    },
    {
        "content": "<p>@michele how does we indicate to the server <em>which</em> exports to keep up to date?   this could be quite voluminous especially if we are subsetting from a large server (e.g. national)</p>",
        "id": 206072311,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596658271
    },
    {
        "content": "<p>A config file? A form in its user interface?</p>",
        "id": 206073432,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1596658958
    },
    {
        "content": "<p>right, but that would be server implementation specific.</p>",
        "id": 206073619,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596659051
    },
    {
        "content": "<p>i would prefer something that wasn't</p>",
        "id": 206073651,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596659067
    },
    {
        "content": "<p>something to specify a \"cache hint\" for the server.   something like an $export-hint operation that takes the same parameters as $export</p>",
        "id": 206076779,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596660810
    },
    {
        "content": "<p>or even a cache-hint parameter under $export</p>",
        "id": 206136313,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596718479
    },
    {
        "content": "<blockquote>\n<p>If Client B wants that same export with X, then it would not know about Client A's request and would need to initiate it's own export operation. </p>\n</blockquote>\n<p>Just to note: this all gets more complex if there are any relative requirements like <code>_since</code>, because in general each client would want to supply its own \"last synced timestamp\" value here. Client A and B likely have different needs.</p>",
        "id": 206163967,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1596730979
    },
    {
        "content": "<p>But Carl, maybe your use case is simpler -- like, if at export time a client can say \"Do this export now, but I'm going offline for a bit, so please keep the result available for 1 week, or 1 month, or until I call delete\"... is that enough? (Or are you saying you need to have the server maintain some kind of cron-like schedule-driven proactive process?)</p>",
        "id": 206164131,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1596731081
    },
    {
        "content": "<p>yes,  agreed A and B would need in general individual timestamps, even if almost the same.  _since is a potential special case here, though I don't think the other parameters would be different for A and B.  perhaps some guidance on on server implementations to index cached results on timestamp.   the _type, _typeFilter and _outputFormat should be consistent for A and B.  </p>\n<p>i don't think the simpler use case would work, at least not as stated.  maybe if it was \"Do this export now, but I'm going offline for a bit, so please keep the result available and refreshed until I call delete\" could work.  I was imagining a more proactive process.</p>",
        "id": 206166023,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596732211
    },
    {
        "content": "<p>as a side note, this is to help inform and facilitate some sync workflows that will be a part of an android fhir sdk and the openhie architecture.</p>",
        "id": 206166196,
        "sender_full_name": "Carl Leitner",
        "timestamp": 1596732298
    }
]