[
    {
        "content": "<p>For a first time participant at a Connectathon, thanks to all participants, and especially those who provided help to me.  It was an eye-opening experience for me, and I look forward to future participation.   Please forgive me if this is a newbie question that’s been previously discussed, but after I left the Connectathon, I had this questions..</p>\n<p>Why isn’t the proposed Bulk Data API RESTful?  If we’re supposed to be following the FHIR API model, couldn’t there be a BulkDataQuery resource that we can POST, GET, PUT and DELETE from the FHIR Server?</p>\n<p>Something like this:</p>\n<p>BulkDataQuery Resource</p>\n<ul>\n<li>Id - FHIR resource id</li>\n<li>QueryParameters - e.g. Patient/$export or whatever gets decided</li>\n<li>Status - done, not done or perhaps Queued, Completed, InProgress, Cancelled</li>\n<li>InitialRequestDateTime</li>\n<li>CompletedDateTime</li>\n<li>Results - List of URI’s</li>\n<li>ResultsExpirationDateTime - the date/time when the results will no longer be available.</li>\n</ul>\n<p>POST - initiates a bulk data request, creates a new BulkDataQuery resource on the server<br>\nGET - gets the BulkDataQuery resource via id (and support some search parameters)<br>\nDELETE - cancels the BulkDataQuery request</p>",
        "id": 153932998,
        "sender_full_name": "Ed Martin",
        "timestamp": 1517249716
    },
    {
        "content": "<p>This is an interesting suggestion. Overall it introduces some indirection (i.e., rather than asking for an async response to your query, you're talking to an entirely different endpoint) and some more functionality (e.g., it implies that a client should be able to receive some interim results, or search for previously generated exports, etc -- which could either be an benefit or a needless complexity, depending on perspective).</p>",
        "id": 153933775,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1517341263
    },
    {
        "content": "<p>it overlaps with the Task resource</p>",
        "id": 153933778,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1517341365
    },
    {
        "content": "<p>Really? (I mean, on some level: what doesn't — but I never thought of <code>Task</code> as an infrastructure resource.)</p>",
        "id": 153933780,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1517341611
    },
    {
        "content": "<p>The asynch response pattern we're doing is a Rest approach (if that's the concern). IE: I could GET all Patients where DOB is after 1970 asynchronously. I wonder if it feels more \"funky\" becuase of the Operation? But then this would be a concern with operations.</p>",
        "id": 153933781,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1517341614
    },
    {
        "content": "<p>If the concern is specifically with the asynch nature, then it wouldn't just be the Bulk Data concern - it would be with all the resources you could select this way.</p>",
        "id": 153933783,
        "sender_full_name": "Jenni Syed",
        "timestamp": 1517341798
    },
    {
        "content": "<p>I think the pattern we're describing generalizes to any call (which came up in discussion here), so it'd be sensible to think of it for non-bulk-export use cases like:</p>\n<p>1.</p>\n<div class=\"codehilite\"><pre><span></span>GET /Observation?code=123\nPrefer: respond-async\n</pre></div>\n\n\n<p>(Or whatever).</p>\n<p>This feels more natural to me than:</p>\n<p>2. </p>\n<div class=\"codehilite\"><pre><span></span>POST /AsyncJob\ncontent-type: application/json\n\n{\n  &quot;query&quot;: &quot;Observation?code=123&quot;,\n  &quot;outptFormat&quot;: &quot;application/fhir+ndjson&quot;\n}\n</pre></div>",
        "id": 153933784,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1517341808
    },
    {
        "content": "<p>Now we could say that requests like #1 tie into #2 by returning results like </p>\n<div class=\"codehilite\"><pre><span></span>Content-location: https://server/fhir/AsyncJob/123\n</pre></div>\n\n\n<p>... which acts like a FHIR resource. But I'm not sure what problem this solves.</p>",
        "id": 153933786,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1517341909
    },
    {
        "content": "<p>(I wrote <code>AsyncJob</code> here where where  <span class=\"user-mention\" data-user-id=\"195152\">@Ed Martin</span> wrote <code>BulkDataQuery</code> -- you should read these as equivalent.)</p>",
        "id": 153933787,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1517341958
    },
    {
        "content": "<p>a resource would potentially mean that you could find each other's requests etc. That's probably not a desired feature. (though that's not something it has to mean)</p>",
        "id": 153933793,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1517342508
    },
    {
        "content": "<p>Hiding responses from other users is certainly something that we need to support.</p>",
        "id": 153933803,
        "sender_full_name": "Bas van den Heuvel",
        "timestamp": 1517343430
    },
    {
        "content": "<p>I agree, <span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> - your GET example is significantly more straightforward.</p>",
        "id": 153933804,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1517343528
    },
    {
        "content": "<p>my server already does GET that way</p>",
        "id": 153933805,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1517343631
    },
    {
        "content": "<p>I am thinking out loud ...What Use Case would use the Async capability on regular FHIR APIs ? (Publish - Subscribe type use cases ? ) Doesn't async make the backend more complicated to spin off requests , keep track of them and create some kind of a bundle that has to persist for some time and then clean up ...is that really required for Base FHIR use cases ?  I can see that complexity being necessary for bulk apis or even for jobs (tasks that are workflow dependent (i.e human intervention) and/or complex, time consuming in nature. (i.e complex queries using some query language or execution of jobs)</p>",
        "id": 153934007,
        "sender_full_name": "Nagesh Bashyam",
        "timestamp": 1517356896
    },
    {
        "content": "<p>I think there's value in saying \"here's a consistent way to request data, whether it's in a giant bundle or in an async pile of ndjson files\". That said: there's no expectation that most servers would support this async model on \"normal\" requests; it's only important on requests that require large responses.</p>",
        "id": 153934028,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1517364913
    },
    {
        "content": "<p>it is more complicated for server and client but that doesn't mean it isn't functional</p>",
        "id": 153934042,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1517367292
    },
    {
        "content": "<p>How about a note in the spec saying that the servers may send a Retry-After header <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\" target=\"_blank\" title=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After</a>? I think in some cases this can lead to better pooling then using the back-off algorithm.</p>",
        "id": 153934334,
        "sender_full_name": "Vladimir Ignatov",
        "timestamp": 1517423676
    },
    {
        "content": "<p>I think that's a super helpful suggestion for hinting clients when to poll.</p>",
        "id": 153934343,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1517425885
    },
    {
        "content": "<p>This is a solid strategy.</p>",
        "id": 153934349,
        "sender_full_name": "Michael Donnelly",
        "timestamp": 1517428141
    },
    {
        "content": "<p>Agreed</p>",
        "id": 153934352,
        "sender_full_name": "Nagesh Bashyam",
        "timestamp": 1517428832
    },
    {
        "content": "<p>besides large requests it is also usefull for requests that potentially take a lot of time, e.g. evaluation of a population measure.</p>",
        "id": 153934464,
        "sender_full_name": "Bas van den Heuvel",
        "timestamp": 1517460683
    },
    {
        "content": "<p>I added a note about the retry-after header to the write up: <a href=\"https://github.com/smart-on-fhir/fhir-bulk-data-docs/blob/master/README.md\" target=\"_blank\" title=\"https://github.com/smart-on-fhir/fhir-bulk-data-docs/blob/master/README.md\">https://github.com/smart-on-fhir/fhir-bulk-data-docs/blob/master/README.md</a></p>",
        "id": 153934694,
        "sender_full_name": "Dan Gottlieb",
        "timestamp": 1517506245
    }
]