[
    {
        "content": "<p>The <a href=\"https://github.com/smart-on-fhir/fhir-bulk-data-docs/blob/master/export.md#response---complete-status\" target=\"_blank\" title=\"https://github.com/smart-on-fhir/fhir-bulk-data-docs/blob/master/export.md#response---complete-status\">bulk data status response</a> includes a boolean _secure_ element:</p>\n<blockquote>\n<p>secure - boolean value indicating whether downloading the generated files will require an authentication token. Note: This may be false in the case of signed S3 urls or an internal file server within an organization's firewall.</p>\n</blockquote>\n<p>This is the intentional support of bulk PHI exposed insecurely. Is this really a good idea? If so, how about additional information around when it's appropriate to use this?</p>",
        "id": 153952130,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1523562930
    },
    {
        "content": "<p>From a secure communications standpoint, a signed URL contains a secret as much as URL+Bearer Token.  It can be revoked. It expires.  I'm not sure I agree that it's \"exposed insecurely\". It's probably not a great idea since URL are not usually treated as secrets in practice.  But putting the secret in a separate header isn't technically more secure.</p>",
        "id": 153952134,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1523565320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> ?</p>",
        "id": 153952135,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1523565328
    },
    {
        "content": "<p>They use case for this field is to tell a client whether or not it needs to include the same authorization header that uses for EHR Communications when fetching this file</p>",
        "id": 153952146,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1523569422
    },
    {
        "content": "<p>It might be better to call it <code>useEhrAuthorization</code> or <code>needAuthorizationHeader</code> or some such</p>",
        "id": 153952147,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1523569467
    },
    {
        "content": "<p>For a self-contained signed URL, this would be set to false whatever we call it</p>",
        "id": 153952148,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1523569492
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> - good point.  It's not \"not secure\". It's about the authorization needed for the link vs. the original request.</p>",
        "id": 153952158,
        "sender_full_name": "Chris Grenz",
        "timestamp": 1523572388
    },
    {
        "content": "<p>Agree that renaming the property to <code>requiresAuthorizationToken</code> or similar is a good idea, <code>secure = false</code> just seems wrong.<br>\nInternal file server (or internal web server) likely also has domain authentication, so is not insecure...</p>",
        "id": 153952162,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1523573501
    },
    {
        "content": "<p>Yeah. The key consideration is that either the url should just work (like a signed URL) or require an EHR authorization token -- it shouldn't require out of band special knowledge to follow.</p>",
        "id": 153952171,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1523576503
    },
    {
        "content": "<p>I would echo the conclusions of the discussion.. although I would also indicate that if a server is willing to communication without security protocols, that is a policy decision that server should be allowed to do. I would not agree that this policy is good, but I will fight for their right to enforce any policy they want to enforce... Note one likely time this is valid is where there are other means securing the communication, such as a point-to-point mutually authenticated VPN.</p>",
        "id": 153952172,
        "sender_full_name": "John Moehrke",
        "timestamp": 1523577558
    },
    {
        "content": "<p>Hey Guys,</p>\n<p>I just created issue <a href=\"https://github.com/smart-on-fhir/fhir-bulk-data-docs/issues/19\" target=\"_blank\" title=\"https://github.com/smart-on-fhir/fhir-bulk-data-docs/issues/19\">#19</a> on the bulk data api spec to capture this feedback. Personally, I like <span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> 's suggestion of <code>requiresAuthorizationToken</code>, despite its length. Are there existing examples of this type of field elsewhere in OAuth / security / the internet?</p>",
        "id": 153952202,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1523599541
    },
    {
        "content": "<p>Thanks Isaac! I haven't seen this kind of thing at other places but it's worth keeping an eye out.</p>",
        "id": 153952215,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1523617471
    },
    {
        "content": "<p>In a very indirect way this specific solution is a concrete example of negotiation that is the abstract concept behind a work item that the security WG is doing around the abstract concept of negotiating a Trust Framework between two communicating partners that don't have a relationship to begin with.  Very abstract work. See the current HL7 ballot --   HL7 Version 3 Standard: Privacy and Security Architecture Framework - Trust Framework for Federated Authorization, Release 1 (PI ID: 914)</p>",
        "id": 153952235,
        "sender_full_name": "John Moehrke",
        "timestamp": 1523625415
    }
]