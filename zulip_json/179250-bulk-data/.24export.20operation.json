[
    {
        "content": "<p>Is there formal definition of $export operation in FHIR spec?</p>",
        "id": 155145073,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1547527206
    },
    {
        "content": "<p>No -- but we're planning on creating one in an IG as we formalize this through the ballot process!</p>",
        "id": 155145087,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1547527255
    },
    {
        "content": "<p>I am considering using $export operation on ValueSet resource. Is that OK?</p>",
        "id": 155145192,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1547527405
    },
    {
        "content": "<p>To export all the valuesets on a server?</p>",
        "id": 155145199,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1547527441
    },
    {
        "content": "<p>In which case you'd do  <code>[base]/$export?_type=ValueSet</code></p>",
        "id": 155145245,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1547527488
    },
    {
        "content": "<p>Kindly. If someone want to get all HL7 FHIR value sets from my server, I need to find a way to support that.<br>\nI am thinking [base]/ValueSet/$export?_typeFilter=ValueSet.publisher=HL7&amp;_since=2018-01-01</p>",
        "id": 155145257,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1547527555
    },
    {
        "content": "<p>We don't currently define an operation at /ValueSet/$export, but the example I gave above should do what you're looking for</p>",
        "id": 155145315,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1547527617
    },
    {
        "content": "<p>I.e. at base/$export</p>",
        "id": 155145325,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1547527640
    },
    {
        "content": "<p>Oh. That is correct.</p>",
        "id": 155145327,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1547527645
    },
    {
        "content": "<p>Reading the current version of the spec, wondering why the <code>Accept</code> header can only be json at the moment?<br>\nIs that really still intentional?</p>",
        "id": 157065793,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548716992
    },
    {
        "content": "<p>On the status API call? We only define a JSON status response.</p>",
        "id": 157065870,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548717030
    },
    {
        "content": "<p>Any reason why that didn't use a Task resource as the response instead of a hand crafted json object?</p>",
        "id": 157066100,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548717312
    },
    {
        "content": "<p>Or is that as it's likely not a FHIR server doing it.</p>",
        "id": 157066112,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548717333
    },
    {
        "content": "<p>Mainly clarity, and the fact that we didn't expect that a bulk data server would necessarily be a more general FHIR server.</p>",
        "id": 157066196,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548717402
    },
    {
        "content": "<p>And the in-progress status has no return body?</p>",
        "id": 157066573,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548717794
    },
    {
        "content": "<p>Could that do an OperationOutcome just as the delete and $export has?</p>",
        "id": 157066690,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548717895
    },
    {
        "content": "<p>There is also no mention of if deleted resources should be included in the output or not (especially since there is the _since parameter) and if they are, how these would be represented in the ndjson file.</p>",
        "id": 157066947,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548718100
    },
    {
        "content": "<p>This would be required to use the format to exchange regular updates to content (such as the provider directory), catalogs, terminologies ...</p>",
        "id": 157067003,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548718169
    },
    {
        "content": "<p>(really search vs history to get deltas)</p>",
        "id": 157067082,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548718210
    },
    {
        "content": "<p>There's also nothing in the status tracking that talks about the requiresAccessToken, only the final result.<br>\nDoes this mean that the DELETE doesn't require the access token? - Should it? (feels like it should)</p>",
        "id": 157068343,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548719632
    },
    {
        "content": "<blockquote>\n<p>And the in-progress status has no return body?</p>\n</blockquote>\n<p>Correct</p>",
        "id": 157068424,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548719713
    },
    {
        "content": "<p>Re: obtaining records of deleted resources, this has been out of scope; the official advice is basically \"occasionally you should query without a _since to learn what has disappeared\".</p>",
        "id": 157068487,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548719811
    },
    {
        "content": "<p>And then perform a match across all the data to determine what is missing, and therefore deleted.<br>\n(which could also be that security has changed too - but same effect right?)</p>",
        "id": 157068527,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548719880
    },
    {
        "content": "<p>Re: access tokens, all API operations (kick off, status, delete) require Authorization. The \"requiresAccessToken\" property is specific to the final step of retrieving results files, which may be hosted somewhere entirely separate. That's why this property needs to be communicated in band</p>",
        "id": 157068587,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548719926
    },
    {
        "content": "<blockquote>\n<p>And then perform a match across all the data to determine what is missing, and therefore deleted. (which could also be that security has changed too - but same effect right?)</p>\n</blockquote>\n<p>Yes, I think that's right. We could think about an operation to bulk fetching History entries, but that's a different thing</p>",
        "id": 157068676,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548720013
    },
    {
        "content": "<p>\"transactionTime\": \"[instant]\" is a little bit obscure to me. <code>... that indicates the server's time when the query is run</code> doesn't quite work for me. Isn't this really the point in time that the last transaction occurred?<br>\nI'm thinking that in some cases we would probably have a pre-prepared daily dump of the store that we can return and the last transaction record would be the end of that day (or hour etc) So isn't really the time when the query is run (and there are many queries here)</p>",
        "id": 157068737,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720114
    },
    {
        "content": "<p>Can we assume that this is really just the point in time where the data was \"snapshotted\" or something like that?</p>",
        "id": 157068800,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720161
    },
    {
        "content": "<p>The important thing is that all transactions up to this time are included; that's why we write \"Note: to properly meet these constraints, a FHIR Server might need to wait for any pending transactions to resolve in its database, before starting the export process\". Is this unclear?</p>",
        "id": 157068829,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548720228
    },
    {
        "content": "<p>As this is the value that I'm expecting that a following export would use<br>\ne.g. $export?_since=[transactionTime from last call]</p>",
        "id": 157068832,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720230
    },
    {
        "content": "<p>Precisely</p>",
        "id": 157068876,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548720244
    },
    {
        "content": "<p>That pattern of client behavior needs to \"work\".</p>",
        "id": 157068883,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548720261
    },
    {
        "content": "<p>(fetching all expected results without introducing a gap)</p>",
        "id": 157068897,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548720277
    },
    {
        "content": "<p>That's why I'm not a fan of <code>the server's time when the query is run</code>, can we re-word that to something more around <code>the point in time where the data was current</code>?</p>",
        "id": 157068932,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720324
    },
    {
        "content": "<p>When it's run isn't quite the same thing.</p>",
        "id": 157068943,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720358
    },
    {
        "content": "<p>Sure -- we've thrashed on the language for this a bit. Happy to accept a PR that clarifies, consistent with the discussion here!</p>",
        "id": 157069011,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548720399
    },
    {
        "content": "<p>(Good to have confirmed that this was the intention - thanks)</p>",
        "id": 157069015,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720412
    },
    {
        "content": "<p>Will write one when I finish the review and how we might do this for directory exchange in the VhDir IG</p>",
        "id": 157069052,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720451
    },
    {
        "content": "<p>Did we end up with a mechanism for requesting that the files be zipped?</p>",
        "id": 157069340,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720830
    },
    {
        "content": "<p>Gzip in transit, yes (http negotiation)</p>",
        "id": 157069389,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548720851
    },
    {
        "content": "<p>Did you mean something else?</p>",
        "id": 157069394,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548720860
    },
    {
        "content": "<p>\"url\" : \"<a href=\"http://serverpath2/patient_file_1.ndjson.zip\" target=\"_blank\" title=\"http://serverpath2/patient_file_1.ndjson.zip\">http://serverpath2/patient_file_1.ndjson.zip</a>\"</p>",
        "id": 157069401,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720868
    },
    {
        "content": "<p>binary file request</p>",
        "id": 157069416,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720887
    },
    {
        "content": "<p>Or is that implied to be done on the wire - compressing in realtime over the http channel.</p>",
        "id": 157069435,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548720922
    },
    {
        "content": "<p>That we didn't define; but you can request gzip on the http connection and then stream into a compression algorithm of your choice</p>",
        "id": 157069441,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548720931
    },
    {
        "content": "<p>Yeah, we're hoping that's good enough, rather than specifying negotiation of different file formats.</p>",
        "id": 157069487,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548720963
    },
    {
        "content": "<p>This is then going to take up much more disk space on the content server holding the staging files too.</p>",
        "id": 157069518,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548721001
    },
    {
        "content": "<p>Hmm, I'm going to look into the costing of Azure storage space here, as that could be relevant for me...</p>",
        "id": 157069562,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548721056
    },
    {
        "content": "<p>That's an interesting point. In many architectures, a server can store files compressed under the hood  -- but maybe not everywhere</p>",
        "id": 157069581,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548721077
    },
    {
        "content": "<p>On a quick look, I can't see anything in the Azure portal to configure transparent compression (only encryption).<br>\nSo might have to do something fancy here, can't just let the web server static file handler serve up the file :(</p>",
        "id": 157069758,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548721250
    },
    {
        "content": "<p><a href=\"https://www.stefangordon.com/azure-storage-gzip-encoding/\" target=\"_blank\" title=\"https://www.stefangordon.com/azure-storage-gzip-encoding/\">https://www.stefangordon.com/azure-storage-gzip-encoding/</a> has some info to suggest an approach ; I haven't tried this.</p>",
        "id": 157069790,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548721321
    },
    {
        "content": "<p>_outputEncoding perhaps?</p>",
        "id": 157069834,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548721325
    },
    {
        "content": "<p>But would you say \"we don't support clients that request an unencoded output\"? If so, you might as well use http headers and always return gzip content</p>",
        "id": 157069856,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548721391
    },
    {
        "content": "<p>Interesting, gzip content, vs a zipfile with the data in it.</p>",
        "id": 157069929,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548721479
    },
    {
        "content": "<p>The Cerner demo implementation works this way, from static S3 hosting, for what it's worth.</p>",
        "id": 157069959,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548721559
    },
    {
        "content": "<p>(files are served up gzip'd, with http headers indicating this is the case.)</p>",
        "id": 157070006,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548721595
    },
    {
        "content": "<p>And the filenames are still .ndjson, and assuming that they use http rather than some other mechanism to get them they never see anything.</p>",
        "id": 157070089,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548721720
    },
    {
        "content": "<p>I don't remember what the filenames are (but the names are technically opaque)...</p>",
        "id": 157070110,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548721767
    },
    {
        "content": "<p>It the process was internal and used a file:// location, then no compression would occur.</p>",
        "id": 157070113,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548721777
    },
    {
        "content": "<p>(But I guess this is really internal only, so who cares)</p>",
        "id": 157070122,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548721800
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 157070186,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548721828
    },
    {
        "content": "<p>Has there been discussion on returning the names of the files as they are completed? I.e. returning the complete body as an inprogress body to show what is complete... which could permit in progress downloads for the parts that are complete.</p>",
        "id": 157071073,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548722971
    },
    {
        "content": "<p>There has been discussion; we deferred this capability because of the complexities of tracking errors, estimating progress, aligning expiration times, etc. The design was simpler with an atomic complete response.</p>",
        "id": 157071184,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548723099
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191414\">@Dan Gottlieb</span> in case I forgot some of the rationale.</p>",
        "id": 157071197,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1548723119
    },
    {
        "content": "<p>Hmm, tracking errors could be interesting there. Also would be nice if there was a way to associate the errors with the section if that was relevant - having not done the implementation, not even sure if that would be a requirement.</p>",
        "id": 157071632,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548723690
    },
    {
        "content": "<p>Also assuming that the count would be an integer in the json format, so no quotes around it.</p>",
        "id": 157072308,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548724579
    },
    {
        "content": "<p>I can confirm Cerner gzip content though the file name is xxx.ndjson. I need to add DecompressionMethods to HttpClientHandler.</p>\n<div class=\"codehilite\"><pre><span></span>            var handler = new HttpClientHandler\n            {\n                AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.None\n            };\n</pre></div>",
        "id": 157075659,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1548729511
    },
    {
        "content": "<p>And it has the content-encoding header defined?</p>",
        "id": 157077359,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548732344
    },
    {
        "content": "<p>I guess so.</p>",
        "id": 157077406,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548732366
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 157077410,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1548732379
    },
    {
        "content": "<p>Yes. It does.<br>\nContent-Encoding: gzip</p>",
        "id": 157145754,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1548802139
    },
    {
        "content": "<p>Where is $export with respect to normative status?</p>",
        "id": 162353398,
        "sender_full_name": "Douglas DeShazo",
        "timestamp": 1554224379
    },
    {
        "content": "<p>It's being balloted for trial use this month, for the first time.</p>",
        "id": 162353809,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1554224623
    },
    {
        "content": "<p>Thanks Josh.</p>",
        "id": 162369031,
        "sender_full_name": "Douglas DeShazo",
        "timestamp": 1554235306
    }
]