[
    {
        "content": "<p>inferno <code>Auth-18: Token endpoint validates the jku token header</code> claims that servers should reject a JWT if it has a jku that doesn't match the jwks url that the client was registered with.</p>\n<p>Keycloak seems to ignore the jku header.<br>\nThe SMART Backend Services spec does have the following from <a href=\"http://build.fhir.org/ig/HL7/bulk-data/authorization.html#signature-verification\">http://build.fhir.org/ig/HL7/bulk-data/authorization.html#signature-verification</a></p>\n<div class=\"codehilite\"><pre><span></span><code>To resolve a key to verify signatures, a FHIR authorization server SHALL follow this algorithm:\n\nIf the jku header is present, verify that the jku is whitelisted (i.e., that it matches the JWKS URL value supplied at registration time for the specified client_id).\nIf the jku header is not whitelisted, the signature verification fails.\n</code></pre></div>\n<p>So in this case I think the test is accurately testing what is in the specification.  What was surprising to me is that this goes beyond standard JWT validation.<br>\nWhat is the rationale for being so stringent on this jku field...is it important for security?</p>",
        "id": 253447897,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1631724423
    },
    {
        "content": "<p>The aim is to ensure that a client registers its JWKS URL(s) ahead of time; we already require that registration <em>needs</em> to result in a client having registered a JWKS URL and/or directly registering a JWKS (but that option is less relevant here).</p>\n<p>So, if a client has registered JWKS URLs ahead of time, why would it be embedding a <em>different</em> JWKS URL in its access tokens? (I agree with your point Lee that ignoring these should be safe, but the presence of an unexpected JWKS URL in one of these tokens implies that something unexpected is going on... and we'd rather avoid that.)</p>",
        "id": 253458776,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1631728386
    },
    {
        "content": "<p>Yeah, it sound fine to me in principle.  Its just that this popular OIDC implementation happens to ignore it and that means it can't pass this test.  So it makes me wonder if its better/easier to try loosening the constraint or patching the server impl.  I wonder whether other OIDC servers that support JWT do this validation of the jku or not.  Any good way to find that answer?</p>",
        "id": 253461636,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1631729380
    },
    {
        "content": "<p>I don't know how to find answers, other than asking developers for other OIDC servers.</p>\n<p>If we wanted to relax the language it'd be to say something like:</p>\n<ul>\n<li>Servers MAY use the <code>jku</code> claim as a hint about which keyset to use, after validating that the value is part of a client's pre-registered list of JWKS URLs</li>\n<li>Servers SHALL NOT dereference the <code>jku</code> if it is not part of a client's pre-registered list of JWKS URLs</li>\n</ul>\n<p>^^ ?</p>",
        "id": 253463657,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1631730217
    },
    {
        "content": "<p>yes, exactly</p>",
        "id": 253466018,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1631731194
    },
    {
        "content": "<p>i'm also willing to look into plugging this conformance gap in keycloak...but first wanted to understand how important validation of jku is in practice.  I can try it in a couple other OIDC servers that I have access to and it might help shape my opinion...honestly not sure what is best in this case</p>",
        "id": 253466265,
        "sender_full_name": "Lee Surprenant",
        "timestamp": 1631731301
    }
]