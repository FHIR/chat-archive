[
    {
        "content": "<p>We're looking at <a href=\"https://github.com/smart-on-fhir/bulk-import/blob/master/import.md\" target=\"_blank\" title=\"https://github.com/smart-on-fhir/bulk-import/blob/master/import.md\">https://github.com/smart-on-fhir/bulk-import/blob/master/import.md</a> ; and roundtable to share experience, directions. I'll keep some live notes here...</p>",
        "id": 175714094,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488126
    },
    {
        "content": "<h3>inputSource</h3>\n<ul>\n<li><code>inputSource</code>currently required, but may not be relevant/known in real life (e.g., for synthetic data). Today, we use this to track light-weight provenance from inputs -&gt; imported resources.</li>\n</ul>",
        "id": 175714185,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488243
    },
    {
        "content": "<p>What's it really trying to track? Goal is to be able to recognize data from the same source, over time.</p>",
        "id": 175714195,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488264
    },
    {
        "content": "<p>We can't assume that all resources in an import have the same real-world origin.</p>",
        "id": 175714286,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488389
    },
    {
        "content": "<p>Proposal: keep <code>inputSource</code> as required, but update docs to note that it's a URI, specified by the client, meant to track data imported through its lifecycle.  Use \"a FHIR server base URL\" as an <em>example</em> but not the definition of this field.</p>",
        "id": 175714371,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488517
    },
    {
        "content": "<p>We can also note that clients may provide more detailed Provenance along the way.</p>",
        "id": 175714421,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488570
    },
    {
        "content": "<p>Note that <code>Resource.id</code> in an import should be unique (no distinct resources that share an ID).</p>",
        "id": 175714514,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488749
    },
    {
        "content": "<h3><code>inputFormat</code></h3>\n<p>In GCP, there are use cases for importing Bundles (i.e., unwrap-bundle-and-import-the-entries) as well as piles of resources.</p>",
        "id": 175714524,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488789
    },
    {
        "content": "<p>Can there be something like an \"unwrap\" mode, or even deeper Bundle semantics?</p>",
        "id": 175714580,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488836
    },
    {
        "content": "<p>1. Resources in NDJSON<br>\n2. Resources in JSON (one per file)<br>\n3. Bundles in NDJSON<br>\n4. Bundles in JSON (one per file)</p>",
        "id": 175714592,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488890
    },
    {
        "content": "<p>Synthea is an example of (4)</p>",
        "id": 175714597,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488897
    },
    {
        "content": "<p>Current bulk data export is an example of (1)</p>",
        "id": 175714600,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488919
    },
    {
        "content": "<p>No real organic use for (2); a little for (3).</p>",
        "id": 175714647,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568488952
    },
    {
        "content": "<p>Which do we want to <em>enable</em> in a standard way, and which do we want to <em>require</em>?</p>",
        "id": 175714776,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568489182
    },
    {
        "content": "<p>Proposal: require support for (1), and define support for all four. With respect to bundle types: build in a parameter that requests something like <code>processBundleAsCollection</code> (so servers can introduce support for Bundles without being expected to manage transaction semantics).</p>",
        "id": 175714857,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568489362
    },
    {
        "content": "<h3><code>input.type</code></h3>",
        "id": 175714924,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568489470
    },
    {
        "content": "<p>DO servers need uniform types per file?</p>",
        "id": 175715005,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568489602
    },
    {
        "content": "<ul>\n<li>use case for servers that are going to just provide analytics</li>\n<li>maintain type-based dependencies in an import (e.g., for CMS API that wants a heuristic like \"load organizations; then practitions; then patients\".)</li>\n</ul>",
        "id": 175715052,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568489658
    },
    {
        "content": "<p>Today, most heterogeneous sets of resources are in the context of bundles (GCP import experience)</p>",
        "id": 175715132,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568489829
    },
    {
        "content": "<p>Proposal: Enable support for \"mixed-type\" payloads, achieved by a client omitting <code>input.type</code>. Some servers might refuse to process mixed-type data.</p>",
        "id": 175715463,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568490428
    },
    {
        "content": "<h3><code>input.url</code></h3>",
        "id": 175715516,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568490506
    },
    {
        "content": "<p>In GCP, cloud-bucket-backed imports provide the ability to list file paths with wildcards, like <code>gcp://my-bucket/path-to/resources/Observation-*.json</code>. Is there something similar that could be done with <code>https</code>-based storage?</p>",
        "id": 175715600,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568490717
    },
    {
        "content": "<p>How does success/error reporting work in the status response?</p>",
        "id": 175715648,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568490759
    },
    {
        "content": "<p>In GCP, logging is in stackdrive, with individual resource-level errors logged, but no file-level summaries.</p>",
        "id": 175715664,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568490811
    },
    {
        "content": "<p>Path expansion happens at the beginning of the import (probably ;-))</p>",
        "id": 175715707,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568490844
    },
    {
        "content": "<p>Also supports <code>**</code> for recursing into subdirectories. (wildcard path components).</p>",
        "id": 175715719,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568490878
    },
    {
        "content": "<p>Wildcard support doesn't exist in http requests; and capabilities/semantics vary among different cloud bucket storage services.</p>",
        "id": 175715730,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568490915
    },
    {
        "content": "<h3>Conformance</h3>\n<ul>\n<li>How does a server advertise support for bundle processing?</li>\n<li>For mixed-type input files?</li>\n<li>For data storage modes (<code>storageDetail.type</code>)?</li>\n</ul>",
        "id": 175715784,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568490986
    },
    {
        "content": "<p>we can fill out placeholders for cloud bucket services and <code>sftp</code>.</p>",
        "id": 175715851,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568491093
    },
    {
        "content": "<p>Proposal: define a conformance discovery process (<code>.well-known/???</code>) for clients to learn this stuff.</p>",
        "id": 175715853,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568491115
    },
    {
        "content": "<p>(and local folder/network folder for internal organization processing/sharing)</p>",
        "id": 175715862,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1568491144
    },
    {
        "content": "<p>And we should allow a server to define in <code>CapabilityStatement</code> that a server supports <code>$import</code>.</p>",
        "id": 175715875,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568491185
    },
    {
        "content": "<h3>Semantics of batch, transaction, etc.</h3>\n<p>Do we want to define these models more formally, so a client can request, e.g., transactional import semantics? (And any given server might support some modes and not others.)</p>\n<h4>Allow clients to request among the following three transactional modes:</h4>\n<ul>\n<li>Best-effort across the import (&lt;-- This is where we are today)</li>\n<li>A set of smaller files, with all-or-nothing behavior per-file (&lt;-- This is really practical).</li>\n<li>All-or-nothing across the import</li>\n</ul>",
        "id": 175716265,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568491803
    },
    {
        "content": "<p>Do we have use cases that would help us make better decisions about requirements, for imports beyond the simple \"best effort\" stuff?</p>",
        "id": 175716282,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568491840
    },
    {
        "content": "<p>Proposal: processBundleAs=<code>collection|transaction</code> to allow clients to request finer-grained transaction boundaries (i.e., via individual Bundle files or ndjson files full of Bundles).</p>",
        "id": 175716803,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568492734
    },
    {
        "content": "<p>For referential integrity, should servers rewrite dangling links with fullUrls back to source materials? Leave them dangling? Fail the import altogether? We'll plan to leave this set of decision until later.</p>",
        "id": 175716869,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568492858
    },
    {
        "content": "<h4>Do clients need to call <code>delete</code> to clean things up / indicate finished?</h4>\n<p><span class=\"user-mention\" data-user-id=\"191367\">@Brian Postlethwaite</span> can you submit a PR for this as a suggestion on $export?</p>",
        "id": 175717155,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568493314
    },
    {
        "content": "<p>(It's actually on the core spec too in the async docco - so I'll log a gforge)</p>",
        "id": 175717360,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1568493705
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> <span class=\"user-mention\" data-user-id=\"191414\">@Dan Gottlieb</span> <br>\nHas anything been finalized w.r.t the four different options and processBundleAs=collection|transaction ?<br>\nI saw the proposal, but wanted to track it for some of our work in DaVinci.</p>\n<p>The use case that I am working on in DaVinci is as follows:  <br>\nPayers create a list of patients who are attributed to different individual or organizational providers based on their coverage, claims and other information. They will be giving this list of patients to provider organizations via a Group Resource. Once the provider organization receives this Group resource, we are thinking that the provider organizations can invoke the Group/[id]/$export to get the relevant data for all the patients in the list. We are thinking it may be good to process the data associated with each patient as a transaction or a collection where a bundle may be useful. <br>\nFeel free to correct us on the thinking or the usage.</p>",
        "id": 175910278,
        "sender_full_name": "Nagesh Bashyam",
        "timestamp": 1568729758
    },
    {
        "content": "<p>Right now, just captured in notes. But to be clear, the discussion was on <code>$import</code>; is the provider org in your example invoking an <code>$import</code> operation somewhere?</p>",
        "id": 175910655,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568729972
    },
    {
        "content": "<p>No, the provider org or the payers are not planning on a $import. There are many other reconciliation processes they go through before finally using/persisting the received data. Since the discussion was interesting and may help other needs where processing using bundles (all related resources for a patient) instead of ndjson files (organized by resources) may be advantageous, we wanted to let the group know about the use case. Will follow the discussion as it proceeds.</p>",
        "id": 175911410,
        "sender_full_name": "Nagesh Bashyam",
        "timestamp": 1568730413
    },
    {
        "content": "<p>I'd rather not have two different ways to represent the same data in bulk export - as individual resource and as bundles. The client importing the data had to resolve references regardless</p>",
        "id": 175920264,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1568735554
    },
    {
        "content": "<p>There are pretty strong use cases for each, though -- this is from production experience with the Google team's import experience. (e.g., folks want to be able to import patient $everything bundles.)</p>",
        "id": 175921142,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1568736155
    },
    {
        "content": "<p>But whether $export should offer bundled output is a separate question. I haven't formed a strong opinion about that yet - the use case in import is driven by data that didn't come from $export.</p>\n<p>If the use case is to sync data between servers while protecting referential and transactional integrity, I could see some utility in having the exporting server bundle up resources according to what it knows about their dependencies.</p>",
        "id": 175922089,
        "sender_full_name": "Paul Church",
        "timestamp": 1568736734
    }
]