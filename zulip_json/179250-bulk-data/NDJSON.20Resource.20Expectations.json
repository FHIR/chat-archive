[
    {
        "content": "<p>Any likelihood of being more prescriptive on the permitted formats of the NDJSON output from a bulk FHIR endpoint? My concern as we implement this in our stack is that there is going be ambiguity on the client side on what to expect in terms of processing a NDJSON file. While I believe the language of the spec is very permissible (i.e. it does not prohibit a bundle of resources, transaction bundle, or individual NJDSON files for each resource type) I am concerned that, in the field, implementations will be very slow and patchy as clients written to the generic spec will struggle with compatibility with server payload formatting. Have I just missed some language in the IG that clarifies this?</p>",
        "id": 244407984,
        "sender_full_name": "Matthew Spielman",
        "timestamp": 1625051980
    },
    {
        "content": "<p>The intent (and all implementation I saw) is definitely to have different NDJSON files for each resource type, with the resources stored directly, not inside bundles. I guess you can have NDJSON of Bundles if that is a native resource type in that server, but that's it.</p>",
        "id": 244421692,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1625059087
    },
    {
        "content": "<p>When you're performing an export, a client names a list of types of data to export. Those types correspond to the output types in  the resulting manifest. If there is some ambiguity, we could add clarification, but we have not seen any practical deviations or confusion on this point, to my knowledge.</p>",
        "id": 244425358,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625060671
    },
    {
        "content": "<p>I think it is pretty clear: \"Each file SHALL contain resources of only one type, but a server MAY create more than one file for each resource type returned.\"</p>",
        "id": 244426747,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1625061255
    },
    {
        "content": "<p>I will mention that we have run into some challenges in our Bulk Client implementation, where having Transaction Bundles might actually make things easier.  For example, a lab result will often be represented by a combination of DiagnosticReport and Observation resources.  And since we are a facade server, we really want to file everything related to a single result at once.  The current structure does make this difficult, as we basically need to process all resources in all files before we can start doing any data filing (which kinda defeats the purpose of ndjson).   Have other folks (who probably aren't using FHIR as the data storage format) run into similar client-side processing issues?</p>",
        "id": 244437098,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1625065248
    },
    {
        "content": "<p>Has this been address in bulk $import?</p>",
        "id": 244444623,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1625068014
    },
    {
        "content": "<p>The Google import operation has a mode that accepts bundles and unwraps them into individual resources (without regard for the bundle type or semantics, it's just a bag of resources - but this could be improved in the future) and users have found that useful. It comes up a lot in cases like synthea where the input is per-patient bundles, but could also apply to scenarios like this.</p>\n<p>I think there's value in expanding beyond the \"ndjson file per resource type\" use case currently in $export.</p>",
        "id": 244449123,
        "sender_full_name": "Paul Church",
        "timestamp": 1625069686
    },
    {
        "content": "<blockquote>\n<p>I think there's value in expanding beyond the \"ndjson file per resource type\" use case currently in $export.</p>\n</blockquote>\n<p>Just to be clear: value in expanding the model <em>within the $export paradigm</em> or value in expanding <em>to support other paradigms like $import</em> ?</p>",
        "id": 244454040,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625071939
    },
    {
        "content": "<p>Probably both. The current $export paradigm is pretty narrow, for the case <span class=\"user-mention\" data-user-id=\"191764\">@Cooper Thompson</span> raises it sounds entirely reasonable that the server would want to organize resources in a way that makes more sense to the use case. Then on the other end, $import benefits from more flexibility anyway as it may get input from sources that are not just $export.</p>",
        "id": 244454923,
        "sender_full_name": "Paul Church",
        "timestamp": 1625072280
    },
    {
        "content": "<p>Yeah, I think others may have the same challenge as well. I am trying to build this into our commercial development/integration stack which will ultimately service multiple internal products as well as our ISVs that use our technology. For some of our products as well as some of our customers as well, the internal APIs to grab patient data are optimized at the patient level (i.e. pull a patient and all the associated data) and are not efficient with requests where we doing things like \"grab all medications for this cohort of patients, then give me their problems, etc.\"</p>\n<p>While it's not a technical blocker, it does force us into some really inefficient processing where we need to collect the data for potentially thousands of patients and then re-sort all their data into different files by resource type instead of just being able to pipe each patient's compartment into a bundle sequentially</p>",
        "id": 244457158,
        "sender_full_name": "Matthew Spielman",
        "timestamp": 1625073077
    },
    {
        "content": "<p>It's definitely the case that for population-level export, we modeled the output in a way that biased it towards convenience of consumption, rather than convenience of production (we heard that it's often useful for clients to populate DB tables directly from these files).</p>",
        "id": 244457862,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625073345
    },
    {
        "content": "<p>That is true if the client system has a relational data model that is aligned with FHIR and isn't too strict about referential integrity. Otherwise you need to spend a bit of time hopping between files to grab required data for a transaction. If the client system is actually mapping the FHIR resources to internal API calls, the same problem applies. I would posit that a lot of existing, established commercial offerings will have that kind of challenge as bulk FHIR clients.</p>\n<p>Again, it's a challenge that our developers can solve (and probably get paid more to do so) but it does introduce some real inefficiencies.</p>",
        "id": 244460391,
        "sender_full_name": "Matthew Spielman",
        "timestamp": 1625074387
    },
    {
        "content": "<p>I don't necessarily know that there is a perfect answer that makes everyone happy but it could introduce some friction into the adoption of the IG</p>",
        "id": 244460607,
        "sender_full_name": "Matthew Spielman",
        "timestamp": 1625074489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191315\">Josh Mandel</span> <a href=\"#narrow/stream/179250-bulk-data/topic/NDJSON.20Resource.20Expectations/near/244457862\">said</a>:</p>\n<blockquote>\n<p>It's definitely the case that for population-level export, we modeled the output in a way that biased it towards convenience of consumption, rather than convenience of production (we heard that it's often useful for clients to populate DB tables directly from these files).</p>\n</blockquote>\n<p>I wish Epic had been about a year farther a long as a Bulk FHIR client so that we could have represented that side better in the Argo project last year.  But as a client, we've decided that we have the same problems when consuming as we do when producing.  Which is to say, our system is patient oriented (just like <span class=\"user-mention\" data-user-id=\"191921\">@Matthew Spielman</span> ) and it would be much easier if we could file all the data for a single patient at once before moving on to the next patient.</p>",
        "id": 244490514,
        "sender_full_name": "Cooper Thompson",
        "timestamp": 1625088445
    },
    {
        "content": "<p>That's fair, thanks for the comments Cooper. In terms of your ideal export configuration...</p>\n<ul>\n<li>Would all data about a given patient be in the same ndjson file as discrete resources/lines?</li>\n<li>Would all data about a given patient be wrapped up in a bundle within a single ndjson line (I assume not since .. these get unbounded)</li>\n<li>Would an ndjson file have data about lots of patients, or would you have one patient per file?</li>\n<li>What about resources like organizations or practitioners that aren't associated with a single patient? Repeat them, or represent them in distinct files from the patient data?</li>\n</ul>",
        "id": 244491586,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625089016
    },
    {
        "content": "<p>Could also be a step in staging the content, rather than the format.<br>\nPatient per file(or am I mistaking something there) would blown out the number of files in the status file...</p>",
        "id": 244493920,
        "sender_full_name": "Brian Postlethwaite",
        "timestamp": 1625090274
    },
    {
        "content": "<blockquote>\n<p>Patient per file(or am I mistaking something there) would blown out the number of files in the status file...</p>\n</blockquote>\n<p>For sure; we hadn't ever really considered it, for that reason. Manifest can't be broken up, and it'd grow 1:1 with patient count. (But, maybe it's not totally untenable; like I said, we never really considered it.)</p>",
        "id": 244499553,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625094195
    },
    {
        "content": "<p>I think output as Bundle is an option. Bulk Export does not exclude Bundle as a output resource, All it says is \"Each file SHALL contain resources of only one type\". So bunlde.ndjosn is definitely feasible.</p>",
        "id": 244500700,
        "sender_full_name": "Yunwei Wang",
        "timestamp": 1625095003
    },
    {
        "content": "<p>That's only okay (per the current spec) if you're exporting bundles -- the equivalent of <code>GET /Bundle</code> from a FHIR REST API -- asking the server for Bundles it has stored</p>",
        "id": 244500971,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625095205
    },
    {
        "content": "<p>It's not a way to somehow get your regular Patient data exported in Bundles.</p>",
        "id": 244501068,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625095286
    },
    {
        "content": "<p>If we want new behavior or flexibility, we need to specify it. I'm not convinced, but I am open minded / sympathetic / interested in learning more about what folks would find useful.</p>",
        "id": 244501165,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625095355
    },
    {
        "content": "<p>I'd be willing to discuss more and explain some of the types of (ostensibly impedance mismatch) issues that exist between products and technologies written 10-20 years ago that I'm trying to address with our current development around FHIR and Bulk FHIR. I've started and stopped trying to summarize them in this thread a few times this evening but it just turns into a dissertation that no one is going to want to read. Perhaps there will be a good opportunity to discuss synchronously at some point in the future.</p>",
        "id": 244513528,
        "sender_full_name": "Matthew Spielman",
        "timestamp": 1625108676
    },
    {
        "content": "<p>Yeah -- would you be up for a discussion next week, ideally one we can record/share?</p>",
        "id": 244515716,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625111744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"191315\">Josh Mandel</span> <a href=\"#narrow/stream/179250-bulk-data/topic/NDJSON.20Resource.20Expectations/near/244515716\">said</a>:</p>\n<blockquote>\n<p>Yeah -- would you be up for a discussion next week, ideally one we can record/share?</p>\n</blockquote>\n<p>Of course, more than happy to. My schedule is only a mild disaster next week but if you send me an email, perhaps Thursday or Friday? (<a href=\"mailto:Matthew.spielman@intersystems.com\">Matthew.spielman@intersystems.com</a>)</p>",
        "id": 244573180,
        "sender_full_name": "Matthew Spielman",
        "timestamp": 1625149022
    },
    {
        "content": "<p>With the new PnP spec for $import, putting this Bundle capability into $export would fix it for both</p>",
        "id": 244609655,
        "sender_full_name": "Sam Sayer",
        "timestamp": 1625164935
    },
    {
        "content": "<p>This was a roadblock we've run into when trying to figure out PnP $import as it relies on $export and it forces us to basically \"stage\" all the resources and then figure out the references between them</p>",
        "id": 244609744,
        "sender_full_name": "Sam Sayer",
        "timestamp": 1625164993
    },
    {
        "content": "<p>Definite +1 on that, figuring out the references in any non-trivial import is a big problem. Solutions that work for 1000 resources might not work for 1 million resources, and 1 billion is even worse.</p>\n<p>Having the exporting server assemble them into transaction bundles that are each self-contained is a good way out, at least for use cases where the exporter can anticipate what the reference structure looks like.</p>",
        "id": 244614305,
        "sender_full_name": "Paul Church",
        "timestamp": 1625167192
    },
    {
        "content": "<p>I think we'd want an explicit client-supplied option on export to say \"partition data into transaction bundles\" -- and also we'd want a way to distinguish these bundles from the ones that'd result from \"GET /Bundle\". Might require a new output type/flag/extension.</p>",
        "id": 244627893,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625174066
    },
    {
        "content": "<p>This topic was moved by <span class=\"user-mention silent\" data-user-id=\"191315\">Josh Mandel</span> to <a class=\"stream-topic\" data-stream-id=\"212434\" href=\"/#narrow/stream/212434-ibm/topic/NDJSON.20Resource.20Expectations\">#ibm &gt; NDJSON Resource Expectations</a></p>",
        "id": 244732143,
        "sender_full_name": "Notification Bot",
        "timestamp": 1625246091
    },
    {
        "content": "<p>I think some kind of \"partition resource\" flag which indicates the resource to build the Bundle around would work. I think we'd still have to figure out how to de-dup things like providers (since the same provider would be referenced by multiple patient bundles in our case), but that's fairly straightforward using the IDs from the data provider.</p>",
        "id": 245050588,
        "sender_full_name": "Sam Sayer",
        "timestamp": 1625583470
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"191921\">@Matthew Spielman</span>, Alexander Brown, and <span class=\"user-mention\" data-user-id=\"191414\">@Dan Gottlieb</span>  for the discussion this afternoon. I've uploaded to <a href=\"https://youtu.be/75Rsgu1Rqnc\">https://youtu.be/75Rsgu1Rqnc</a> in case others are interested</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"75Rsgu1Rqnc\" href=\"https://youtu.be/75Rsgu1Rqnc\"><img src=\"https://uploads.zulipusercontent.net/2d6e78cc6374d64193ba57ab8d62bc958a9ca0fe/68747470733a2f2f692e7974696d672e636f6d2f76692f3735527367753152716e632f64656661756c742e6a7067\"></a></div><blockquote>\n<p>In this session, I catch up with Alexander Brown and Matthew Spielman (Intersystems) and Dan Gottlieb (Central Square Solutions). We discuss FHIR Bulk Data formats for $export and $import with; dig into architecture for data processing; and compare strategies for grouping data. We review regulatory timeframes for ONC Certification / Cures Rule compliance, $export API extensibility, and techniques to balance the diverse needs of clients and servers.</p>\n</blockquote>",
        "id": 245492577,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1625861928
    },
    {
        "content": "<p>Is anyone planning on doing anything related to this at the Connectathon?</p>",
        "id": 248375958,
        "sender_full_name": "Sam Sayer",
        "timestamp": 1628095662
    },
    {
        "content": "<p>Where can one find (prelim?) specs on Bulk Data Import?   Advance Thanks!</p>",
        "id": 248390606,
        "sender_full_name": "John Silva",
        "timestamp": 1628102539
    },
    {
        "content": "<p><a href=\"https://github.com/smart-on-fhir/bulk-import/blob/master/import.md\">https://github.com/smart-on-fhir/bulk-import/blob/master/import.md</a></p>",
        "id": 248390676,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1628102574
    },
    {
        "content": "<p>This links to two proposals; the \"Ping and Pull Proposal\" is our latest/best current thinking.</p>",
        "id": 248390704,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1628102591
    },
    {
        "content": "<p>Hi Josh, is there any update to the discussion you posted on YouTube regarding grouping data for bulk $export and $import?</p>",
        "id": 256575470,
        "sender_full_name": "Raj Sankuratri",
        "timestamp": 1633612694
    },
    {
        "content": "<p>For $import, I would certainly encourage folks to experiment. We have a draft specification but it's only going to be through real world feedback that we might take this into a formal standards project.</p>\n<p>For $export, these operations have been formally standardized and I don't think we would change their default behavior, but we could introduce new output modes to accommodate different grouping methods; if anyone is interested in prototyping this, I would suggest just adding an optional flag to the kickoff request, defaulting it to the currently standardized grouping method (by resource type) but introducing client facing options for finer grained control.</p>",
        "id": 256578677,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1633613960
    }
]