[
    {
        "content": "<p>Has anyone from the CMS side mentioned our work on adding in an additional layer of payload encryption to our bulk data server implementation?</p>",
        "id": 154025952,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1545064577
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"196495\">@Sutton</span>, <span class=\"user-mention\" data-user-id=\"196496\">@Ryan Nagle</span></p>",
        "id": 154025953,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1545064594
    },
    {
        "content": "<p>to add some color, we've been working on an encryption strategy that uses a public key provided by the API client to secure a payload so that it is protected on both sides of the transfer, only accessible to the party that possesses the corresponding private key.</p>",
        "id": 154026128,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545154116
    },
    {
        "content": "<p>the initial request/download process matches the current spec, but we've added some fields to responses from our job status endpoint to indicate the key used to protect each file</p>",
        "id": 154026129,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545154286
    },
    {
        "content": "<p>we're planning on providing additional documentation to API consumers to explain how to handle the files once they're in their possession</p>",
        "id": 154026130,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545154367
    },
    {
        "content": "<p>anyway, thought we'd share the idea here in the event anyone has thoughts/feedback for us</p>",
        "id": 154026131,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545154596
    },
    {
        "content": "<p>happy to share more here or arrange a call, feel free to @-msg me <span class=\"emoji emoji-1f44d\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 154026132,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545154716
    },
    {
        "content": "<p>Do you have a test server?</p>",
        "id": 154026139,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1545158553
    },
    {
        "content": "<p>what is the risk that this payload encryption is protecting against? I am starting with the requirement for TLS, and OAuth client authentication/authorization. So I am not clear what risk this payload encryption is protecting against. Without understanding of the risk, it is hard to determine if this solution has reduced that risk. I am a fan of encryption, but it needs to be used properly. Adding more encryption does not always lower risk. For example a payload encryption presents an \"Availability\" risk caused by loss of keys.</p>",
        "id": 154026140,
        "sender_full_name": "John Moehrke",
        "timestamp": 1545158600
    },
    {
        "content": "<p>currently, we do not have a public test server</p>",
        "id": 154026143,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545159358
    },
    {
        "content": "<p>ok, thanks</p>",
        "id": 154026144,
        "sender_full_name": "Michele Mottini",
        "timestamp": 1545159377
    },
    {
        "content": "<p>one risk we've discussed is the exposure of client credentials. if a client's credentials are compromised and an attacker successfully queries for their data, the payload is effectively useless to them without also gaining access to the private key.</p>",
        "id": 154026151,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545163488
    },
    {
        "content": "<p>it happens that this approach also satisfies some compliance with CMS acceptable risk safeguards with regard to protecting sensitive data at-rest</p>",
        "id": 154026152,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545163619
    },
    {
        "content": "<p>that's the gist of it, would love to hear from you all. thanks for the time!</p>",
        "id": 154026153,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545163692
    },
    {
        "content": "<p>it the client credentials are exposed, you can just repeat the query?</p>",
        "id": 154026163,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1545165709
    },
    {
        "content": "<p>right -- for example, if the client is not aware their credentials have been compromised / they have not been revoked, an attacker could use the creds to initiate a new request</p>",
        "id": 154026176,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545168722
    },
    {
        "content": "<p>Hey Ryan, I <em>thought</em> the intent of the <a href=\"https://github.com/smart-on-fhir/fhir-bulk-data-docs/blob/master/authorization.md#registering-a-smart-backend-service-communicating-public-keys\" target=\"_blank\" title=\"https://github.com/smart-on-fhir/fhir-bulk-data-docs/blob/master/authorization.md#registering-a-smart-backend-service-communicating-public-keys\">Backend Services</a> spec was to limit the use of OAuth2 client_credentials to only \"asymmetric\" authentication mechanisms (e.g. public/private key pairs), which are further, optionally protected by rotating the certs referenced in the Json Web Key Set.</p>",
        "id": 154026184,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1545169862
    },
    {
        "content": "<p>The rotating JWK Set not only provides public/private key pairs as authentication within the existing spec, but also includes the ability to rotate these keys pretty quickly.</p>",
        "id": 154026185,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1545169865
    },
    {
        "content": "<p>Do you think we should modify this section of the spec to also encrypt the payload?</p>",
        "id": 154026186,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1545169866
    },
    {
        "content": "<p>hey isaac, thanks for the reply</p>",
        "id": 154026197,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545172716
    },
    {
        "content": "<p>i should've mention up front -- we're still exploring options for our auth/n/z strategy and don't know for sure if the backend services spec will 100% work for us.</p>",
        "id": 154026198,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545172792
    },
    {
        "content": "<p>in my example above, i was assuming the typical client_credentials workflow (i.e., using a <code>client_id</code> and <code>client_secret</code>)</p>",
        "id": 154026199,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545172815
    },
    {
        "content": "<p>in all events, i'm happy to share more re: our experience working with the backend services spec, but it'll probably be a while before we have coherent feedback :-)</p>",
        "id": 154026200,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545172861
    },
    {
        "content": "<p>to answer your question, i don't think the spec should necessarily require payload encryption. it makes sense given our requirements, but might not work for others.</p>",
        "id": 154026202,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545173178
    },
    {
        "content": "<p>i suppose i'm wondering where you all see these sorts of modifications/addenda for specifics use cases fitting in with the spec in general, if at all</p>",
        "id": 154026203,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545173663
    },
    {
        "content": "<blockquote>\n<p>if the client is not aware their credentials have been compromised / they have not been revoked, an attacker could use the creds to initiate a new request</p>\n</blockquote>\n<p>So what does encryption achieve? not much....</p>",
        "id": 154026235,
        "sender_full_name": "Grahame Grieve",
        "timestamp": 1545189329
    },
    {
        "content": "<p>I'm just catching up here -- thanks for the discussion. I'm on the same page as John: would definitely help to understand specific threats.</p>",
        "id": 154026236,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545189736
    },
    {
        "content": "<p>A few quick notes:</p>\n<ul>\n<li>\n<p>The current Bulk Data spec is written independent of the Backend Services security spec (but they're designed to work well together).</p>\n</li>\n<li>\n<p>Modifications/addenda are always the trick when it comes to standardizing an end-to-end system for data exchange. If you introduce a modification to a protocol, and it's <em>required</em> for clients who talk to your system, then your system is no longer compatible with generic clients.</p>\n</li>\n<li>\n<p>This means that, especially for modifications/addenda that are general-purpose or important (or likely to be made <em>mandatory</em> by some servers), we'd like to understand these up-front as much as possible, and incorporate them into our initial design.</p>\n</li>\n</ul>",
        "id": 154026237,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545189834
    },
    {
        "content": "<p>As Isaac points out, the client's credentials never go over the wire in our current Backend Service spec; they're used only for asymmetric signatures, and can be rotated by the client.</p>",
        "id": 154026238,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545189882
    },
    {
        "content": "<p>It's also worth pointing out the <em>reason</em> we have compliance issues here that we're trying to address: In general, our risk mitigation policies aren't thrilled with the idea of \"we have a server on the open internet sitting around with a ton of bulk data PII/PHI on it.\"</p>\n<p>That leaves us only one remote code execution vulnerability away from \"oops, someone just scraped all the waiting-for-delivery payloads off our disk and sent them to &lt;bad-actor-of-your-choice&gt;.\" And while that absolutely is a low probability event (those vulns don't come along very often), the pain if it happens is high enough to warrant extra mitigation effort. The reasonablest approach we could get agreement on was ensuring that files weren't sitting effectively-unencrypted at rest (disk-level or single-key encryption aren't helpful here).</p>\n<p><span class=\"user-mention\" data-user-id=\"196496\">@Ryan Nagle</span> Is that an accurate summary of the compliance concerns?</p>",
        "id": 154026360,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1545238206
    },
    {
        "content": "<p>It would be good to describe technically how the approach you're outlining (re: per-client encryption) could be built on top of the current specs (which have the potential advantage that a client's public key is already known by a server at the time an export request is issued).</p>",
        "id": 154026362,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545238490
    },
    {
        "content": "<p>(BTW, I really appreciate the background here -- thanks for engaging in the discussion!)</p>",
        "id": 154026364,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545238565
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192789\">@Karl M. Davis</span> accurate in my opinion, thanks for chiming in. <span class=\"emoji emoji-1f44d\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 154026365,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545238876
    },
    {
        "content": "<p>Isn't that risk usually addressed by operational security technology such as encrypting databases, encypting filesystems, etc? Things that don't need to affect the Interoperability layer?<br>\nFurther by indicating it is per-client encryption, this means that the data is available on that server in non-encrypted form so that it can be encrypted to a targeted client. <br>\nWhat I am worried about is added complexity at the Interoperability layer caused by security-theater.</p>",
        "id": 154026366,
        "sender_full_name": "John Moehrke",
        "timestamp": 1545238919
    },
    {
        "content": "<p>Is there a write-up on how you're approaching this from a technical perspective, <span class=\"user-mention\" data-user-id=\"196496\">@Ryan Nagle</span> ?</p>",
        "id": 154026367,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545239008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> I agree it's important to nail down these details, with clear discussion about threats. In practice, one very common error (outside of remote code execution vulnerabilities on cloud VMs) is for a server to push files to a cloud storage bucket (for a client to fetch from) and then someone accidentally makes that bucket public. Plenty of stories in the news on this kind of misconfiguration, and the additional encryption <em>does</em> mitigate the risk. It all comes back to the threats we're most concerned about.</p>",
        "id": 154026368,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545239268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> we're working on that as we speak, we should have a solid draft in the next few weeks</p>",
        "id": 154026369,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545239269
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> Those aren't effective mitigation strategies, because -- from the standpoint of an attacker with a code execution exploit -- the encryption doesn't exist. Filesystem, DB, etc. encryption only really protects from the, \"someone robbed the data center and walked away with the disks,\" risk, which... <em>okay</em>, but isn't a real big concern.</p>",
        "id": 154026370,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1545239358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"196496\">@Ryan Nagle</span> ok -- on the timing here, is there an intention to describe your approach as a \"small diff\" building on top of the specification we have today? I think it could be a useful exercise, but if you want to go this route it would be good to think about that from the beginning.</p>",
        "id": 154026371,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545239375
    },
    {
        "content": "<p>It's also worth mentioning that we here at CMS (and the VA and the DoD) have a very different risk profile from your average provider or payer considering use of the bulk data API.</p>",
        "id": 154026372,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1545239605
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> I agree it's important to nail down these details, with clear discussion about threats. In practice, one very common error (outside of remote code execution vulnerabilities on cloud VMs) is for a server to push files to a cloud storage bucket (for a client to fetch from) and then someone accidentally makes that bucket public. Plenty of stories in the news on this kind of misconfiguration, and the additional encryption <em>does</em> mitigate the risk. It all comes back to the threats we're most concerned about.</p>\n</blockquote>\n<p>For this I would agree that encrypting the blob is a good a proper solution.</p>",
        "id": 154026373,
        "sender_full_name": "John Moehrke",
        "timestamp": 1545239612
    },
    {
        "content": "<p>(Actually, KMS is pretty awesome and does protect against the, \"we just oopsed our S3 ACLs,\" risk. But the point, in general, is still a good one: there's lots of ways to footgun yourself and we have to take a defense-in-depth approach, which the payload encryption is a part of.)</p>",
        "id": 154026374,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1545239720
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191315\">@Josh Mandel</span> that's more or less correct. in short, everything about the request and delivery process matches the current state of the bulk data spec, the difference comes in the \"post-processing\" of the payload.</p>",
        "id": 154026375,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545239820
    },
    {
        "content": "<p>Is there a negotiation or some protocol over the wire to determine what sort of encryption will be used, or to communicate to the client what has been used?</p>",
        "id": 154026376,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545239890
    },
    {
        "content": "<p>that's a good question. at present, we're using AES GCM and planned on specifying that in our documentation. i can't see us offering other options for encryption, since we're limited in what we can use cipher-wise for compliance. but, if it were generalized, i think communicating that as part of file delivery makes sense.</p>",
        "id": 154026379,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545240145
    },
    {
        "content": "<p>you mentioned the advantage of having a client pub key already in-hand -- this is exactly what we're hoping to leverage. but, like i said, we're still working on our story for client registration, client credentials workflow and so on. we'll have more we can share in the coming weeks.</p>",
        "id": 154026380,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545240362
    },
    {
        "content": "<p>Interesting ; so for the AES approach, you'll define some way to communicate a symmetrically shared AES key to the client. Will it be one AES key per client, or per export job, or per exported file? Given the threat model you outlined, I'd expect one AES key per job, which could be communicated directly as part of the JSON manifest file for the job when it's complete. If that's vaguely right, we'd be talking about something like adding a parameter to the manifest payload to communicate this key, which would be populated at the server's discretion when exported-file-encryption was enabled.</p>",
        "id": 154026400,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545241254
    },
    {
        "content": "<p>If I was reading the spec right however many months ago, one area of potential non-compliance is that it specifically says the payload must be an NDJSON file, and doesn't it also call out a MIME type or two?</p>",
        "id": 154026414,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1545243792
    },
    {
        "content": "<p>That's not hard to fix, I'm sure, but still worth noting.</p>",
        "id": 154026415,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1545243810
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"196496\">@Ryan Nagle</span> Are you still thinking of moving to streaming encryption at some point? Does that impact this conversation at all?</p>",
        "id": 154026416,
        "sender_full_name": "Karl M. Davis",
        "timestamp": 1545244066
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"192789\">@Karl M. Davis</span> yep, i believe you're right about the payload format. good point.</p>",
        "id": 154026417,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545245304
    },
    {
        "content": "<p>we're taking a pretty naive approach to payload encryption to start, encrypting the entire file as a single message</p>",
        "id": 154026418,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545245361
    },
    {
        "content": "<p>we're going to have to look at other options, including chunking large files into smaller contiguous messages so that both the server and client don't have to hold potentially very large files in memory to decrypt</p>",
        "id": 154026419,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545245424
    },
    {
        "content": "<p>i should say server side to encrypt, client side to decrypt</p>",
        "id": 154026420,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545245788
    },
    {
        "content": "<p>I would recommend the use of standards based enclosures that already have key management and algorithm communication. The standard I would recommend is CMS. I have written profiles in IHE that use CMS for end-to-end security. In the case of IHE (DEN profile), the mechanism fits within a Document Sharing environment, or used on portable media (CD-ROM, USB-Memory). This CMS standard is very flexible.</p>",
        "id": 154026421,
        "sender_full_name": "John Moehrke",
        "timestamp": 1545245835
    },
    {
        "content": "<p>this is the same standard that makes up the cryptography portion of S/MIME, leveraged by the USA specific Direct Project.</p>",
        "id": 154026422,
        "sender_full_name": "John Moehrke",
        "timestamp": 1545245947
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191404\">@John Moehrke</span> awesome, thank you. i'll read up!</p>",
        "id": 154026423,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545245979
    },
    {
        "content": "<p>High level intro to the IHE DEN Profile <a href=\"https://wiki.ihe.net/index.php/Document_Encryption\" target=\"_blank\" title=\"https://wiki.ihe.net/index.php/Document_Encryption\">https://wiki.ihe.net/index.php/Document_Encryption</a><br>\nFormal normative text <a href=\"http://www.ihe.net/uploadedFiles/Documents/ITI/IHE_ITI_Suppl_DEN.pdf\" target=\"_blank\" title=\"http://www.ihe.net/uploadedFiles/Documents/ITI/IHE_ITI_Suppl_DEN.pdf\">http://www.ihe.net/uploadedFiles/Documents/ITI/IHE_ITI_Suppl_DEN.pdf</a><br>\nThese are global standards. The standards are available to use... one must just select them.</p>",
        "id": 154026425,
        "sender_full_name": "John Moehrke",
        "timestamp": 1545246119
    },
    {
        "content": "<p>so my ask about the risk is not because I am against encryption... I authored the IHE, and was the author of the security assessment of the Direct Project... I simply am making sure that the risk you are trying to address is worthy of the 'costs' of applying end-to-end encryption. I have too often seen excited people define end-to-end encryption only to find that it is very costly in terms of technology, management, and failure-modes.</p>",
        "id": 154026426,
        "sender_full_name": "John Moehrke",
        "timestamp": 1545246227
    },
    {
        "content": "<p>I am also worried when we start to re-invent protocols such as SOAP which has end-to-end encryption and authenticity as a major benefit of using that technology over the more simple http/REST. One can do REST over SOAP. SOAP also has asynchronous modes and many other features. If that is desired, accessing the FHIR REST resources can be done leveraging those existing and well-implemented standards.</p>",
        "id": 154026427,
        "sender_full_name": "John Moehrke",
        "timestamp": 1545246393
    },
    {
        "content": "<p>(and in this specific case, the use of end-to-end encryption is unique and therefore breaks current Backend Services / bulk data clients. )</p>",
        "id": 154026428,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1545246489
    },
    {
        "content": "<p>i understand and i appreciate your questions and comments, this is been a tremendously valuable conversation for me.</p>",
        "id": 154026430,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545246527
    },
    {
        "content": "<p>Ryan, the FHIR connectathon is a whole weekend of this type of feedback! Think you'll make it?</p>",
        "id": 154026431,
        "sender_full_name": "Isaac Vetter",
        "timestamp": 1545246587
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"191864\">@Isaac Vetter</span> i _might_ be able to, i'm not sure at the moment</p>",
        "id": 154026433,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545246955
    },
    {
        "content": "<p>i only know that it is happening, but don't recall the dates</p>",
        "id": 154026434,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545247030
    },
    {
        "content": "<p>January 12-13, 2019 (<a href=\"http://www.hl7.org/events/working_group_meeting/2019/01/\" target=\"_blank\" title=\"http://www.hl7.org/events/working_group_meeting/2019/01/\">http://www.hl7.org/events/working_group_meeting/2019/01/</a>)</p>",
        "id": 154026435,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545247085
    },
    {
        "content": "<p>thank you</p>",
        "id": 154026436,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1545247163
    },
    {
        "content": "<p>Re: the mime type question, for encrypted payloads it's a good question. I think our protocol would still want to convey/negotiate what's inside (confirming NDJSON vs Parquet or whatever), as well an indication that the content is encrypted.</p>",
        "id": 154026437,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545247525
    },
    {
        "content": "<p>In the IHE DEN profile it is made clear that the contained object(s) that is encrypted can be of any mime-type, and that mime-type is recorded in the CMS header, while the CMS object it-self is described using the mime-type of \"application/pkcs7-mime\".<br>\nThat doesn't answer the question Josh is asking, which is more how does the client identify what type of payload they want.. Which seems to me could be simply use of the http negotiate mecahnism. Use the fhir type you see in the negotiation, and also see that application/pkcs7-mime is in negotiate.. right?</p>",
        "id": 154026442,
        "sender_full_name": "John Moehrke",
        "timestamp": 1545249788
    },
    {
        "content": "<p>Well, we don't use straight-up HTTP content-type negotiation because we're not negotiating the content-type of the <em>response manifest file</em> -- we're negotiating the content-type of the eventually-to-be-exported data files. But it's the same basic idea (i.e., the client passes along a parameter to the kick-off request saying \"I want NDJSON out in the end, please\").</p>",
        "id": 154026443,
        "sender_full_name": "Josh Mandel",
        "timestamp": 1545249884
    },
    {
        "content": "<p>happy new year, all <span class=\"emoji emoji-1f44b\" title=\"wave\">:wave:</span></p>",
        "id": 154243169,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1546526606
    },
    {
        "content": "<p>as promised, a (draft) doc explaining how we implement per-client payload encryption: <a href=\"https://github.com/CMSgov/bcda-app/blob/master/ENCRYPTION.md\" target=\"_blank\" title=\"https://github.com/CMSgov/bcda-app/blob/master/ENCRYPTION.md\">https://github.com/CMSgov/bcda-app/blob/master/ENCRYPTION.md</a></p>",
        "id": 154243254,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1546526685
    },
    {
        "content": "<p>appreciate any critique/feedback you are willing to offer</p>",
        "id": 154243306,
        "sender_full_name": "Ryan Nagle",
        "timestamp": 1546526751
    }
]